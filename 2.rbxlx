<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBXD5550C41CE834589925ABF42A6AB5021">
		<Properties>
			<float name="AirDensity">0.00120000006</float>
			<float name="AirTurbulenceIntensity">0</float>
			<bool name="AllowThirdPartySales">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AuthorityMode">1</token>
			<token name="AvatarUnificationMode">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="ClientAnimatorThrottling">0</token>
			<BinaryString name="CollisionGroupData">AQEABP////8HRGVmYXVsdA==</BinaryString>
			<Ref name="CurrentCamera">RBXDF3DFFD910E54CE78B7C052750250FEC</Ref>
			<bool name="DefinesCapabilities">false</bool>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<bool name="FallHeightEnabled">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<token name="FluidForces">0</token>
			<Vector3 name="GlobalWind">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<float name="Gravity">196.199997</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="IKControlConstraintSupport">0</token>
			<token name="LevelOfDetail">0</token>
			<token name="LuauTypeCheckMode">0</token>
			<token name="MeshPartHeadsAndAccessories">0</token>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<token name="ModelStreamingBehavior">0</token>
			<token name="ModelStreamingMode">0</token>
			<token name="MoverConstraintRootBehavior">0</token>
			<string name="Name">Workspace</string>
			<bool name="NeedsPivotMigration">false</bool>
			<token name="PathfindingUseImprovedSearch">0</token>
			<token name="PhysicsImprovedSleep">0</token>
			<token name="PhysicsSteppingMethod">0</token>
			<token name="PlayerCharacterDestroyBehavior">0</token>
			<token name="PrimalPhysicsSolver">0</token>
			<Ref name="PrimaryPart">null</Ref>
			<token name="RejectCharacterDeletions">0</token>
			<token name="RenderingCacheOptimizations">0</token>
			<token name="ReplicateInstanceDestroySetting">0</token>
			<token name="Retargeting">0</token>
			<token name="SandboxedInstanceMode">0</token>
			<float name="ScaleFactor">1</float>
			<token name="SignalBehavior2">2</token>
			<int64 name="SourceAssetId">-1</int64>
			<token name="StreamOutBehavior">2</token>
			<bool name="StreamingEnabled">true</bool>
			<token name="StreamingIntegrityMode">3</token>
			<int name="StreamingMinRadius">64</int>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
			<token name="TouchEventsUseCollisionGroups">0</token>
			<bool name="TouchesUseCollisionGroups">false</bool>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000002</UniqueId>
			<token name="UseImprovedModelLod">0</token>
			<token name="UseNewLuauTypeSolver">0</token>
			<OptionalCoordinateFrame name="WorldPivotData">
				<CFrame>
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CFrame>
			</OptionalCoordinateFrame>
		</Properties>
		<Item class="Camera" referent="RBXDF3DFFD910E54CE78B7C052750250FEC">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>-42.1983376</X>
					<Y>90.2725983</Y>
					<Z>-29.1185989</Z>
					<R00>-0.990395784</R00>
					<R01>0.102459654</R01>
					<R02>-0.0928343982</R02>
					<R10>-0</R10>
					<R11>0.671441376</R11>
					<R12>0.741057754</R12>
					<R20>0.138261363</R20>
					<R21>0.733940482</R21>
					<R22>-0.66499275</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<float name="FieldOfView">70</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>-42.0126686</X>
					<Y>88.7904816</Y>
					<Z>-27.7886124</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000399</UniqueId>
				<bool name="VRTiltAndRollEnabled">false</bool>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX98E17509AAE44FF4B05E1A865E6ADBCA">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AudioCanCollide">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>-8</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4284177243</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Baseplate</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000039a</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">0</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>2048</X>
					<Y>16</Y>
					<Z>2048</Z>
				</Vector3>
			</Properties>
			<Item class="Texture" referent="RBX5823EADDF55E4207811A941735CACF2E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<Color3 name="Color3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<bool name="DefinesCapabilities">false</bool>
					<token name="Face">1</token>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="MetalnessMap"><null></null></Content>
					<string name="Name">Texture</string>
					<Content name="NormalMap"><null></null></Content>
					<float name="OffsetStudsU">0</float>
					<float name="OffsetStudsV">0</float>
					<Content name="RoughnessMap"><null></null></Content>
					<int64 name="SourceAssetId">-1</int64>
					<float name="StudsPerTileU">8</float>
					<float name="StudsPerTileV">8</float>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxassetid://6372755229</url></Content>
					<Content name="TexturePack"><null></null></Content>
					<string name="TexturePackMetadata"></string>
					<float name="Transparency">0.800000012</float>
					<Vector2 name="UVOffset">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Vector2 name="UVScale">
						<X>1</X>
						<Y>1</Y>
					</Vector2>
					<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000039b</UniqueId>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
		</Item>
		<Item class="Terrain" referent="RBX6E97265E23BE466C8EB61522FF22A95B">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AudioCanCollide">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">true</bool>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="GrassLength">0.699999988</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAb34+WFlWmJiYimFJz8unrJRsY2Rm3eTl6/3/lHxfeXBiS0pKjIJo/xhDUFRUhoZ2
zNLfaoZA///+//PAj5CH]]></BinaryString>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<bool name="SmoothVoxelsUpgraded">false</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000039c</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0470588282</R>
					<G>0.329411775</G>
					<B>0.360784322</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="SpawnLocation" referent="RBXAEA8BB89EE974A3D8D4AC10732700E39">
			<Properties>
				<bool name="AllowTeamChangeOnTouch">false</bool>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AudioCanCollide">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0.5</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="DefinesCapabilities">false</bool>
				<int name="Duration">0</int>
				<bool name="EnableFluidForces">true</bool>
				<bool name="Enabled">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">SpawnLocation</string>
				<bool name="Neutral">true</bool>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<int name="TeamColor">194</int>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000039d</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>12</X>
					<Y>1</Y>
					<Z>12</Z>
				</Vector3>
			</Properties>
			<Item class="Decal" referent="RBX956135559F744B5594A75F54469CD809">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<Color3 name="Color3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<bool name="DefinesCapabilities">false</bool>
					<token name="Face">1</token>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="MetalnessMap"><null></null></Content>
					<string name="Name">Decal</string>
					<Content name="NormalMap"><null></null></Content>
					<Content name="RoughnessMap"><null></null></Content>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxasset://textures/SpawnLocation.png</url></Content>
					<Content name="TexturePack"><null></null></Content>
					<string name="TexturePackMetadata"></string>
					<float name="Transparency">0</float>
					<Vector2 name="UVOffset">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Vector2 name="UVScale">
						<X>1</X>
						<Y>1</Y>
					</Vector2>
					<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000039e</UniqueId>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXC4EA76EBA9C34D128EA4F8BC7B3F4F98">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Character selection system</string>
				<int64 name="SourceAssetId">110951364739343</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600006564</UniqueId>
			</Properties>
			<Item class="Script" referent="RBXE98142B147074284A34B6CB7CBCC96C8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Disabled">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">README</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{3C0ADD97-134E-4C39-8CFF-F8117D9826EE}</string>
					<ProtectedString name="Source"><![CDATA[--- Model was created by @coolcapidog and upgraded by @DMiner_YT

--- Ungroup all folders into right places

--- Place your R15 chatacters into Characters folder in Replicated Storage

script:Destroy()]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000069ef</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX2A98522205BE4177821DD6475364B611">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">MapLoaded</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000071f9</UniqueId>
			</Properties>
			<Item class="Folder" referent="RBXEDB7586C041E4FF28F3FAF2382C9B9BF">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Map1</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000071fa</UniqueId>
				</Properties>
				<Item class="Folder" referent="RBX0CFE572741954749B35C79A20146B84A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">Chests</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000071fb</UniqueId>
					</Properties>
					<Item class="Model" referent="RBX7F976C18CFD54E82984BCD12B34BBFC2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<token name="LevelOfDetail">0</token>
							<CoordinateFrame name="ModelMeshCFrame">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<Vector3 name="ModelMeshSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="ModelStreamingMode">0</token>
							<string name="Name">Chest</string>
							<bool name="NeedsPivotMigration">false</bool>
							<Ref name="PrimaryPart">RBX34C7349883184E26AA8D14B5D5D689B2</Ref>
							<float name="ScaleFactor">1</float>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">0b3605faaf024e0308a299e300001b74</UniqueId>
							<OptionalCoordinateFrame name="WorldPivotData">
								<CFrame>
									<X>-22.1324444</X>
									<Y>2</Y>
									<Z>74.0384369</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CFrame>
							</OptionalCoordinateFrame>
						</Properties>
						<Item class="Part" referent="RBX34C7349883184E26AA8D14B5D5D689B2">
							<Properties>
								<bool name="Anchored">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AudioCanCollide">true</bool>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>-22.1324444</X>
									<Y>1.75</Y>
									<Z>74.0384369</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<bool name="CanCollide">true</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="CastShadow">true</bool>
								<string name="CollisionGroup">Default</string>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="EnableFluidForces">true</bool>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">256</token>
								<string name="MaterialVariantSerialized"></string>
								<string name="Name">Chest</string>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000070ad</UniqueId>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">1</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>4</X>
									<Y>3.5</Y>
									<Z>4</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Part" referent="RBX5B56CBB6FC754990880355D487C9DF77">
							<Properties>
								<bool name="Anchored">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AudioCanCollide">true</bool>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>-22.1324444</X>
									<Y>3.75</Y>
									<Z>74.0384369</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<bool name="CanCollide">true</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="CastShadow">true</bool>
								<string name="CollisionGroup">Default</string>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="EnableFluidForces">true</bool>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de6000070ad</UniqueId>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">256</token>
								<string name="MaterialVariantSerialized"></string>
								<string name="Name">Drawer</string>
								<CoordinateFrame name="PivotOffset">
									<X>2</X>
									<Y>-0.25</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<UniqueId name="UniqueId">7745f3117c4a251a089954ce000055f7</UniqueId>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">1</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>4</X>
									<Y>0.5</Y>
									<Z>4</Z>
								</Vector3>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX1ED39187506C429B8346546631A0D9DB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">Walls</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a408912243000135dd</UniqueId>
					</Properties>
					<Item class="Part" referent="RBXF5C2A2ED5C1E4BBB83FF84D560D949DE">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-14.2403374</X>
								<Y>8.38592339</Y>
								<Z>60.0999985</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">Wall1</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">66680db6359cbbc70890955000006920</UniqueId>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>2.4793241</X>
								<Y>16.7718391</Y>
								<Z>17.9293575</Z>
							</Vector3>
						</Properties>
						<Item class="Attachment" referent="RBXA00D0449CBE248B5849B64134085D905">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>-1.23965454</X>
									<Y>1.9369669</Y>
									<Z>0.0910606384</Z>
									<R00>-1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>-1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">CameraAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">733767970d0729a408912243000135e3</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBXEC9E62955F0E4ABB83EC58BD3CF76A86">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>-1.23965454</X>
									<Y>1.9369669</Y>
									<Z>-3.53126526</Z>
									<R00>-1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>-1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">733767970d0729a408912243000135e3</UniqueId>
								<string name="Name">CameraAttachment2</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">733767970d0729a408912243000154da</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
					</Item>
					<Item class="Part" referent="RBXF6EBBF4F47894335B199C91B09E36C09">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-63.8546143</X>
								<Y>8.38592339</Y>
								<Z>60.0999985</Z>
								<R00>-1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<UniqueId name="HistoryId">66680db6359cbbc70890955000006920</UniqueId>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">Wall2</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">733767970d0729a408912243000143f1</UniqueId>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>2.4793241</X>
								<Y>16.7718391</Y>
								<Z>17.9293575</Z>
							</Vector3>
						</Properties>
						<Item class="Attachment" referent="RBXE7F205E107FE405082A0A99635FCD7F6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>-1.23965454</X>
									<Y>1.9369669</Y>
									<Z>0.0910606384</Z>
									<R00>-1</R00>
									<R01>0</R01>
									<R02>-8.74227766e-08</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>8.74227766e-08</R20>
									<R21>0</R21>
									<R22>-1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">733767970d0729a408912243000135e3</UniqueId>
								<string name="Name">CameraAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">733767970d0729a408912243000143f2</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
					</Item>
					<Item class="Part" referent="RBX3C2D080837334287A363CC96D969F7FA">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-29.7603397</X>
								<Y>8.38591957</Y>
								<Z>40.9646797</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<UniqueId name="HistoryId">66680db6359cbbc70890955000006920</UniqueId>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">Wall3</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">733767970d0729a408912243000159a4</UniqueId>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>2.4793241</X>
								<Y>16.7718391</Y>
								<Z>17.9293575</Z>
							</Vector3>
						</Properties>
						<Item class="Attachment" referent="RBXD8A5274DFEFB4CE9BCC3C6C0524C750B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>-1.23965454</X>
									<Y>1.9369669</Y>
									<Z>0.0910606384</Z>
									<R00>-1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>-1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">733767970d0729a408912243000135e3</UniqueId>
								<string name="Name">CameraAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">733767970d0729a408912243000159a5</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBX80CE50654C4041F6ACC425C5F180B640">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>-1.23965454</X>
									<Y>1.9369669</Y>
									<Z>-3.53126526</Z>
									<R00>-1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>-1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">733767970d0729a408912243000135e3</UniqueId>
								<string name="Name">CameraAttachment2</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">733767970d0729a408912243000159a6</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Model" referent="RBX75CCDE1CB7044549ADB53D1F873DDAAF">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="LevelOfDetail">0</token>
				<CoordinateFrame name="ModelMeshCFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
				<Vector3 name="ModelMeshSize">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="ModelStreamingMode">0</token>
				<string name="Name">SecurityCamera</string>
				<bool name="NeedsPivotMigration">false</bool>
				<Ref name="PrimaryPart">RBXE72C5323F2E54C08851E5566790EB066</Ref>
				<float name="ScaleFactor">1</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">733767970d0729a408912243000135c5</UniqueId>
				<OptionalCoordinateFrame name="WorldPivotData">
					<CFrame>
						<X>-18.570467</X>
						<Y>9.47479439</Y>
						<Z>63.5800018</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CFrame>
				</OptionalCoordinateFrame>
			</Properties>
			<Item class="Part" referent="RBXFF25543CA049496A8BB8C8CAB3174D71">
				<Properties>
					<bool name="Anchored">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-16.8145733</X>
						<Y>8.58728313</Y>
						<Z>63.2208595</Z>
						<R00>-0.992546141</R00>
						<R01>0</R01>
						<R02>0.121869326</R02>
						<R10>0.121869326</R10>
						<R11>0</R11>
						<R12>0.992546141</R12>
						<R20>0</R20>
						<R21>1</R21>
						<R22>0</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Big</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">66680db6359cbbc70890955000006c06</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">2</token>
					<Vector3 name="size">
						<X>3.14934349</X>
						<Y>2</Y>
						<Z>0.415768385</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Part" referent="RBXE2E9523DB31D4C529A2A6E43ADD8FC79">
				<Properties>
					<bool name="Anchored">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-18.7388916</X>
						<Y>9.25434208</Y>
						<Z>63.2208595</Z>
						<R00>-0.681998432</R00>
						<R01>0</R01>
						<R02>0.7313537</R02>
						<R10>0.7313537</R10>
						<R11>0</R11>
						<R12>0.681998432</R12>
						<R20>0</R20>
						<R21>1</R21>
						<R22>0</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">66680db6359cbbc70890955000006c06</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Small</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">66680db6359cbbc70890955000006eea</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">2</token>
					<Vector3 name="size">
						<X>1.38441133</X>
						<Y>2</Y>
						<Z>0.415768385</Z>
					</Vector3>
				</Properties>
				<Item class="Motor6D" referent="RBX711DA8613A024F8CAAFD9DC8380DE669">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="C0">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<CoordinateFrame name="C1">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="DesiredAngle">0</float>
						<bool name="Enabled">true</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="MaxVelocity">0</float>
						<string name="Name">Motor6D</string>
						<Ref name="Part0">RBXE2E9523DB31D4C529A2A6E43ADD8FC79</Ref>
						<Ref name="Part1">RBXE72C5323F2E54C08851E5566790EB066</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">66680db6359cbbc70890955000007588</UniqueId>
					</Properties>
				</Item>
				<Item class="IKControl" referent="RBX725EF5BBA5974EE38811F21CB86B06DD">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<Ref name="ChainRoot">null</Ref>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Enabled">true</bool>
						<Ref name="EndEffector">null</Ref>
						<CoordinateFrame name="EndEffectorOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">IKControl</string>
						<CoordinateFrame name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<Ref name="Pole">null</Ref>
						<int name="Priority">0</int>
						<float name="SmoothTime">0.0500000007</float>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<Ref name="Target">null</Ref>
						<token name="Type">0</token>
						<UniqueId name="UniqueId">66680db6359cbbc7089095500000759f</UniqueId>
						<float name="Weight">1</float>
					</Properties>
				</Item>
				<Item class="AlignOrientation" referent="RBX8B0D67E16EA14BD09E3A60E8B9C810DA">
					<Properties>
						<token name="AlignType">0</token>
						<Ref name="Attachment0">null</Ref>
						<Ref name="Attachment1">null</Ref>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<int name="Color">23</int>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Enabled">true</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="MaxAngularVelocity">INF</float>
						<float name="MaxTorque">10000</float>
						<token name="Mode">1</token>
						<string name="Name">AlignOrientation</string>
						<bool name="PrimaryAxisOnly">false</bool>
						<bool name="ReactionTorqueEnabled">false</bool>
						<float name="Responsiveness">10</float>
						<bool name="RigidityEnabled">false</bool>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">66680db6359cbbc708909550000075c5</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX790E98FE0EB940088CD7EF33625F064F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0.670682907</X>
							<Y>-0.386501312</Y>
							<Z>-0.0774064064</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">66680db6359cbbc70890955000006720</UniqueId>
						<string name="Name">Rotate</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">66680db6359cbbc7089095500000dd02</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="WeldConstraint" referent="RBXABDD175655544FADA2DA4754467B93AC">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame0">
							<X>-1.80023766</X>
							<Y>0</Y>
							<Z>0.952424049</Z>
							<R00>0.766044497</R00>
							<R01>0</R01>
							<R02>0.642787635</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>-0.642787635</R20>
							<R21>0</R21>
							<R22>0.766044497</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">WeldConstraint</string>
						<Ref name="Part0Internal">RBXE2E9523DB31D4C529A2A6E43ADD8FC79</Ref>
						<Ref name="Part1Internal">RBXFF25543CA049496A8BB8C8CAB3174D71</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<int name="State">3</int>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a4089122430001384e</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBXE72C5323F2E54C08851E5566790EB066">
				<Properties>
					<bool name="Anchored">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-19.9146309</X>
						<Y>10.2605448</Y>
						<Z>63.5800018</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Camera</string>
					<CoordinateFrame name="PivotOffset">
						<X>0.692209244</X>
						<Y>-0.487681389</Y>
						<Z>-0.359142303</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">66680db6359cbbc70890955000006677</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>4</X>
						<Y>1</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBX77D7D540E912430A80165FEEE561505E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>-1.99996948</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">Face</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">66680db6359cbbc70890955000006720</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBXD160E036492F4A549A7C43C86330B24C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0.753692627</X>
							<Y>-0.386500359</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">66680db6359cbbc70890955000006720</UniqueId>
						<string name="Name">Rotate</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">66680db6359cbbc7089095500000db6d</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Motor6D" referent="RBXB6BB6A8B9B3D4C7F83D018F66DD22476">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="C0">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<CoordinateFrame name="C1">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="DesiredAngle">0</float>
						<bool name="Enabled">true</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="MaxVelocity">0</float>
						<string name="Name">Motor6D</string>
						<Ref name="Part0">RBXE72C5323F2E54C08851E5566790EB066</Ref>
						<Ref name="Part1">RBXE2E9523DB31D4C529A2A6E43ADD8FC79</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a408912243000137ea</UniqueId>
					</Properties>
				</Item>
				<Item class="WeldConstraint" referent="RBXB5C820059DCE4A01835CAC2D8DC040EE">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame0">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">WeldConstraint</string>
						<Ref name="Part0Internal">null</Ref>
						<Ref name="Part1Internal">null</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<int name="State">3</int>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a40891224300013871</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Model" referent="RBXF7B78B4F7573427796D2B773C5B8A598">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">733767970d0729a408912243000135c5</UniqueId>
				<token name="LevelOfDetail">0</token>
				<CoordinateFrame name="ModelMeshCFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
				<Vector3 name="ModelMeshSize">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="ModelStreamingMode">0</token>
				<string name="Name">SecurityCamera3</string>
				<bool name="NeedsPivotMigration">false</bool>
				<Ref name="PrimaryPart">RBX614270086FE6411DB82CB523B27F4553</Ref>
				<float name="ScaleFactor">1</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">733767970d0729a408912243000156ff</UniqueId>
				<OptionalCoordinateFrame name="WorldPivotData">
					<CFrame>
						<X>-46.6544189</X>
						<Y>11.0679941</Y>
						<Z>20.2049885</Z>
						<R00>0.749084353</R00>
						<R01>-0.0919757932</R01>
						<R02>0.656059027</R02>
						<R10>0.121869072</R10>
						<R11>0.99254632</R11>
						<R12>0</R12>
						<R20>-0.651169002</R20>
						<R21>0.0799533278</R21>
						<R22>0.754709601</R22>
					</CFrame>
				</OptionalCoordinateFrame>
			</Properties>
			<Item class="Part" referent="RBXF28FEB537E8A443EB36E609FB57AE5A6">
				<Properties>
					<bool name="Anchored">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-44.7539291</X>
						<Y>10.3228912</Y>
						<Z>18.5528908</Z>
						<R00>-0.754710376</R00>
						<R01>-2.98023224e-08</R01>
						<R02>-0.656059086</R02>
						<R10>8.94069672e-08</R10>
						<R11>1.00000048</R11>
						<R12>-2.9449053e-08</R12>
						<R20>0.656059504</R20>
						<R21>8.94069672e-08</R21>
						<R22>-0.754709542</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">66680db6359cbbc70890955000006c06</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Big</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">733767970d0729a40891224300015700</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">2</token>
					<Vector3 name="size">
						<X>3.14934349</X>
						<Y>2</Y>
						<Z>0.415768385</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Part" referent="RBXD0B8952738F546EFA34BBC4ADC333FE4">
				<Properties>
					<bool name="Anchored">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-46.2445221</X>
						<Y>10.7255487</Y>
						<Z>19.848671</Z>
						<R00>-0.57814157</R00>
						<R01>0.656059086</R01>
						<R02>0.485118568</R02>
						<R10>0.642788172</R10>
						<R11>2.94491045e-08</R11>
						<R12>0.766044617</R12>
						<R20>0.502570689</R20>
						<R21>0.754709542</R21>
						<R22>-0.421706975</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">66680db6359cbbc70890955000006c06</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Small</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">733767970d0729a40891224300015701</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">2</token>
					<Vector3 name="size">
						<X>1.38441133</X>
						<Y>2</Y>
						<Z>0.415768385</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBX4D7A4E5ECA5B44BCABE5765104348A51">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0.670682907</X>
							<Y>-0.386501312</Y>
							<Z>-0.0774064064</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">66680db6359cbbc70890955000006720</UniqueId>
						<string name="Name">Rotate</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a40891224300015702</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Motor6D" referent="RBXFCA705C3612D4D84951EE0CFD51B40C1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="C0">
							<X>-1.80023766</X>
							<Y>0</Y>
							<Z>0.952424049</Z>
							<R00>0.766044497</R00>
							<R01>0</R01>
							<R02>0.642787635</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>-0.642787635</R20>
							<R21>0</R21>
							<R22>0.766044497</R22>
						</CoordinateFrame>
						<CoordinateFrame name="C1">
							<X>-0.0161976814</X>
							<Y>-0.0249143764</Y>
							<Z>-2.28881836e-05</Z>
							<R00>1</R00>
							<R01>-7.94333607e-14</R01>
							<R02>-2.68220134e-07</R02>
							<R10>2.68220134e-07</R10>
							<R11>5.27055816e-14</R11>
							<R12>1</R12>
							<R20>-7.94333674e-14</R20>
							<R21>-1</R21>
							<R22>5.27055985e-14</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="DesiredAngle">0</float>
						<bool name="Enabled">true</bool>
						<UniqueId name="HistoryId">733767970d0729a40891224300013a42</UniqueId>
						<float name="MaxVelocity">0</float>
						<string name="Name">Big</string>
						<Ref name="Part0">RBXD0B8952738F546EFA34BBC4ADC333FE4</Ref>
						<Ref name="Part1">RBXF28FEB537E8A443EB36E609FB57AE5A6</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a40891224300015703</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX614270086FE6411DB82CB523B27F4553">
				<Properties>
					<bool name="Anchored">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-46.9821777</X>
						<Y>11.4676828</Y>
						<Z>20.9657726</Z>
						<R00>0.749084771</R00>
						<R01>-0.0919758454</R01>
						<R02>0.656059086</R02>
						<R10>0.121869072</R10>
						<R11>0.992546558</R11>
						<R12>2.94491009e-08</R12>
						<R20>-0.65116924</R20>
						<R21>0.0799534023</R21>
						<R22>0.754709542</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">66680db6359cbbc70890955000006677</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Camera</string>
					<CoordinateFrame name="PivotOffset">
						<X>0.692209244</X>
						<Y>-0.487681389</Y>
						<Z>-0.359142303</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">733767970d0729a40891224300015704</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>4</X>
						<Y>1</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBXDAE902020D874FABB3F2DC1206302D8C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>-1.99996948</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">66680db6359cbbc70890955000006720</UniqueId>
						<string name="Name">Face</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a40891224300015705</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX6CD5844CB0C54200BD951ED334B0AFD0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0.753692627</X>
							<Y>-0.386500359</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">66680db6359cbbc70890955000006720</UniqueId>
						<string name="Name">Rotate</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a40891224300015706</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Motor6D" referent="RBX8BFEC3047A1B408A8537F3450D9F3BB0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="C0">
							<X>1.1895448</X>
							<Y>-0.893764615</Y>
							<Z>-0.359142303</Z>
							<R00>-0.681998491</R00>
							<R01>7.10539178e-15</R01>
							<R02>0.73135376</R02>
							<R10>0.73135376</R10>
							<R11>3.55269631e-15</R11>
							<R12>0.681998491</R12>
							<R20>2.24758837e-15</R20>
							<R21>1</R21>
							<R22>-7.61948657e-15</R22>
						</CoordinateFrame>
						<CoordinateFrame name="C1">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="DesiredAngle">0</float>
						<bool name="Enabled">true</bool>
						<UniqueId name="HistoryId">733767970d0729a40891224300013a32</UniqueId>
						<float name="MaxVelocity">0</float>
						<string name="Name">Small</string>
						<Ref name="Part0">RBX614270086FE6411DB82CB523B27F4553</Ref>
						<Ref name="Part1">RBXD0B8952738F546EFA34BBC4ADC333FE4</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a40891224300015707</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Model" referent="RBXCAF225A1EC00421588CE80C256CFA8E9">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">733767970d0729a408912243000135c5</UniqueId>
				<token name="LevelOfDetail">0</token>
				<CoordinateFrame name="ModelMeshCFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
				<Vector3 name="ModelMeshSize">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="ModelStreamingMode">0</token>
				<string name="Name">SecurityCameraSImple1</string>
				<bool name="NeedsPivotMigration">false</bool>
				<Ref name="PrimaryPart">RBXA1040D243978488C9E3FBE157DF42BA0</Ref>
				<float name="ScaleFactor">1</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">733767970d0729a40891224300015d30</UniqueId>
				<OptionalCoordinateFrame name="WorldPivotData">
					<CFrame>
						<X>-15.4799995</X>
						<Y>9.77286339</Y>
						<Z>53.5625725</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CFrame>
				</OptionalCoordinateFrame>
			</Properties>
			<Item class="Part" referent="RBXA1040D243978488C9E3FBE157DF42BA0">
				<Properties>
					<bool name="Anchored">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-16.1722088</X>
						<Y>10.2605448</Y>
						<Z>53.9217148</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">66680db6359cbbc70890955000006677</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Camera</string>
					<CoordinateFrame name="PivotOffset">
						<X>0.692209244</X>
						<Y>-0.487681389</Y>
						<Z>-0.359142303</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">733767970d0729a40891224300015d38</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>4</X>
						<Y>1</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBX019CF96AC21C4D8AB1E8FF283C4705CA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>-1.99996948</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">66680db6359cbbc70890955000006720</UniqueId>
						<string name="Name">Face</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a40891224300015d39</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX346FEF493111466A89A9F5BB4BCFA5DB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0.753692627</X>
							<Y>-0.386500359</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">66680db6359cbbc70890955000006720</UniqueId>
						<string name="Name">Rotate</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a40891224300015d3a</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Model" referent="RBX6891BB9752474918883878BC29286E22">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">733767970d0729a408912243000135c5</UniqueId>
				<token name="LevelOfDetail">0</token>
				<CoordinateFrame name="ModelMeshCFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
				<Vector3 name="ModelMeshSize">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="ModelStreamingMode">0</token>
				<string name="Name">SecurityCamera2</string>
				<bool name="NeedsPivotMigration">false</bool>
				<Ref name="PrimaryPart">RBX736801F7E31C4367B7A65556D99B5826</Ref>
				<float name="ScaleFactor">1</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">733767970d0729a408912243000138c0</UniqueId>
				<OptionalCoordinateFrame name="WorldPivotData">
					<CFrame>
						<X>-58.5220985</X>
						<Y>11.0679951</Y>
						<Z>60.0089149</Z>
						<R00>-0.992546976</R00>
						<R01>0.121869184</R01>
						<R02>0</R02>
						<R10>0.121869184</R10>
						<R11>0.992546976</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>-1</R22>
					</CFrame>
				</OptionalCoordinateFrame>
			</Properties>
			<Item class="Part" referent="RBXD705DE4507894D0EAFFF5FBFD4074E8A">
				<Properties>
					<bool name="Anchored">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-61.0402908</X>
						<Y>10.3228884</Y>
						<Z>60.0089378</Z>
						<R00>1.0000025</R00>
						<R01>2.98023224e-08</R01>
						<R02>-7.30305844e-14</R02>
						<R10>-2.98023224e-08</R10>
						<R11>1.0000025</R11>
						<R12>4.65504473e-14</R12>
						<R20>7.25974118e-14</R20>
						<R21>-5.0076554e-14</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">66680db6359cbbc70890955000006c06</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Big</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">733767970d0729a408912243000138c1</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">2</token>
					<Vector3 name="size">
						<X>3.14934349</X>
						<Y>2</Y>
						<Z>0.415768385</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Part" referent="RBX7F971D56DA04453C834503CB28B9405E">
				<Properties>
					<bool name="Anchored">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-59.0652161</X>
						<Y>10.7255468</Y>
						<Z>60.0089149</Z>
						<R00>0.766046226</R00>
						<R01>-6.4029986e-15</R01>
						<R02>-0.642789364</R02>
						<R10>0.642789364</R10>
						<R11>6.15527069e-15</R11>
						<R12>0.766046226</R12>
						<R20>-3.54673363e-15</R20>
						<R21>-1</R21>
						<R22>6.40801389e-15</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">66680db6359cbbc70890955000006c06</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Small</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">733767970d0729a408912243000138c2</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">2</token>
					<Vector3 name="size">
						<X>1.38441133</X>
						<Y>2</Y>
						<Z>0.415768385</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBXC1AE77D41B36436694888A73AE695B6F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0.670682907</X>
							<Y>-0.386501312</Y>
							<Z>-0.0774064064</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">66680db6359cbbc70890955000006720</UniqueId>
						<string name="Name">Rotate</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a408912243000138c6</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Motor6D" referent="RBX297CAD225307478CB525521077A7BD8D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="C0">
							<X>-1.80023766</X>
							<Y>0</Y>
							<Z>0.952424049</Z>
							<R00>0.766044497</R00>
							<R01>0</R01>
							<R02>0.642787635</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>-0.642787635</R20>
							<R21>0</R21>
							<R22>0.766044497</R22>
						</CoordinateFrame>
						<CoordinateFrame name="C1">
							<X>-0.0161976814</X>
							<Y>-0.0249143764</Y>
							<Z>-2.28881836e-05</Z>
							<R00>1</R00>
							<R01>-7.94333607e-14</R01>
							<R02>-2.68220134e-07</R02>
							<R10>2.68220134e-07</R10>
							<R11>5.27055816e-14</R11>
							<R12>1</R12>
							<R20>-7.94333674e-14</R20>
							<R21>-1</R21>
							<R22>5.27055985e-14</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="DesiredAngle">0</float>
						<bool name="Enabled">true</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="MaxVelocity">0</float>
						<string name="Name">Big</string>
						<Ref name="Part0">RBX7F971D56DA04453C834503CB28B9405E</Ref>
						<Ref name="Part1">RBXD705DE4507894D0EAFFF5FBFD4074E8A</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a40891224300013a42</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX736801F7E31C4367B7A65556D99B5826">
				<Properties>
					<bool name="Anchored">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-57.7756119</X>
						<Y>11.4676828</Y>
						<Z>59.6497726</Z>
						<R00>-0.992548525</R00>
						<R01>0.12186937</R01>
						<R02>2.16483159e-16</R02>
						<R10>0.12186937</R10>
						<R11>0.992548525</R11>
						<R12>1.76311761e-15</R12>
						<R20>0</R20>
						<R21>-1.77635684e-15</R21>
						<R22>-1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">66680db6359cbbc70890955000006677</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Camera</string>
					<CoordinateFrame name="PivotOffset">
						<X>0.692209244</X>
						<Y>-0.487681389</Y>
						<Z>-0.359142303</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">733767970d0729a408912243000138c8</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>4</X>
						<Y>1</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBX129728A67B514A11A08062B94AC63C84">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>-1.99996948</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">66680db6359cbbc70890955000006720</UniqueId>
						<string name="Name">Face</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a408912243000138c9</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBXA2F1DB79412C48DCB37FAF31873159A3">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0.753692627</X>
							<Y>-0.386500359</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">66680db6359cbbc70890955000006720</UniqueId>
						<string name="Name">Rotate</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a408912243000138ca</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Motor6D" referent="RBXB64D55491F5942BCAFE9045835B7018C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="C0">
							<X>1.1895448</X>
							<Y>-0.893764615</Y>
							<Z>-0.359142303</Z>
							<R00>-0.681998491</R00>
							<R01>7.10539178e-15</R01>
							<R02>0.73135376</R02>
							<R10>0.73135376</R10>
							<R11>3.55269631e-15</R11>
							<R12>0.681998491</R12>
							<R20>2.24758837e-15</R20>
							<R21>1</R21>
							<R22>-7.61948657e-15</R22>
						</CoordinateFrame>
						<CoordinateFrame name="C1">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="DesiredAngle">0</float>
						<bool name="Enabled">true</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="MaxVelocity">0</float>
						<string name="Name">Small</string>
						<Ref name="Part0">RBX736801F7E31C4367B7A65556D99B5826</Ref>
						<Ref name="Part1">RBX7F971D56DA04453C834503CB28B9405E</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a40891224300013a32</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Part" referent="RBXC0091F0F6AE24EF5AEB0D3DA30A6DA0D">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AudioCanCollide">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>-69.7130585</X>
					<Y>3.15754628</Y>
					<Z>20.5257149</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">false</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Area1</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0.699999988</float>
				<UniqueId name="UniqueId">1e81e3ab4178f7f508957bec00000de2</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>26.3738594</X>
					<Y>6.31509256</Y>
					<Z>17.1485405</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBXBAEA1BD3E1F846908E0437BE731079A5">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AudioCanCollide">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>-19.1499882</X>
					<Y>1.5999999</Y>
					<Z>-19.1500168</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">false</bool>
				<bool name="CanQuery">false</bool>
				<bool name="CanTouch">false</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4289003520</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">bau1</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0.899999976</float>
				<UniqueId name="UniqueId">206247380e8f98a908a38b6700000a24</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>0.999999762</X>
					<Y>1</Y>
					<Z>1</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX0AE5C80D4B35438984151DD5CD4A719E">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="LevelOfDetail">0</token>
				<CoordinateFrame name="ModelMeshCFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
				<Vector3 name="ModelMeshSize">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="ModelStreamingMode">0</token>
				<string name="Name">MetalDetector</string>
				<bool name="NeedsPivotMigration">false</bool>
				<Ref name="PrimaryPart">null</Ref>
				<float name="ScaleFactor">1</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">43c00655b7588da408b74743000012c7</UniqueId>
				<OptionalCoordinateFrame name="WorldPivotData">
					<CFrame>
						<X>-54</X>
						<Y>6.5</Y>
						<Z>51.9999924</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CFrame>
				</OptionalCoordinateFrame>
			</Properties>
			<Item class="Model" referent="RBXAF1A7532195D4AA5A4A82F4A31F8793D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<token name="LevelOfDetail">0</token>
					<CoordinateFrame name="ModelMeshCFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
					<Vector3 name="ModelMeshSize">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="ModelStreamingMode">0</token>
					<string name="Name">Bar</string>
					<bool name="NeedsPivotMigration">false</bool>
					<Ref name="PrimaryPart">null</Ref>
					<float name="ScaleFactor">1</float>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">22ef1a1bb98897c308be5c68000069dd</UniqueId>
					<OptionalCoordinateFrame name="WorldPivotData">
						<CFrame>
							<X>-54</X>
							<Y>6.5</Y>
							<Z>52</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CFrame>
					</OptionalCoordinateFrame>
				</Properties>
				<Item class="Part" referent="RBXA5B624D527DE42C6AD27211CD36E434F">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-52</X>
							<Y>6</Y>
							<Z>52</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">7745f3117c4a251a089954ce00001051</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">Part</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce000013d3</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>1</X>
							<Y>8</Y>
							<Z>2</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX7587D3C955C4400EAD73865E5B85DF06">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-54</X>
							<Y>9.5</Y>
							<Z>52</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">7745f3117c4a251a089954ce00001051</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">Part</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001531</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>4</X>
							<Y>1</Y>
							<Z>2</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX29B47554A0D54577A1E7C40D5D836660">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-56</X>
							<Y>6</Y>
							<Z>52</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">Part</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001051</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>1</X>
							<Y>8</Y>
							<Z>2</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX33CFAED936214EB1A3A90E6AC90A79D4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<token name="LevelOfDetail">0</token>
					<CoordinateFrame name="ModelMeshCFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
					<Vector3 name="ModelMeshSize">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="ModelStreamingMode">0</token>
					<string name="Name">AlertLight1</string>
					<bool name="NeedsPivotMigration">false</bool>
					<Ref name="PrimaryPart">null</Ref>
					<float name="ScaleFactor">1</float>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">22ef1a1bb98897c308be5c6800006a1c</UniqueId>
					<OptionalCoordinateFrame name="WorldPivotData">
						<CFrame>
							<X>-54.0000076</X>
							<Y>9.5</Y>
							<Z>53.0999908</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>-1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>-1</R22>
						</CFrame>
					</OptionalCoordinateFrame>
				</Properties>
				<Item class="Part" referent="RBXF2C2069AE1DE43B195A6CDB3AB0C4F90">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-54.0000076</X>
							<Y>9.5</Y>
							<Z>53.0249825</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>1</R02>
							<R10>0</R10>
							<R11>-1</R11>
							<R12>0</R12>
							<R20>1</R20>
							<R21>0</R21>
							<R22>-0</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4283058763</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">7745f3117c4a251a089954ce00003845</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">Part</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000461f</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">2</token>
						<Vector3 name="size">
							<X>0.0499999523</X>
							<Y>2</Y>
							<Z>0.699999988</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBXAE8AAB6535C5447AA93A8125C4AC4D3F">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-54.0000076</X>
							<Y>9.5</Y>
							<Z>53.0749817</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>1</R02>
							<R10>0</R10>
							<R11>-1</R11>
							<R12>0</R12>
							<R20>1</R20>
							<R21>0</R21>
							<R22>-0</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4285098346</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">7745f3117c4a251a089954ce00003845</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">Part</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00004621</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">2</token>
						<Vector3 name="size">
							<X>0.149999946</X>
							<Y>2</Y>
							<Z>0.599999964</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX34A61E313A7A44CBAFFFBE9662E94D19">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-54.0000076</X>
							<Y>9.5</Y>
							<Z>53.0999908</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>-1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>-1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4283826175</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">7745f3117c4a251a089954ce00004172</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">288</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">AlertLight</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags">QWxlcnRMaWdodA==</BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00004620</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">0</token>
						<Vector3 name="size">
							<X>0.600000024</X>
							<Y>0.600000024</Y>
							<Z>0.600000024</Z>
						</Vector3>
					</Properties>
					<Item class="PointLight" referent="RBX755806B983FA44168A32F03B7A4D5EBD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="Brightness">0.5</float>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color">
								<R>0.333333343</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Enabled">true</bool>
							<UniqueId name="HistoryId">22ef1a1bb98897c308be5c6800009226</UniqueId>
							<string name="Name">PointLight</string>
							<float name="Range">6</float>
							<bool name="Shadows">false</bool>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">22ef1a1bb98897c308be5c68000092e4</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Model" referent="RBX983DE39358144D1F9C7D04A31D1739E3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<token name="LevelOfDetail">0</token>
					<CoordinateFrame name="ModelMeshCFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
					<Vector3 name="ModelMeshSize">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="ModelStreamingMode">0</token>
					<string name="Name">AlertLight1</string>
					<bool name="NeedsPivotMigration">false</bool>
					<Ref name="PrimaryPart">null</Ref>
					<float name="ScaleFactor">1</float>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">22ef1a1bb98897c308be5c6800006a1d</UniqueId>
					<OptionalCoordinateFrame name="WorldPivotData">
						<CFrame>
							<X>-54.0000076</X>
							<Y>9.5</Y>
							<Z>50.8999901</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CFrame>
					</OptionalCoordinateFrame>
				</Properties>
				<Item class="Part" referent="RBX102A26C271F7485AA3CEFB3EE0A3580D">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-54.0000076</X>
							<Y>9.5</Y>
							<Z>50.8999901</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>0.707106769</R11>
							<R12>0.707106769</R12>
							<R20>0</R20>
							<R21>-0.707106769</R21>
							<R22>0.707106769</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4283826175</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">288</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">AlertLight</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags">QWxlcnRMaWdodA==</BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00004172</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">0</token>
						<Vector3 name="size">
							<X>0.600000024</X>
							<Y>0.600000024</Y>
							<Z>0.600000024</Z>
						</Vector3>
					</Properties>
					<Item class="PointLight" referent="RBXD1F0FF44E2714796B3FF6D2D5651DFF9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="Brightness">0.5</float>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color">
								<R>0.333333343</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Enabled">true</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">PointLight</string>
							<float name="Range">6</float>
							<bool name="Shadows">false</bool>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">22ef1a1bb98897c308be5c6800009226</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Part" referent="RBX2DB10028DFD54FFA9C4201F6377182FB">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-54.0000076</X>
							<Y>9.5</Y>
							<Z>50.9749985</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>-0</R12>
							<R20>-1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4283058763</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">Part</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00003845</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">2</token>
						<Vector3 name="size">
							<X>0.0499999523</X>
							<Y>2</Y>
							<Z>0.699999988</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBXA2C5730EADFA477D92E0F502A89FBF02">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-54.0000076</X>
							<Y>9.5</Y>
							<Z>50.9249992</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>-0</R12>
							<R20>-1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4285098346</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">7745f3117c4a251a089954ce00003845</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">Part</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00003faf</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">2</token>
						<Vector3 name="size">
							<X>0.149999946</X>
							<Y>2</Y>
							<Z>0.599999964</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="Model" referent="RBX6C42CDC3DEE646239335D68C013CF346">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<token name="LevelOfDetail">0</token>
					<CoordinateFrame name="ModelMeshCFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
					<Vector3 name="ModelMeshSize">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="ModelStreamingMode">0</token>
					<string name="Name">AlertBarLight</string>
					<bool name="NeedsPivotMigration">false</bool>
					<Ref name="PrimaryPart">null</Ref>
					<float name="ScaleFactor">1</float>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">22ef1a1bb98897c308be5c6800006a1e</UniqueId>
					<OptionalCoordinateFrame name="WorldPivotData">
						<CFrame>
							<X>-54</X>
							<Y>6.02499962</Y>
							<Z>52</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CFrame>
					</OptionalCoordinateFrame>
				</Properties>
				<Item class="Part" referent="RBXB01486EE67B6490EB5ADE4FAE67B7B8F">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-55.5</X>
							<Y>6</Y>
							<Z>52</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4283826175</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">7745f3117c4a251a089954ce00001051</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">288</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">AlertLight</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags">QWxlcnRMaWdodA==</BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00003139</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>0.0500000007</X>
							<Y>5.99999952</Y>
							<Z>0.100000001</Z>
						</Vector3>
					</Properties>
					<Item class="PointLight" referent="RBX4B87A49A5A51487FB457D5AAE2E423A7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="Brightness">0.5</float>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color">
								<R>0.333333343</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Enabled">true</bool>
							<UniqueId name="HistoryId">22ef1a1bb98897c308be5c6800009226</UniqueId>
							<string name="Name">PointLight</string>
							<float name="Range">6</float>
							<bool name="Shadows">false</bool>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">22ef1a1bb98897c308be5c68000092e7</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Part" referent="RBX793618ABC2DC43C2B70FF159F459D462">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-54</X>
							<Y>9</Y>
							<Z>52</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4283826175</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">7745f3117c4a251a089954ce00001051</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">288</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">AlertLight</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags">QWxlcnRMaWdodA==</BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00003562</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>3.20000005</X>
							<Y>0.0999999642</Y>
							<Z>0.0999984741</Z>
						</Vector3>
					</Properties>
					<Item class="PointLight" referent="RBX059207CE41F14CC883DDF0B391D30738">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="Brightness">0.5</float>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color">
								<R>0.333333343</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Enabled">true</bool>
							<UniqueId name="HistoryId">22ef1a1bb98897c308be5c6800009226</UniqueId>
							<string name="Name">PointLight</string>
							<float name="Range">6</float>
							<bool name="Shadows">false</bool>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">22ef1a1bb98897c308be5c68000092e5</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Part" referent="RBXF22DF88AA94148B5B3AD79A6B9C05B53">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-52.4999962</X>
							<Y>6</Y>
							<Z>52</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4283826175</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">7745f3117c4a251a089954ce00001051</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">288</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">AlertLight</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags">QWxlcnRMaWdodA==</BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00002f31</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>0.0500000007</X>
							<Y>5.99999952</Y>
							<Z>0.100000001</Z>
						</Vector3>
					</Properties>
					<Item class="PointLight" referent="RBX4D7D2AD12E7240A09237022917C624BF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="Brightness">0.5</float>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color">
								<R>0.333333343</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Enabled">true</bool>
							<UniqueId name="HistoryId">22ef1a1bb98897c308be5c6800009226</UniqueId>
							<string name="Name">PointLight</string>
							<float name="Range">6</float>
							<bool name="Shadows">false</bool>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">22ef1a1bb98897c308be5c68000092e6</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Part" referent="RBXB52504B2336549DB828EEE0E1AE31D2E">
				<Properties>
					<bool name="Anchored">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-54</X>
						<Y>5.49999952</Y>
						<Z>52</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CanQuery">false</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4294901760</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">7745f3117c4a251a089954ce00001051</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">DetectionArea</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0.600000024</float>
					<UniqueId name="UniqueId">22ef1a1bb98897c308be5c6800006d47</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>2.79999995</X>
						<Y>6.80000019</Y>
						<Z>0.586206794</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="Model" referent="RBX0FCB10E227E145568CF7F5934F8203E4">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="LevelOfDetail">0</token>
				<CoordinateFrame name="ModelMeshCFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
				<Vector3 name="ModelMeshSize">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="ModelStreamingMode">0</token>
				<string name="Name">Rig</string>
				<bool name="NeedsPivotMigration">false</bool>
				<Ref name="PrimaryPart">RBX32C95C900677423DBE6731CE3FBE118B</Ref>
				<float name="ScaleFactor">1</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001775</UniqueId>
				<OptionalCoordinateFrame name="WorldPivotData">
					<CFrame>
						<X>-53.849987</X>
						<Y>0</Y>
						<Z>54.2999878</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CFrame>
				</OptionalCoordinateFrame>
			</Properties>
			<Item class="Part" referent="RBX32C95C900677423DBE6731CE3FBE118B">
				<Properties>
					<bool name="Anchored">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">4</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-53.849987</X>
						<Y>4.5</Y>
						<Z>54.2999878</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4286545791</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Head</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>-4.5</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001776</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">0</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>2</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="SpecialMesh" referent="RBX76EB8CD7C8984B90AB1059880BDE3FFF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="MeshId"><null></null></Content>
						<token name="MeshType">0</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1.25</X>
							<Y>1.25</Y>
							<Z>1.25</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<Content name="TextureId"><null></null></Content>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001777</UniqueId>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Decal" referent="RBXCA6C9BD2B7064CF3929FB7327A85C961">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<Color3 name="Color3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<bool name="DefinesCapabilities">false</bool>
						<token name="Face">5</token>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="MetalnessMap"><null></null></Content>
						<string name="Name">face</string>
						<Content name="NormalMap"><null></null></Content>
						<Content name="RoughnessMap"><null></null></Content>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<Content name="Texture"><url>rbxasset://textures/face.png</url></Content>
						<Content name="TexturePack"><null></null></Content>
						<string name="TexturePackMetadata"></string>
						<float name="Transparency">0</float>
						<Vector2 name="UVOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="UVScale">
							<X>1</X>
							<Y>1</Y>
						</Vector2>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001778</UniqueId>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX89F684860BC64EFFB10EE38C8E4EE1A2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0.600000024</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">HairAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001779</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBXE8FC426E62E2473EBB322B6C982BB28A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0.600000024</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">HatAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000177a</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX68ACE760E8D34CCB89ABA41B7A69A45C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>-0.600000024</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">FaceFrontAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000177b</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX230531AD87274A3F96FED3952A65B04E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">FaceCenterAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000177c</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX0E60E706EBD94461A70D95ACD77B466C">
				<Properties>
					<bool name="Anchored">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">4</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-53.849987</X>
						<Y>3</Y>
						<Z>54.2999878</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4286545791</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<float name="LeftParamA">0</float>
					<float name="LeftParamB">0</float>
					<token name="LeftSurface">2</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Torso</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">0</float>
					<float name="RightParamB">0</float>
					<token name="RightSurface">2</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000177d</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">0</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>2</X>
						<Y>2</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="Decal" referent="RBXCBFAD52F20D248ACB7B6E38C303F858A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<Color3 name="Color3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<bool name="DefinesCapabilities">false</bool>
						<token name="Face">5</token>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="MetalnessMap"><null></null></Content>
						<string name="Name">roblox</string>
						<Content name="NormalMap"><null></null></Content>
						<Content name="RoughnessMap"><null></null></Content>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<Content name="Texture"><null></null></Content>
						<Content name="TexturePack"><null></null></Content>
						<string name="TexturePackMetadata"></string>
						<float name="Transparency">0</float>
						<Vector2 name="UVOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="UVScale">
							<X>1</X>
							<Y>1</Y>
						</Vector2>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000177e</UniqueId>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX8E53FF0A251C4948A415497B36B267A8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>1</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">NeckAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000177f</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBXAACC1A9A2B7C4F3C9F83BA73299D1DD1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>-0.5</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">BodyFrontAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001780</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX86B94205E8A448009CC2D2AEFF4561FA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0.5</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">BodyBackAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001781</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBXC6E247B839044F958B6221674519A761">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>-1</X>
							<Y>1</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">LeftCollarAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001782</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBXE319E39742D34C109EE48BA5D7D25FEC">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>1</X>
							<Y>1</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">RightCollarAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001783</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX68AB5E506F804274B5273CEE299AA8E7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>-1</Y>
							<Z>-0.5</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">WaistFrontAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001784</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX958AB914E0D0445AB5DC18DFE1A8436A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>-1</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">WaistCenterAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001785</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX272D1559DBF8473BA09DF5E1C31A651D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>-1</Y>
							<Z>0.5</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">WaistBackAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001786</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Motor6D" referent="RBX80223F86DD934F93B69F2C28CB83797F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="C0">
							<X>1</X>
							<Y>0.5</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>-0</R12>
							<R20>-1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<CoordinateFrame name="C1">
							<X>-0.5</X>
							<Y>0.5</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>-0</R12>
							<R20>-1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="DesiredAngle">0</float>
						<bool name="Enabled">true</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="MaxVelocity">0.100000001</float>
						<string name="Name">Right Shoulder</string>
						<Ref name="Part0">RBX0E60E706EBD94461A70D95ACD77B466C</Ref>
						<Ref name="Part1">RBX331BBC98C20B4710B236D523C72FC356</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001787</UniqueId>
					</Properties>
				</Item>
				<Item class="Motor6D" referent="RBXED9D4C1D9CD44ED5A05867FE191A519A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="C0">
							<X>-1</X>
							<Y>0.5</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>-1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<CoordinateFrame name="C1">
							<X>0.5</X>
							<Y>0.5</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>-1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="DesiredAngle">0</float>
						<bool name="Enabled">true</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="MaxVelocity">0.100000001</float>
						<string name="Name">Left Shoulder</string>
						<Ref name="Part0">RBX0E60E706EBD94461A70D95ACD77B466C</Ref>
						<Ref name="Part1">RBXBD02EBDB408C4EAEAD2F7CC94CB30557</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001788</UniqueId>
					</Properties>
				</Item>
				<Item class="Motor6D" referent="RBX19BB9770D9EC4DFF8693889E1CE78C43">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="C0">
							<X>1</X>
							<Y>-1</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>-0</R12>
							<R20>-1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<CoordinateFrame name="C1">
							<X>0.5</X>
							<Y>1</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>-0</R12>
							<R20>-1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="DesiredAngle">0</float>
						<bool name="Enabled">true</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="MaxVelocity">0.100000001</float>
						<string name="Name">Right Hip</string>
						<Ref name="Part0">RBX0E60E706EBD94461A70D95ACD77B466C</Ref>
						<Ref name="Part1">RBX9B3B5C3CC56944E98D386F80A5FCC556</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001789</UniqueId>
					</Properties>
				</Item>
				<Item class="Motor6D" referent="RBX5F7A4ED4B9EC43A5B03565793FE97230">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="C0">
							<X>-1</X>
							<Y>-1</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>-1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<CoordinateFrame name="C1">
							<X>-0.5</X>
							<Y>1</Y>
							<Z>0</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>-1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="DesiredAngle">0</float>
						<bool name="Enabled">true</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="MaxVelocity">0.100000001</float>
						<string name="Name">Left Hip</string>
						<Ref name="Part0">RBX0E60E706EBD94461A70D95ACD77B466C</Ref>
						<Ref name="Part1">RBX1265ADAD80B54DBBB8DDCD995691B050</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000178a</UniqueId>
					</Properties>
				</Item>
				<Item class="Motor6D" referent="RBX0814BEFE72B748678113EB1947A19C04">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="C0">
							<X>0</X>
							<Y>1</Y>
							<Z>0</Z>
							<R00>-1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>0</R11>
							<R12>1</R12>
							<R20>0</R20>
							<R21>1</R21>
							<R22>-0</R22>
						</CoordinateFrame>
						<CoordinateFrame name="C1">
							<X>0</X>
							<Y>-0.5</Y>
							<Z>0</Z>
							<R00>-1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>0</R11>
							<R12>1</R12>
							<R20>0</R20>
							<R21>1</R21>
							<R22>-0</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="DesiredAngle">0</float>
						<bool name="Enabled">true</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="MaxVelocity">0.100000001</float>
						<string name="Name">Neck</string>
						<Ref name="Part0">RBX0E60E706EBD94461A70D95ACD77B466C</Ref>
						<Ref name="Part1">RBX32C95C900677423DBE6731CE3FBE118B</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000178b</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBXBD02EBDB408C4EAEAD2F7CC94CB30557">
				<Properties>
					<bool name="Anchored">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">4</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-55.349987</X>
						<Y>3</Y>
						<Z>54.2999878</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4286545791</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Left Arm</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000178c</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">0</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>2</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBX953E1362E4BA48CDA108E7BACE9A116D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>1</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">LeftShoulderAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000178d</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX818CE8FBCD604499BB2A7973F5ACC7C6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>-1</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">LeftGripAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000178e</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX331BBC98C20B4710B236D523C72FC356">
				<Properties>
					<bool name="Anchored">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">4</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-52.349987</X>
						<Y>3</Y>
						<Z>54.2999878</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4286545791</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Right Arm</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000178f</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">0</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>2</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBXE4D0D104188945528ADD5C9FF026F287">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>1</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">RightShoulderAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001790</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Attachment" referent="RBX0E281C4288F7453D909DABD0C6FAC964">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>-1</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">RightGripAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001791</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX1265ADAD80B54DBBB8DDCD995691B050">
				<Properties>
					<bool name="Anchored">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-54.349987</X>
						<Y>1</Y>
						<Z>54.2999878</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4286545791</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Left Leg</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001792</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">0</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>2</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBXD52CAAB508024C14A5179BEB7BEDAB65">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>-1</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">LeftFootAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001793</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX9B3B5C3CC56944E98D386F80A5FCC556">
				<Properties>
					<bool name="Anchored">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-53.349987</X>
						<Y>1</Y>
						<Z>54.2999878</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4286545791</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Right Leg</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001794</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">0</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>2</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBX9B50CF16FAC242C58267FB220A7424E0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>-1</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">RightFootAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001795</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Humanoid" referent="RBX029EE2A5AF7447D99BE1E70BE368C1B1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoJumpEnabled">true</bool>
					<bool name="AutoRotate">true</bool>
					<bool name="AutomaticScalingEnabled">true</bool>
					<bool name="BreakJointsOnDeath">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<token name="CollisionType">0</token>
					<bool name="DefinesCapabilities">false</bool>
					<token name="DisplayDistanceType">0</token>
					<string name="DisplayName"></string>
					<bool name="EvaluateStateMachine">true</bool>
					<float name="HealthDisplayDistance">100</float>
					<token name="HealthDisplayType">0</token>
					<float name="Health_XML">100</float>
					<float name="HipHeight">0</float>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Vector3 name="InternalBodyScale">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
					<float name="InternalHeadScale">1</float>
					<float name="JumpHeight">7.19999981</float>
					<float name="JumpPower">50</float>
					<float name="MaxHealth">100</float>
					<float name="MaxSlopeAngle">89</float>
					<string name="Name">Humanoid</string>
					<float name="NameDisplayDistance">100</float>
					<token name="NameOcclusion">2</token>
					<bool name="RequiresNeck">true</bool>
					<token name="RigType">0</token>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001796</UniqueId>
					<bool name="UseJumpPower">true</bool>
					<float name="WalkSpeed">16</float>
				</Properties>
				<Item class="Animator" referent="RBXB85743807BA74057B84DFDA1FE674329">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">Animator</string>
						<bool name="PreferLodEnabled">true</bool>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001798</UniqueId>
					</Properties>
				</Item>
				<Item class="HumanoidDescription" referent="RBX69FCD7B740D941729E55ED49AD9D0EE6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<float name="BodyTypeScale">0</float>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<int64 name="ClimbAnimation">0</int64>
						<bool name="DefinesCapabilities">false</bool>
						<float name="DepthScale">1</float>
						<string name="EmotesDataInternal"></string>
						<string name="EquippedEmotesDataInternal"></string>
						<int64 name="Face">0</int64>
						<int64 name="FallAnimation">0</int64>
						<int64 name="GraphicTShirt">0</int64>
						<float name="HeadScale">1</float>
						<float name="HeightScale">1</float>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<int64 name="IdleAnimation">0</int64>
						<int64 name="JumpAnimation">0</int64>
						<int64 name="MoodAnimation">0</int64>
						<string name="Name">HumanoidDescription</string>
						<int64 name="Pants">0</int64>
						<float name="ProportionScale">0</float>
						<int64 name="RunAnimation">0</int64>
						<int64 name="Shirt">0</int64>
						<int64 name="SourceAssetId">-1</int64>
						<int64 name="SwimAnimation">0</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00001799</UniqueId>
						<int64 name="WalkAnimation">0</int64>
						<float name="WidthScale">1</float>
					</Properties>
					<Item class="BodyPartDescription" referent="RBXF31FB56C54F24871A119B477A209CDA5">
						<Properties>
							<int64 name="AssetId">0</int64>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<token name="BodyPart">0</token>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color">
								<R>0.5</R>
								<G>0.5</G>
								<B>0.5</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Ref name="Instance">null</Ref>
							<string name="Name">BodyPartDescription</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000179a</UniqueId>
						</Properties>
					</Item>
					<Item class="BodyPartDescription" referent="RBXB46D3468EF1D472AA8DF33F4DB3BD8C0">
						<Properties>
							<int64 name="AssetId">0</int64>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<token name="BodyPart">2</token>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color">
								<R>0.5</R>
								<G>0.5</G>
								<B>0.5</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Ref name="Instance">null</Ref>
							<string name="Name">BodyPartDescription</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000179b</UniqueId>
						</Properties>
					</Item>
					<Item class="BodyPartDescription" referent="RBX77F34F983B5543B4AD7CE0C72F2D72BC">
						<Properties>
							<int64 name="AssetId">0</int64>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<token name="BodyPart">4</token>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color">
								<R>0.5</R>
								<G>0.5</G>
								<B>0.5</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Ref name="Instance">null</Ref>
							<string name="Name">BodyPartDescription</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000179c</UniqueId>
						</Properties>
					</Item>
					<Item class="BodyPartDescription" referent="RBX95C5CBB654374EEE9B1FCD8C8CCCD34D">
						<Properties>
							<int64 name="AssetId">0</int64>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<token name="BodyPart">3</token>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color">
								<R>0.5</R>
								<G>0.5</G>
								<B>0.5</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Ref name="Instance">null</Ref>
							<string name="Name">BodyPartDescription</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000179d</UniqueId>
						</Properties>
					</Item>
					<Item class="BodyPartDescription" referent="RBX80F7DB8A3E49422DA4B4AC4902DBCC8D">
						<Properties>
							<int64 name="AssetId">0</int64>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<token name="BodyPart">5</token>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color">
								<R>0.5</R>
								<G>0.5</G>
								<B>0.5</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Ref name="Instance">null</Ref>
							<string name="Name">BodyPartDescription</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000179e</UniqueId>
						</Properties>
					</Item>
					<Item class="BodyPartDescription" referent="RBX37E6079C85564CEF8816A458A2159432">
						<Properties>
							<int64 name="AssetId">0</int64>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<token name="BodyPart">1</token>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color">
								<R>0.5</R>
								<G>0.5</G>
								<B>0.5</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Ref name="Instance">null</Ref>
							<string name="Name">BodyPartDescription</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000179f</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Part" referent="RBX2E2C8344A17441EBA052E2D0B8D7E369">
				<Properties>
					<bool name="Anchored">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-53.849987</X>
						<Y>3</Y>
						<Z>54.2999878</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<float name="LeftParamA">0</float>
					<float name="LeftParamB">0</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">HumanoidRootPart</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">0</float>
					<float name="RightParamB">0</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">1</float>
					<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017a0</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">0</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>2</X>
						<Y>2</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBXA2288EDD7D4F45DE9C4553DA2C82097B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">RootAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017a1</UniqueId>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Motor6D" referent="RBXF5534B2C80144C40BB519585A759FCEB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="C0">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>-1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>0</R11>
							<R12>1</R12>
							<R20>0</R20>
							<R21>1</R21>
							<R22>-0</R22>
						</CoordinateFrame>
						<CoordinateFrame name="C1">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>-1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>0</R11>
							<R12>1</R12>
							<R20>0</R20>
							<R21>1</R21>
							<R22>-0</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="DesiredAngle">0</float>
						<bool name="Enabled">true</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="MaxVelocity">0.100000001</float>
						<string name="Name">RootJoint</string>
						<Ref name="Part0">RBX2E2C8344A17441EBA052E2D0B8D7E369</Ref>
						<Ref name="Part1">RBX0E60E706EBD94461A70D95ACD77B466C</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017a2</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX91F33BDA02B149D3972B4C6F25B50DD0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Disabled">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Animate</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{61C256F3-99C3-4F3E-8C3F-A579BC4D54C6}</string>
					<ProtectedString name="Source"><![CDATA[-- humanoidAnimatePlayEmote.lua

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local EMOTE_TRANSITION_TIME = 0.1

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Figure:GetScale()
	else
		return 1
	end
end

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	speed /= getRigScale()
	
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	speed /= getRigScale()
	
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

---- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, 0.1, Humanoid)
	end

end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end
	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end

	-- Return false to indicate that the emote could not be played
	return false
end
-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end


]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017a3</UniqueId>
				</Properties>
				<Item class="StringValue" referent="RBX353A9ED2CC9B446686BB2351392F4114">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">idle</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017a4</UniqueId>
						<string name="Value"></string>
					</Properties>
					<Item class="Animation" referent="RBXE92CCD3E27044E919896EE0671412172">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=180435571</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">Animation1</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017a5</UniqueId>
						</Properties>
						<Item class="NumberValue" referent="RBX762D8897A5244193B3972FC08D8E7968">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Weight</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017a6</UniqueId>
								<double name="Value">9</double>
							</Properties>
						</Item>
					</Item>
					<Item class="Animation" referent="RBXC480FE35899548CC9A94055B86837EA7">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=180435792</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">Animation2</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017a7</UniqueId>
						</Properties>
						<Item class="NumberValue" referent="RBXEE76D461D05C45969F758AB7B10CCB72">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Weight</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017a8</UniqueId>
								<double name="Value">1</double>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="StringValue" referent="RBX46D67186551C4459AE73B38DB7E84405">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">walk</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017a9</UniqueId>
						<string name="Value"></string>
					</Properties>
					<Item class="Animation" referent="RBX169758EBEE1044D6B756F0B6E4E9C638">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=180426354</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">WalkAnim</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017aa</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="StringValue" referent="RBXF12B50F0EAF94C19AADE56941F77FB66">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">run</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017ab</UniqueId>
						<string name="Value"></string>
					</Properties>
					<Item class="Animation" referent="RBX2A5F4D15B7284CFBB13C2ADC8BEDE5F8">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=180426354</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">RunAnim</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017ac</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="StringValue" referent="RBXE5E960A7482345E69290A3D30BCB4607">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">jump</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017ad</UniqueId>
						<string name="Value"></string>
					</Properties>
					<Item class="Animation" referent="RBX8B40E34845AB4C6C896A75F0197EDE72">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=125750702</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">JumpAnim</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017ae</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="StringValue" referent="RBX84563F61BD874178A309E4F635C22707">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">climb</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017af</UniqueId>
						<string name="Value"></string>
					</Properties>
					<Item class="Animation" referent="RBX05B5CF2685A145C6A9FF07A58F9341E2">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=180436334</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">ClimbAnim</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017b0</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="StringValue" referent="RBXA73C79BCA830445F9FD51906F4A33E9C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">toolnone</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017b1</UniqueId>
						<string name="Value"></string>
					</Properties>
					<Item class="Animation" referent="RBX33E42B98AF094975866F9DF362F3D77A">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=182393478</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">ToolNoneAnim</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017b2</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="StringValue" referent="RBXA8AFE43E0C194813AED28234800DCFFB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">fall</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017b3</UniqueId>
						<string name="Value"></string>
					</Properties>
					<Item class="Animation" referent="RBXF120DED22CA44BD796382F18C1DB32EF">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=180436148</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">FallAnim</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017b4</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="StringValue" referent="RBX1DE083E132B9418C80B3DCBED1C6323E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">sit</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017b5</UniqueId>
						<string name="Value"></string>
					</Properties>
					<Item class="Animation" referent="RBX838D05874A71489C9505941104478B66">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=178130996</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">SitAnim</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017b6</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="BindableFunction" referent="RBX7B8759EAB56D46CCBEB2AEC284792811">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">PlayEmote</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017b7</UniqueId>
					</Properties>
				</Item>
				<Item class="NumberValue" referent="RBX4B988A08CAC84F0DBC1A2F3910867846">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">ScaleDampeningPercent</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017b8</UniqueId>
						<double name="Value">1</double>
					</Properties>
				</Item>
			</Item>
			<Item class="BodyColors" referent="RBXC86ACD29221F47FA9D73FEFA38D7D6B6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Color3 name="HeadColor3">
						<R>0.5</R>
						<G>0.5</G>
						<B>0.5</B>
					</Color3>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Color3 name="LeftArmColor3">
						<R>0.5</R>
						<G>0.5</G>
						<B>0.5</B>
					</Color3>
					<Color3 name="LeftLegColor3">
						<R>0.5</R>
						<G>0.5</G>
						<B>0.5</B>
					</Color3>
					<string name="Name">Body Colors</string>
					<Color3 name="RightArmColor3">
						<R>0.5</R>
						<G>0.5</G>
						<B>0.5</B>
					</Color3>
					<Color3 name="RightLegColor3">
						<R>0.5</R>
						<G>0.5</G>
						<B>0.5</B>
					</Color3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<Color3 name="TorsoColor3">
						<R>0.5</R>
						<G>0.5</G>
						<B>0.5</B>
					</Color3>
					<UniqueId name="UniqueId">7745f3117c4a251a089954ce000017b9</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="Part" referent="RBXF6D30410F772469A8E1919C2830C56CC">
			<Properties>
				<bool name="Anchored">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AudioCanCollide">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>3.25</X>
					<Y>3.90000415</Y>
					<Z>24.6999989</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">test</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">3b4d352275f2c90608b5fa7900003272</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
			<Item class="ProximityPrompt" referent="RBXCFEB533F288C46009DAD27D445EC49F0">
				<Properties>
					<string name="ActionText">Interact</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="ClickablePrompt">true</bool>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Enabled">true</bool>
					<token name="Exclusivity">0</token>
					<token name="GamepadKeyCode">1000</token>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<float name="HoldDuration">2</float>
					<token name="KeyboardKeyCode">101</token>
					<float name="MaxActivationDistance">10</float>
					<float name="MaxIndicatorDistance">0</float>
					<string name="Name">ProximityPrompt</string>
					<string name="ObjectText"></string>
					<bool name="RequiresLineOfSight">true</bool>
					<Ref name="RootLocalizationTable">null</Ref>
					<int64 name="SourceAssetId">-1</int64>
					<token name="Style">0</token>
					<BinaryString name="Tags"></BinaryString>
					<Vector2 name="UIOffset">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<UniqueId name="UniqueId">3b4d352275f2c90608b5fa7900003312</UniqueId>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX7D8A5440B351448485D89921FA0390F4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Disabled">true</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Script</string>
					<token name="RunContext">2</token>
					<string name="ScriptGuid">{014A7D67-7656-47AC-B315-57C293AC8354}</string>
					<ProtectedString name="Source"><![CDATA[script.Parent.ProximityPrompt.PromptButtonHoldBegan:Connect(function(p)
	print(p)
end)
script.Parent.ProximityPrompt.PromptButtonHoldEnded:Connect(function(p)
	print(p)
end)
script.Parent.ProximityPrompt.Triggered:Connect(function(p)
	print(p)
end)
script.Parent.ProximityPrompt.TriggerEnded:Connect(function(p)
	print(p)
end)]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">3b4d352275f2c90608b5fa7900003424</UniqueId>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX6411232BBB384D45A0ED4D9BE0D96A38">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Disabled">true</bool>
					<UniqueId name="HistoryId">3b4d352275f2c90608b5fa7900003424</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Script</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{38DA1C43-A860-43EE-A2DD-E8B2853E961A}</string>
					<ProtectedString name="Source"><![CDATA[script.Parent.ProximityPrompt.PromptButtonHoldBegan:Connect(function(p)
	print(p)
end)
script.Parent.ProximityPrompt.PromptButtonHoldEnded:Connect(function(p)
	print(p)
end)
script.Parent.ProximityPrompt.Triggered:Connect(function(p)
	print(p)
end)
script.Parent.ProximityPrompt.TriggerEnded:Connect(function(p)
	print(p)
end)]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">3b4d352275f2c90608b5fa790000349f</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="Part" referent="RBX5DBF9458D4AD4EAE8BCD1FA726D1E8DC">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AudioCanCollide">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>-11.1499987</X>
					<Y>3</Y>
					<Z>-13.9499989</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">false</bool>
				<bool name="CanQuery">false</bool>
				<bool name="CanTouch">false</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4289003520</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<UniqueId name="HistoryId">206247380e8f98a908a38b6700000a24</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">md1</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0.899999976</float>
				<UniqueId name="UniqueId">22ef1a1bb98897c308be5c68000093bb</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>0.999999762</X>
					<Y>1</Y>
					<Z>1</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBXBC44BC1A9D0E49978FF7841854CC1853">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AudioCanCollide">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>2.35001183</X>
					<Y>1.5999999</Y>
					<Z>-19.1500168</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">false</bool>
				<bool name="CanQuery">false</bool>
				<bool name="CanTouch">false</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4289003520</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<UniqueId name="HistoryId">206247380e8f98a908a38b6700000a24</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">bau2</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0.899999976</float>
				<UniqueId name="UniqueId">168c9cf1626aca5308c261a9000010fe</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>0.999999762</X>
					<Y>1</Y>
					<Z>1</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX0E8D3D3D9BAB424C89D4AD3FEC6ACE8A">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AudioCanCollide">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>15.3500118</X>
					<Y>1.5999999</Y>
					<Z>-10.9000168</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">false</bool>
				<bool name="CanQuery">false</bool>
				<bool name="CanTouch">false</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4289003520</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<UniqueId name="HistoryId">206247380e8f98a908a38b6700000a24</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">bau3</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0.899999976</float>
				<UniqueId name="UniqueId">168c9cf1626aca5308c261a9000011af</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>0.999999762</X>
					<Y>1</Y>
					<Z>1</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX2493659C2AC5400A8AE334664EBEB621">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AudioCanCollide">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>12.6000023</X>
					<Y>3</Y>
					<Z>7.70000076</Z>
					<R00>0</R00>
					<R01>0</R01>
					<R02>-1</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>1</R20>
					<R21>0</R21>
					<R22>0</R22>
				</CoordinateFrame>
				<bool name="CanCollide">false</bool>
				<bool name="CanQuery">false</bool>
				<bool name="CanTouch">false</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4289003520</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<UniqueId name="HistoryId">206247380e8f98a908a38b6700000a24</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">md2</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0.899999976</float>
				<UniqueId name="UniqueId">168c9cf1626aca5308c261a90000127e</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>0.999999762</X>
					<Y>1</Y>
					<Z>1</Z>
				</Vector3>
			</Properties>
		</Item>
	</Item>
	<Item class="TimerService" referent="RBX976C53026A2F476393E2D737CEACCD40">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000322</UniqueId>
		</Properties>
	</Item>
	<Item class="SoundService" referent="RBXF39790311EFE492AAC5A7C8C8BD4E712">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AudioApiByDefault">0</token>
			<token name="AudioPlayerVolumeFix">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="CharacterSoundsUseNewApi">0</token>
			<token name="DefaultListenerLocation">3</token>
			<bool name="DefinesCapabilities">false</bool>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="IsNewExpForAudioApiByDefault">false</bool>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">true</bool>
			<float name="RolloffScale">1</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000323</UniqueId>
			<token name="VolumetricAudio">1</token>
		</Properties>
	</Item>
	<Item class="VideoCaptureService" referent="RBXCE2F17F85E9B4FD48D94721D1AB0E4F8">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VideoCaptureService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000032f</UniqueId>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBXC324D82467B445E487D38FB80030A7E9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000330</UniqueId>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBX107BB837218746959332E09F20511222">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000331</UniqueId>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBX2ABB4A06D88F487EBA889276B9528F75">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">true</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="IsAutoMigrated">true</bool>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000336</UniqueId>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX331CA590691A4A908E07FCECE439092C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BanningEnabled">true</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="CharacterAutoLoads">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxPlayersInternal">60</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">60</int>
			<float name="RespawnTime">3</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000338</UniqueId>
			<bool name="UseStrafingAnimations">false</bool>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBXB4FE4CE1C8D34F90AB8136032C884106">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000033b</UniqueId>
		</Properties>
		<Item class="LocalScript" referent="RBXE925F8A74F2945F2B4FEE9B3C952C84F">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LocalScript</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{73B0EF0A-1C87-456C-B79C-8A2F2B7C375C}</string>
				<ProtectedString name="Source"><![CDATA[if not game:IsLoaded() then
	game.Loaded:Wait()
end

local replicatedStorage = game:GetService("ReplicatedStorage")
local lib = require(replicatedStorage.lib)

local modules = replicatedStorage.Modules
local remotes = lib.Remotes

local sharedServices = modules.Shared.Services
local instanceHandler = require(sharedServices.ReplicableInstancesHandler)

local playerData = require(script.PlayerDataController)
local inventoryS = require(script.InventoryController)

playerData.Start()
playerData.Init()

instanceHandler.Init()
instanceHandler.Start()

inventoryS.Init()
inventoryS.Start()

--local replicableInstance = require(replicatedStorage.Modules.Shared.Classes.ReplicableInstance)
--replicableInstance.Init()
--replicableInstance.Start()

remotes.PlayerLoaded:Fire()
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">206247380e8f98a908a38b6700001671</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBXAE6A4174630544C69F6F8E474DAB5CF7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">7745f3117c4a251a089954ce00004f1c</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PlayerDataController</string>
					<string name="ScriptGuid">{C14C9D88-9730-4F1B-A2A3-9B1CADF14048}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local lib = require(ReplicatedStorage.lib)
local TableToRemoteTable = lib.Utils.TableToRemoteTable
local tableUtil = lib.FunctionUtils.Table
local remotes = lib.Remotes
local playerDataUpdatedEvent = remotes.PlayerDataUpdated

local playerDataModule = require(ReplicatedStorage.Modules.Client.PlayerData)

local module = {}

function module.Init()
	
end

function module.Start()
	playerDataUpdatedEvent.OnClientEvent:Connect(function(new)
		warn('New Player Data Received:', new)
		new = TableToRemoteTable.decode(new)
		playerDataModule.NewDataReceived:Fire(new)
		if not tableUtil.checkTableEquality(playerDataModule.Data, new) then
			playerDataModule.Data = new
			warn('Player Data Updated:', new)
			playerDataModule.DataUpdated:Fire(new)
		end
	end)
	
end

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005086</UniqueId>
				</Properties>
				<Item class="Folder" referent="RBX0BAA1ED30495408A99FB0A5811F8B150">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">Folder</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00003fdc</UniqueId>
					</Properties>
					<Item class="ClickDetector" referent="RBX861E1338FFD647DE8EA064F2F77DBF38">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Content name="CursorIcon"><null></null></Content>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<float name="MaxActivationDistance">32</float>
							<string name="Name">ClickDetector</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00003fde</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX08DD5F8098A443C1BF1CBD2AA17AF251">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">InventoryController</string>
					<string name="ScriptGuid">{B4431CFC-A21D-4C1A-BFB8-97556E5408F1}</string>
					<ProtectedString name="Source"><![CDATA[-- local replicatedStorage = game:GetService("ReplicatedStorage")
-- local userInputService = game:GetService("UserInputService")
-- local player = game.Players.LocalPlayer

-- local lib = require(replicatedStorage:WaitForChild("lib"))
-- local inventoryUtilShared = require(replicatedStorage.Modules.Shared.Utils.InventoryUtilShared)
-- local replicableInstance = require(replicatedStorage.Modules.Shared.Classes.ReplicableInstance)

-- local playerData = require(replicatedStorage.Modules.Client.PlayerData)

local module = {}
module.inventoryItems = {}
module.equippeditem = nil

-- local acceptableInputs = {
-- 	One = 1,
-- 	Two = 2,
-- 	Three = 3,
-- 	Four = 4,
-- 	Five = 5,
-- 	Six = 6,
-- }

function module.Init() end

function module.Start()
	-- 	--userInputService.InputBegan:Connect(function(inp)
	-- 	--	local acceptableInp = acceptableInputs[inp.KeyCode.Name]
	-- 	--	if acceptableInp then
	-- 	--		inventoryUtilShared.toggleEquip(acceptableInp)
	-- 	--	end
	-- 	--end)
	-- 	--playerData.NewDataReceived:Connect(function(data)
	-- 	--	print('analize')
	-- 	--	local oldData = playerData.Data
	-- 	--	for i, currentItemUID in data.inventory do
	-- 	--		local previousItemUID = oldData.inventory[i]
	-- 	--		if previousItemUID == currentItemUID then continue end
	-- 	--		local item = instancesManager.getObj(currentItemUID)
	-- 	--		local pos = table.find(oldData, currentItemUID)
	-- 	--		if pos then
	-- 	--			inventoryUtilShared.toggleEquip(player, pos, i)
	-- 	--		else

	-- 	--		end
	-- 	--	end
	-- 	--end)
end

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4312145b2bb60a89089d39140000383d</UniqueId>
				</Properties>
				<Item class="Folder" referent="RBXD4FF8FD80EE344BFB46F8C1F8DB20CA5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">Folder</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00003fdb</UniqueId>
					</Properties>
					<Item class="Decal" referent="RBX37AA41AB7A7C47FDB3F1B4E4B12ADEB6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<token name="Face">5</token>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="MetalnessMap"><null></null></Content>
							<string name="Name">Decal</string>
							<Content name="NormalMap"><null></null></Content>
							<Content name="RoughnessMap"><null></null></Content>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="Texture"><null></null></Content>
							<Content name="TexturePack"><null></null></Content>
							<string name="TexturePackMetadata"></string>
							<float name="Transparency">0</float>
							<Vector2 name="UVOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="UVScale">
								<X>1</X>
								<Y>1</Y>
							</Vector2>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00003fdd</UniqueId>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Animation" referent="RBXE75AAEA1164A4658AE38435375C0A6B9">
				<Properties>
					<Content name="AnimationId"><null></null></Content>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Animation</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00003db7</UniqueId>
				</Properties>
				<Item class="DragDetector" referent="RBX55DD57E4E7674C4589716EC4A5EDA583">
					<Properties>
						<Content name="ActivatedCursorIcon"><null></null></Content>
						<bool name="ApplyAtCenterOfMass">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<Content name="CursorIcon"><null></null></Content>
						<bool name="DefinesCapabilities">false</bool>
						<CoordinateFrame name="DragFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<token name="DragStyle">1</token>
						<bool name="Enabled">true</bool>
						<token name="GamepadModeSwitchKeyCode">1004</token>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<token name="KeyboardModeSwitchKeyCode">306</token>
						<float name="MaxActivationDistance">32</float>
						<float name="MaxDragAngle">0</float>
						<Vector3 name="MaxDragTranslation">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<float name="MaxForce">10000000</float>
						<float name="MaxTorque">10000</float>
						<float name="MinDragAngle">0</float>
						<Vector3 name="MinDragTranslation">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<string name="Name">DragDetector</string>
						<Vector3 name="Orientation">
							<X>-0</X>
							<Y>180</Y>
							<Z>90</Z>
						</Vector3>
						<token name="PermissionPolicy">1</token>
						<Ref name="ReferenceInstance">null</Ref>
						<token name="ResponseStyle">1</token>
						<float name="Responsiveness">10</float>
						<bool name="RunLocally">false</bool>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TrackballRadialPullFactor">1</float>
						<float name="TrackballRollFactor">1</float>
						<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00003e43</UniqueId>
						<token name="VRSwitchKeyCode">1007</token>
					</Properties>
				</Item>
			</Item>
			<Item class="Animation" referent="RBX5BF0B08DE6024DEA8F8DB229B4F5F762">
				<Properties>
					<Content name="AnimationId"><null></null></Content>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Animation</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00003f2c</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX99D8713E1B844C23AE5BDC05E13ACC7F">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LocalScript</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{32721B24-5C53-407D-AEC8-4B2FAE17445A}</string>
				<ProtectedString name="Source"><![CDATA[print("Hello world!")
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">38e5043c158bb8f708cc740e000038c6</UniqueId>
			</Properties>
			<Item class="DragDetector" referent="RBXAF4189F473004F7296AB8F4EBA22AFED">
				<Properties>
					<Content name="ActivatedCursorIcon"><null></null></Content>
					<bool name="ApplyAtCenterOfMass">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<Content name="CursorIcon"><null></null></Content>
					<bool name="DefinesCapabilities">false</bool>
					<CoordinateFrame name="DragFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<token name="DragStyle">1</token>
					<bool name="Enabled">true</bool>
					<token name="GamepadModeSwitchKeyCode">1004</token>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<token name="KeyboardModeSwitchKeyCode">306</token>
					<float name="MaxActivationDistance">32</float>
					<float name="MaxDragAngle">0</float>
					<Vector3 name="MaxDragTranslation">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="MaxForce">10000000</float>
					<float name="MaxTorque">10000</float>
					<float name="MinDragAngle">0</float>
					<Vector3 name="MinDragTranslation">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<string name="Name">DragDetector</string>
					<Vector3 name="Orientation">
						<X>-0</X>
						<Y>180</Y>
						<Z>90</Z>
					</Vector3>
					<token name="PermissionPolicy">1</token>
					<Ref name="ReferenceInstance">null</Ref>
					<token name="ResponseStyle">1</token>
					<float name="Responsiveness">10</float>
					<bool name="RunLocally">false</bool>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TrackballRadialPullFactor">1</float>
					<float name="TrackballRollFactor">1</float>
					<UniqueId name="UniqueId">38e5043c158bb8f708cc740e000039cb</UniqueId>
					<token name="VRSwitchKeyCode">1007</token>
				</Properties>
			</Item>
		</Item>
		<Item class="MaterialVariant" referent="RBXBC4B25FD9DE14D739A338506AF6C1FC4">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<token name="BaseMaterial">256</token>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<Content name="ColorMap"><null></null></Content>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="MaterialPattern">0</token>
				<Content name="MetalnessMap"><null></null></Content>
				<string name="Name">MaterialVariant</string>
				<Content name="NormalMap"><null></null></Content>
				<Content name="RoughnessMap"><null></null></Content>
				<int64 name="SourceAssetId">-1</int64>
				<float name="StudsPerTile">10</float>
				<BinaryString name="Tags"></BinaryString>
				<Content name="TexturePack"><null></null></Content>
				<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00003945</UniqueId>
			</Properties>
			<Item class="TerrainDetail" referent="RBX3450FF2B159940DD974997021DE7BCA7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<Content name="ColorMap"><null></null></Content>
					<bool name="DefinesCapabilities">false</bool>
					<token name="Face">1</token>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<token name="MaterialPattern">0</token>
					<Content name="MetalnessMap"><null></null></Content>
					<string name="Name">TerrainDetail</string>
					<Content name="NormalMap"><null></null></Content>
					<Content name="RoughnessMap"><null></null></Content>
					<int64 name="SourceAssetId">-1</int64>
					<float name="StudsPerTile">10</float>
					<BinaryString name="Tags"></BinaryString>
					<Content name="TexturePack"><null></null></Content>
					<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00003a52</UniqueId>
				</Properties>
				<Item class="Frame" referent="RBX31095C60A1C0409F844F6ED6A87653E3">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="ClipsDescendants">false</bool>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Draggable">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">Frame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>100</XO>
							<YS>0</YS>
							<YO>100</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00003a53</UniqueId>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Folder" referent="RBX6ECB5CC34C40430E9BE27D4C4A8CA63F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">Folder</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00003a54</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="TweenService" referent="RBX37C56140DA554B9088A8CF1C777D6F1F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000033d</UniqueId>
		</Properties>
	</Item>
	<Item class="MaterialService" referent="RBX5C99A6F57DF244F79D12355244D989EE">
		<Properties>
			<string name="AsphaltName">Asphalt</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="BasaltName">Basalt</string>
			<string name="BrickName">Brick</string>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<string name="CardboardName">Cardboard</string>
			<string name="CarpetName">Carpet</string>
			<string name="CeramicTilesName">CeramicTiles</string>
			<string name="ClayRoofTilesName">ClayRoofTiles</string>
			<string name="CobblestoneName">Cobblestone</string>
			<string name="ConcreteName">Concrete</string>
			<string name="CorrodedMetalName">CorrodedMetal</string>
			<string name="CrackedLavaName">CrackedLava</string>
			<bool name="DefinesCapabilities">false</bool>
			<string name="DiamondPlateName">DiamondPlate</string>
			<string name="FabricName">Fabric</string>
			<string name="FoilName">Foil</string>
			<string name="GlacierName">Glacier</string>
			<string name="GraniteName">Granite</string>
			<string name="GrassName">Grass</string>
			<string name="GroundName">Ground</string>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="IceName">Ice</string>
			<string name="LeafyGrassName">LeafyGrass</string>
			<string name="LeatherName">Leather</string>
			<string name="LimestoneName">Limestone</string>
			<string name="MarbleName">Marble</string>
			<string name="MetalName">Metal</string>
			<string name="MudName">Mud</string>
			<string name="Name">MaterialService</string>
			<string name="PavementName">Pavement</string>
			<string name="PebbleName">Pebble</string>
			<string name="PlasterName">Plaster</string>
			<string name="PlasticName">Plastic</string>
			<string name="RockName">Rock</string>
			<string name="RoofShinglesName">RoofShingles</string>
			<string name="RubberName">Rubber</string>
			<string name="SaltName">Salt</string>
			<string name="SandName">Sand</string>
			<string name="SandstoneName">Sandstone</string>
			<string name="SlateName">Slate</string>
			<string name="SmoothPlasticName">SmoothPlastic</string>
			<string name="SnowName">Snow</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000033e</UniqueId>
			<bool name="Use2022MaterialsXml">true</bool>
			<string name="WoodName">Wood</string>
			<string name="WoodPlanksName">WoodPlanks</string>
		</Properties>
	</Item>
	<Item class="TextChatService" referent="RBXEF6179ECCACB442D8250B6C1C5ED87DE">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="ChatTranslationFTUXShown">true</bool>
			<bool name="ChatTranslationToggleEnabled">false</bool>
			<token name="ChatVersion">1</token>
			<bool name="CreateDefaultCommands">true</bool>
			<bool name="CreateDefaultTextChannels">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="HasSeenDeprecationDialog">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="IsLegacyChatDisabled">true</bool>
			<string name="Name">TextChatService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000033f</UniqueId>
		</Properties>
		<Item class="ChatWindowConfiguration" referent="RBX88354424A0C94D2580DC2A512C060CCF">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2999999999999999889</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/BuilderSans.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/BuilderSans-Medium.otf</url></CachedFaceId>
				</Font>
				<float name="HeightScale">1</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="HorizontalAlignment">1</token>
				<string name="Name">ChatWindowConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">18</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003a8</UniqueId>
				<token name="VerticalAlignment">1</token>
				<float name="WidthScale">1</float>
			</Properties>
		</Item>
		<Item class="ChatInputBarConfiguration" referent="RBXD6D875FC9FB149DEA1970FBD39D6E3C1">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutocompleteEnabled">true</bool>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2000000000000000111</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/BuilderSans.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/BuilderSans-Medium.otf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="KeyboardKeyCode">47</token>
				<string name="Name">ChatInputBarConfiguration</string>
				<Color3 name="PlaceholderColor3">
					<R>0.698039234</R>
					<G>0.698039234</G>
					<B>0.698039234</B>
				</Color3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Ref name="TargetTextChannel">null</Ref>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">18</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003a9</UniqueId>
			</Properties>
		</Item>
		<Item class="BubbleChatConfiguration" referent="RBXAE2FDBDB49E34E9BB0F6302840518DD2">
			<Properties>
				<string name="AdorneeName">HumanoidRootPart</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.980392158</R>
					<G>0.980392158</G>
					<B>0.980392158</B>
				</Color3>
				<double name="BackgroundTransparency">0.10000000000000000555</double>
				<float name="BubbleDuration">15</float>
				<float name="BubblesSpacing">6</float>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<token name="Font">47</token>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/BuilderSans.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/BuilderSans-Medium.otf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Vector3 name="LocalPlayerStudsOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="MaxBubbles">3</float>
				<float name="MaxDistance">100</float>
				<float name="MinimizeDistance">40</float>
				<string name="Name">BubbleChatConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<bool name="TailVisible">true</bool>
				<Color3 name="TextColor3">
					<R>0.223529413</R>
					<G>0.23137255</G>
					<B>0.239215687</B>
				</Color3>
				<int64 name="TextSize">20</int64>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003aa</UniqueId>
				<float name="VerticalStudsOffset">0</float>
			</Properties>
			<Item class="UIGradient" referent="RBX4C6B3F8E6F374C62846A313851A93093">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<ColorSequence name="Color">0 1 1 1 0 1 1 1 1 0 </ColorSequence>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Enabled">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">UIGradient</string>
					<Vector2 name="Offset">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<float name="Rotation">0</float>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
					<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003ab</UniqueId>
				</Properties>
			</Item>
			<Item class="ImageLabel" referent="RBXE3AE8BC43099458F9F8B0565D02EEC10">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">
						<R>0.105882362</R>
						<G>0.164705887</G>
						<B>0.207843155</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">1</int>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="ClipsDescendants">false</bool>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Draggable">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="Image"><null></null></Content>
					<Color3 name="ImageColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<Vector2 name="ImageRectOffset">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Vector2 name="ImageRectSize">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<float name="ImageTransparency">0</float>
					<bool name="Interactable">true</bool>
					<int name="LayoutOrder">0</int>
					<string name="Name">ImageLabel</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<token name="ResampleMode">0</token>
					<Ref name="RootLocalizationTable">null</Ref>
					<float name="Rotation">0</float>
					<token name="ScaleType">0</token>
					<bool name="Selectable">false</bool>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>100</XO>
						<YS>0</YS>
						<YO>100</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<Rect2D name="SliceCenter">
						<min>
							<X>0</X>
							<Y>0</Y>
						</min>
						<max>
							<X>0</X>
							<Y>0</Y>
						</max>
					</Rect2D>
					<float name="SliceScale">1</float>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UDim2 name="TileSize">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003ac</UniqueId>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
			<Item class="UICorner" referent="RBXDB9AA8A6852A42CA9132C645A7EA1940">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<UDim name="CornerRadius">
						<S>0</S>
						<O>12</O>
					</UDim>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">UICorner</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003ad</UniqueId>
				</Properties>
			</Item>
			<Item class="UIPadding" referent="RBX2019563395C24AD09D9952FBEA4BF0F9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">UIPadding</string>
					<UDim name="PaddingBottom">
						<S>0</S>
						<O>8</O>
					</UDim>
					<UDim name="PaddingLeft">
						<S>0</S>
						<O>8</O>
					</UDim>
					<UDim name="PaddingRight">
						<S>0</S>
						<O>8</O>
					</UDim>
					<UDim name="PaddingTop">
						<S>0</S>
						<O>8</O>
					</UDim>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003ae</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="ChannelTabsConfiguration" referent="RBXFE5F635178704542A70CC1451A7FB1ED">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">false</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/BuilderSans.json</url></Family>
					<Weight>700</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/BuilderSans-Bold.otf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Color3 name="HoverBackgroundColor3">
					<R>0.490196079</R>
					<G>0.490196079</G>
					<B>0.490196079</B>
				</Color3>
				<string name="Name">ChannelTabsConfiguration</string>
				<Color3 name="SelectedTabTextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Color3 name="TextColor3">
					<R>0.686274529</R>
					<G>0.686274529</G>
					<B>0.686274529</B>
				</Color3>
				<int64 name="TextSize">18</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">1</double>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003af</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="PermissionsService" referent="RBX905A889379DB4AC38ED57CF36BFD6718">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4a0ecd628f8319c008ca16da00000bf7</UniqueId>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="RBXFA685FE751B044549146C45B6AA681A0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="CustomPoliciesEnabled">false</bool>
			<bool name="DefinesCapabilities">false</bool>
			<string name="EmulatedCountryCode"></string>
			<string name="EmulatedGameLocale"></string>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PlayerEmulatorService</string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<bool name="PseudolocalizationEnabled">false</bool>
			<BinaryString name="SerializedEmulatedPolicyInfo"></BinaryString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<int name="TextElongationFactor">0</int>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000342</UniqueId>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBX5F46C6C470AC45D9BCA9A1E793DBD1A0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000346</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="RBX3875F95C2CB040A88E59491173C3F448">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<token name="AvatarJointUpgrade_SerializedRollout">0</token>
			<float name="CameraMaxZoomDistance">128</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">false</bool>
			<float name="CharacterWalkSpeed">16</float>
			<bool name="ClassicDeath">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<token name="EnableDynamicHeads">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadCharacterAppearance">true</bool>
			<token name="LoadCharacterLayeredClothing">0</token>
			<token name="LuaCharacterController">0</token>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<bool name="RagdollDeath">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000348</UniqueId>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="RBXC5AA0F5A2AAC4C80BD9DB6C0C0694651">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003a0</UniqueId>
			</Properties>
			<Item class="LocalScript" referent="RBX03B8BFF3A30E4A6F8F300804A31D33F6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Disabled">true</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LocalScript</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{5DBF1CB7-E320-4E33-AD57-865F4198AF3B}</string>
					<ProtectedString name="Source"><![CDATA[local part = workspace:WaitForChild('Part')

part.Touched:Connect(function(part)
	--while part.Parent ~= workspace do part = part.Parent end
	if part.Name ~= 'HumanoidRootPart' then return end
	print('started', part.Name)
end)

part.TouchEnded:Connect(function(part)
	--while part.Parent ~= workspace do part = part.Parent end
	if part.Name ~= 'HumanoidRootPart' then return end

	print('finished', part.Name)
end)

--local zone = require(game.ReplicatedStorage.lib.ModuleUtils._Zone)
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1e81e3ab4178f7f508957bec00000de7</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBXBF5EA1C1ABA84C74975469801011838C">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003a1</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBX6C97DE54D57D48D0B19A62380905042B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000349</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBXE299F9F17A824C3189FF6CC23B682525">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="RtlTextSupport">0</token>
			<token name="ScreenOrientation">4</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<Ref name="StudioDefaultStyleSheet">null</Ref>
			<Ref name="StudioInsertWidgetLayerCollectorAutoLinkStyleSheet">null</Ref>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000034a</UniqueId>
			<token name="VirtualCursorMode">0</token>
		</Properties>
		<Item class="ScreenGui" referent="RBXE329EEF7155B4080A6F0F47E6C168201">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutoLocalize">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="ClipToDeviceSafeArea">true</bool>
				<bool name="DefinesCapabilities">false</bool>
				<int name="DisplayOrder">0</int>
				<bool name="Enabled">true</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Chests</string>
				<bool name="ResetOnSpawn">false</bool>
				<Ref name="RootLocalizationTable">null</Ref>
				<token name="SafeAreaCompatibility">1</token>
				<token name="ScreenInsets">1</token>
				<token name="SelectionBehaviorDown">0</token>
				<token name="SelectionBehaviorLeft">0</token>
				<token name="SelectionBehaviorRight">0</token>
				<token name="SelectionBehaviorUp">0</token>
				<bool name="SelectionGroup">false</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600007246</UniqueId>
				<token name="ZIndexBehavior">1</token>
			</Properties>
			<Item class="Frame" referent="RBX8DC690BF0D20422FBC04541692CA1E14">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0.5</Y>
					</Vector2>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<float name="BackgroundTransparency">0.5</float>
					<Color3 name="BorderColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="ClipsDescendants">false</bool>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Draggable">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<bool name="Interactable">true</bool>
					<int name="LayoutOrder">0</int>
					<string name="Name">ChestTemplate</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0.5</YS>
						<YO>0</YO>
					</UDim2>
					<Ref name="RootLocalizationTable">null</Ref>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0.600000024</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<int64 name="SourceAssetId">-1</int64>
					<token name="Style">0</token>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600007287</UniqueId>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX228B0F47D2164248AA5720F43C769FCC">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0.5</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="ClipsDescendants">false</bool>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Draggable">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">Frame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.5</YS>
							<YO>-2</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005d20</UniqueId>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX242BBD6FD2D6481F85BD32140B39BF6D">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">1</int>
							<string name="Name">DeskContents</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.333000004</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.600000024</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000730c</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBX3054A59272134718942C3A2886EB2C71">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">7745f3117c4a251a089954ce00005e79</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">2</int>
								<string name="Name">Items</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005edc</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIPadding" referent="RBXD59C20564E184EE081EB817A1EF537FC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007449</UniqueId>
									<string name="Name">UIPadding</string>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>0</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>0</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>5</O>
									</UDim>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005ede</UniqueId>
								</Properties>
							</Item>
							<Item class="Frame" referent="RBXCE28876939AE4BA18551E4CC7E8A74C2">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder1</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005edf</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBXEFE767D7840C424D95762B3681D6B736">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005ee0</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX1590FEF7870A46E78C9EE83CC8B2A9AD">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005ee1</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX85089621B8C04BD7BC99070BFFE638FD">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005ee2</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXB361A199025E440FBC0A9E53DF168EB4">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005ee3</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="UIListLayout" referent="RBXC079151C3FFE437283F3DBEE2C5B1D98">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<token name="FillDirection">0</token>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<token name="HorizontalAlignment">1</token>
									<token name="HorizontalFlex">3</token>
									<token name="ItemLineAlignment">0</token>
									<string name="Name">UIListLayout</string>
									<UDim name="Padding">
										<S>0.00499999989</S>
										<O>0</O>
									</UDim>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f88</UniqueId>
									<token name="VerticalAlignment">1</token>
									<token name="VerticalFlex">4</token>
									<bool name="Wraps">true</bool>
								</Properties>
							</Item>
							<Item class="Frame" referent="RBXDE4A50D60F614859B8F28B998870A556">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder2</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f89</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBX558DC0BCBECC482D95AB0B5E55BD0730">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f8a</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXD2C28A1A946045E3AFCCF65FC342F60E">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f8b</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX78F66F31B7C74B15BBB27717B2B6593E">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f8c</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX5B6020BC142E4CAEBE5C0549115B8402">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f8d</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBXF92318CEE2804A5086A4929B0E8DC7D7">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder3</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f8e</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBXCC402E2C02D7424C8A5165DDA624BADE">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f8f</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXC26D3F0FFAFE46C791DE74346E12CDF5">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f90</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX89D6675F0F014EE5B29E387B0C79EB33">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f91</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXA24C519ED57E4854B867B4ED4952B9AD">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f92</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX34F5D8081F2A4917ACFC0A3F6A332685">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder4</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f93</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBXE42DF9FE4A29427999721A0C72B1B637">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f94</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX711358FDAF1249B2876B994035AFE401">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f95</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXBC170BDDD579455C946FEC4DFF126C51">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f96</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXF76926A6F0E14F7D96DBBBB576CE8805">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f97</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBXD060B2C65B84433F883A1FBC5F318182">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder5</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f98</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBXEEE5178C2D5F460DB8BDE31AABF37149">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f99</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX7E1FF0B17384404DA336BE2615BB4012">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f9a</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX21EC9D5B9DF64EA5B5221CF957E46B1F">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f9b</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXE27A1FD76EA441F19CF337AFFD3BB60F">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f9c</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX40B0DFB8AECB4C2FAADF6F24E369B0F5">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder6</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7745f3117c4a251a089954ce00007539</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBXBE91EAF87B5C4D369130BEF14F45B8A3">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000753a</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXB46D65A90C164C00833C8ECDDDC7C46E">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000753b</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX24F0C76EF27849CF98FBE5C90F5BBC08">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000753c</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX722C6CC556F5465C9C29E2368706E795">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000753d</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX71CE238526534A938BEAC9B886D72127">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder7</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075df</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBX4599C490E3134F41BD6397FC13130C5A">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075e0</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXA80F4EA47C354684BB1CB75B7FF0A0FC">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075e1</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX92736044257D484A8D190C9C21ABFA57">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075e2</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX0605427235014CF4A61282BF68D594F2">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075e3</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX38D4552A3FBD4572A78303144D292580">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder8</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075e4</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBX5005B83CFC7748A5B37C9BFD5008B7C0">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075e5</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX64AEA89F03B34E07ABCF92910C485C0A">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075e6</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX45CE619369A7492B94654C23D207A19D">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075e7</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX1E39E2F2CF6C437EA459762E220544BA">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075e8</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBXC25DA8F3BF45424998257E1D4412F711">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder9</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075e9</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBX3D7030BD2057466EBF47C88BE68CA646">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075ea</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXF7B56749D9C14D829D9491D24C25E3CE">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075eb</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX658E91360517436BADDC7A30C19DF683">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075ec</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX28B09533F3634ABF8462E9E233711858">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075ed</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX3DC2B7BC85734E1C930E006DB933F43A">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder10</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075ee</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBXF56D1963923C41E08DBD5E37DDF88BAD">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075ef</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX9115ED6A0BD746B5A262835D6E03F4AE">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075f0</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX1E89B7692B0C4CC5A081B24D94C22416">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075f1</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX27137F37977A42C196F1CC6B13E932EE">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075f2</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX6EE3DE362AD143618AE0D70F2196664C">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder11</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075f3</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBX2A25F2F3A887414887DC4C3A0324C974">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075f4</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX6FDA66333A434B099C0189D905854077">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075f5</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX2DC6BA1664A84AAA801562D34683D9BF">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075f6</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXC6B37C2D1FC24DD88C84DFD47123C14D">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075f7</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBXD2F6CEC8431D448BA8E0B588AFD92F46">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder12</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075f8</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBX074E45B280844BA38FE1BB1125236DBA">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075f9</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX5C776032FE704E678D924147E28A630C">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075fa</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX09808CD3BD0140938D16BF3BE96161C3">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075fb</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX5C99C938F92144ED9F5630A202350588">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075fc</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="UIListLayout" referent="RBX9C7E59BA3F554B7A9DDDB74FBA2DEEA3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<token name="FillDirection">1</token>
								<UniqueId name="HistoryId">7745f3117c4a251a089954ce00005ebb</UniqueId>
								<token name="HorizontalAlignment">1</token>
								<token name="HorizontalFlex">0</token>
								<token name="ItemLineAlignment">0</token>
								<string name="Name">UIListLayout</string>
								<UDim name="Padding">
									<S>0</S>
									<O>0</O>
								</UDim>
								<token name="SortOrder">2</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005ee5</UniqueId>
								<token name="VerticalAlignment">1</token>
								<token name="VerticalFlex">0</token>
								<bool name="Wraps">false</bool>
							</Properties>
						</Item>
						<Item class="UIPadding" referent="RBXE2180315324B49EA855D870B1C29F762">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">UIPadding</string>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>5</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>5</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>5</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>5</O>
								</UDim>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600007449</UniqueId>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX4E80B03A11B748BC9EC35BEF96A66188">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>700</Weight>
									<Style>Normal</Style>
								</Font>
								<UniqueId name="HistoryId">7745f3117c4a251a089954ce00005eba</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">1</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">TextLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0.100000001</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">   Items</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">1</token>
								<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005ee4</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBXC1A7600ADE8340908D5B317072545B21">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de60000730c</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">3</int>
							<string name="Name">HiddenContents</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.333000004</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.400000006</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005b9a</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UIListLayout" referent="RBX7D9534988A454C7DB6BD2A965E58FE0D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<token name="FillDirection">1</token>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<token name="HorizontalAlignment">1</token>
								<token name="HorizontalFlex">0</token>
								<token name="ItemLineAlignment">0</token>
								<string name="Name">UIListLayout</string>
								<UDim name="Padding">
									<S>0</S>
									<O>0</O>
								</UDim>
								<token name="SortOrder">2</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005ebb</UniqueId>
								<token name="VerticalAlignment">1</token>
								<token name="VerticalFlex">0</token>
								<bool name="Wraps">false</bool>
							</Properties>
						</Item>
						<Item class="UIPadding" referent="RBX29B15B200C4A44E3A5B53CDAC558F0F9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007449</UniqueId>
								<string name="Name">UIPadding</string>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>5</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>5</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>5</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>15</O>
								</UDim>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005f26</UniqueId>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX1423029DE8A442FDBB1EBCE308A99B6F">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">7745f3117c4a251a089954ce00005e79</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">2</int>
								<string name="Name">Items</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075be</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIPadding" referent="RBX7B51BE7FE7EF4931B1DB046E3534AC8B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007449</UniqueId>
									<string name="Name">UIPadding</string>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>0</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>0</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>5</O>
									</UDim>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075bf</UniqueId>
								</Properties>
							</Item>
							<Item class="UIListLayout" referent="RBX264C9E77853146A4AA361854DDD8FC5E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<token name="FillDirection">0</token>
									<UniqueId name="HistoryId">7745f3117c4a251a089954ce00005f88</UniqueId>
									<token name="HorizontalAlignment">1</token>
									<token name="HorizontalFlex">3</token>
									<token name="ItemLineAlignment">0</token>
									<string name="Name">UIListLayout</string>
									<UDim name="Padding">
										<S>0.00499999989</S>
										<O>0</O>
									</UDim>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7745f3117c4a251a089954ce000075c5</UniqueId>
									<token name="VerticalAlignment">1</token>
									<token name="VerticalFlex">3</token>
									<bool name="Wraps">true</bool>
								</Properties>
							</Item>
							<Item class="Frame" referent="RBX974CB8A1716F4B68803E3F901FFD2743">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder1</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3b4d352275f2c90608b5fa790000578b</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBX96AB72D927A44A5A81AC787A2EED435A">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa790000578c</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXCBC281D52F59447CA428B2962BDF7049">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa790000578d</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXCB24BAED61CE45AB91D0F6F3212596EA">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa790000578e</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXCAE290C0AD8B478BB81A36FF49EC4937">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa790000578f</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX34BB9CDA4D3440AAB6FBF516B6A9D2FF">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder2</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3b4d352275f2c90608b5fa7900005790</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBX4A859FD962F94A79A20990F29C34F189">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa7900005791</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX81D97252F8784767B79EB72E1A04F2AF">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa7900005792</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXA505AD9870FB453EBE432F1D36B83AC1">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa7900005793</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXBAE9E4971C164D06B9364F6CB00A9CAB">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa7900005794</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX7CCF3D586BC04F3F99BA25F85F9679C1">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder3</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3b4d352275f2c90608b5fa7900005795</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBX3E2828242BA24178B9414855CB635D90">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa7900005796</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX30DC09C03469418DBA54CD25FD2571C0">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa7900005797</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX2C69752A9D404B08B2102FBE4E2FDB37">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa7900005798</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXEFF49E5F76244158A42532DEF1278E82">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa7900005799</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBXD6F09A3323834F42BA49883068B31F5A">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder4</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3b4d352275f2c90608b5fa790000579a</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBXE2E72CBF051C4662BF52267DABF0C113">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa790000579b</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXE1F287911C004455A4DF9DE5D2F43D72">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa790000579c</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX67E651BC057B48EF915ED34A1454F560">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa790000579d</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXF40AAD686CAC4DA4A724FAF15A3F1AA0">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa790000579e</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX9CA853E555704CAAA5CEF0798BDECEE9">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder5</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3b4d352275f2c90608b5fa790000579f</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBXC77C3A79BFC74E8DA465FA2246861F11">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa79000057a0</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX42D27A8E37374851926F102351A183C2">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa79000057a1</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX7E39807F29364D6AAA0EB939F3D20965">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa79000057a2</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX5B1E531CE8DD4E63A47BDBA87D121A3F">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa79000057a3</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX973BBFFBF50A4565803D3AD1E9FE97A0">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.5</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PlaceHolder6</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.159999996</XS>
										<XO>0</XO>
										<YS>0.159999996</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3b4d352275f2c90608b5fa79000057a4</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="Frame" referent="RBX190F07ECE2CA468588D703C1B43471AB">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa79000057a5</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXA3A05567B3FF48CC809F54DC9519DA2D">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa79000057a6</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX3CD3A3C2A6C848C3BDB6F06E041B7614">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>1</XO>
											<YS>0</YS>
											<YO>5</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa79000057a7</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX6A00BBBFC5704943A1AEC7AEC532408A">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0</YS>
											<YO>1</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3b4d352275f2c90608b5fa79000057a8</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="TextLabel" referent="RBX8377C4170B1C4052B206963FA12653B2">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>700</Weight>
									<Style>Normal</Style>
								</Font>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">1</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">TextLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0.200000003</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">   Hidden Items</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">1</token>
								<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005eba</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="UIListLayout" referent="RBXA37FA9F08CF5400DB3EBC6805120016D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<token name="FillDirection">1</token>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<token name="HorizontalAlignment">0</token>
							<token name="HorizontalFlex">0</token>
							<token name="ItemLineAlignment">0</token>
							<string name="Name">UIListLayout</string>
							<UDim name="Padding">
								<S>0</S>
								<O>0</O>
							</UDim>
							<token name="SortOrder">2</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600007331</UniqueId>
							<token name="VerticalAlignment">0</token>
							<token name="VerticalFlex">4</token>
							<bool name="Wraps">false</bool>
						</Properties>
					</Item>
					<Item class="UIPadding" referent="RBX8A0DBC27B92C4DC59AF6D459360C0414">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de6000072eb</UniqueId>
							<string name="Name">UIPadding</string>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>10</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>10</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>10</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>10</O>
							</UDim>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600007328</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="UIAspectRatioConstraint" referent="RBX77BF6DCE8CBF45CCB76ED79BAC99D7B4">
					<Properties>
						<float name="AspectRatio">1.5</float>
						<token name="AspectType">0</token>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<token name="DominantAxis">0</token>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">UIAspectRatioConstraint</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4759be5bc435f364089ffe8100000f50</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="UIPadding" referent="RBX00E0E62F119A4A33901DDA0E9B425F1A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">UIPadding</string>
					<UDim name="PaddingBottom">
						<S>0</S>
						<O>25</O>
					</UDim>
					<UDim name="PaddingLeft">
						<S>0</S>
						<O>25</O>
					</UDim>
					<UDim name="PaddingRight">
						<S>0</S>
						<O>25</O>
					</UDim>
					<UDim name="PaddingTop">
						<S>0</S>
						<O>25</O>
					</UDim>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000072eb</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBXC320E6C1CB2D4FEA8F5065D1B9086F9C">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutoLocalize">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="ClipToDeviceSafeArea">true</bool>
				<bool name="DefinesCapabilities">false</bool>
				<int name="DisplayOrder">0</int>
				<bool name="Enabled">true</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Inventory</string>
				<bool name="ResetOnSpawn">false</bool>
				<Ref name="RootLocalizationTable">null</Ref>
				<token name="SafeAreaCompatibility">1</token>
				<token name="ScreenInsets">1</token>
				<token name="SelectionBehaviorDown">0</token>
				<token name="SelectionBehaviorLeft">0</token>
				<token name="SelectionBehaviorRight">0</token>
				<token name="SelectionBehaviorUp">0</token>
				<bool name="SelectionGroup">false</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4759be5bc435f364089ffe8100000fd1</UniqueId>
				<token name="ZIndexBehavior">1</token>
			</Properties>
			<Item class="Frame" referent="RBX5B5E350A55924057B0C793C94B174D43">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>1</Y>
					</Vector2>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<float name="BackgroundTransparency">0.5</float>
					<Color3 name="BorderColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="ClipsDescendants">false</bool>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Draggable">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<bool name="Interactable">true</bool>
					<int name="LayoutOrder">0</int>
					<string name="Name">Frame</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<Ref name="RootLocalizationTable">null</Ref>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0.179999992</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<int64 name="SourceAssetId">-1</int64>
					<token name="Style">0</token>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001072</UniqueId>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX5240C6229A284BCE801B356B9321752F">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0.5</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="ClipsDescendants">false</bool>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Draggable">false</bool>
						<UniqueId name="HistoryId">4759be5bc435f364089ffe8100001072</UniqueId>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">Frame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0.970000029</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001969</UniqueId>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="UIListLayout" referent="RBXAB53BC8C40ED45B4807F7D8FD26D2DB2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<token name="FillDirection">0</token>
							<UniqueId name="HistoryId">7745f3117c4a251a089954ce00005f88</UniqueId>
							<token name="HorizontalAlignment">1</token>
							<token name="HorizontalFlex">3</token>
							<token name="ItemLineAlignment">0</token>
							<string name="Name">UIListLayout</string>
							<UDim name="Padding">
								<S>0.00499999989</S>
								<O>0</O>
							</UDim>
							<token name="SortOrder">2</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4759be5bc435f364089ffe810000196a</UniqueId>
							<token name="VerticalAlignment">1</token>
							<token name="VerticalFlex">3</token>
							<bool name="Wraps">true</bool>
						</Properties>
					</Item>
					<Item class="UIPadding" referent="RBX8DF8A5206A894483A041E5BBC0461FA9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007449</UniqueId>
							<string name="Name">UIPadding</string>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>5</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>5</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>5</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>5</O>
							</UDim>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4759be5bc435f364089ffe810000196b</UniqueId>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBXECFDB0CA47AF4F37934FFA9EF2652228">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">PlaceHolder1</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.159999996</XS>
								<XO>0</XO>
								<YS>0.159999996</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">1</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4759be5bc435f364089ffe810000196c</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBX9944621D435546E6B642D1AF9AB6EC82">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0.721568644</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe810000196d</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX66148ECEE4C14665AB5E86552ACD9F07">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0.721568644</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe810000196e</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBXAD3C0C5F441246A09244DD4343DC2F7F">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0.721568644</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe810000196f</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX3AA50537DB56417AAD0CEC9D48C2A9C6">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0.721568644</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001970</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX1E9B933E71FD42A4AC332BD52110F7D3">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
								</Font>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">TextLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.174999997</XS>
									<XO>0</XO>
									<YS>0.174999997</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">1</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">0</token>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe81000019eb</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX591E715D4C594F278EF5EC73AC59AB54">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0.721568644</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">551644548e65349908aacf550000313e</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBXB9FBE94A9D4E459BB7AC745374CDC3DD">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0.721568644</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">551644548e65349908aacf550000313f</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX1E30BED2FCB14026A6722C8B090170A8">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0.721568644</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">551644548e65349908aacf5500003140</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX8D660AC00F2E411682C24553456EEC7C">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0.721568644</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">551644548e65349908aacf5500003141</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX8EDD4A65E0904BC1A8A4FDF26208FA5A">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">PlaceHolder2</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.159999996</XS>
								<XO>0</XO>
								<YS>0.159999996</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">1</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a0c</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBX59A86029E13543B4BD4ED43158746D4E">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a0d</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX594A7C389CA8484A99D6361E2185C743">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a0e</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBXD9EB1607E5AA4967AD6E3A8773108994">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a0f</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX55BC0F369D6F41A5BB65A43FE41BED8F">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a10</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX241C9C798BE542578E9289EF1237FC3F">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
								</Font>
								<UniqueId name="HistoryId">4759be5bc435f364089ffe81000019eb</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">TextLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.174999997</XS>
									<XO>0</XO>
									<YS>0.174999997</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">2</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">0</token>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a11</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX4FE8A7203CC94596ADCEEB5FF5F33C9C">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">PlaceHolder3</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.159999996</XS>
								<XO>0</XO>
								<YS>0.159999996</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">1</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a12</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBXA61AFD32BC5E411C9638F8F9CED38503">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a13</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX8D87CD28C7404E988A3BD13D157BF39A">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a14</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX279C8D0203214F3CB44B671FA4952A3D">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a15</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX89C2A7FF74FE45C0B5BD4B97C00921F1">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a16</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX07E07F6B25C2498EAFCC4105DA07B5C2">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
								</Font>
								<UniqueId name="HistoryId">4759be5bc435f364089ffe81000019eb</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">TextLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.174999997</XS>
									<XO>0</XO>
									<YS>0.174999997</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">3</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">0</token>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a17</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX13F48ACFA21C4C25BE08C1FA3FD86AF4">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">PlaceHolder4</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.159999996</XS>
								<XO>0</XO>
								<YS>0.159999996</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">1</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a18</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBXCC3427888A744096AE70DA6BB122EE0B">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a19</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX8C8D9AE71E804FAA86DE4E0889436221">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a1a</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX5CCC30D4546C4B7EB85D5D083FC7472C">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a1b</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX2C8AC3B7D092415D8723AA4AA1A50C4B">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a1c</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX2E5E9C41952643F18365A9613CC56B83">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
								</Font>
								<UniqueId name="HistoryId">4759be5bc435f364089ffe81000019eb</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">TextLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.174999997</XS>
									<XO>0</XO>
									<YS>0.174999997</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">4</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">0</token>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a1d</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBXC31CB4F572D04EAABBEDB6535165A93B">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">PlaceHolder5</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.159999996</XS>
								<XO>0</XO>
								<YS>0.159999996</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">1</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a1e</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBXFA55B650C5F24AEFAD7E9E1427256AF2">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a1f</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBXAD32A2B7FE5E49EBB7796467C0CF60A7">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a20</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBXC8E296649E8143B1A4DA95BF5271133E">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a21</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX1BD4A3F864094E9691A0E6B771092FB1">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a22</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBXBBCFAB23EA20473088FA713AEB01E5FE">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
								</Font>
								<UniqueId name="HistoryId">4759be5bc435f364089ffe81000019eb</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">TextLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.174999997</XS>
									<XO>0</XO>
									<YS>0.174999997</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">5</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">0</token>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a23</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX2872B9F96C4046D5A36FE2CE50478AAA">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">PlaceHolder6</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.159999996</XS>
								<XO>0</XO>
								<YS>0.159999996</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">1</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a24</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBX85A975527DCA4CFFA27EF769B3E772B1">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a25</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX6A249CA60455442696F810C7CE8D8EB9">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a26</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX31E2C2E738F4419B83B4B3C103912A50">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a27</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBXBF56F09D6DF146D1AA8ADB3536236BD2">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a28</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX80CD1CFACAE8403BBB9F3A323BEE43A1">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
								</Font>
								<UniqueId name="HistoryId">4759be5bc435f364089ffe81000019eb</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">TextLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.174999997</XS>
									<XO>0</XO>
									<YS>0.174999997</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">6</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">0</token>
								<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a29</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="UIAspectRatioConstraint" referent="RBX49BFCC4E5BB44855A8AC448AA5C4D99A">
					<Properties>
						<float name="AspectRatio">5</float>
						<token name="AspectType">0</token>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<token name="DominantAxis">0</token>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">UIAspectRatioConstraint</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4759be5bc435f364089ffe81000019ea</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="UIPadding" referent="RBXAC788B8A55BB46CBBC965CCD8A2BCECA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">UIPadding</string>
					<UDim name="PaddingBottom">
						<S>0</S>
						<O>25</O>
					</UDim>
					<UDim name="PaddingLeft">
						<S>0</S>
						<O>25</O>
					</UDim>
					<UDim name="PaddingRight">
						<S>0</S>
						<O>25</O>
					</UDim>
					<UDim name="PaddingTop">
						<S>0</S>
						<O>25</O>
					</UDim>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4759be5bc435f364089ffe810000123e</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX5FEC917FFF3A41E08724DBE497D588C5">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutoLocalize">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="ClipToDeviceSafeArea">true</bool>
				<bool name="DefinesCapabilities">false</bool>
				<int name="DisplayOrder">0</int>
				<bool name="Enabled">true</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">OverlayGui</string>
				<bool name="ResetOnSpawn">false</bool>
				<Ref name="RootLocalizationTable">null</Ref>
				<token name="SafeAreaCompatibility">1</token>
				<token name="ScreenInsets">1</token>
				<token name="SelectionBehaviorDown">0</token>
				<token name="SelectionBehaviorLeft">0</token>
				<token name="SelectionBehaviorRight">0</token>
				<token name="SelectionBehaviorUp">0</token>
				<bool name="SelectionGroup">false</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">43c00655b7588da408b747430000121a</UniqueId>
				<token name="ZIndexBehavior">1</token>
			</Properties>
		</Item>
		<Item class="ScreenGui" referent="RBXC416FBBEC4D24510A2457C4726B8B8A3">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutoLocalize">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="ClipToDeviceSafeArea">true</bool>
				<bool name="DefinesCapabilities">false</bool>
				<int name="DisplayOrder">0</int>
				<bool name="Enabled">true</bool>
				<UniqueId name="HistoryId">4759be5bc435f364089ffe8100000fd1</UniqueId>
				<string name="Name">ButtonsHelp</string>
				<bool name="ResetOnSpawn">false</bool>
				<Ref name="RootLocalizationTable">null</Ref>
				<token name="SafeAreaCompatibility">1</token>
				<token name="ScreenInsets">1</token>
				<token name="SelectionBehaviorDown">0</token>
				<token name="SelectionBehaviorLeft">0</token>
				<token name="SelectionBehaviorRight">0</token>
				<token name="SelectionBehaviorUp">0</token>
				<bool name="SelectionGroup">false</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">43c00655b7588da408b74743000021b1</UniqueId>
				<token name="ZIndexBehavior">1</token>
			</Properties>
			<Item class="Frame" referent="RBX42EFD3F2623C49BDB1ED0ADC15973D34">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>1</X>
						<Y>1</Y>
					</Vector2>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<float name="BackgroundTransparency">0.5</float>
					<Color3 name="BorderColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="ClipsDescendants">false</bool>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Draggable">false</bool>
					<UniqueId name="HistoryId">4759be5bc435f364089ffe8100001072</UniqueId>
					<bool name="Interactable">true</bool>
					<int name="LayoutOrder">0</int>
					<string name="Name">Chest</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<Ref name="RootLocalizationTable">null</Ref>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>0.100000001</XS>
						<XO>0</XO>
						<YS>0.150000006</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<int64 name="SourceAssetId">-1</int64>
					<token name="Style">0</token>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">43c00655b7588da408b74743000021b2</UniqueId>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX0694B0F00F294D2998049271EEF525F7">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0.5</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="ClipsDescendants">false</bool>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Draggable">false</bool>
						<UniqueId name="HistoryId">4759be5bc435f364089ffe8100001072</UniqueId>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">Frame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0.970000029</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">43c00655b7588da408b74743000021b3</UniqueId>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="UIListLayout" referent="RBX3A452105AED94859A49B24744C92A701">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<token name="FillDirection">0</token>
							<UniqueId name="HistoryId">7745f3117c4a251a089954ce00005f88</UniqueId>
							<token name="HorizontalAlignment">1</token>
							<token name="HorizontalFlex">0</token>
							<token name="ItemLineAlignment">0</token>
							<string name="Name">UIListLayout</string>
							<UDim name="Padding">
								<S>0.00499999989</S>
								<O>0</O>
							</UDim>
							<token name="SortOrder">2</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">43c00655b7588da408b74743000021b4</UniqueId>
							<token name="VerticalAlignment">1</token>
							<token name="VerticalFlex">3</token>
							<bool name="Wraps">true</bool>
						</Properties>
					</Item>
					<Item class="UIPadding" referent="RBXD4FB5878D4F94824AA7A72A894DD1E7C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007449</UniqueId>
							<string name="Name">UIPadding</string>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>5</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>5</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>5</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>5</O>
							</UDim>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">43c00655b7588da408b74743000021b5</UniqueId>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX50A7EA806D574C14AD1141590285A206">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">PlaceHolder1</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">43c00655b7588da408b74743000021c0</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBX237AD5CB7AE148A48EB4C8E99D5D9680">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">43c00655b7588da408b74743000021c1</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBXAC7CE38692BB452DAB9D80D3A1B291CC">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">43c00655b7588da408b74743000021c2</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX07C1E1081E4A4547AB4C55BA68B17647">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">43c00655b7588da408b74743000021c3</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBXF13E0589B0DF4DDEA878202C9484F0AF">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">43c00655b7588da408b74743000021c4</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX3F69D437FC4046DDA203CF7214B86900">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">43c00655b7588da408b747430000237b</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIPadding" referent="RBX0153452021AD45619E3DD1174437DC77">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">UIPadding</string>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>5</O>
									</UDim>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">43c00655b7588da408b747430000237c</UniqueId>
								</Properties>
							</Item>
							<Item class="Frame" referent="RBXB89C33830ED844BBB04934D15E68C72B">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Frame</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">43c00655b7588da408b747430000237d</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="TextLabel" referent="RBXC01F730297284B7DBF7FE8859179A9F6">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<UniqueId name="HistoryId">4759be5bc435f364089ffe81000019eb</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">TextLabel</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">E</string>
										<Color3 name="TextColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">0</token>
										<UniqueId name="UniqueId">43c00655b7588da408b74743000021c5</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="UIListLayout" referent="RBX7235A4735D9247DF991EF23180F26425">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<token name="FillDirection">0</token>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<token name="HorizontalAlignment">1</token>
									<token name="HorizontalFlex">3</token>
									<token name="ItemLineAlignment">0</token>
									<string name="Name">UIListLayout</string>
									<UDim name="Padding">
										<S>0</S>
										<O>0</O>
									</UDim>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">43c00655b7588da408b747430000237e</UniqueId>
									<token name="VerticalAlignment">1</token>
									<token name="VerticalFlex">0</token>
									<bool name="Wraps">false</bool>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX163655C6C6BF4F7FB56F977422931E44">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<UniqueId name="HistoryId">4759be5bc435f364089ffe81000019eb</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">TextLabel</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<string name="OpenTypeFeatures"></string>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.800000012</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Pick up item</string>
									<Color3 name="TextColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">16</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">1</token>
									<UniqueId name="UniqueId">43c00655b7588da408b747430000237f</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX826D1BAF14D3410E98F72FCA8D838929">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007334</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">PlaceHolder2</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">43c00655b7588da408b74743000023a0</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBXC57AB760852A47E894A8C29745E977D4">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">43c00655b7588da408b74743000023a1</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBXD3FEBBB6E68A40EA89DB7E7DF3E710DC">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">43c00655b7588da408b74743000023a2</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX5F9E60D6BB814529BDE376A33CBADD5C">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>1</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">43c00655b7588da408b74743000023a3</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBXBB3C3E9D89D548999726C9A715571E7B">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">759ee19baa6ba7f8088b6de600007423</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>1</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">43c00655b7588da408b74743000023a4</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBXA20A7CE2E35449A5B51FA506D84EC20F">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">43c00655b7588da408b747430000237b</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">43c00655b7588da408b74743000023a5</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIPadding" referent="RBX5378D12A8DEB47C68D1B1A5FC2B0DB29">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">43c00655b7588da408b747430000237c</UniqueId>
									<string name="Name">UIPadding</string>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>5</O>
									</UDim>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">43c00655b7588da408b74743000023a6</UniqueId>
								</Properties>
							</Item>
							<Item class="Frame" referent="RBX0F80C5BB14CD4C8BBB130616F8DE3460">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">43c00655b7588da408b747430000237d</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Frame</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">43c00655b7588da408b74743000023a7</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="TextLabel" referent="RBXA067C282B5D64D0B9E8063024E96B433">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<UniqueId name="HistoryId">4759be5bc435f364089ffe81000019eb</UniqueId>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">TextLabel</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Q</string>
										<Color3 name="TextColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">0</token>
										<UniqueId name="UniqueId">43c00655b7588da408b74743000023a8</UniqueId>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="UIListLayout" referent="RBX829D61930E694CCCBF5D7122D9661A14">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<token name="FillDirection">0</token>
									<UniqueId name="HistoryId">43c00655b7588da408b747430000237e</UniqueId>
									<token name="HorizontalAlignment">1</token>
									<token name="HorizontalFlex">3</token>
									<token name="ItemLineAlignment">0</token>
									<string name="Name">UIListLayout</string>
									<UDim name="Padding">
										<S>0</S>
										<O>0</O>
									</UDim>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">43c00655b7588da408b74743000023a9</UniqueId>
									<token name="VerticalAlignment">1</token>
									<token name="VerticalFlex">0</token>
									<bool name="Wraps">false</bool>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBXB54257A249D948B5911ECFC448B2AB59">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<UniqueId name="HistoryId">4759be5bc435f364089ffe81000019eb</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">TextLabel</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<string name="OpenTypeFeatures"></string>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.800000012</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Hide Item</string>
									<Color3 name="TextColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">16</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">1</token>
									<UniqueId name="UniqueId">43c00655b7588da408b74743000023aa</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="UIAspectRatioConstraint" referent="RBX40EB3D9DCB6244AABA3368B8F24A8E90">
					<Properties>
						<float name="AspectRatio">2</float>
						<token name="AspectType">0</token>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<token name="DominantAxis">0</token>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">UIAspectRatioConstraint</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">43c00655b7588da408b74743000023ab</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="UIPadding" referent="RBX3D0D616944BA4B749DAE6F3D52DADE54">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">4759be5bc435f364089ffe810000123e</UniqueId>
					<string name="Name">UIPadding</string>
					<UDim name="PaddingBottom">
						<S>0</S>
						<O>25</O>
					</UDim>
					<UDim name="PaddingLeft">
						<S>0</S>
						<O>25</O>
					</UDim>
					<UDim name="PaddingRight">
						<S>0</S>
						<O>25</O>
					</UDim>
					<UDim name="PaddingTop">
						<S>0</S>
						<O>25</O>
					</UDim>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">43c00655b7588da408b74743000021df</UniqueId>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="LocalizationService" referent="RBX2C8850C91EB54FAA8CAC815C54E18E6A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000034c</UniqueId>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBXD442A8FB0D194B099A9B8E9BBDABA50F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000351</UniqueId>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBXDA294CE43DA141AE92FC60E9C0F88229">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000353</UniqueId>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBXC317328113654A6D923704DD67F01619">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000354</UniqueId>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBXD3BF31F45DE0409F996F742D0A570EBF">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000357</UniqueId>
		</Properties>
		<Item class="StringValue" referent="RBXA98C2467EE8D495FA3077EF2BAA64532">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003a2</UniqueId>
				<string name="Value">{B5EDC2CD-1A08-40E3-91CF-B20F53667181}</string>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="RBXA489F502F867405FBD8B4177CB20D4A9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000358</UniqueId>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBXF7171A70B813444587AFB197E48EFDAC">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000359</UniqueId>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX1747BFE2FBB44876A445E5CA9BB9C0E1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000035a</UniqueId>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBXC8082866122F41DC9BEE38BA5E1D1665">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000035b</UniqueId>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBX333B67B6E529495FB1A5A02E57506B63">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AutomaticScaling">0</token>
			<bool name="AvatarGestures">false</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="ControllerModels">1</token>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="FadeOutViewOnCollision">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="LaserPointer">1</token>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000035f</UniqueId>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBX5B81C9CB98F9415698A087A27224B6E8">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000360</UniqueId>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBXDB3A8160BE574C3F9461BEB636C9A544">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000361</UniqueId>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBXCDEAA3E915D8412E801DD074C13B2126">
		<Properties>
			<bool name="AllowInsertFreeAssets">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000362</UniqueId>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBXF1BEE848E2004C66B4D27B4EA78322A2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000363</UniqueId>
		</Properties>
	</Item>
	<Item class="AvatarSettings" referent="RBXDEFC03AD4A60474CB463D87157E2F5FB">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">AvatarSettings</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">1ac1e67b311e6603089095480000036e</UniqueId>
		</Properties>
		<Item class="AvatarRules" referent="RBXA8394F36080A4F09982E4746CE113D37">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<token name="AvatarType">1</token>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">DefaultAvatarRules</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">4a0ecd628f8319c008ca16da00000bf1</UniqueId>
			</Properties>
			<Item class="AvatarBodyRules" referent="RBX7436827CCCAF4CCB8C884CD8370F039D">
				<Properties>
					<token name="AppearanceMode">0</token>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<token name="BuildMode">0</token>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<int64 name="CustomBodyBundleId">0</int64>
					<token name="CustomBodyType">0</token>
					<NumberRange name="CustomBodyTypeScale">0 1 </NumberRange>
					<bool name="CustomEyebrowEnabled">false</bool>
					<int64 name="CustomEyebrowId">0</int64>
					<bool name="CustomEyelashEnabled">false</bool>
					<int64 name="CustomEyelashId">0</int64>
					<bool name="CustomFaceEnabled">false</bool>
					<int64 name="CustomFaceId">0</int64>
					<bool name="CustomHeadEnabled">false</bool>
					<int64 name="CustomHeadId">0</int64>
					<NumberRange name="CustomHeadScale">0.95 1 </NumberRange>
					<NumberRange name="CustomHeight">5.5 5.5 </NumberRange>
					<NumberRange name="CustomHeightScale">0.9 1.05 </NumberRange>
					<bool name="CustomLeftArmEnabled">false</bool>
					<int64 name="CustomLeftArmId">0</int64>
					<bool name="CustomLeftLegEnabled">false</bool>
					<int64 name="CustomLeftLegId">0</int64>
					<bool name="CustomMoodEnabled">false</bool>
					<int64 name="CustomMoodId">0</int64>
					<NumberRange name="CustomProportionsScale">0 1 </NumberRange>
					<bool name="CustomRightArmEnabled">false</bool>
					<int64 name="CustomRightArmId">0</int64>
					<bool name="CustomRightLegEnabled">false</bool>
					<int64 name="CustomRightLegId">0</int64>
					<bool name="CustomTorsoEnabled">false</bool>
					<int64 name="CustomTorsoId">0</int64>
					<NumberRange name="CustomWidthScale">0.7 1 </NumberRange>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<bool name="KeepPlayerHead">true</bool>
					<string name="Name">AvatarBodyRules</string>
					<token name="ScaleMode">0</token>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4a0ecd628f8319c008ca16da00000bf2</UniqueId>
				</Properties>
			</Item>
			<Item class="AvatarCollisionRules" referent="RBX2E2E0037F1B8401EAC646E2312126F61">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<token name="CollisionMode">0</token>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<token name="HitAndTouchDetectionMode">0</token>
					<token name="LegacyCollisionMode">1</token>
					<string name="Name">AvatarCollisionRules</string>
					<Vector3 name="SingleColliderSize">
						<X>2</X>
						<Y>4</Y>
						<Z>1</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4a0ecd628f8319c008ca16da00000bf3</UniqueId>
				</Properties>
			</Item>
			<Item class="AvatarAnimationRules" referent="RBX25F47CE63AB647CDB72799F183E767AB">
				<Properties>
					<token name="AnimationClipsMode">0</token>
					<token name="AnimationPacksMode">0</token>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CustomClimbAnimationEnabled">false</bool>
					<int64 name="CustomClimbAnimationId">0</int64>
					<bool name="CustomFallAnimationEnabled">false</bool>
					<int64 name="CustomFallAnimationId">0</int64>
					<bool name="CustomIdleAlt1AnimationEnabled">false</bool>
					<int64 name="CustomIdleAlt1AnimationId">0</int64>
					<bool name="CustomIdleAlt2AnimationEnabled">false</bool>
					<int64 name="CustomIdleAlt2AnimationId">0</int64>
					<bool name="CustomIdleAnimationEnabled">false</bool>
					<int64 name="CustomIdleAnimationId">0</int64>
					<bool name="CustomJumpAnimationEnabled">false</bool>
					<int64 name="CustomJumpAnimationId">0</int64>
					<bool name="CustomRunAnimationEnabled">false</bool>
					<int64 name="CustomRunAnimationId">0</int64>
					<bool name="CustomSwimAnimationEnabled">false</bool>
					<int64 name="CustomSwimAnimationId">0</int64>
					<bool name="CustomSwimIdleAnimationEnabled">false</bool>
					<int64 name="CustomSwimIdleAnimationId">0</int64>
					<bool name="CustomWalkAnimationEnabled">false</bool>
					<int64 name="CustomWalkAnimationId">0</int64>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">AvatarAnimationRules</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4a0ecd628f8319c008ca16da00000bf4</UniqueId>
				</Properties>
			</Item>
			<Item class="AvatarAccessoryRules" referent="RBXC866647437E74496A485BEC2609E158C">
				<Properties>
					<token name="AccessoryMode">0</token>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<token name="CustomAccessoryMode">0</token>
					<bool name="CustomBackAccessoryEnabled">false</bool>
					<int64 name="CustomBackAccessoryId">0</int64>
					<bool name="CustomFaceAccessoryEnabled">false</bool>
					<int64 name="CustomFaceAccessoryId">0</int64>
					<bool name="CustomFrontAccessoryEnabled">false</bool>
					<int64 name="CustomFrontAccessoryId">0</int64>
					<bool name="CustomHairAccessoryEnabled">false</bool>
					<int64 name="CustomHairAccessoryId">0</int64>
					<bool name="CustomHeadAccessoryEnabled">false</bool>
					<int64 name="CustomHeadAccessoryId">0</int64>
					<bool name="CustomNeckAccessoryEnabled">false</bool>
					<int64 name="CustomNeckAccessoryId">0</int64>
					<bool name="CustomShoulderAccessoryEnabled">false</bool>
					<int64 name="CustomShoulderAccessoryId">0</int64>
					<bool name="CustomWaistAccessoryEnabled">false</bool>
					<int64 name="CustomWaistAccessoryId">0</int64>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableSound">true</bool>
					<bool name="EnableVFX">true</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Vector3 name="LimitBounds">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="LimitMethod">1</token>
					<string name="Name">AvatarAccessoryRules</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4a0ecd628f8319c008ca16da00000bf5</UniqueId>
				</Properties>
			</Item>
			<Item class="AvatarClothingRules" referent="RBX246373E50EB04EC398837FBA3CBF7ECA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<token name="ClothingMode">0</token>
					<bool name="CustomClassicPantsAccessoryEnabled">false</bool>
					<int64 name="CustomClassicPantsAccessoryId">0</int64>
					<bool name="CustomClassicShirtsAccessoryEnabled">false</bool>
					<int64 name="CustomClassicShirtsAccessoryId">0</int64>
					<bool name="CustomClassicTShirtsAccessoryEnabled">false</bool>
					<int64 name="CustomClassicTShirtsAccessoryId">0</int64>
					<token name="CustomClothingMode">0</token>
					<bool name="CustomDressSkirtAccessoryEnabled">false</bool>
					<int64 name="CustomDressSkirtAccessoryId">0</int64>
					<bool name="CustomJacketAccessoryEnabled">false</bool>
					<int64 name="CustomJacketAccessoryId">0</int64>
					<bool name="CustomLeftShoesAccessoryEnabled">false</bool>
					<int64 name="CustomLeftShoesAccessoryId">0</int64>
					<bool name="CustomPantsAccessoryEnabled">false</bool>
					<int64 name="CustomPantsAccessoryId">0</int64>
					<bool name="CustomRightShoesAccessoryEnabled">false</bool>
					<int64 name="CustomRightShoesAccessoryId">0</int64>
					<bool name="CustomShirtAccessoryEnabled">false</bool>
					<int64 name="CustomShirtAccessoryId">0</int64>
					<bool name="CustomShortsAccessoryEnabled">false</bool>
					<int64 name="CustomShortsAccessoryId">0</int64>
					<bool name="CustomSweaterAccessoryEnabled">false</bool>
					<int64 name="CustomSweaterAccessoryId">0</int64>
					<bool name="CustomTShirtAccessoryEnabled">false</bool>
					<int64 name="CustomTShirtAccessoryId">0</int64>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Vector3 name="LimitBounds">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<string name="Name">AvatarClothingRules</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4a0ecd628f8319c008ca16da00000bf6</UniqueId>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="LuaWebService" referent="RBX6C9DE6DBAA2546309D1D39B5903A7B5C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LuaWebService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4a0ecd628f8319c008ca16da00000ce1</UniqueId>
		</Properties>
	</Item>
	<Item class="ProcessInstancePhysicsService" referent="RBXA6AEACC441844F76ACFF12FC430A0F00">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ProcessInstancePhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00000377</UniqueId>
		</Properties>
	</Item>
	<Item class="ReplicatedStorage" referent="RBXBB6B66660B7540D095E9FDCADC97A1F0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000372</UniqueId>
		</Properties>
		<Item class="Folder" referent="RBX016B8D2CB03F4FCEA403489664E56634">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Modules</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600006107</UniqueId>
			</Properties>
			<Item class="Folder" referent="RBX99E22AB2C8964626AB3D8868D03EE48A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Client</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">6e87ccb51f069bf408b38bfe0000117e</UniqueId>
				</Properties>
				<Item class="Folder" referent="RBXF49C0E47CCFA4E9DBB371264B0BB78B2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">Replicas</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a2d</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX5A8FB4046DA740E4BAE456941291A047">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ItemReplica</string>
							<string name="ScriptGuid">{E48B2C98-CF95-4EF2-B43A-1D364926B68D}</string>
							<ProtectedString name="Source"><![CDATA[local replicatedStorage = game:GetService('ReplicatedStorage')
local userInputService = game:GetService("UserInputService")
local tweenService = game:GetService("TweenService")

local itemsDirectory = require(replicatedStorage.Directory.Items)

local lib = require(replicatedStorage:WaitForChild('lib'))
local clientModules = replicatedStorage.Modules.Client
local sharedModules = replicatedStorage.Modules.Shared

local replicableInstance = require(sharedModules.Classes.ReplicableInstance)
local instancesManager = require(sharedModules.Managers.InstancesManager)

local inventoryUtil = require(sharedModules.Utils.InventoryUtilShared)
local inventoryUtilClient = require(clientModules.Utils.InventoryUtilClient)

local itemHover = require(clientModules.Utils.ItemHover)

local localPlayer = game.Players.LocalPlayer

local module = setmetatable({}, replicableInstance)
module.__index = module

export type ClassType = typeof(setmetatable(
	{}:: {
		Model: typeof(itemsDirectory.directoryFolder["00 | Template"].Model),
		equipped: boolean,
		Display: Frame,
		InstantiatedTo: string | Player, -- Parent
		
		animType: 'KeyDown' | nil,
	},
	module
)) & lib.ReplicableInstance & itemsDirectory.Type

function module.new(UID: string)
	local self: ClassType = setmetatable(replicableInstance.new(UID) :: lib.ReplicableInstance, module)
	self._Type = 'Item'
	self.equipped = false

	return self
end

function module.AttachItem(self: ClassType, itemId: number)
	local itemInfo = itemsDirectory:getItemInfo(itemId)
	if not itemId then return end

	for k, v in itemInfo do
		self[k] = v
	end
	
	return self
end

function module.Materialize(self: ClassType)
	self.Model = itemsDirectory:getItemModel(self.Id):Clone()

	return self
end

function module.CreateDisplay(self: ClassType)
	if self.Display then return end
	self.Display = itemsDirectory:getItemDisplay(self.Id):Clone()
	self.Display.Name = self.UID
	local twI1 = TweenInfo.new(0.1, Enum.EasingStyle.Sine)
	local originalSize = self.Display.Size
	local futureSize = UDim2.fromScale(originalSize.X.Scale * 1.1, originalSize.Y.Scale * 1.1)
	local tw1 = tweenService:Create(self.Display, twI1, {Size = futureSize})
	local tw2 = tweenService:Create(self.Display, twI1, {Size = originalSize})
	self.Display.MouseEnter:Connect(function()
		tw1:Play()
	end)
	self.Display.MouseLeave:Connect(function()
		tw2:Play()
	end)
	self:AnimKeyDown()
	
	if self.Legal then
		self.Display.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		self.Display.Transparency = 1
	else
		self.Display.BackgroundColor3 = Color3.fromRGB(255, 0, 4)
		self.Display.Transparency = .85
	end
	
	return self
end

function module.AddToInventory(self: ClassType, inv: {any}?, slot: number?)
	inv = inv or inventoryUtil.getPlayerInventory(self.InstantiatedTo)
	if inventoryUtil.canAddItem(inv, self.UID) then
		print(self.InstantiatedTo)
		self:InstantiateTo(localPlayer)
		print(self.InstantiatedTo)
		local slot = slot or inventoryUtil.getNextSlotForANewItem(inv)
		
		inventoryUtil.addItemToInventory(self.UID, inv, slot)
		inventoryUtilClient.putItemOnInventorySlot(self.UID, slot)
	end

	return self
end

function module.AddToChest(self: ClassType, chestUID: string?, contentTabName: string?)
	self:CreateDisplay()
	self:AnimKeyDown()
	
	self:InstantiateTo(chestUID, contentTabName)

	return self
end

function module.AnimKeyDown(self: ClassType)
	if self.animType == 'KeyDown' then return end
	self.animType = 'KeyDown'
	if not self.Display then self:CreateDisplay() end
	
	local conHoverStarted
	local conHoverEnded
	
	itemHover.addItem(self)
	
	local listening = false
	self.Display.MouseEnter:Connect(function()
		if listening then return end
		listening = true
		local conKey = userInputService.InputBegan:Connect(function(inp)
			if inp.KeyCode == Enum.KeyCode.E then
				print(self.InstantiatedTo)
				if type(self.InstantiatedTo) == 'string' then
					if self.InstantiatedTo == '' then
						
					else
						self:AddToInventory()
						self.Remote:Fire(self.UID, 'TryToInstantiateTo', {self.InstantiatedTo})
					end
				elseif typeof(self.InstantiatedTo) == 'Instance' and self.InstantiatedTo:IsA('Player') then
					local chestOpen = localPlayer:GetAttribute('ChestOpen')
					if chestOpen then
						local chest = instancesManager.getObj(chestOpen)
						print(chest)
						print(chestOpen)
						if chest and chest._Type == 'Chest' then
							self:AddToChest(chestOpen, 'DeskContents')
						end
						self.Remote:Fire(self.UID, 'TryToInstantiateTo', {self.InstantiatedTo})
					end
				end
			end
		end)
		local conLeave; conLeave = self.Display.MouseLeave:Connect(function()
			conKey:Disconnect()
			conLeave:Disconnect()
			listening = false
		end)
		self.Trove:Add(conKey); self.Trove:Add(conLeave)
	end)
	
	return self
end

function module.Drop(self: ClassType)
	if self.InstantiatedTo ~= '' then
		self:InstantiateTo('')
	end
	
	self.Model:PivotTo(self.Model:GetPivot() * CFrame.new(0, 4, 0))
	
	return self
end

function module.InstantiateTo(self: ClassType, any: string | Player, chestStorage: string?)
	if self.InstantiatedTo == any then return self end

	local isPlayer = (typeof(any) == "Instance" and any:IsA("Player"))
	local isChest  = (type(any) == "string" and any ~= "")
	local isGround = (type(any) == "string" and any == "")

	if not (isPlayer or isChest or isGround) then return self end

	if type(self.InstantiatedTo) == "string" and self.InstantiatedTo ~= "" then
		local chestNow = instancesManager.getObj(self.InstantiatedTo)
		if chestNow then
			chestNow:RemoveItem(self.UID)
		end
	end

	self.InstantiatedTo = any
	if isGround then
		self:Drop()
	elseif isChest then
		local chest = instancesManager.getObj(any)
		if chest and chest._Type == 'Chest' then
			self:AddToChest()
			chest:AddItem(self.UID, chestStorage)
		end
	elseif isPlayer then
		self:AddToInventory()
	end

	return self
end

function module.RemoveFromChest(self: ClassType)
	local chest = instancesManager.getObj(self.InstantiatedTo)
	if chest then
		chest:RemoveItem(self.UID)
	end

	itemHover.removeItem(self)
	return self
end

function module.Inventorize(self: ClassType)
	self:RemoveFromChest()
	
	return self
end

function module.EquipItem(self: ClassType)
	if self.equipped then return end
	if not (typeof(self.InstantiatedTo) == "Instance" and self.InstantiatedTo:IsA("Player")) then return end
	
	local char = self.InstantiatedTo.Character
	if char then
		local hrp = char.PrimaryPart
		if hrp then
			self.Model:PivotTo(hrp.CFrame * CFrame.new(0, 4, 0))
		end
	end
	
	return self
end

function module.UnequipItem(self: ClassType)
	if not self.equipped then return end
	
	return self
end

function module.ToggleEquip(self: ClassType)

end


return module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">551644548e65349908aacf550000298d</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX64D487518F0D439891EB81EB4E2CBE01">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ChestReplica</string>
							<string name="ScriptGuid">{B12D0460-EB48-4451-953E-F03C5A80D3D5}</string>
							<ProtectedString name="Source"><![CDATA[local replicatedStorage = game:GetService("ReplicatedStorage")
local PlayersService = game:GetService("Players")
local runService = game:GetService("RunService")

local lib = require(replicatedStorage:WaitForChild("lib"))
local clientModules = replicatedStorage.Modules.Client
local sharedModules = replicatedStorage.Modules.Shared

local replicableInstance = require(sharedModules.Classes.ReplicableInstance)
local instancesManager = require(sharedModules.Managers.InstancesManager)

local spring = lib.ModuleUtils.Spring
local charUtils = lib.FunctionUtils.Character

local chestDirectory = require(replicatedStorage.Directory.Chests)
local chestSharedClass = require(sharedModules.Classes.ChestClasse)

local itemsReplica = require(clientModules.Replicas.ItemReplica)

local localplayer = PlayersService.LocalPlayer

local module = setmetatable({}, { __index = chestSharedClass })

export type ClassType = typeof(setmetatable(
	{} :: {
		Model: typeof(chestDirectory.directoryFolder["00 _ Template"].Model),
		Display: typeof(chestDirectory.directoryFolder["00 _ Template"].Display),
		DrawerSpring: typeof(spring.new()),
		DrawerPivotPosition: Vector3,
		ProximityPrompt: ProximityPrompt,
	},
	{ __index = module }
)) & chestSharedClass.ClassType

function module.new(UID: string)
	local self: ClassType = replicableInstance.newLinkedToAClass(module, chestSharedClass, UID) :: ClassType
	self._Type = "Chest"
	self.ItemsInside = {
		DeskContents = {},
		HiddenContents = {},
	}

	return self
end

function module.AttachChest(_self: ClassType, _chestId: number | string)
	--SHARED
end

function module.Materialize(self: ClassType, _CF: CFrame)
	self.ProximityPrompt = self.Model.Chest.ProximityPrompt

	self.Model:PivotTo(self.CFrame)
	self.Model.Parent = workspace
	self.DrawerPivotPosition = self.Model.Drawer:GetPivot().Position

	self.DrawerSpring = spring.new(0)
	self.DrawerSpring.Speed = 15

	self.ProximityPrompt.MaxActivationDistance = self.MaxDistanceToInteract
	self.ProximityPrompt.HoldDuration = self.OpenTime

	self.Trove:Add(self.ProximityPrompt.PromptButtonHoldBegan:Connect(function()
		self.Remote:Fire(self.UID, "playerBeganHoldingProximityPrompt", {})
	end))
	self.Trove:Add(self.ProximityPrompt.PromptButtonHoldEnded:Connect(function()
		self.Remote:Fire(self.UID, "playerEndedHoldingProximityPrompt", {})
	end))
	self.Trove:Add(self.ProximityPrompt.Triggered:Connect(function()
		self.Display.Visible = true
		self.ProximityPrompt.Enabled = false

		local con
		con = runService.Heartbeat:Connect(function()
			local plrRootPart = charUtils.getAlivePlayerRootPart(localplayer)
			if
				not plrRootPart
				or (plrRootPart.Position - self.CFrame.Position).Magnitude >= self.MaxDistanceToInteract
			then
				self.Display.Visible = false
				self.ProximityPrompt.Enabled = true
				con:Disconnect()
				con = nil
				return
			end
		end)
		self.Trove:Add(con)
	end))

	self.Trove:Add(runService.RenderStepped:Connect(function()
		local hrp = localplayer.Character.PrimaryPart
		local sprPos = self.DrawerSpring.Position

		if not hrp then
			return
		end
		if (hrp.Position - self.Model.PrimaryPart.Position).Magnitude <= self.MaxDistanceToInteract then
			self.DrawerSpring.Damping = 0.4
			self.DrawerSpring.Target = 40
			if self.DrawerSpring:IsAtRest() then
				self.DrawerSpring:Reset(40)
				return
			end
			self.Model.Drawer:PivotTo(CFrame.new(self.DrawerPivotPosition) * CFrame.Angles(0, 0, math.rad(-sprPos)))

			for _, a: Part in self.Model:GetChildren() do
				pcall(function()
					a.Color = Color3.fromRGB(50 + sprPos * 3, 50 + sprPos * 3, 50 + sprPos * 3)
				end)
			end
		else
			self.DrawerSpring.Damping = 0.75
			self.DrawerSpring.Target = 0
			if self.DrawerSpring:IsAtRest() then
				self.DrawerSpring:Reset(0)
				return
			end
			self.Model.Drawer:PivotTo(CFrame.new(self.DrawerPivotPosition) * CFrame.Angles(0, 0, math.rad(-sprPos)))

			for _, a: Part in self.Model:GetChildren() do
				pcall(function()
					a.Color = Color3.fromRGB(50 + sprPos * 3, 50 + sprPos * 3, 50 + sprPos * 3)
				end)
			end
		end
	end))

	self.Display = chestDirectory:getItemDisplay(self.Id):Clone()
	self.Display.Name = self.UID
	self.Display.Visible = false
	self.Display.Parent = localplayer.PlayerGui.Chests

	return self
end

function module.AddItem(self: ClassType, _itemUID: string, _contentName: string?)
	-- SHARED

	return self
end

function module.RemoveItem(self: ClassType)
	-- SHARED

	return self
end

function module.UpdateItemsInside(self: ClassType, itemsUIDTab: { [string]: { string } })
	local itemsInside = self.ItemsInside
	for contentName, contentTab in itemsUIDTab do
		itemsInside[contentName] = {}
		for _, uid in contentTab do
			local _item = (instancesManager.getObj(uid) or itemsReplica.new(uid)) :: itemsReplica.ClassType
			self:AddItem(uid, contentName)
		end
	end

	return self
end

function module.SetOwner(self: ClassType, _plr: Player)
	--SHARED

	return self
end

return module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a2a</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6A94ED39DE334E7F9D6C3D99FD879C77">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">IlegalItemDetectorReplica</string>
							<string name="ScriptGuid">{77875B20-F758-4DB8-9CFB-DE899E5212FA}</string>
							<ProtectedString name="Source"><![CDATA[local replicatedStorage = game:GetService('ReplicatedStorage')
local tweenService = game:GetService('TweenService')
local Players = game:GetService('Players')

local localPlayer = Players.LocalPlayer

local ilegalItemsDetectorDirectory = require(replicatedStorage.Directory.IlegalItemDetector)

local lib = require(replicatedStorage:WaitForChild('lib'))
local charUtil = lib.FunctionUtils.Character
local t = lib.FunctionUtils.t
local replicableInstance = require(replicatedStorage.Modules.Shared.Classes.ReplicableInstance)

local inventorySharedUtil = require(replicatedStorage.Modules.Shared.Utils.InventoryUtilShared)

local module = setmetatable({}, replicableInstance)
module.__index = module

export type ClassType = typeof(setmetatable(
	{} :: {
		Model: typeof(ilegalItemsDetectorDirectory.directoryFolder['00 | Template'].Model),
		isActivated: boolean,
		CFrame: CFrame,
		DetectionArea: Part,
		AlertLights: {Part},

		AlertLevel: number, -- 0..3
		PlayerAlerting: boolean,
		AlertClientThread: thread?,

		LastBlinkedLight: number,
	},
	module
	)) & lib.ReplicableInstance & ilegalItemsDetectorDirectory.Type

local alertingSettings = {
	[0] = {
		LightColor = Color3.fromRGB(85, 255, 255),
	},
	[1] = {
		TimeDuration = 6,
		LightColor1 = Color3.new(1, 0, 0.0156863),
		LightColor2 = Color3.new(0.388235, 0, 0.00784314),
	},
	[2] = {
		TimeDuration = 10,
		LightColor1 = Color3.new(1, 0, 0.0156863),
		LightColor2 = Color3.new(0.388235, 0, 0.00784314),
	},
	[3] = {
		TimeDuration = 15,
		LightColor1 = Color3.new(1, 1, 1),
		LightColor2 = Color3.new(0, 0, 0),
	},
}

local function clampLevel(n: number): number
	return math.clamp(n, 0, 3)
end

local function countSet(setTbl: {[number]: boolean}): number
	local n = 0
	for _ in setTbl do n += 1 end
	return n
end

function module.new(UID: string): ClassType
	local self: ClassType = setmetatable(replicableInstance.new(UID) :: lib.ReplicableInstance, module)
	self._Type = 'Item'
	self.AlertLights = {}
	self.AlertLevel = 0
	self.LastBlinkedLight = 1
	self.PlayerAlerting = nil
	return self
end

function module.AttachIlegalItemDetector(self: ClassType, itemId: number)
	local itemInfo = ilegalItemsDetectorDirectory:getItemInfo(itemId)
	if not itemInfo then return self end
	for k, v in itemInfo do
		self[k] = v
	end
	return self
end

function module.Materialize(self: ClassType, CF: CFrame)
	if not t.CFrame(CF) then return self end
	self.CFrame = CF

	self.Model = ilegalItemsDetectorDirectory:getItemModel(self.Id):Clone()
	self.Model:PivotTo(self.CFrame)
	self.Model.Name = self.UID
	self.Model.Parent = workspace

	self.DetectionArea = self.Model.DetectionArea
	self.DetectionArea.CFrame = CF

	self.AlertLights = {}
	for _, part in self.Model:GetDescendants() do
		if part.Name == 'AlertLight' and part:IsA('BasePart') then
			table.insert(self.AlertLights, part)
		end
	end
	return self
end

-- anima um passo de cor (pisca)
function module.ChangeLightsColor(self: ClassType, level: number?)
	task.spawn(function()
		self.LastBlinkedLight = (self.LastBlinkedLight == 2) and 1 or 2
		local lvl = level or self.AlertLevel
		local cfg = alertingSettings[lvl]
		if not cfg then return end

		local colorName = lvl == 0 and 'LightColor' or 'LightColor' .. self.LastBlinkedLight
		local color = cfg[colorName] or cfg.LightColor

		for _, part: Part in self.AlertLights do
			part.Color = color
			local pointLight = part:FindFirstChild('PointLight') :: PointLight?
			if pointLight then
				pointLight.Color = color
				if lvl == 0 then
					pointLight.Brightness = 0.5
					pointLight.Range = 6
				else
					pointLight.Brightness = 1.5
					pointLight.Range = 10
				end
			end
		end
	end)
	return self
end

-- aplica nível e controla o loop de pisca
function module.SetLevel(self: ClassType, newLevel: number)
	newLevel = clampLevel(newLevel)
	if newLevel == self.AlertLevel then
		return self
	end
	self.AlertLevel = newLevel
	self:ChangeLightsColor(newLevel)
	
	if newLevel == 0 then
		return self
	end

	task.spawn(function()
		local thisLevel = newLevel
		while task.wait(0.1) and self.AlertLevel == thisLevel do
			self:ChangeLightsColor(self.AlertLevel)
		end
	end)

	return self
end

-- entrada local (quando o próprio jogador toca e tem item ilegal)
function module.Alert(self: ClassType, level: number?)
	level = level or self.AlertLevel
	self:SetLevel(level)

	-- agenda a remoção local após o tempo do nível atual
	local duration = alertingSettings[level] and alertingSettings[level].TimeDuration or 0
	
	if self.AlertClientThread and self.AlertClientThread ~= coroutine.running() then
		task.cancel(self.AlertClientThread)
		self.AlertClientThread = nil
	end
	if duration > 0 then
		self.AlertClientThread = task.delay(duration, function()
			if self.PlayerAlerting then
				print(self.PlayerAlerting)
				self.PlayerAlerting = nil
				print(self.PlayerAlerting)
				local newLevel = self.AlertLevel - 1
				self:SetLevel(newLevel) -- se zerar, para de piscar
			end
		end)
	end

	return self
end

function module.PlayerTriggered(self: ClassType)
	if self.PlayerAlerting then return end
	self.PlayerAlerting = true
	

	self:SetLevel(clampLevel(self.AlertLevel + 1))
	self:Alert()
	
	return self
end


function module.Active(self: ClassType)
	if self.isActivated then return self end
	self.isActivated = true

	self.Trove:Add(self.DetectionArea.Touched:Connect(function(who: Instance)
		local plr = charUtil.getPlayerFromCharacter(who)
		if plr and plr == localPlayer then
			if inventorySharedUtil.isThereAnIlegalItemOnInventory(inventorySharedUtil.getPlayerInventory(plr)) then
				self:PlayerTriggered(plr) -- cliente anima e debouncia localmente
			end
		end
	end))

	return self
end

return module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">22ef1a1bb98897c308be5c6800007381</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXBBDFC6E6058F4CDBA400BFC2C0C924C4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">Utils</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">6e87ccb51f069bf408b38bfe0000221c</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC7668A777D984977A25D405A11EAAE1F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlayerData</string>
						<string name="ScriptGuid">{2343C922-2613-4162-AFF7-D7AE3A070647}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local lib = require(ReplicatedStorage.lib)
local Signal = lib.ModuleUtils.Signal

local module = {}
module.Data = nil
module.NewDataReceived = Signal.new()
module.DataUpdated = Signal.new()

function module.GetData()
	local data = module.Data
	if data then
		return data
	end

	while not data do
		task.wait(0.5)
	end

	return data
end

return module
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">3b4d352275f2c90608b5fa790000201d</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX1399E9D0D7304A4BB2A3C9857631CFFE">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Shared</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">6e87ccb51f069bf408b38bfe0000117f</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBXE66688D6615842058FD3F7A9EC7DFD0E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GameSettings</string>
						<string name="ScriptGuid">{BB875659-3649-4226-917E-1FCF27F6BF35}</string>
						<ProtectedString name="Source"><![CDATA[return {
	MaxDistanceToGetAnItem = 8,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">733767970d0729a40891224300015cf6</UniqueId>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXE272D262C11F4174B9002C793C4C3C06">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">Services</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">44cf0ce48b76346f08b4b31f000013c4</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBXE1832C5786EC47DE99914E746CAE5161">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ReplicableInstancesHandler</string>
							<string name="ScriptGuid">{D9B8089A-517C-4371-B597-65C363D4AEB6}</string>
							<ProtectedString name="Source"><![CDATA[local replicatedStorage = game:GetService('ReplicatedStorage')
local runService = game:GetService('RunService')
local ReplicasFolder = replicatedStorage:WaitForChild('Modules'):WaitForChild('Client'):WaitForChild('Replicas')

local lib = require(replicatedStorage:WaitForChild('lib'))
local trove = lib.ModuleUtils.Trove
local remotesList = lib.Remotes
local instancesManager = require(replicatedStorage.Modules.Shared.Managers.InstancesManager)

local instanceCreatedEventList = remotesList.instanceCreated

local module = {}

function module.Init()
	module.Remote = remotesList.UpdateObj
	module.Trove = trove.new()
end

function module.Start()
	local modules = {}
	
	if runService:IsServer() then
		local funcAllowedToCall = require(game:GetService('ServerStorage').Modules.Configurations.FunctionsAllowedToSendToServer)
		module.Remote.OnServerEvent:Connect(function(plr, uid, funcName, args: {any})
			local obj = instancesManager.getObj(uid)
			if not obj then return end
			if funcAllowedToCall[obj._Type][funcName] then
				if not obj then return end
				obj[funcName](obj, plr, table.unpack(args or {}))
			end
		end)
		
		module.Trove:Add(remotesList.PlayerLoaded.OnServerEvent:Connect(function(plr)
			for _, obj in instancesManager.objsCreated.ToReplicate do
				task.spawn(obj.ReplicateTo, obj, plr)
			end
		end))
	else
		for name, remote in instanceCreatedEventList do
			local moduleName = name .. 'Replica'
			local moduleScript = ReplicasFolder:FindFirstChild(moduleName)
			if moduleScript then
				modules[name] = require(moduleScript)
			end
			
			remote.OnClientEvent:Connect(function(UID: string, ...)
				print(name)
				if instancesManager.getObj(UID) then return end
				modules[name].new(UID, ...)
				--return true
			end)
		end
		
		module.Trove:Add(module.Remote.OnClientEvent:Connect(function(uid, funcName, args: {any})
			local obj = instancesManager.getObj(uid)
			if not obj then return end
			obj[funcName](obj, table.unpack(args or {}))
		end))
	end
end

return module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6988f3395311923d08a2367700000a2e</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXC7E0727345E64F35A87204CD9BB3ED31">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">Classes</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">3b4d352275f2c90608b5fa7900001190</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX74ADD006FB0A466DBDE773ED71AD8AB9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ChestClasse</string>
							<string name="ScriptGuid">{AAED6D1E-D8C1-4235-8EC7-8DB190B54A5A}</string>
							<ProtectedString name="Source"><![CDATA[local replicatedStorage = game:GetService("ReplicatedStorage")
local _runService = game:GetService("RunService") -- unused currently

local sharedModules = replicatedStorage.Modules.Shared

local lib = require(replicatedStorage.lib)
local t = lib.FunctionUtils.t
local replicableInstance = require(sharedModules.Classes.ReplicableInstance)
local instancesManager = require(sharedModules.Managers.InstancesManager)
local _charUtils = lib.FunctionUtils.Character -- unused currently

local directoryFolder = replicatedStorage.Directory

local chestDirectory = require(directoryFolder.Chests)

local module = setmetatable({}, { __index = replicableInstance }) --:: & replicableInstance.ClassType

local Storages = {
	DeskContents = {
		Name = "DeskContents",
		MaxAmountOfItems = 12,
	},
	HiddenContents = {
		Name = "HiddenContents",
		MaxAmountOfItems = 6,
	},
}

export type Storages = "DeskContents" | "HiddenContents"

export type ChestItems = {
	DeskContents: { string },
	HiddenContents: { string },
}

export type ClassType = typeof(setmetatable(
	{} :: {
		CFrame: CFrame,
		PlayerOwner: Player?,
		ItemsInside: ChestItems,
	},
	{ __index = module }
)) & replicableInstance.ClassType & chestDirectory.Type

function module.new(id: string | number?): ClassType
	local self = replicableInstance.newLinkedToAClass(module, replicableInstance) :: ClassType
	self._Type = "Chest"
	self.ItemsInside = {
		DeskContents = {},
		HiddenContents = {},
	}

	if id then
		self:AttachId(id)
	end
	return self
end

function module.Materialize(self: ClassType, CF: CFrame)
	if not t.CFrame(CF) then
		return self
	end
	CF = lib.Utils.GetLegalCFrame(CF)
	self.CFrame = CF

	return self
end

function module.getNextFreeSlot(self: ClassType, contentName: Storages)
	if not contentName then
		return
	end
	local items: ChestItems = self.ItemsInside
	local chestStorage = items[contentName]
	local maxNOfItems = Storages[contentName].MaxAmountOfItems
	if maxNOfItems <= #chestStorage then
		return self
	end

	print(#chestStorage)
	for i = 1, maxNOfItems do
		local uid = chestStorage[i]
		if not uid then
			return i
		end
	end

	return self
end

function module.AddItem(self: ClassType, itemUID: string, contentName: Storages)
	if not itemUID then
		return self
	end
	local item = instancesManager.getObj(itemUID)
	if not item then
		return self
	end
	contentName = contentName or "DeskContents"

	local items: ChestItems = self.ItemsInside
	local contentTab = items[contentName]
	if table.find(contentTab, itemUID) then
		return self
	end

	local pos = self:getNextFreeSlot(contentName)
	if pos then
		contentTab[pos] = itemUID
		item:InstantiateTo(self.UID, contentName)
	end

	return self
end

function module.RemoveItem(self: ClassType, itemUID: string, contentName: Storages?)
	print("REMOVE")
	print(itemUID)
	print(self.ItemsInside)

	if contentName then
		local items: ChestItems = self.ItemsInside
		local chestStorage = items[contentName]
		local pos = table.find(chestStorage, itemUID)
		if pos then
			chestStorage[pos] = nil
		end
	else
		print()
		local items: ChestItems = self.ItemsInside
		for _, storage in items do
			local pos = table.find(storage, itemUID)
			print(storage)
			print(pos)
			if pos then
				print(storage[pos])
				storage[pos] = nil
				return self
			end
		end
	end
	print(self.ItemsInside)

	return self
end

function module.UpdatePlayerSearching(_self: ClassType, _plr: Player)
	--SERVER ONLY
end

function module.playerBeganHoldingProximityPrompt(_self: ClassType, _plr: Player)
	--SERVER ONLY
end

function module.updatePlayerItensInside(self: ClassType, plr: Player, nothing: boolean?)
	if nothing then
		self.Remote:FireClient(plr, self.UID, "UpdateItemsInside", { { DeskContents = {}, HiddenContents = {} } })
	else
		print(self.PlayerOwner)
		local tabToSend = {}
		local items: ChestItems = self.ItemsInside
		for contentName, contentTab in items do
			local owner = self.PlayerOwner :: Player?
			if owner and owner ~= plr and contentName == "HiddenContents" then
				continue
			end
			tabToSend[contentName] = {}
			for _, itemUID in contentTab do
				table.insert(tabToSend[contentName], itemUID)
				local item = instancesManager.getObj(itemUID)
				if item then
					item:Replicate(true)
				end
			end
		end
		print(tabToSend)
		self.Remote:FireClient(plr, self.UID, "UpdateItemsInside", { tabToSend })
	end
	return self
end

function module.SetOwner(self: ClassType, plr: Player?)
	if not t.Player(plr) then
		return self
	end

	self.PlayerOwner = plr
	return self
end

return module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">22ef1a1bb98897c308be5c6800000dec</UniqueId>
						</Properties>
					</Item>
					<Item class="Script" referent="RBXD0B0460C9193442789F7CBD03A2A6DBE">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Disabled">true</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TODO</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{C579E69F-A426-46ED-B9A2-6BC159C98B89}</string>
							<ProtectedString name="Source">--TODO</ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">22ef1a1bb98897c308be5c6800000df0</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX3D0C331FEBD9485181384A5169875D54">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ReplicableInstance</string>
							<string name="ScriptGuid">{73B886BF-D2E5-462F-803C-93F9C938BA2B}</string>
							<ProtectedString name="Source"><![CDATA[local replicatedStorage = game:GetService("ReplicatedStorage")

local lib = require(replicatedStorage.lib)
local packet = lib.ModuleUtils.Packet
local trove = lib.ModuleUtils.Trove
local getLegalUID = lib.Utils.GetLegalUID
local t = lib.FunctionUtils.t
local remotes = lib.Remotes

local sharedModules = replicatedStorage.Modules.Shared
local instancesManager = require(sharedModules.Managers.InstancesManager)

local module = setmetatable({}, { __index = instancesManager })

export type genericObjType = instancesManager.genericObjType

export type ClassType = typeof(setmetatable(
	{} :: {
		Remote: typeof(packet("")),
		Trove: typeof(trove.new()),
	},
	{ __index = module }
)) & genericObjType

function module.new(UID: string?): ClassType
	local self = setmetatable({
		UID = UID or getLegalUID(),
		Trove = trove.new(),
		Remote = remotes.UpdateObj,
	}, { __index = module }) :: ClassType

	instancesManager.addObj(self)
	return self
end

function module.newLinkedToAClass<T, T2>(
	realClassModule: { [string]: any },
	sharedClassModule: { [string]: any },
	UID: string?
): ClassType
	local self = setmetatable(sharedClassModule.new(UID), {
		__index = function(_, k)
			local func2 = rawget(realClassModule, k)
			if typeof(func2) == "function" then
				return function(...)
					local func1 = sharedClassModule[k]
					if func1 then
						func1(...)
					end

					func2(...)
				end
			else
				return func2
			end
		end,
	})

	return self
end

function module.Replicate<T>(self: T & ClassType, replicate: boolean?)
	self:Replicate(replicate)
	return self
end

function module.AttachId<T>(self: T & ClassType, id: number)
	local directory = require(replicatedStorage.Directory[self._Type .. "s"])
	local info = directory:getItemInfo(id)

	for k, v in info do
		(self :: any)[k] = v
	end
	return self
end

function module.Materialize<T>(self: T & ClassType, CF: CFrame?)
	local directory = require(replicatedStorage.Directory[self._Type .. "s"])
	local model = directory:getItemModel(self.Id):Clone()

	self.Model = model

	if not CF or not t.CFrame(CF) then
		return self
	end
	if self.Model then
		self.CFrame = lib.Utils.GetLegalCFrame(CF)
		self.Model.CFrame = self.CFrame
	end

	return self
end

return module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400000e1c</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXB2D8F0B76E794D3885C22CFC1E2E949F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">Utils</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">3b4d352275f2c90608b5fa7900001194</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX6A2ABC1A633B48679D6C9E39D37E5B5E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">InventoryUtilShared</string>
							<string name="ScriptGuid">{0EB2FB71-AE2C-4C6F-B6EA-1F1D375D2335}</string>
							<ProtectedString name="Source"><![CDATA[local replicatedStorage = game:GetService("ReplicatedStorage")
local runService = game:GetService("RunService")
local playersService = game:GetService('Players')
local lib = require(replicatedStorage.lib)
local t = lib.FunctionUtils.t
local instancesManager = require(replicatedStorage.Modules.Shared.Managers.InstancesManager)

local charUtil = lib.FunctionUtils.Character

local gameSettings = require(replicatedStorage.Modules.Shared.GameSettings)

local module = {}
module.checks = {}

local maxItensOnInventory = 6

local function getPlayer(plr: Player?)
	if t.Instance(plr) and plr:IsA('Player') then
		return plr
	else
		if runService:IsServer() then
			warn('Player is not defined')
			return
		end
		return playersService.LocalPlayer
	end
end

function module.getPlayerInventory(plr:Player?)
	plr = getPlayer(plr)
	if not plr then return end
	if runService:IsServer() then
		return require(game.ServerStorage.Modules.Managers.PlayerDataManager).getProfileData(plr).inventory
	end
	return require(game:GetService('ReplicatedStorage').Modules.Client.PlayerData).GetData().inventory
end

function module.checks.findItemInInventory(inv: {any}, itemUID: string)
	if not itemUID then return end
	if not inv then return end
	
	for k, v in inv do
		if v.UID == itemUID then
			return k
		end
	end
	return nil
end

function module.checks.hasSpaceOnInventory(inv: {any})
	if not inv or type(inv) ~= 'table' then return end
	local t = 0
	for k, v in inv do
		t += 1
	end
	return t < 6
end

function module.checks.isSlotFree(inv: {any}, slot: number)
	if not inv or type(inv) ~= 'table' or type(slot) ~= 'number' then return end
	return not inv[slot]
end

function module.checks.isOnRange(itemUID: string, plr: Player)
	plr = getPlayer(plr)
	if not itemUID or not plr then return end
	local item = instancesManager.getObj(itemUID)
	if not item then return end
	
	local itemInstantiatedTo = item.InstantiatedTo
	local pos
	if type(itemInstantiatedTo) == 'string' then
		if itemInstantiatedTo == '' then
			pos = item.Position
		else
			local chest = instancesManager.getObj(itemInstantiatedTo)
			if chest then
				pos = chest.PrimaryPart.Position
			end
		end
	end
	
	local hrp = charUtil.getAlivePlayerRootPart(plr)
	
	if hrp and pos and (hrp.Position - pos).Magnitude <= gameSettings.MaxDistanceToGetAnItem then
		return true
	end
end

function module.checks.isOnRay()
	-- TODO Raycast to the item/chest
end

function module.getNextSlotForANewItem(inv: {any})
	if not inv or type(inv) ~= 'table' then return end
	if not module.checks.hasSpaceOnInventory(inv) then return end
	for i = 2, maxItensOnInventory do
		if module.checks.isSlotFree(inv, i) then
			return i
		end
	end
	if module.checks.isSlotFree(inv, 1) then return 1 end
end

function module.canAddItem(inv: {any}, itemUID: string)
	if not itemUID then return end
	if not inv or type(inv) ~= 'table' then return end
	if not module.getNextSlotForANewItem(inv) then return end

	local item = instancesManager.getObj(itemUID)
	if not item then return end

	if type(item.InstantiatedTo) ~= 'string' then return end
	if module.checks.findItemInInventory(inv, itemUID) then return end

	return true
end

function module.canRemoveItem(inv: {any}, itemUID: string)
	if type(inv) ~= 'table' or not itemUID then return end
	local item = instancesManager.getObj(itemUID)
	if not item then return end
end

function module.equipItem(itemUID: string, plr: Player?)

end

function module.unequipItem(itemUID: string, plr: Player?)


end

function module.isThereAnIlegalItemOnInventory(inv: {any})
	if type(inv) ~= 'table' then return end
	for i, uid in inv do
		local item = instancesManager.getObj(uid)
		if not item then continue end
		if item._Type ~= 'Item' then return end
		if not item.Legal then return true end
	end
	return false
end

function module.toggleEquip(inv: {any}, pos1: number, pos2: number)
	if not pos1 then return end
	if not pos2 then pos2 = 1 end
	
	inv[pos2], inv[pos1] = inv[pos1], inv[pos2]
	
	if inv[1] == inv[pos1] then
		inv[pos2].UnequipItem()
		inv[pos1].EquipItem()
	end
	if inv[1] == inv[pos2] then
		inv[pos1].UnequipItem()
		inv[pos2].EquipItem()
	end
end

function module.addItemToInventory(itemUID: string, inv: {any}, pos: number?)
	if not module.canAddItem(inv, itemUID) then return end
	local item = instancesManager.getObj(itemUID)
	if not item then return end
	
	local pos = pos or module.getNextSlotForANewItem(inv)
	if not pos then return end
	print('add', inv, pos, itemUID)
	inv[pos] = itemUID 
end

function module.removeItem(inv: {any}, itemUID: string)
	if not itemUID and not inv then return end
	if not module.canRemoveItem(inv, itemUID) then return end
	
	for i, UID in inv do
		if UID == itemUID then
			inv[i] = nil
			return
		end
	end
end


return module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6e87ccb51f069bf408b38bfe00002219</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX6EA7BDF5C34F41CA80BDD8693703EEB1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">Managers</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">6f0f77140b30bd3208c3a7500000118c</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX5BAD80F8F5BB489A9383DBE46E9B00CD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">InstancesManager</string>
							<string name="ScriptGuid">{5DE96F31-A149-402A-993D-9B4852FF9E4A}</string>
							<ProtectedString name="Source"><![CDATA[export type genericObjType = {
	_Type: string,
	UID: string,
} & { [string]: any }

local module = {}
module.objsCreated = {
	ToReplicate = {} :: { [string]: { genericObjType } },
	NotToReplicate = {} :: { [string]: { genericObjType } },
}

function module.Replicate(self: genericObjType, replicate: boolean?)
	local UID = self.UID
	local notToReplicateTab = module.objsCreated.NotToReplicate
	local toReplicateTab = module.objsCreated.ToReplicate

	if replicate or notToReplicateTab[UID] then
		notToReplicateTab[UID] = nil
		toReplicateTab[UID] = self
		self:ReplicateTo()
	else
		toReplicateTab[UID] = nil
		notToReplicateTab[UID] = self
	end

	return self
end

function module.addObj(self: genericObjType, replicate: boolean?)
	module.Replicate(self, replicate)
end

function module.removeObj(UID: string)
	local obj = module.getObj(UID)
	if obj then
		obj:Destroy()
		module.objsCreated[UID] = nil
	end
end

function module.getObj(UID: string)
	return module.objsCreated.ToReplicate[UID] or module.objsCreated.NotToReplicate[UID]
end

return module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6f0f77140b30bd3208c3a7500000118d</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXEC02637C651C494C8B6119CF3F65ACCE">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Directory</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">1103f67fa8a2bc43089174340000652d</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBX48CA64C5D0EA4B18B4D450CA2986540D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Chests</string>
					<string name="ScriptGuid">{9B06A382-FE38-4E31-9FDE-F2725677EC80}</string>
					<ProtectedString name="Source"><![CDATA[local template = script:FindFirstChild("00 _ Template")
assert(template, "Template module not found in directory")
export type Type = typeof(template)

local DirUtil = require(script.Parent:WaitForChild("Utils"):WaitForChild("Directory"))
return DirUtil.newDirectory(script) :: DirUtil.ClassType<typeof(template)>
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">0b3605faaf024e0308a299e300001b3e</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX5A3732FD80054F21A3418A670A2FCE5B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">01 _ chestA</string>
						<string name="ScriptGuid">{FCCF75F4-0729-486A-A1FA-DE33365EEB2B}</string>
						<ProtectedString name="Source"><![CDATA[return {
	
	Name = script.Name:match("| (.*)"), 
	Id = tonumber(script.Name:match("^(.-) |")),
	CanSpawnItems = true,
	CanSpawnIlegalItems = true,
	MaxDistanceToInteract = 8,
	OpenTime = 1,
	
}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b26</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD9A1642A545D437A8BA3BACBEF5F4405">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">00 _ Template</string>
						<string name="ScriptGuid">{666FBD3E-5159-42C2-A3D2-52F53A337A85}</string>
						<ProtectedString name="Source"><![CDATA[return {

	Name = script.Name:match("| (.*)"), 
	Id = tonumber(script.Name:match("^(.-) |")),
	CanSpawnItems = true,
	CanSpawnIlegalItems = true,
	MaxDistanceToInteract = 6,
	OpenTime = 4,

}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b47</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX8AFC66F061724B67B61E7CC9FF9558B0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SecurityCameras</string>
					<string name="ScriptGuid">{BDF08DDC-B460-4548-A7D5-AB4686AD6C28}</string>
					<ProtectedString name="Source"><![CDATA[local template = script:FindFirstChild("00 _ Template")
assert(template, "Template module not found in directory")
export type Type = typeof(template)

local DirUtil = require(script.Parent:WaitForChild("Utils"):WaitForChild("Directory"))
return DirUtil.newDirectory(script) :: DirUtil.ClassType<typeof(template)>
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1103f67fa8a2bc43089174340000cb7c</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX72EC68AE4D5249AEA88DBE3A7AF82474">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">00 _ Template</string>
						<string name="ScriptGuid">{12B24CC8-261F-4CE4-A32E-B894A179EC54}</string>
						<ProtectedString name="Source"><![CDATA[return {
	RotationDelay = 2,
	RotationAngle = 15,
	Fov = 60,
	MaxDistance = 40,	
}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b42</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXEF40015ECCCB4004992C744A6CBE915D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">01 _ DefaultCamera</string>
						<string name="ScriptGuid">{E84E6D41-1E49-4B5E-98A5-7FEFEF13CF32}</string>
						<ProtectedString name="Source"><![CDATA[return {
	RotationDelay = 2,
	RotationAngle = 15,
	Fov = 60,
	MaxDistance = 40,	
}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b6e</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX4A865D28ACFE4E348E6235E2145056E7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Items</string>
					<string name="ScriptGuid">{34DB3BB3-11E0-4579-8F9D-1EB340D5E372}</string>
					<ProtectedString name="Source"><![CDATA[export type AttackInfoPreset = {
	Value: number,
	Name: string,
}

local template = script:FindFirstChild("00 _ Template")
assert(template, "Template module not found in directory")
export type Type = typeof(template)

local DirUtil = require(script.Parent:WaitForChild("Utils"):WaitForChild("Directory"))
return DirUtil.newDirectory(script) :: DirUtil.ClassType<typeof(template)>
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">4312145b2bb60a89089d391400001bfd</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBXB63481C13C234A0AB50CAADE233F687F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">00 _ Template</string>
						<string name="ScriptGuid">{3EA0E9CB-A3CA-4550-9328-FE4A187DAD7A}</string>
						<ProtectedString name="Source"><![CDATA[local module = {
	
	Name = script.Name:match("| (.*)"), 
	Id = tonumber(script.Name:match("^(.-) |")),
	Legal = true,
	MetalDetectorCanDetect = true,
	CanSpawnInChests = true,

	AttackInfos = {
		Speed = {
			Value = 1,
			Name = 'Low'
		},
		Damage = {
			Value = 2,
			Name = 'Medium'
		},
		Range = {
			Value = 3,
			Name = 'High'
		}
	}
}

return module
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b82</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5661C16EE1664BF9A051B3BFC765F38B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">02 _ Tape</string>
						<string name="ScriptGuid">{98003BAC-2130-4EE8-BF9B-D6ABA2372DE2}</string>
						<ProtectedString name="Source"><![CDATA[local module = {
	
	Name = script.Name:match("| (.*)"), 
	Id = tonumber(script.Name:match("^(.-) |")),
	Legal = true,
	MetalDetectorCanDetect = true,
	CanSpawnInChests = true,
	
	AttackInfos = {
		Speed = {
			Value = 0,
			Name = '-'
		},
		Damage = {
			Value = 0,
			Name = '-'
		},
		Range = {
			Value = 0,
			Name = '-'
		}
	}
	
}

return module
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b8f</UniqueId>
					</Properties>
					<Item class="Folder" referent="RBX6875FCD42BDD45E687F771DF8212C737">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">Folder</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e000040fe</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX626FA8522996411FBD6D515DF1AB55D6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">01 _ itemA</string>
						<string name="ScriptGuid">{F3E9B21E-9DAF-405E-946B-CC0C555EA072}</string>
						<ProtectedString name="Source"><![CDATA[local module = {
	
	Name = script.Name:match("| (.*)"), 
	Id = tonumber(script.Name:match("^(.-) |")),
	Legal = false,
	MetalDetectorCanDetect = true,
	CanSpawnInChests = true,
	
	AttackInfos = {
		Speed = {
			Value = 1,
			Name = 'Low'
		},
		Damage = {
			Value = 2,
			Name = 'Medium'
		},
		Range = {
			Value = 3,
			Name = 'High'
		}
	}
	
}

return module
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b92</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX3E35659B542649B28BE7B62EC9989520">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Utils</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">0b3605faaf024e0308a299e300001b44</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX362F610B40C44DD093027C57CC52CA25">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Directory</string>
						<string name="ScriptGuid">{64A81AA9-AF90-4586-921C-B4CF8FF573ED}</string>
						<ProtectedString name="Source"><![CDATA[local module = {}

local MT = {}
MT.__index = MT

type anytype = string & number & { [string]: any } & ModuleScript

export type ClassType<ModuleScriptDirectory = typeof(script.Parent.Parent.Template)> = typeof(setmetatable(
	{} :: {
		directoryFolder: ModuleScriptDirectory & ModuleScript,
	},
	MT
))

function module.newDirectory<ModuleScriptDirectory>(directoryFolder: ModuleScriptDirectory & Instance): ClassType<ModuleScriptDirectory>?
	if not directoryFolder or not directoryFolder:IsA("ModuleScript") then
		return nil
	end
	local self = setmetatable({
		directoryFolder = directoryFolder :: typeof(directoryFolder),
	}, MT) :: ClassType<ModuleScriptDirectory>
	return self
end

function MT:getItemInfo(itemId: anytype)
	local itemType = typeof(itemId)
	if itemType == "string" or itemType == "number" then
		for _, Name in self.directoryFolder:GetChildren() do
			if tonumber(itemId) == tonumber(Name.Name:match("^(.-) _ ")) then
				return require(Name)
			end
		end
	elseif itemType == "Instance" and itemId:IsA("ModuleScript") then
		return require(itemId)
	end

	return itemId
end

function MT.getItemModule(self: ClassType, item: anytype) --: typeof(self.directoryFolder["00 | Template"])
	local itemtype = type(item)
	if itemtype == "table" then
		return self.directoryFolder:FindFirstChild(string.format("%02d", item.Id) .. " | " .. item.Name)
	elseif itemtype == "number" or itemtype == "string" then
		local childs = self.directoryFolder:GetChildren()
		for _, value in childs do
			local keyId = tonumber(value.Name:match("^(%d+)%s*_"))
			if keyId == tonumber(item) then
				return value
			end
		end
	end

	return item --:: typeof(self.directoryFolder["00 | Template"])
end

function MT.getRandomItemModule<ModuleScriptDirectory>(self: ClassType<ModuleScriptDirectory>): ModuleScript
	local items = self.directoryFolder:GetChildren()
	local randomItem = items[math.random(1, #items)]
	return randomItem
end

function MT.getRandomItemId(self: ClassType): number
	return require(self:getRandomItemModule()).Id
end

function MT.getItemModel(self: ClassType, item: anytype): PVInstance
	local itemModule = self:getItemModule(item)
	return itemModule:FindFirstChild("Model") --:: typeof(self.directoryFolder["00 | Template"].Model)
end

function MT.getItemDisplay(self: ClassType, item: anytype): Frame
	local itemModule = self:getItemModule(item)
	return itemModule:FindFirstChild("Display") --:: typeof(self.directoryFolder["00 | Template"].Display)
end

--local Items = directorysFolder:WaitForChild('Items')
--local Chests = directorysFolder:WaitForChild('Chests')
--local SecurityCameras = directorysFolder:WaitForChild('SecurityCameras')
--local Crafts = directorysFolder:WaitForChild('Crafts')

return {
	--Items = module.newDirectory(Items),
	--Chests = module.newDirectory(Chests),
	--SecurityCameras = module.newDirectory(SecurityCameras),
	--Crafts = module.newDirectory(Crafts),
	newDirectory = module.newDirectory,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">6988f3395311923d08a2367700000bab</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXB8493B8ADD5D44DF9D91FA543C5624FC">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Crafts</string>
					<string name="ScriptGuid">{CD0E7BA8-5452-4C57-A0EF-DCE111094844}</string>
					<ProtectedString name="Source"><![CDATA[local module = {}

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">0b3605faaf024e0308a299e300001b7d</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXAA60A701E1E740AA9062BF77AE4255C8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Maps</string>
					<string name="ScriptGuid">{D21CBD94-F795-4CD9-B12C-576D155600F4}</string>
					<ProtectedString name="Source"><![CDATA[export type Type = {
	Name: string,
	Id: number,
	Difficult: number, --1 --2 --3
}

local template = script:FindFirstChild("00 _ Template")
assert(template, "Template module not found in directory")
--export type Type = typeof(template)

local DirUtil = require(script.Parent:WaitForChild("Utils"):WaitForChild("Directory"))
return DirUtil.newDirectory(script) :: DirUtil.ClassType<typeof(template)>
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">202599fc2afe428b08a77683000013ef</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX47EDDF4615A54418ACFF52D6CB576144">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">IlegalItemDetector</string>
					<string name="ScriptGuid">{DBAF3735-39EB-4B5E-B3A6-36BD15705A51}</string>
					<ProtectedString name="Source"><![CDATA[local template = script:FindFirstChild("00 _ Template")
assert(template, "Template module not found in directory")
export type Type = typeof(template)

local DirUtil = require(script.Parent:WaitForChild("Utils"):WaitForChild("Directory"))
return DirUtil.newDirectory(script) :: DirUtil.ClassType<typeof(template)>
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">22ef1a1bb98897c308be5c6800006901</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX89FDC001839144559FBB054F1138F625">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Template</string>
					<string name="ScriptGuid">{C7A6FFA7-02FA-46D9-A7A1-5881C1D21706}</string>
					<ProtectedString name="Source"><![CDATA[local template = script:FindFirstChild("00 _ Template")
assert(template, "Template module not found in directory")
export type Type = typeof(template)

local DirUtil = require(script.Parent:WaitForChild("Utils"):WaitForChild("Directory"))
return DirUtil.newDirectory(script) :: DirUtil.ClassType<typeof(template)>
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">22ef1a1bb98897c308be5c6800007282</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX2E2D74814BA146F9A4CCFDA2B9A67F23">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">00 _ Template</string>
						<string name="ScriptGuid">{5EF9E040-17AF-48DE-9657-7034CD6B7F21}</string>
						<ProtectedString name="Source"><![CDATA[local module = {
	
	Name = script.Name:match("| (.*)"), 
	Id = tonumber(script.Name:match("^(.-) |")),
}

return module
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b8b</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="RemoteEvent" referent="RBX903F3AE6DDF84F0EB546829C2B248A79">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">RemoteEvent</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">38e5043c158bb8f708cc740e000040fd</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBXBCA2FDF290F9481FBDA7E530A1649010">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">lib</string>
				<string name="ScriptGuid">{65FC3F65-B4E3-4643-A3F9-9981AD2A2775}</string>
				<ProtectedString name="Source"><![CDATA[local lib = require(script.lib)
local types = require(script.Types)
local utils = require(script.Utils)
local remotes = require(script.Remotes)

---------ClientModuleUtils Types ---------------

export type Cinematic = lib.Cinematic
export type CinematicStartArgs = lib.CinematicStartArgs

export type Icon = lib.Icon

export type WrappedGuiButton = lib.WrappedGuiButton

export type WrappedGuiImage = lib.WrappedGuiImage

export type WrappedGuiObject = lib.WrappedGuiObject

export type WrappedGuiStroke = lib.WrappedGuiStroke

export type WrappedTextLabel = lib.WrappedTextLabel

export type WrappedSurfaceGui = lib.WrappedSurfaceGui

export type WrappedBillboardGui = lib.WrappedBillboardGui

export type InterfaceEffect = lib.InterfaceEffect

export type LightningBolt = lib.LightningBolt
export type LightningSparks = lib.LightningSparks
export type LightningExplosion = lib.LightningExplosion

export type ParallaxWindow = lib.ParallaxWindow

export type StreamableType = lib.StreamableType

export type WindLineCreator = lib.WindLineCreator
export type WindLineCreatorParams = lib.WindLineCreatorParams

export type WindShakeSettings = lib.WindShakeSettings

export type GamepadType = lib.GamepadType
export type MouseType = lib.MouseType
export type KeyboardType = lib.KeyboardType
export type TouchType = lib.TouchType

export type screen3D = lib.screen3D
export type screenGen = lib.screenGen
export type component3D = lib.component3D
export type componentGen = lib.componentGen

-------------FunctionUtils Types-----------------

export type Schema = lib.Schema

-------------ModuleUtils Types-------------------

export type Packet<A... = (), B... = ()> = lib.Packet<A..., B...>
export type Lottery = lib.Lottery
export type LotteryTicket = lib.LotteryTicket

export type LessSimpleZone<U, T...> = lib.LessSimpleZone<U, T...>
export type Zone = lib.Zone

export type ZoneQueryOptions = lib.ZoneQueryOptions
export type ZoneBox = lib.ZoneBox

export type Future<T...> = lib.Future<T...>

export type RateLimiter = lib.RateLimiter

export type PromiseAny = lib.PromiseAny
export type Promise<T...> = lib.Promise<T...>

export type SchedulerType = lib.SchedulerType

-- Func is the function passed to :Once() or :Connect(). ReturnVals is the data returned from :Wait() or passed to :Fire()
-- The args in Func should match ReturnVals!
--export type SignalType<Func, ReturnVals...> = lib.SignalType<Func, ReturnVals...>
-- If you don't want to bother defining argument names:
export type Signal<func, ReturnVals...> = lib.Signal<func, ReturnVals...>
--export type GenericSignal = lib.GenericSignal
--export type SignalConnection = lib.SignalConnection

export type TroveType = lib.TroveType

export type OctreeType = lib.OctreeType
export type OctreeNodeType = lib.OctreeNodeType

export type TimerType = lib.TimerType

export type ShakeType = lib.ShakeType
export type ShakeProperties = lib.ShakeProperties

export type PartCache = lib.PartCache

export type CacheType = lib.CacheType

export type Spring<T> = lib.Spring<T>

export type Proxy<T = { [any]: any }> = lib.Proxy<T>

export type Binder = lib.Binder

export type LoggerType = lib.LoggerType

export type Quaternion = lib.Quaternion
export type QuaternionSpring = lib.QuaternionSpring

-- Typed Remotes & Bindables
export type RemoteEvent<Server..., Client...> = lib.RemoteEvent<Server..., Client...>
export type RemoteFunction<Send..., Receive...> = lib.RemoteFunction<Send..., Receive...>
export type BindableEvent<Send...> = lib.BindableEvent<Send...>
export type BindableFunction<Send..., Receive...> = lib.BindableFunction<Send..., Receive...>

export type AdjustmentPool = lib.AdjustmentPool
export type AcceptedPoolValues = lib.AcceptedPoolValues

export type PredicateManager = lib.PredicateManager
export type CallbackManager = lib.CallbackManager

export type TimeKeeper = lib.TimeKeeper
export type UniversalTimestamp = lib.UniversalTimestamp

export type PathfinderInstance = lib.PathfinderInstance

export type Batcher = lib.Batcher

export type BezierCurve = lib.BezierCurve

export type DataCatalog<T> = lib.DataCatalog<T>

export type RandomRotator = lib.RandomRotator
export type RotationConfig = lib.RotationConfig

export type Respawner = lib.Respawner

export type DynamicOctree = lib.DynamicOctree

-------------Game Utils-------------------

export type ReplicableInstance = utils.ReplicableInstance

-------------Game Types-------------------

local module = {
	ClientModuleUtils = lib.ClientModuleUtils,
	FunctionUtils = lib.FunctionUtils,
	ModuleUtils = lib.ModuleUtils,
	Types = types,
	Utils = utils,
	Remotes = remotes,
}

return module
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">6988f3395311923d08a2367700000b5c</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBXCE740C9DEBA64B2F8A970964E11713A2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Types</string>
					<string name="ScriptGuid">{370055F7-75F7-4966-B194-CB4572844A8C}</string>
					<ProtectedString name="Source"><![CDATA[--[[local replicatedStorage = game:GetService("ReplicatedStorage")

local replicasFolder = replicatedStorage.Modules.Client.Replicas

local itemReplica = require(replicasFolder.ItemReplica)
local chestReplica = require(replicasFolder.ChestReplica)

export type ItemReplicaClassType = itemReplica.ClassType
export type ChestReplicaClassType = chestReplica.ClassType

local a = {} :: itemReplica.ClassType

a:
]]


return {}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">6988f3395311923d08a2367700000b60</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX1CAF045FA0AA42259F98C25251327D0B">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Utils</string>
					<string name="ScriptGuid">{B46773EF-2645-43B0-9C24-457EB9B8F59B}</string>
					<ProtectedString name="Source"><![CDATA[local GetLegalUID = require(script.GetLegalUID)
local TableToRemoteTable = require(script.TableToRemoteTable)
local GetLegalCFrame = require(script.GetLegalCFrame)

export type ReplicableInstance = ReplicableInstance.ClassType

local module = {
	GetLegalUID = GetLegalUID,
	TableToRemoteTable = TableToRemoteTable,
	GetLegalCFrame = GetLegalCFrame,
}

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">6988f3395311923d08a2367700000bb0</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX5C8DCBDF69F74EF7BD46625A5D060274">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GetLegalUID</string>
						<string name="ScriptGuid">{E70ADD2D-51CF-4B3D-85F1-B0EC6FB8CA16}</string>
						<ProtectedString name="Source"><![CDATA[return function() : string
	local httpsService = game:GetService('HttpService')
	local uid = httpsService:GenerateGUID(false)
	return string.gsub(uid, '-', '')
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">206247380e8f98a908a38b670000127c</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX59F01061745349D38B0AF189DE31FABD">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TableToRemoteTable</string>
						<string name="ScriptGuid">{C8DAEB7E-0ED0-4112-86C9-42FB0E38DCB8}</string>
						<ProtectedString name="Source"><![CDATA[local packet = require(game.ReplicatedStorage.lib.lib.ModuleUtils._Packet)

local module = {}
module.remoteTableType = {{Key = packet.String, Value = packet.Any}}

function module.encode(tab: {[string]: any})
	local new = {}

	for k, v in tab do
		new[#new + 1] = {Key = k, Value = v}
	end

	return new
end

function module.decode(tab: {[string]: any})
	local new = {}
	
	for i, v in tab do
		new[v.Key] = v.Value
	end
	
	return new
end

return module
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">58ebb84b280b6e7308ab6b0600001bb9</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB14A0C496B554E6BB072046583D9C4A2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GetLegalCFrame</string>
						<string name="ScriptGuid">{1450C5A6-CCF2-44C1-8FCB-74A819D1F3D3}</string>
						<ProtectedString name="Source"><![CDATA[--!strict

function a(cf: CFrame): CFrame
	local p = cf.Position
	local x = math.floor(p.X/4)*4 + 2
	local y = math.round(p.Y/2)*2
	local z = math.floor(p.Z/4)*4 + 2
	-- Se quiser manter a rotação original, troque para: cf.Rotation * CFrame.new(x, y, z)
	return CFrame.new(x, y, z) * cf.Rotation
end

local a1 = a(workspace.bau3.CFrame)
local a2 = a(a1)
print(a1)
print(a2)

return function(cf: CFrame): CFrame
	local p = cf.Position
	local x = math.floor(p.X/4)*4 + 2
	local y = math.round(p.Y/2)*2
	local z = math.floor(p.Z/4)*4 + 2
	-- Se quiser manter a rotação original, troque para: cf.Rotation * CFrame.new(x, y, z)
	return CFrame.new(x, y, z) * cf.Rotation
end
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">22ef1a1bb98897c308be5c6800006c43</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX05F9EEBA016C4FD5A8CFB04EA80267D9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Remotes</string>
					<string name="ScriptGuid">{CA24A2F1-C661-4251-818F-4642144E822E}</string>
					<ProtectedString name="Source"><![CDATA[local packet = require(game:GetService("ReplicatedStorage").lib.lib.ModuleUtils._Packet)

local module = {
	PlayerLoaded      			 = packet('PlayerLoaded'),
	PlayerDataUpdated			 = packet('PlayerDataUpdated', {{Key = packet.String, Value = packet.Any}}),
	
	instanceCreated = {
		Chest         			 = packet('Chest', packet.String),--:Response(packet.Boolean8),
		Item          			 = packet('Item', packet.String),--:Response(packet.Boolean8),
		SecurityCamera 			 = packet('SecurityCamera', packet.String),--:Response(packet.Boolean8),
		IlegalItemDetector		 = packet('IlegalItemDetector', packet.String),--:Response(packet.Boolean8),
	},
	UpdateObj         			 = packet('UpdateObj', packet.String, packet.String, {packet.Any}),
	
	AddItemToInventory			 = packet('AddItemToInventory', packet.String),
	EquipItem         			 = packet('EquipItem', packet.String)
}

--for _, remote in module.instanceCreated do
--	remote.ResponseTimeout = 2
--	remote.ResponseTimeoutValue = false
--end

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400000e12</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX336E0B0DBB854D768BD389CA18A27A2E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">70ead98c63ba06e0088b89a000006109</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">lib</string>
					<string name="ScriptGuid">{217B4E0F-23F0-433C-A8C8-1A6039D9624D}</string>
					<ProtectedString name="Source"><![CDATA[local ClientModuleUtils = require(script.ClientModuleUtils)
local FunctionUtils = require(script.FunctionUtils)
local ModuleUtils = require(script.ModuleUtils)

---------ClientModuleUtils Types ---------------

export type Cinematic = ClientModuleUtils.Cinematic
export type CinematicStartArgs = ClientModuleUtils.CinematicStartArgs

export type Icon = ClientModuleUtils.Icon

export type WrappedGuiButton = ClientModuleUtils.WrappedGuiButton

export type WrappedGuiImage = ClientModuleUtils.WrappedGuiImage

export type WrappedGuiObject = ClientModuleUtils.WrappedGuiObject

export type WrappedGuiStroke = ClientModuleUtils.WrappedGuiStroke

export type WrappedTextLabel = ClientModuleUtils.WrappedTextLabel

export type WrappedSurfaceGui = ClientModuleUtils.WrappedSurfaceGui

export type WrappedBillboardGui = ClientModuleUtils.WrappedBillboardGui

export type InterfaceEffect = ClientModuleUtils.InterfaceEffect

export type LightningBolt = ClientModuleUtils.LightningBolt
export type LightningSparks = ClientModuleUtils.LightningSparks
export type LightningExplosion = ClientModuleUtils.LightningExplosion

export type ParallaxWindow = ClientModuleUtils.ParallaxWindow

export type StreamableType = ClientModuleUtils.StreamableType

export type WindLineCreator = ClientModuleUtils.WindLineCreator
export type WindLineCreatorParams = ClientModuleUtils.WindLineCreatorParams

export type WindShakeSettings = ClientModuleUtils.WindShakeSettings

export type GamepadType = ClientModuleUtils.GamepadType
export type MouseType = ClientModuleUtils.MouseType
export type KeyboardType = ClientModuleUtils.KeyboardType
export type TouchType = ClientModuleUtils.TouchType

export type screen3D = ClientModuleUtils.screen3D
export type screenGen = ClientModuleUtils.screenGen
export type component3D = ClientModuleUtils.component3D
export type componentGen = ClientModuleUtils.componentGen

-------------FunctionUtils Types-----------------

export type Schema = FunctionUtils.Schema

-------------ModuleUtils Types-------------------

export type Packet<A... = (), B... = ()> = ModuleUtils.Packet<A..., B...>

export type Lottery = ModuleUtils.Lottery
export type LotteryTicket = ModuleUtils.LotteryTicket

export type LessSimpleZone<U, T...> = ModuleUtils.LessSimpleZone<U, T...>
export type Zone = ModuleUtils.Zone

export type ZoneQueryOptions = ModuleUtils.ZoneQueryOptions
export type ZoneBox = ModuleUtils.ZoneBox

export type Future<T...> = ModuleUtils.Future<T...>

export type RateLimiter = ModuleUtils.RateLimiter

export type PromiseAny = ModuleUtils.PromiseAny
export type Promise<T...> = ModuleUtils.Promise<T...>

export type SchedulerType = ModuleUtils.SchedulerType

-- Func is the function passed to :Once() or :Connect(). ReturnVals is the data returned from :Wait() or passed to :Fire()
-- The args in Func should match ReturnVals!
--export type SignalType<Func, ReturnVals...> = ModuleUtils.SignalType<Func, ReturnVals...>
-- If you don't want to bother defining argument names:
export type Signal<Func, ReturnVals...> = ModuleUtils.Signal<Func, ReturnVals...>
--export type GenericSignal = ModuleUtils.GenericSignal
--export type SignalConnection = ModuleUtils.SignalConnection

export type TroveType = ModuleUtils.TroveType

export type OctreeType = ModuleUtils.OctreeType
export type OctreeNodeType = ModuleUtils.OctreeNodeType

export type TimerType = ModuleUtils.TimerType

export type ShakeType = ModuleUtils.ShakeType
export type ShakeProperties = ModuleUtils.ShakeProperties

export type PartCache = ModuleUtils.PartCache

export type CacheType = ModuleUtils.CacheType

-- Importar tipo nlerpable diretamente do Spring
export type Spring<T> = ModuleUtils.Spring<T>

export type Proxy<T = { [any]: any }> = ModuleUtils.Proxy<T>

export type Binder = ModuleUtils.Binder

export type LoggerType = ModuleUtils.LoggerType

export type Quaternion = ModuleUtils.Quaternion
export type QuaternionSpring = ModuleUtils.QuaternionSpring

-- Typed Remotes & Bindables
export type RemoteEvent<Server..., Client...> = ModuleUtils.RemoteEvent<Server..., Client...>
export type RemoteFunction<Send..., Receive...> = ModuleUtils.RemoteFunction<Send..., Receive...>
export type BindableEvent<Send...> = ModuleUtils.BindableEvent<Send...>
export type BindableFunction<Send..., Receive...> = ModuleUtils.BindableFunction<Send..., Receive...>

export type AdjustmentPool = ModuleUtils.AdjustmentPool
export type AcceptedPoolValues = ModuleUtils.AcceptedPoolValues

export type PredicateManager = ModuleUtils.PredicateManager
export type CallbackManager = ModuleUtils.CallbackManager

export type TimeKeeper = ModuleUtils.TimeKeeper
export type UniversalTimestamp = ModuleUtils.UniversalTimestamp

export type PathfinderInstance = ModuleUtils.PathfinderInstance

export type Batcher = ModuleUtils.Batcher

export type BezierCurve = ModuleUtils.BezierCurve

export type DataCatalog<T> = ModuleUtils.DataCatalog<T>

export type RandomRotator = ModuleUtils.RandomRotator
export type RotationConfig = ModuleUtils.RotationConfig

export type Respawner = ModuleUtils.Respawner

export type DynamicOctree = ModuleUtils.DynamicOctree

local module = {
	ClientModuleUtils = ClientModuleUtils,
	FunctionUtils = FunctionUtils,
	ModuleUtils = ModuleUtils,
}

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">103174396272469</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042b2</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBXBFD3FF8FC54648E3AD0DE78AC76C5D05">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009661</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ModuleUtils</string>
						<string name="ScriptGuid">{6BDB5A04-AF4B-4EB8-BB7B-D2FABBF94E15}</string>
						<ProtectedString name="Source"><![CDATA[--!strict
local GlobalTypes = require(script.Parent.GlobalTypes)

local _Promise = require(script._Promise)
local _Scheduler = require(script._Scheduler)
local _Signal = require(script._Signal)
local _Trove = require(script._Trove)
local _Octree = require(script._Octree)
local _Timer = require(script._Timer)
local _Shake = require(script._Shake)
local _FastCastRedux = require(script._FastCastRedux)
local _PartCache = require(script._PartCache)
local _Cache = require(script._Cache)
local _GoodSignal = require(script._GoodSignal)
local _Spring = require(script._Spring)
local _SpringUtils = require(script._SpringUtils)
local _DuckTypeUtils = require(script._DuckTypeUtils)
local _Proxy = require(script._Proxy)
local _Binder = require(script._Binder)
local _Logger = require(script._Logger)
local _Quaternion = require(script._Quaternion)
local _QuaternionSpring = require(script._QuaternionSpring)
local _TypedBindable = require(script._TypedBindable)
local _TypedRemote = require(script._TypedRemote)
local _AdjustmentPool = require(script._AdjustmentPool)
local _PredicateManager = require(script._PredicateManager)
local _TimeKeeper = require(script._TimeKeeper)
local _CallbackManager = require(script._CallbackManager)
local _CollisionParticles = require(script._CollisionParticles)
local _Pathfinder = require(script._Pathfinder)
local _Batcher = require(script._Batcher)
local _Bezier = require(script._Bezier)
local _DataCatalog = require(script._DataCatalog)
local _RandomRotator = require(script._RandomRotator)
local _Respawner = require(script._Respawner)
local _Packet = require(script._Packet)
export type Packet<A... = (), B... = ()> = _Packet.Packet<A..., B...>

local _Lottery = require(script._Lottery)
export type Lottery = _Lottery.Lottery
export type LotteryTicket = _Lottery.LotteryTicket

local _Zone = require(script._Zone)
export type LessSimpleZone<U, T...> = _Zone.LessSimpleZone<U, T...>
export type Zone = _Zone.Zone

export type ZoneQueryOptions = _Zone.QueryOptions
export type ZoneBox = _Zone.Box

local _Future = require(script._Future) -- replacement for promises
export type Future<T...> = _Future.Future<T...>

local _RateLimiter = require(script._RateLimiter)
export type RateLimiter = _RateLimiter.RateLimiter

export type PromiseAny = _Promise.PromiseAny
export type Promise<T...> = _Promise.Promise<T...>

export type SchedulerType = _Scheduler.SchedulerType

-- Func is the function passed to :Once() or :Connect(). ReturnVals is the data returned from :Wait() or passed to :Fire()
-- The args in Func should match ReturnVals!
--export type SignalType<Func, ReturnVals...> = _Signal.SignalType<Func, ReturnVals...>
-- If you don't want to bother defining argument names:
export type Signal<func, ReturnVals...> = _Signal.Signal<func, ReturnVals...>
--export type GenericSignal = _Signal.GenericSignal
--export type SignalConnection = _Signal.SignalConnection

export type TroveType = _Trove.TroveType

export type OctreeType = _Octree.OctreeType
export type OctreeNodeType = _Octree.OctreeNodeType

export type TimerType = _Timer.TimerType

export type ShakeType = _Shake.ShakeType
export type ShakeProperties = _Shake.ShakeProperties

export type PartCache = _PartCache.PartCache

export type CacheType = _Cache.CacheType

type nlerpable = _Spring.nlerpable
export type Spring<T = nlerpable> = _Spring.Spring<T>

export type Proxy<T = { [any]: any }> = _Proxy.Proxy<T>

export type Binder = _Binder.Binder

export type LoggerType = _Logger.LoggerType

export type Quaternion = _Quaternion.Quaternion
export type QuaternionSpring = _QuaternionSpring.QuaternionSpring

-- Typed Remotes & Bindables
export type RemoteEvent<Server..., Client...> = _TypedRemote.Event<Server..., Client...>
export type RemoteFunction<Send..., Receive...> = _TypedRemote.Function<Send..., Receive...>
export type BindableEvent<Send...> = _TypedBindable.Event<Send...>
export type BindableFunction<Send..., Receive...> = _TypedBindable.Function<Send..., Receive...>

export type AdjustmentPool = _AdjustmentPool.AdjustmentPool
export type AcceptedPoolValues = _AdjustmentPool.AcceptedValues

export type PredicateManager = _PredicateManager.PredicateManager
export type CallbackManager = _CallbackManager.CallbackManager

export type TimeKeeper = _TimeKeeper.TimeKeeper
export type UniversalTimestamp = GlobalTypes.UniversalTimestamp

export type PathfinderInstance = _Pathfinder.PathfinderInstance

export type Batcher = _Batcher.Batcher

export type BezierCurve = _Bezier.BezierCurve

export type DataCatalog<T> = _DataCatalog.DataCatalog<T>

export type RandomRotator = _RandomRotator.RandomRotator
export type RotationConfig = _RandomRotator.RotationConfig

export type Respawner = _Respawner.Respawner

local _DynamicOctree = require(script._DynamicOctree)
export type DynamicOctree = _DynamicOctree.DynamicOctree

local _ZonePlus = require(script._ZonePlus)

return {
	Promise = _Promise,
	Scheduler = _Scheduler,
	Signal = _Signal,
	GoodSignal = _GoodSignal,
	Trove = _Trove,
	Zone = _Zone,
	ZonePlus = _ZonePlus,
	Octree = _Octree,
	Timer = _Timer,
	Shake = _Shake,
	FastCast = _FastCastRedux,
	PartCache = _PartCache,
	Cache = _Cache,
	Spring = _Spring,
	SpringUtils = _SpringUtils,
	DuckTypeUtils = _DuckTypeUtils,
	Proxy = _Proxy,
	Binder = _Binder,
	Logger = _Logger,
	Quaternion = _Quaternion,
	QuaternionSpring = _QuaternionSpring,
	TypedRemote = _TypedRemote,
	TypedBindable = _TypedBindable,
	PredicateManager = _PredicateManager,
	CallbackManager = _CallbackManager,
	TimeKeeper = _TimeKeeper,
	AdjustmentPool = _AdjustmentPool,
	Pathfinder = _Pathfinder,
	Batcher = _Batcher,
	CollisionParticles = _CollisionParticles,
	Bezier = _Bezier,
	DataCatalog = _DataCatalog,
	RandomRotator = _RandomRotator,
	Respawner = _Respawner,
	Packet = _Packet,
	Lottery = _Lottery,
	Future = _Future,
	RateLimiter = _RateLimiter,
	DynamicOctree = _DynamicOctree,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042b3</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX9E11F79052CE4EACB273BED75589EBD0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009662</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Promise</string>
							<string name="ScriptGuid">{F2FDE228-7823-4393-8B30-0607BE6AEF83}</string>
							<ProtectedString name="Source"><![CDATA[-- fewkz/typed-luau-promise 2023
-- Generated by generate-promise.ts
type PromiseStatus = "Started" | "Resolved" | "Rejected" | "Cancelled"
type PromiseLike<T...> = { expect: (self: PromiseLike<T...>) -> T..., [any]: any }
-- stylua: ignore start
type PromiseExhausted = {
	andThen: <T2...>(
		self: PromiseLike<...any>,
		successHandler: ((...any) -> T2...)?,
		failureHandler: ((...any) -> T2...)?
	) -> PromiseExhausted,
	andThenCall: <A..., T2...>(
		self: PromiseLike<...any>,
		callback: (A...) -> T2...,
		A...
	) -> PromiseExhausted,
	andThenReturn: <T2...>(self: PromiseLike<...any>, T2...) -> PromiseExhausted,
	cancel: (self: PromiseLike<...any>) -> (),
	catch: <T2...>(
		self: PromiseLike<...any>,
		failureHandler: (...any) -> T2...
	) -> PromiseExhausted,
	expect: (self: PromiseLike<...any>) -> ...any,
	finally: <T2...>(self: PromiseLike<...any>, (status: "Resolved" | "Rejected" | "Cancelled") -> T2...) -> PromiseExhausted,
	getStatus: (self: PromiseLike<...any>) -> PromiseStatus,
	now: (self: PromiseLike<...any>, rejectionValue: any?) -> PromiseExhausted,
	await: (self: PromiseLike<T...>) -> (boolean, T...)
}
type Promise8<T...> = {
	andThen: <T2...>(
		self: PromiseLike<T...>,
		successHandler: ((T...) -> T2...)?,
		failureHandler: ((...any) -> T2...)?
	) -> PromiseExhausted,
	andThenCall: <A..., T2...>(
		self: PromiseLike<T...>,
		callback: (A...) -> T2...,
		A...
	) -> PromiseExhausted,
	andThenReturn: <T2...>(self: PromiseLike<T...>, T2...) -> PromiseExhausted,
	cancel: (self: PromiseLike<T...>) -> (),
	catch: <T2...>(
		self: PromiseLike<T...>,
		failureHandler: (...any) -> T2...
	) -> PromiseExhausted,
	expect: (self: PromiseLike<T...>) -> T...,
	finally: <T2...>(self: PromiseLike<T...>, (status: "Resolved" | "Rejected" | "Cancelled") -> T2...) -> PromiseExhausted,
	getStatus: (self: PromiseLike<T...>) -> PromiseStatus,
	now: (self: PromiseLike<T...>, rejectionValue: any?) -> Promise8<T...>,
	await: (self: PromiseLike<T...>) -> (boolean, T...)
}
type Promise7<T...> = {
	andThen: <T2...>(
		self: PromiseLike<T...>,
		successHandler: ((T...) -> T2...)?,
		failureHandler: ((...any) -> T2...)?
	) -> Promise8<T2...>,
	andThenCall: <A..., T2...>(
		self: PromiseLike<T...>,
		callback: (A...) -> T2...,
		A...
	) -> Promise8<T2...>,
	andThenReturn: <T2...>(self: PromiseLike<T...>, T2...) -> Promise8<T2...>,
	cancel: (self: PromiseLike<T...>) -> (),
	catch: <T2...>(
		self: PromiseLike<T...>,
		failureHandler: (...any) -> T2...
	) -> Promise8<T2...>,
	expect: (self: PromiseLike<T...>) -> T...,
	finally: <T2...>(self: PromiseLike<T...>, (status: "Resolved" | "Rejected" | "Cancelled") -> T2...) -> Promise8<T2...>,
	getStatus: (self: PromiseLike<T...>) -> PromiseStatus,
	now: (self: PromiseLike<T...>, rejectionValue: any?) -> Promise7<T...>,
	await: (self: PromiseLike<T...>) -> (boolean, T...)
}
type Promise6<T...> = {
	andThen: <T2...>(
		self: PromiseLike<T...>,
		successHandler: ((T...) -> T2...)?,
		failureHandler: ((...any) -> T2...)?
	) -> Promise7<T2...>,
	andThenCall: <A..., T2...>(
		self: PromiseLike<T...>,
		callback: (A...) -> T2...,
		A...
	) -> Promise7<T2...>,
	andThenReturn: <T2...>(self: PromiseLike<T...>, T2...) -> Promise7<T2...>,
	cancel: (self: PromiseLike<T...>) -> (),
	catch: <T2...>(
		self: PromiseLike<T...>,
		failureHandler: (...any) -> T2...
	) -> Promise7<T2...>,
	expect: (self: PromiseLike<T...>) -> T...,
	finally: <T2...>(self: PromiseLike<T...>, (status: "Resolved" | "Rejected" | "Cancelled") -> T2...) -> Promise7<T2...>,
	getStatus: (self: PromiseLike<T...>) -> PromiseStatus,
	now: (self: PromiseLike<T...>, rejectionValue: any?) -> Promise6<T...>,
	await: (self: PromiseLike<T...>) -> (boolean, T...)
}
type Promise5<T...> = {
	andThen: <T2...>(
		self: PromiseLike<T...>,
		successHandler: ((T...) -> T2...)?,
		failureHandler: ((...any) -> T2...)?
	) -> Promise6<T2...>,
	andThenCall: <A..., T2...>(
		self: PromiseLike<T...>,
		callback: (A...) -> T2...,
		A...
	) -> Promise6<T2...>,
	andThenReturn: <T2...>(self: PromiseLike<T...>, T2...) -> Promise6<T2...>,
	cancel: (self: PromiseLike<T...>) -> (),
	catch: <T2...>(
		self: PromiseLike<T...>,
		failureHandler: (...any) -> T2...
	) -> Promise6<T2...>,
	expect: (self: PromiseLike<T...>) -> T...,
	finally: <T2...>(self: PromiseLike<T...>, (status: "Resolved" | "Rejected" | "Cancelled") -> T2...) -> Promise6<T2...>,
	getStatus: (self: PromiseLike<T...>) -> PromiseStatus,
	now: (self: PromiseLike<T...>, rejectionValue: any?) -> Promise5<T...>,
	await: (self: PromiseLike<T...>) -> (boolean, T...)
}
type Promise4<T...> = {
	andThen: <T2...>(
		self: PromiseLike<T...>,
		successHandler: ((T...) -> T2...)?,
		failureHandler: ((...any) -> T2...)?
	) -> Promise5<T2...>,
	andThenCall: <A..., T2...>(
		self: PromiseLike<T...>,
		callback: (A...) -> T2...,
		A...
	) -> Promise5<T2...>,
	andThenReturn: <T2...>(self: PromiseLike<T...>, T2...) -> Promise5<T2...>,
	cancel: (self: PromiseLike<T...>) -> (),
	catch: <T2...>(
		self: PromiseLike<T...>,
		failureHandler: (...any) -> T2...
	) -> Promise5<T2...>,
	expect: (self: PromiseLike<T...>) -> T...,
	finally: <T2...>(self: PromiseLike<T...>, (status: "Resolved" | "Rejected" | "Cancelled") -> T2...) -> Promise5<T2...>,
	getStatus: (self: PromiseLike<T...>) -> PromiseStatus,
	now: (self: PromiseLike<T...>, rejectionValue: any?) -> Promise4<T...>,
	await: (self: PromiseLike<T...>) -> (boolean, T...)
}
type Promise3<T...> = {
	andThen: <T2...>(
		self: PromiseLike<T...>,
		successHandler: ((T...) -> T2...)?,
		failureHandler: ((...any) -> T2...)?
	) -> Promise4<T2...>,
	andThenCall: <A..., T2...>(
		self: PromiseLike<T...>,
		callback: (A...) -> T2...,
		A...
	) -> Promise4<T2...>,
	andThenReturn: <T2...>(self: PromiseLike<T...>, T2...) -> Promise4<T2...>,
	cancel: (self: PromiseLike<T...>) -> (),
	catch: <T2...>(
		self: PromiseLike<T...>,
		failureHandler: (...any) -> T2...
	) -> Promise4<T2...>,
	expect: (self: PromiseLike<T...>) -> T...,
	finally: <T2...>(self: PromiseLike<T...>, (status: "Resolved" | "Rejected" | "Cancelled") -> T2...) -> Promise4<T2...>,
	getStatus: (self: PromiseLike<T...>) -> PromiseStatus,
	now: (self: PromiseLike<T...>, rejectionValue: any?) -> Promise3<T...>,
	await: (self: PromiseLike<T...>) -> (boolean, ...any)
}
type Promise2<T...> = {
	andThen: <T2...>(
		self: PromiseLike<T...>,
		successHandler: ((T...) -> T2...)?,
		failureHandler: ((...any) -> T2...)?
	) -> Promise3<T2...>,
	andThenCall: <A..., T2...>(
		self: PromiseLike<T...>,
		callback: (A...) -> T2...,
		A...
	) -> Promise3<T2...>,
	andThenReturn: <T2...>(self: PromiseLike<T...>, T2...) -> Promise3<T2...>,
	cancel: (self: PromiseLike<T...>) -> (),
	catch: <T2...>(
		self: PromiseLike<T...>,
		failureHandler: (...any) -> T2...
	) -> Promise3<T2...>,
	expect: (self: PromiseLike<T...>) -> T...,
	finally: <T2...>(self: PromiseLike<T...>, (status: "Resolved" | "Rejected" | "Cancelled") -> T2...) -> Promise3<T2...>,
	getStatus: (self: PromiseLike<T...>) -> PromiseStatus,
	now: (self: PromiseLike<T...>, rejectionValue: any?) -> Promise2<T...>,
	await: (self: PromiseLike<T...>) -> (boolean, T...)
}
export type Promise<T...> = {
	andThen: <T2...>(
		self: PromiseLike<T...>,
		successHandler: ((T...) -> T2...)?,
		failureHandler: ((...any) -> T2...)?
	) -> Promise2<T2...>,
	andThenCall: <A..., T2...>(
		self: PromiseLike<T...>,
		callback: (A...) -> T2...,
		A...
	) -> Promise2<T2...>,
	andThenReturn: <T2...>(self: PromiseLike<T...>, T2...) -> Promise2<T2...>,
	cancel: (self: PromiseLike<T...>) -> (),
	catch: <T2...>(
		self: PromiseLike<T...>,
		failureHandler: (...any) -> T2...
	) -> Promise2<T2...>,
	expect: (self: PromiseLike<T...>) -> T...,
	finally: <T2...>(self: PromiseLike<T...>, (status: "Resolved" | "Rejected" | "Cancelled") -> T2...) -> Promise2<T2...>,
	getStatus: (self: PromiseLike<T...>) -> PromiseStatus,
	now: (self: PromiseLike<T...>, rejectionValue: any?) -> Promise<T...>,
	await: (self: PromiseLike<T...>) -> (boolean, T...)
}
type _PromiseAny = {
	andThen: <T2...>(
		self: PromiseLike<...any>,
		successHandler: ((...any) -> T2...)?,
		failureHandler: ((...any) -> T2...)?
	) -> any,
	andThenCall: <A..., T2...>(
		self: PromiseLike<...any>,
		callback: (A...) -> T2...,
		A...
	) -> any,
	andThenReturn: <T2...>(self: PromiseLike<...any>, T2...) -> any,
	cancel: (self: PromiseLike<...any>) -> (),
	catch: <T2...>(
		self: PromiseLike<...any>,
		failureHandler: (...any) -> T2...
	) -> any,
	expect: (self: PromiseLike<...any>) -> ...any,
	finally: <T2...>(self: PromiseLike<...any>, (status: "Resolved" | "Rejected" | "Cancelled") -> T2...) -> any,
	getStatus: (self: PromiseLike<...any>) -> PromiseStatus,
	now: (self: PromiseLike<...any>, rejectionValue: any?) -> _PromiseAny,
	await: (self: PromiseLike<...any>) -> (boolean, ...any)
}
export type PromiseAny = _PromiseAny
type PromiseLib = {
	Status: {
		Started: "Started",
		Resolved: "Resolved",
		Rejected: "Rejected",
		Cancelled: "Cancelled",
	},

	all: <T>(promises: { PromiseLike<T> }) -> Promise<{ T }>,
	delay: (seconds: number) -> Promise<number>,
	fromEvent: <T...>(event: RBXScriptSignal<T...>, predicate: ((T...) -> boolean)?) -> Promise<T...>,
	new: <T...>((
		resolve: (T...) -> (),
		reject: (...any) -> (),
		cancel: ((callback: (() -> ())?) -> boolean) -> ()
		) -> ()) -> Promise<T...>,
	promisify: <T..., R...>(callback: (T...) -> (R...)) -> ( (T...) -> Promise<R...> ),
	resolve: <T...>(T...) -> Promise<T...>,
	try: <T..., A...>(callback: (A...) -> T..., A...) -> Promise<T...>,
}
-- stylua: ignore end

return require(script._UntypedPromise) :: PromiseLib]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042b4</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX1CD675400863437D86C7D9641C8A24D0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009663</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_UntypedPromise</string>
								<string name="ScriptGuid">{1581E674-37FC-4C70-BE8A-F4FB00413497}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end
	warn(`Promise is deprecated and recommended to use Future for new work.\n`, debug.traceback())
	
	local self = {
		-- The executor thread.
		_thread = nil,

		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	self._thread = coroutine.create(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)

	task.spawn(self._thread)

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	:::caution
	If the Promise is cancelled, the `executor` thread is closed with `coroutine.close` after the cancellation hook is called.

	You must perform any cleanup code in the cancellation hook: any time your executor yields, it **may never resume**.
	:::

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		task.defer(function()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is a wrapper around `task.delay`.

	:::warning
	Passing NaN, +Infinity, -Infinity, 0, or any other number less than the duration of a Heartbeat will cause the promise to resolve on the very next Heartbeat.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
function Promise.delay(seconds)
	assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
	local startTime = Promise._getTime()
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		task.delay(seconds, function()
			resolve(Promise._getTime() - startTime)
		end)
	end)
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- If we are already cancelled, we return a cancelled Promise
	if self._status == Promise.Status.Cancelled then
		local promise = Promise.new(function() end)
		promise:cancel()

		return promise
	end

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)

			onCancel(function()
				-- These are guaranteed to exist because the cancellation handler is guaranteed to only
				-- be called at most once
				if self._status == Promise.Status.Started then
					table.remove(self._queuedResolve, table.find(self._queuedResolve, successCallback))
					table.remove(self._queuedReject, table.find(self._queuedReject, failureCallback))
				end
			end)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	You can return a Promise from the success or failure handler and it will be chained onto.

	Calling `andThen` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `andThen` is cancelled, `successHandler` and `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Calling `catch` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `catch` is cancelled,  `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	coroutine.close(self._thread)

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled.
]]
function Promise.prototype:_finally(traceback, finallyHandler)
	self._unhandledRejection = false

	local promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local handlerPromise

		onCancel(function()
			-- The finally Promise is not a proper consumer of self. We don't care about the resolved value.
			-- All we care about is running at the end. Therefore, if self has no other consumers, it's safe to
			-- cancel. We don't need to hold out cancelling just because there's a finally handler.
			self:_consumerCancelled(self)

			if handlerPromise then
				handlerPromise:cancel()
			end
		end)

		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = function(...)
				local ok, _, resultList = runExecutor(traceback, finallyHandler, ...)
				local result = resultList[1]
				if not ok then
					return reject(result)
				end

				if Promise.is(result) then
					handlerPromise = result

					result
						:finally(function(status)
							if status ~= Promise.Status.Rejected then
							resolve(self)
						end
						end)
						:catch(function(...)
							reject(...)
						end)
				else
					resolve(self)
				end
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end)

	return promise
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is
	resolved, rejected, *or* cancelled.

	Returns a new Promise that:
	- resolves with the same values that this Promise resolves with.
	- rejects with the same values that this Promise rejects with.
	- is cancelled if this Promise is cancelled.

	If the value you return from the handler is a Promise:
	- We wait for the Promise to resolve, but we ultimately discard the resolved value.
	- If the returned Promise rejects, the Promise returned from `finally` will reject with the rejected value from the
	*returned* promise.
	- If the `finally` Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too.

	Otherwise, the return value from the `finally` handler is entirely discarded.

	:::note Cancellation
	As of Promise v4, `Promise:finally` does not count as a consumer of the parent Promise for cancellation purposes.
	This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers,
	the Promise is cancelled and the finally callbacks run then and there.

	Cancellation still propagates through the `finally` Promise though: if you cancel the `finally` Promise, it can cancel
	its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the `finally` Promise
	will also be cancelled.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local thread = coroutine.running()

		self
			:finally(function()
				task.spawn(thread)
			end)
			-- The finally promise can propagate rejections, so we attach a catch handler to prevent the unhandled
			-- rejection warning from appearing
			:catch(
				function() end
			)

		coroutine.yield()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end

	task.defer(coroutine.close, self._thread)
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042b5</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX9979FBFED5604A97A6A4AEC29863FCB0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009664</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Scheduler</string>
							<string name="ScriptGuid">{DF643C36-DA8E-4E0D-A375-E9F094A8E612}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@title: SchedulerType
--@author: crusherfire
--@date: 4/2/24
--[[@description:
	Allows to place 'tasks' in queue. A task can be anything (function, table, etc). These 'tasks' will be passed to
	the bound callback function responsible for handling the tasks. A new incoming task won't be available to
	the handler callback until :DoneHandlingTask() is called.
	
	Change the policy on the fly using :SetPolicy(). (FIFO is default)
	Add a predicate to filter out undesireable tasks in the queue!
	Return false from your predicate if you wish for the task to be removed from the queue.
	
	DOCUMENTATION:
	
	.new(policy: Policies?): SchedulerType
	Returns a Scheduler object with an optional policy parameter. The default policy is "FIFO" if none is provided.
	
	:ChangePolicy(policy: Policies)
	Changes the policy of the scheduler. This can be changed even while the scheduler is handling tasks 
	and will be reflected when the next task is going to be chosen.
	
	:BindCallback(callback: (nextTask: any) -> ())
	Binds the callback to handle tasks given from the scheduler. This MUST be called before adding tasks to the scheduler.
	
	:UnbindCallback()
	Removes the callback that handles tasks given from the queue. This will stop the scheduler and clears 
	all tasks currently in queue. Before adding a new task, a new callback must be bound.
	
	:ConnectToQueueEmptySignal(callback: () -> ()): Signal.SignalConnection
	Returns a connection to the queue empty signal. This signal fires when there are no more tasks in the queue.
	
	:AddPredicate(predicate: (nextTask: any) -> (boolean))
	Adds an optional predicate to filter out undesirable tasks from the queue.
	
	:RemovePredicate()
	Removes the predicate.
	
	:DoneHandlingTask()
	This function notifies the scheduler that the callback is ready to receive the next task in the queue. 
	If you do not call this function, the scheduler will wait forever.
	
	:AddTask(newTask: any)
	Adds a new task to the queue. You must have a callback bound. If the scheduler is not active, this will start the scheduler.
	
	:GetNumberOfTasks()
	Returns the number of tasks currently in queue.
	
	:Destroy()
	Halts the scheduler & clears all values.
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local Signal = require(script.Parent._Signal)
local Trove = require(script.Parent._Trove)

-----------------------------
-- TYPES --
-----------------------------
type Policies = "LIFO" | "FIFO"
type Predicate = (nextTask: any) -> (boolean)
type Callback = (nextTask: any) -> ()
type self = {
	_trove: Trove.TroveType,
	TasksInQueue: {any},
	QueueEmptySignal: Signal.SignalType<() -> (), ()>,
	_callback: Callback?,
	_policy: Policies,
	_predicates: { [string]: Predicate },
	_activeThread: thread?
}

-----------------------------
-- VARIABLES --
-----------------------------
local Scheduler = {}
local MT = {}
MT.__index = MT

export type SchedulerType = typeof(setmetatable({} :: self, MT))

-- CONSTANTS --

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------
local function startTaskLoop(self: SchedulerType)
	while self._callback do
		local index = if self._policy == "FIFO" then 1 else #self.TasksInQueue
		local currentTask = self.TasksInQueue[index]
		if not currentTask then
			break
		end
		
		local removed = false
		for _, predicate in pairs(self._predicates) do
			if not predicate(currentTask) then
				table.remove(self.TasksInQueue, index)
				removed = true
				break
			end
		end
		if removed then
			continue
		end
		
		local success, err = pcall(function()
			self._callback(currentTask)
		end)
		if err then
			warn("Encountered error while handling task:\n", err)
		end
		table.remove(self.TasksInQueue, index)
	end
	self._activeThread = nil
	table.clear(self.TasksInQueue)
	self.QueueEmptySignal:Fire()
end

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Creates a new Scheduler.
function Scheduler.new(policy: Policies?): SchedulerType
	local self = {} :: self

	self._trove = Trove.new()
	self.TasksInQueue = {}
	self.QueueEmptySignal = self._trove:Construct(Signal)
	self._predicates = {}
	self._policy = policy or "FIFO"

	return setmetatable(self, MT)
end

function MT.ChangePolicy(self: SchedulerType, policy: Policies)
	assert(policy == "LIFO" or policy == "FIFO", "Unexpected value passed to policy parameter!")

	self._policy = policy
end

function MT.GetNumberOfTasks(self: SchedulerType)
	return #self.TasksInQueue
end

function MT.BindCallback(self: SchedulerType, callback: (nextTask: any) -> ())
	if self._callback then
		warn("Callback is already bound to scheduler!")
		return
	end
	assert(typeof(callback) == "function", "Callback must be a function!")

	self._callback = callback
end

function MT.ConnectToQueueEmptySignal(self: SchedulerType, callback: () -> ()): Signal.SignalConnection
	assert(typeof(callback) == "function", "Expected function for callback!")
	
	return self.QueueEmptySignal:Connect(callback)
end

-- Unbinding the callback will halt the scheduler and clears all values in the queue.
function MT.UnbindCallback(self: SchedulerType)
	self._callback = nil
end

function MT.AddPredicate(self: SchedulerType, identifier: string, allowNextTask: (nextTask: any) -> (boolean))
	assert(typeof(identifier) == "string", "Identifier must be a string!")
	assert(typeof(allowNextTask) == "function", "Predicate must be a function!")
	
	self._predicates[identifier] = allowNextTask
end

function MT.RemovePredicate(self: SchedulerType, identifier: string)
	self._predicates[identifier] = nil
end

-- Callback MUST be bound before adding a task to the scheduler!
function MT.AddTask(self: SchedulerType, ...: any)
	assert(self._callback, "No callback has been bound to the Scheduler!")

	local tasks = {...}
	for _, t in tasks do
		table.insert(self.TasksInQueue, t)
	end

	if not self._activeThread then
		self._activeThread = task.spawn(startTaskLoop, self)
	end
end

function MT:Destroy()
	task.cancel(self._activeThread)
	self._trove:Clean()
	setmetatable(self, nil)
	table.clear(self :: any)
end

-----------------------------
-- MAIN --
-----------------------------
return Scheduler]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042b6</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX29BEECE75964480C9EBAB99AFE60E43D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">709515ba1a11973a08a5673300001705</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_GoodSignal</string>
							<string name="ScriptGuid">{394E7A0B-C31B-4F6E-9630-C8E6E79DEA03}</string>
							<ProtectedString name="Source"><![CDATA[-- -----------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- License:                                                                   --
--   Licensed under the MIT license.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--   sleitnick - August 3rd, 2021 - Modified for Knit.                        --
-- -----------------------------------------------------------------------------

-- Signal types
export type Connection = {
	Disconnect: (self: Connection) -> (),
	Destroy: (self: Connection) -> (),
	Connected: boolean,
}

export type Signal<T...> = {
	Fire: (self: Signal<T...>, T...) -> (),
	FireDeferred: (self: Signal<T...>, T...) -> (),
	Connect: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	Once: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	DisconnectAll: (self: Signal<T...>) -> (),
	GetConnections: (self: Signal<T...>) -> { Connection },
	Destroy: (self: Signal<T...>) -> (),
	Wait: (self: Signal<T...>) -> T...,
}

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread(...)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

--[[
	@within Signal
	@interface SignalConnection
	.Connected boolean
	.Disconnect (SignalConnection) -> ()
	Represents a connection to a signal.
	```lua
	local connection = signal:Connect(function() end)
	print(connection.Connected) --> true
	connection:Disconnect()
	print(connection.Connected) --> false
	```
]]

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		Connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	if not self.Connected then
		return
	end
	self.Connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end

Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(_tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

--[[
	@within Signal
	@type ConnectionFn (...any) -> ()
	A function connected to a signal.
]]

--[[
	@class Signal
	Signals allow events to be dispatched and handled.
	For example:
	```lua
	local signal = Signal.new()
	signal:Connect(function(msg)
		print("Got message:", msg)
	end)
	signal:Fire("Hello world!")
	```
]]
local Signal = {}
Signal.__index = Signal

--[[
	Constructs a new Signal
	@return Signal
]]
function Signal.new<T...>(): Signal<T...>
	local self = setmetatable({
		_handlerListHead = false,
		_proxyHandler = nil,
	}, Signal)
	return self
end

--[[
	Constructs a new Signal that wraps around an RBXScriptSignal.
	@param rbxScriptSignal RBXScriptSignal -- Existing RBXScriptSignal to wrap
	@return Signal
	For example:
	```lua
	local signal = Signal.Wrap(workspace.ChildAdded)
	signal:Connect(function(part) print(part.Name .. " added") end)
	Instance.new("Part").Parent = workspace
	```
]]
function Signal.Wrap<T...>(rbxScriptSignal: RBXScriptSignal): Signal<T...>
	assert(
		typeof(rbxScriptSignal) == "RBXScriptSignal",
		"Argument #1 to Signal.Wrap must be a RBXScriptSignal; got " .. typeof(rbxScriptSignal)
	)
	local signal = Signal.new()
	signal._proxyHandler = rbxScriptSignal:Connect(function(...)
		signal:Fire(...)
	end)
	return signal
end

--[[
	Checks if the given object is a Signal.
	@param obj any -- Object to check
	@return boolean -- `true` if the object is a Signal.
]]
function Signal.Is(obj: any): boolean
	return type(obj) == "table" and getmetatable(obj) == Signal
end

--[[
	@param fn ConnectionFn
	@return SignalConnection
	Connects a function to the signal, which will be called anytime the signal is fired.
	```lua
	signal:Connect(function(msg, num)
		print(msg, num)
	end)
	signal:Fire("Hello", 25)
	```
]]
function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end
	return connection
end

--[[
	@deprecated v1.3.0 -- Use `Signal:Once` instead.
	@param fn ConnectionFn
	@return SignalConnection
]]
function Signal:ConnectOnce(fn)
	return self:Once(fn)
end

--[[
	@param fn ConnectionFn
	@return SignalConnection
	Connects a function to the signal, which will be called the next time the signal fires. Once
	the connection is triggered, it will disconnect itself.
	```lua
	signal:Once(function(msg, num)
		print(msg, num)
	end)
	signal:Fire("Hello", 25)
	signal:Fire("This message will not go through", 10)
	```
]]
function Signal:Once(fn)
	local connection
	local done = false
	connection = self:Connect(function(...)
		if done then
			return
		end
		done = true
		connection:Disconnect()
		fn(...)
	end)
	return connection
end

function Signal:GetConnections()
	local items = {}
	local item = self._handlerListHead
	while item do
		table.insert(items, item)
		item = item._next
	end
	return items
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
--[[
	Disconnects all connections from the signal.
	```lua
	signal:DisconnectAll()
	```
]]
function Signal:DisconnectAll()
	local item = self._handlerListHead
	while item do
		item.Connected = false
		item = item._next
	end
	self._handlerListHead = false
end

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
--[[
	@param ... any
	Fire the signal, which will call all of the connected functions with the given arguments.
	```lua
	signal:Fire("Hello")
	-- Any number of arguments can be fired:
	signal:Fire("Hello", 32, {Test = "Test"}, true)
	```
]]
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item.Connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

--[[
	@param ... any
	Same as `Fire`, but uses `task.defer` internally & doesn't take advantage of thread reuse.
	```lua
	signal:FireDeferred("Hello")
	```
]]
function Signal:FireDeferred(...)
	local item = self._handlerListHead
	while item do
		task.defer(item._fn, ...)
		item = item._next
	end
end

--[[
	@return ... any
	@yields
	Yields the current thread until the signal is fired, and returns the arguments fired from the signal.
	Yielding the current thread is not always desirable. If the desire is to only capture the next event
	fired, using `Once` might be a better solution.
	```lua
	task.spawn(function()
		local msg, num = signal:Wait()
		print(msg, num) --> "Hello", 32
	end)
	signal:Fire("Hello", 32)
	```
]]
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local connection
	local done = false
	connection = self:Connect(function(...)
		if done then
			return
		end
		done = true
		connection:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end

--[[
	Cleans up the signal.
	Technically, this is only necessary if the signal is created using
	`Signal.Wrap`. Connections should be properly GC'd once the signal
	is no longer referenced anywhere. However, it is still good practice
	to include ways to strictly clean up resources. Calling `Destroy`
	on a signal will also disconnect all connections immediately.
	```lua
	signal:Destroy()
	```
]]
function Signal:Destroy()
	self:DisconnectAll()
	local proxyHandler = rawget(self, "_proxyHandler")
	if proxyHandler then
		proxyHandler:Disconnect()
	end
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(_tb, key)
		print(key)
		print(rawget(_tb, key))
		return rawget(_tb, key)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

return {
	new = Signal.new,
	Wrap = Signal.Wrap,
	Is = Signal.Is,
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042b7</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX96D61B66D65541CAB80973401427D9E2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">2d05e6f30428e30a05a9c3a60000e855</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Trove</string>
							<string name="ScriptGuid">{879CE731-0861-44F2-9D76-AF19B991277F}</string>
							<ProtectedString name="Source"><![CDATA[-- Trove
-- Stephen Leitnick
-- October 16, 2021
local FN_MARKER = newproxy()
local THREAD_MARKER = newproxy()
local GENERIC_OBJECT_CLEANUP_METHODS = { "Destroy", "Disconnect", "destroy", "disconnect" }

local RunService = game:GetService("RunService")

local function GetObjectCleanupFunction(object, cleanupMethod)
	local t = typeof(object)
	if t == "function" then
		return FN_MARKER
	elseif t == "thread" then
		return THREAD_MARKER
	end
	if cleanupMethod then
		return cleanupMethod
	end
	if t == "Instance" then
		return "Destroy"
	elseif t == "RBXScriptConnection" then
		return "Disconnect"
	elseif t == "table" then
		for _, genericCleanupMethod in GENERIC_OBJECT_CLEANUP_METHODS do
			if typeof(object[genericCleanupMethod]) == "function" then
				return genericCleanupMethod
			end
		end
	end
	error("Failed to get cleanup function for object " .. t .. ": " .. tostring(object), 3)
end

local function AssertPromiseLike(object)
	if
		typeof(object) ~= "table"
		or typeof(object.getStatus) ~= "function"
		or typeof(object.finally) ~= "function"
		or typeof(object.cancel) ~= "function"
	then
		error("Did not receive a Promise as an argument", 3)
	end
end

local function AssertFutureLike(object)
	if
		typeof(object) ~= "table"
		or typeof(object.Await) ~= "function"
		or typeof(object.After) ~= "function"
		or typeof(object.Cancel) ~= "function"
	then
		error(`Did not receive a Future as an argument`, 3)
	end
end

--[=[
	@class Trove
	A Trove is helpful for tracking any sort of object during
	runtime that needs to get cleaned up at some point.
]=]
local Trove = {}
Trove.__index = Trove
type self = {
	_objects: {[any]: any},
	_cleaning: boolean
}
export type TroveType = typeof(setmetatable({} :: self, Trove))

--[=[
	@return Trove
	Constructs a Trove object.
]=]
function Trove.new(): TroveType
	local self = setmetatable({}, Trove)
	self._objects = {}
	self._cleaning = false
	return self
end

--[=[
	@return Trove
	Creates and adds another trove to itself. This is just shorthand
	for `trove:Construct(Trove)`. This is useful for contexts where
	the trove object is present, but the class itself isn't.

	:::note
	This does _not_ clone the trove. In other words, the objects in the
	trove are not given to the new constructed trove. This is simply to
	construct a new Trove and add it as an object to track.
	:::

	```lua
	local trove = Trove.new()
	local subTrove = trove:Extend()

	trove:Clean() -- Cleans up the subTrove too
	```
]=]
function Trove:Extend()
	if self._cleaning then
		error("Cannot call trove:Extend() while cleaning", 2)
	end
	return self:Construct(Trove)
end

--[=[
	Clones the given instance and adds it to the trove. Shorthand for
	`trove:Add(instance:Clone())`.
]=]
function Trove:Clone(instance: Instance): Instance
	if self._cleaning then
		error("Cannot call trove:Clone() while cleaning", 2)
	end
	return self:Add(instance:Clone())
end

--[=[
	@param class table | (...any) -> any
	@param ... any
	@return any
	Constructs a new object from either the
	table or function given.

	If a table is given, the table's `new`
	function will be called with the given
	arguments.

	If a function is given, the function will
	be called with the given arguments.
	
	The result from either of the two options
	will be added to the trove.

	This is shorthand for `trove:Add(SomeClass.new(...))`
	and `trove:Add(SomeFunction(...))`.

	```lua
	local Signal = require(somewhere.Signal)

	-- All of these are identical:
	local s = trove:Construct(Signal)
	local s = trove:Construct(Signal.new)
	local s = trove:Construct(function() return Signal.new() end)
	local s = trove:Add(Signal.new())

	-- Even Roblox instances can be created:
	local part = trove:Construct(Instance, "Part")
	```
]=]
function Trove:Construct(class, ...)
	if self._cleaning then
		error("Cannot call trove:Construct() while cleaning", 2)
	end
	local object = nil
	local t = typeof(class)
	if t == "table" then
		object = class.new(...)
	elseif t == "function" then
		object = class(...)
	end
	return self:Add(object)
end

--[=[
	@param signal RBXScriptSignal
	@param fn (...: any) -> ()
	@return RBXScriptConnection
	Connects the function to the signal, adds the connection
	to the trove, and then returns the connection.

	This is shorthand for `trove:Add(signal:Connect(fn))`.

	```lua
	trove:Connect(workspace.ChildAdded, function(instance)
		print(instance.Name .. " added to workspace")
	end)
	```
]=]
function Trove:Connect(signal, fn)
	if self._cleaning then
		error("Cannot call trove:Connect() while cleaning", 2)
	end
	return self:Add(signal:Connect(fn))
end

--[=[
	@param signal RBXScriptSignal
	@param fn (...: any) -> ()
	@return RBXScriptConnection
	Connects a function to the signal just once, then disconnects.
	Adds the connection to the trove for cleanup if needed.
]=]
function Trove:Once(signal, fn)
	if self._cleaning then
		error("Cannot call trove:Once() while cleaning", 2)
	end
	local connection
	connection = signal:Connect(function(...)
		fn(...)
		connection:Disconnect()
		self:_findAndRemoveFromObjects(connection, false)
	end)
	return self:Add(connection)
end

--[=[
	@param name string
	@param priority number
	@param fn (dt: number) -> ()
	Calls `RunService:BindToRenderStep` and registers a function in the
	trove that will call `RunService:UnbindFromRenderStep` on cleanup.

	```lua
	trove:BindToRenderStep("Test", Enum.RenderPriority.Last.Value, function(dt)
		-- Do something
	end)
	```
]=]
function Trove:BindToRenderStep(name: string, priority: number, fn: (dt: number) -> ())
	if self._cleaning then
		error("Cannot call trove:BindToRenderStep() while cleaning", 2)
	end
	RunService:BindToRenderStep(name, priority, fn)
	self:Add(function()
		RunService:UnbindFromRenderStep(name)
	end)
end

--[=[
	@param promise Promise
	@return Promise
	Gives the promise to the trove, which will cancel the promise if the trove is cleaned up or if the promise
	is removed. The exact promise is returned, thus allowing chaining.

	```lua
	trove:AddPromise(doSomethingThatReturnsAPromise())
		:andThen(function()
			print("Done")
		end)
	-- Will cancel the above promise (assuming it didn't resolve immediately)
	trove:Clean()

	local p = trove:AddPromise(doSomethingThatReturnsAPromise())
	-- Will also cancel the promise
	trove:Remove(p)
	```

	:::caution Promise v4 Only
	This is only compatible with the [roblox-lua-promise](https://eryn.io/roblox-lua-promise/) library, version 4.
	:::
]=]
function Trove:AddPromise(promise)
	if self._cleaning then
		error("Cannot call trove:AddPromise() while cleaning", 2)
	end
	AssertPromiseLike(promise)
	if promise:getStatus() == "Started" then
		promise:finally(function()
			if self._cleaning then
				return
			end
			self:_findAndRemoveFromObjects(promise, false)
		end)
		self:Add(promise, "cancel")
	end
	return promise
end

--[=[
	@param future Future
	@return Future
	Gives the future to the trove, which will cancel the future if the trove is cleaned up or if the future
	is removed. The exact future is returned.

	```lua
	trove:AddFuture(doSomethingThatReturnsAFuture())
		:After(function()
			print("Done")
		end)
	-- Will cancel the above future (assuming it didn't resolve immediately)
	trove:Clean()

	local f = trove:AddFuture(doSomethingThatReturnsAFuture())
	-- Will also cancel the promise
	trove:Remove(f)
	```

	:::caution Forked Future Only
	This is only compatible with the forked Future in ModuleUtils that has a Cancel method
	:::
]=]
function Trove:AddFuture(future)
	if self._cleaning then
		error("Cannot call trove:AddFuture() while cleaning", 2)
	end
	AssertFutureLike(future)
	if future:IsPending() then
		future:After(function()
			if self._cleaning then
				return
			end
			self:_findAndRemoveFromObjects(future, false)
		end)
		self:Add(future, "Cancel")
	end
	return future
end

--[=[
	@param object any -- Object to track
	@param cleanupMethod string? -- Optional cleanup name override
	@return object: any
	Adds an object to the trove. Once the trove is cleaned or
	destroyed, the object will also be cleaned up.

	The following types are accepted (e.g. `typeof(object)`):

	| Type | Cleanup |
	| ---- | ------- |
	| `Instance` | `object:Destroy()` |
	| `RBXScriptConnection` | `object:Disconnect()` |
	| `function` | `object()` |
	| `thread` | `task.cancel(object)` |
	| `table` | `object:Destroy()` _or_ `object:Disconnect()` _or_ `object:destroy()` _or_ `object:disconnect()` |
	| `table` with `cleanupMethod` | `object:<cleanupMethod>()` |

	Returns the object added.

	```lua
	-- Add a part to the trove, then destroy the trove,
	-- which will also destroy the part:
	local part = Instance.new("Part")
	trove:Add(part)
	trove:Destroy()

	-- Add a function to the trove:
	trove:Add(function()
		print("Cleanup!")
	end)
	trove:Destroy()

	-- Standard cleanup from table:
	local tbl = {}
	function tbl:Destroy()
		print("Cleanup")
	end
	trove:Add(tbl)

	-- Custom cleanup from table:
	local tbl = {}
	function tbl:DoSomething()
		print("Do something on cleanup")
	end
	trove:Add(tbl, "DoSomething")
	```
]=]
function Trove:Add(object: any, cleanupMethod: string?): any
	if self._cleaning then
		error("Cannot call trove:Add() while cleaning", 2)
	end
	local cleanup = GetObjectCleanupFunction(object, cleanupMethod)
	table.insert(self._objects, { object, cleanup })
	return object
end

--[=[
	@param object any -- Object to remove
	Removes the object from the Trove and cleans it up.
	Thread removal is protected.

	```lua
	local part = Instance.new("Part")
	trove:Add(part)
	trove:Remove(part)
	```
]=]
function Trove:Remove(object: any): boolean
	if self._cleaning then
		error("Cannot call trove:Remove() while cleaning", 2)
	end
	return self:_findAndRemoveFromObjects(object, true)
end

--[=[
	Cleans up all objects in the trove. This is
	similar to calling `Remove` on each object
	within the trove. The ordering of the objects
	removed is _not_ guaranteed.
]=]
function Trove:Clean()
	if self._cleaning then
		return
	end
	self._cleaning = true
	for _, obj in self._objects do
		self:_cleanupObject(obj[1], obj[2])
	end
	table.clear(self._objects)
	self._cleaning = false
end

function Trove:_findAndRemoveFromObjects(object: any, cleanup: boolean): boolean
	local objects = self._objects
	for i, obj in ipairs(objects) do
		if obj[1] == object then
			local n = #objects
			objects[i] = objects[n]
			objects[n] = nil
			if cleanup then
				self:_cleanupObject(obj[1], obj[2])
			end
			return true
		end
	end
	return false
end

function Trove:_cleanupObject(object, cleanupMethod)
	if cleanupMethod == FN_MARKER then
		object()
	elseif cleanupMethod == THREAD_MARKER then
		pcall(task.cancel, object)
	else
		object[cleanupMethod](object)
	end
end

--[=[
	@param instance Instance
	@return RBXScriptConnection
	Attaches the trove to a Roblox instance. Once this
	instance is removed from the game (parent or ancestor's
	parent set to `nil`), the trove will automatically
	clean up.

	:::caution
	Will throw an error if `instance` is not a descendant
	of the game hierarchy.
	:::
]=]
function Trove:AttachToInstance(instance: Instance)
	if self._cleaning then
		error("Cannot call trove:AttachToInstance() while cleaning", 2)
	elseif not instance:IsDescendantOf(game) then
		error("Instance is not a descendant of the game hierarchy", 2)
	end
	return self:Connect(instance.Destroying, function()
		self:Destroy()
	end)
end

-- Returns if the trove is actively cleaning objects.
function Trove:IsCleaning(): boolean
	return self._cleaning
end

--[=[
	Alias for `trove:Clean()`.
]=]
function Trove:Destroy()
	self:Clean()
end

return Trove]]></ProtectedString>
							<int64 name="SourceAssetId">15881559866</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042b8</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC316069B17DC4C0591FEA2370746D7E2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc08218013000096e9</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_DataCatalog</string>
							<string name="ScriptGuid">{D52D3CCB-0925-4673-BE29-B7BCBAB37F63}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 4/22/25
--[[@description:
	For creating catalog data containers.
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local Cache = require("./_Cache")
local FunctionUtils = require("../FunctionUtils")
local t = FunctionUtils.t

-----------------------------
-- TYPES --
-----------------------------

export type DataCatalog<T> = {
	_data: { [string]: T },
	_entryCache: Cache.CacheType,
	_entryCount: number,

	-- SUPER hacky for functions w/comments but it works!
	GetEntries: ( typeof(
		-- Returns all entries. This table is frozen and cannot be modified.
		function(self: DataCatalog<T>): { [string]: T }
			return nil :: any
		end
		)
	),
	GetEnumNames: typeof(
		-- Returns all enum names as an array in the catalog.
		function(self: DataCatalog<T>): { string }
			return {}
		end
	),
	GetEntryByName: ( typeof(
		-- Grabs a guaranteed entry in the catalog based on the <code>enumName</code>.
		-- Throws an error if the <code>enumName</code> is invalid. If this behavior is not desired, index for the entry directly from <code>:GetEntires()</code>
		function(self: DataCatalog<T>, enumName: string): T
			return nil :: any
		end)
	),
	GetEntryByKeyValue: typeof(
		-- Looks for the entry in the catalog based on <code>key</code> and if the value at <code>key</code> matches <code>matchValue</code>.
		function(self: DataCatalog<T>, key: string, matchValue: any): T?
			return nil :: any
		end
	),
	GetEntriesByKeyValue: typeof(
		-- Looks for all entries in the catalog based on <code>key</code> and if the value at <code>key</code> matches <code>matchValue</code>.
		function(self: DataCatalog<T>, key: string, matchValue: any): { T }
			return nil :: any
		end
	),
	GetNameByEntry: typeof( 
		-- Looks for the entry in the catalog and returns its name if found.
		-- Results are cached.
		function(self: DataCatalog<T>, entry: any): string?
			return
		end
	),
	GetSorted: typeof(
		-- Returns an array of all values and keys in the catalog sorted by <code>comparator</code>
		-- These results are cached with the same comparator!
		function(self: DataCatalog<T>, comparator: (a: T, b: T) -> (boolean)): ( { T }, { string } )
			return nil :: any, nil :: any
		end
	),
	GetEntryCount: typeof(
		--[[
			Returns the number of entries present in the DataCatalog.
			Result is cached.
		]]
		function(self: DataCatalog<T>): number
			return 0
		end
	)
}

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}
local MT = {}
MT.__index = MT

local sortedCatalogCache = FunctionUtils.Table.weakCache("k")

-- CONSTANTS --

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- CLASS FUNCTIONS --
-----------------------------

-- Freezes the data table and stores it.
function Module.new<T>(data: { [string]: T }): DataCatalog<T>
	local self = setmetatable({}, MT) :: any
	
	self._data = if table.isfrozen(data) then data else table.freeze(data)
	self._entryCache = Cache.new()
	self._entryCount = 0
	for _, _ in data do
		self._entryCount += 1
	end
	
	return self
end

function Module:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")

	local mt = getmetatable(object)
	return mt ~= nil and mt.__index == MT
end

-----------------------------
-- METHODS --
-----------------------------

-----------------------------
-- SETTERS --
-----------------------------

-----------------------------
-- GETTERS --
-----------------------------

-- Returns all entries. This table is frozen and cannot be modified.
function MT.GetEntries(self: DataCatalog<any>): any
	return self._data
end

function MT.GetEnumNames(self: DataCatalog<any>): { string }
	local _, names = FunctionUtils.Table.toArrayCached(self._data)
	return names
end

-- Grabs a guaranteed entry in the catalog based on the <code>enumName</code>.
-- Throws an error if the <code>enumName</code> is invalid. If this behavior is not desired, index for the entry directly from <code>:GetEntires()</code>
function MT.GetEntryByName(self: DataCatalog<any>, enumName: string): any
	local result = self._data[enumName]
	if not result then
		error(`invalid enumName: {enumName}`, 2)
	end
	return result
end

-- Looks for the entry in the catalog based on <code>key</code> and if the value at <code>key</code> matches <code>matchValue</code>.
function MT.GetEntryByKeyValue(self: DataCatalog<any>, key: string, matchValue: any): any?
	for name, entry: any in pairs(self._data) do
		if entry[key] == matchValue then
			return entry
		end
	end
	return
end

-- Looks for all entries in the catalog based on <code>key</code> and if the value at <code>key</code> matches <code>matchValue</code>.
function MT.GetEntriesByKeyValue(self: DataCatalog<any>, key: string, matchValue: any): any?
	local result = {}
	for name, entry in pairs(self._data) do
		if entry[key] == matchValue then
			table.insert(result, entry)
		end
	end
	return result
end

-- Looks for the entry in the catalog and returns its name if found.
-- Results are cached.
function MT.GetNameByEntry(self: DataCatalog<any>, entry: any): string?
	local result = self._entryCache:Get(entry)
	if result then
		return if result == true then nil else result
	end
	for name, _entry in pairs(self._data) do
		if _entry == entry then
			result = name
			break
		end
	end
	self._entryCache:Set(entry, result or true)
	return result
end

function MT.GetSorted(self: DataCatalog<any>, comparator: (any, any) -> (boolean)): ( { any }, { string } )
	assert(typeof(comparator) == "function", "Expected comparator to be a function")

	local data = self._data
	local cacheForData = sortedCatalogCache[data]
	if not cacheForData then
		cacheForData = FunctionUtils.Table.weakCache("k")
		sortedCatalogCache[data] = cacheForData
	end

	local cached = cacheForData[comparator]
	if cached then
		-- Return cloned arrays to avoid external mutation
		return table.clone(cached.Values), table.clone(cached.Keys)
	end

	local values, keys = FunctionUtils.Table.toArrayCached(data)

	local indexed = table.create(#values)
	for i = 1, #values do
		indexed[i] = {
			Key = keys[i],
			Value = values[i],
		}
	end

	table.sort(indexed, function(a, b)
		return comparator(a.Value, b.Value)
	end)

	local sortedValues = table.create(#indexed)
	local sortedKeys = table.create(#indexed)
	for i = 1, #indexed do
		sortedValues[i] = indexed[i].Value
		sortedKeys[i] = indexed[i].Key
	end

	cacheForData[comparator] = {
		Values = sortedValues,
		Keys = sortedKeys,
	}

	return table.clone(sortedValues), table.clone(sortedKeys)
end

function MT.GetEntryCount(self: DataCatalog<any>): number
	return self._entryCount
end

-----------------------------
-- CLEANUP --
-----------------------------

-----------------------------
-- MAIN --
-----------------------------
return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042b9</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0E4559E5085746EC8657ABB45126F69B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">0459cbd235ed6de70833b39800041171</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Lottery</string>
							<string name="ScriptGuid">{BBA5F22F-E143-4016-A121-B1A0B1C61147}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 5/12/25
--[[@description:
	Random lottery pulling of identifiers with weights.
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-----------------------------
-- DEPENDENCIES --
-----------------------------

-----------------------------
-- TYPES --
-----------------------------
-- For all of the properties/fields of an object made from this class.
type fields = {
	_tickets: { LotteryTicket }
}

export type LotteryTicket = {
	EnumName: string?, -- DEPRECATED
	Identifier: any,
	Weight: number,
	[string]: any -- if you wish to store anything else associated with the ticket
}

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}
local MT = {}
MT.__index = MT
export type Lottery = typeof(setmetatable({} :: fields, MT))

-- Use a shared RNG seeded by current time
local rng = Random.new(tick())

-----------------------------
-- CLASS FUNCTIONS --
-----------------------------

function Module.new(tickets: { LotteryTicket }?): Lottery
	local self = setmetatable({} :: fields, MT) :: Lottery
	if tickets then
		for _, ticket in tickets do
			if ticket.EnumName then
				warn(`EnumName for LotteryTicket is deprecated`, debug.traceback())
				ticket.Identifier = ticket.EnumName
			end
		end
	end
	self._tickets = tickets or {}
	return self
end

function Module:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")
	return getmetatable(object) == MT
end

-----------------------------
-- METHODS --
-----------------------------

-- Adds a lottery ticket with an associated positive weight to the pool.
function MT.AddTicket(self: Lottery, identifier: any, weight: number)
	assert(typeof(weight) == "number" and weight > 0, "Lottery:AddTicket expected weight to be a positive number")
	table.insert(self._tickets, { EnumName = identifier, Identifier = identifier, Weight = weight })
end

-- Draws a random ticket based on weights, without removing it from the pool.
-- Returns the drawn ticket.
function MT.DrawTicket(self: Lottery): LotteryTicket
	assert(#self._tickets > 0, "Lottery:DrawTicket called on empty ticket pool")

	local totalWeight = 0
	for _, ticket in ipairs(self._tickets) do
		totalWeight += ticket.Weight
	end

	local pick = rng:NextInteger(0, totalWeight)
	local cumulative = 0

	for _, ticket in ipairs(self._tickets) do
		cumulative += ticket.Weight
		if pick <= cumulative then
			return ticket
		end
	end

	-- Fallback
	return self._tickets[#self._tickets]
end

function MT.GetTickets(self: Lottery): { LotteryTicket }
	return self._tickets
end

-----------------------------
-- CLEANUP / MAIN --
-----------------------------
return Module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042ba</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC56C43F3FEF94AE897127E75DCA19905">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009675</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Octree</string>
							<string name="ScriptGuid">{423DACB9-121B-4E78-A40B-E9ED2C179B11}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--!native
--[=[
	BY: @Quenty
	Pulled from Nevermore to be a single module.
	https://quenty.github.io/NevermoreEngine/
	
	Note from @crusherfire:
	Slightly modified to include some basic type annotation.
	All work and credit goes to @Quenty!

	Octree implementation. An octree is a data structure that allows for quick spatial
	data queries of static objects. For example, trees can be stored in an octree, and
	nearby trees could be found near the player.

	Octrees exists as a grid of nodes, which are subdivided in half in each axis, which
	results in 8 different regions. This recursively happens to a set depth.

	This allows for O(n) data storage and log(n) retrieval of nearby objects. With a large
	quantity of items in the octree, this can make data retrieval significantly faster.

	See also: https://en.wikipedia.org/wiki/Octree

	```lua
	local octree = Octree.new()
	octree:CreateNode(Vector3.zero, "A")
	octree:CreateNode(Vector3.zero, "B")
	octree:CreateNode(Vector3.zero, workspace)
	octree:CreateNode(Vector3.new(0, 0, 1000), "C")
	print(octree:RadiusSearch(Vector3.zero, 100)) --> { "A", "B", workspace }
	```

	:::tip
	Octrees are best for static objects in the world, and not objects moving around, since then
	data can be statically cached.

	Sometimes using Roblox's spatial hash using the region API is faster than using an octree. However,
	for data that is centralized, or static, an octree can be a very efficient spatial query mechanism.

	That said, it is totally fine to track the objects that DO move around using octree, as long as you
	apply proper optimizations. The main performance cost of doing this comes down to tracking and
	updating the position of the objects, which is fine if:
		1) You have a way to detect the movement without having to loop through all the moving
		objects to update the position
		2) You can tolerate some inaccuracy with positions and smear this update
		3) You have less than 1000 objects to track, in this case looping through everything
		shouldn't be too costly.
	:::

	@class Octree
]=]

local OctreeRegionUtils = require(script._OctreeRegionUtils)
local OctreeNode = require(script._OctreeNode)

local EPSILON = 1e-9

local Octree = {}
Octree.ClassName = "Octree"
Octree.__index = Octree

type fields = {
	_maxRegionSize: any,
	_maxDepth: any,
	_regionHashMap: any,
}

export type OctreeType = typeof(setmetatable({} :: fields, Octree))
export type OctreeNodeType = OctreeNode.OctreeNodeType

--[=[
	Constructs a new Octree.

	@return Octree<T>
]=]
function Octree.new(): OctreeType
	local self = setmetatable({}, Octree)

	self._maxRegionSize = { 512, 512, 512 } -- these should all be the same number
	self._maxDepth = 4
	self._regionHashMap = {} -- [hash] = region

	return self
end

--[=[
	Returns all octree nodes stored in the octree!

	```lua
	local octree = Octree.new()
	octree:CreateNode(Vector3.zero, "Hi")
	octree:CreateNode(Vector3.zero, "Bob")
	print(octree:GetAllNodes()) --> { "Hi", "Bob" }
	```

	Order is not guaranteed.

	:::warning
	If you have 100,000 nodes in your octree, this is going to be very slow.
	:::

	@return { OctreeNode<T> }
]=]
function Octree.GetAllNodes(self: OctreeType): { OctreeNode.OctreeNodeType }
	local options = {}

	for _, regionList in pairs(self._regionHashMap) do
		for _, region in pairs(regionList) do
			for node, _ in pairs(region.nodes) do
				options[#options+1] = node
			end
		end
	end

	return options
end

--[=[
	Creates a new OctreeNode at the given position which can be retrieved

	:::tip
	Be sure to call :Destroy() on a node if the data becomes stale. Note that
	this is not necessary if the whole octree is removed from memory.
	:::

	```lua
	local octree = Octree.new()
	octree:CreateNode(Vector3.zero, "A")
	octree:CreateNode(Vector3.zero, "B")
	```

	@param position Vector3
	@param object T
	@return OctreeNode<T>
]=]
function Octree.CreateNode(self: OctreeType, position: Vector3, object: any): OctreeNode.OctreeNodeType
	assert(typeof(position) == "Vector3", "Bad position value")
	assert(object, "Bad object value")

	local node = OctreeNode.new(self, object)

	node:SetPosition(position)

	return node
end

--[=[
	Searches at the position and radius for any objects that may be within
	this radius.

	```lua
	local octree = Octree.new()
	octree:CreateNode(Vector3.zero, "A")
	octree:CreateNode(Vector3.zero, "B")
	octree:CreateNode(Vector3.new(0, 0, 1000), "C")
	print(octree:RadiusSearch(Vector3.zero, 100)) --> { "A", "B" }
	```

	@param position Vector3
	@param radius number
	@return { T } -- Objects found
	@return { number } -- Distances squared
]=]
function Octree.RadiusSearch(self: OctreeType, position: Vector3, radius: number): ({ any }, { number })
	assert(typeof(position) == "Vector3", "Bad position")
	assert(type(radius) == "number", "Bad radius")

	local px, py, pz = position.X, position.Y, position.Z
	return self:_radiusSearch(px, py, pz, radius)
end

--[=[
	Searches at the position and radius for any objects that may be within
	this radius. Returns the knearest entries.

	The closest entities will be first in the list.

	@param position Vector3
	@param k number -- Number of objects to find
	@param radius number
	@return { any } -- Objects found
	@return { number } -- Distances squared
]=]
function Octree.KNearestNeighborsSearch(self: OctreeType, position: Vector3, k: number, radius: number): ({ any }, { number })
	assert(typeof(position) == "Vector3", "Bad position")
	assert(type(radius) == "number", "Bad radius")

	local px, py, pz = position.X, position.Y, position.Z
	local objects, nodeDistances2 = self:_radiusSearch(px, py, pz, radius)

	local sortable = {}
	for index, dist2 in pairs(nodeDistances2) do
		table.insert(sortable, {
			dist2 = dist2;
			index = index;
		})
	end

	table.sort(sortable, function(a, b)
		return a.dist2 < b.dist2
	end)

	local knearest = {}
	local knearestDist2 = {}
	for i = 1, math.min(#sortable, k) do
		local sorted = sortable[i]
		knearestDist2[#knearestDist2 + 1] = sorted.dist2
		knearest[#knearest + 1] = objects[sorted.index]
	end

	return knearest, knearestDist2
end

--[=[
	Internal API to create lowest subregion

	@private
	@param px number
	@param py number
	@param pz number
	@return OctreeSubregion
]=]
function Octree.GetOrCreateLowestSubRegion(self: OctreeType, px: number, py: number, pz: number)
	local region = self:_getOrCreateRegion(px, py, pz)
	return OctreeRegionUtils.getOrCreateSubRegionAtDepth(region, px, py, pz, self._maxDepth)
end

function Octree._radiusSearch(self: OctreeType, px: number, py: number, pz: number, radius: number)
	local objectsFound = {}
	local nodeDistances2 = {}

	local diameter = self._maxRegionSize[1]
	local searchRadiusSquared = OctreeRegionUtils.getSearchRadiusSquared(radius, diameter, EPSILON)

	for _, regionList in pairs(self._regionHashMap) do
		for _, region in pairs(regionList) do
			local rpos = region.position
			local rpx, rpy, rpz = rpos[1], rpos[2], rpos[3]
			local ox, oy, oz = px - rpx, py - rpy, pz - rpz
			local dist2 = ox*ox + oy*oy + oz*oz

			if dist2 <= searchRadiusSquared then
				OctreeRegionUtils.getNeighborsWithinRadius(
					region, radius, px, py, pz, objectsFound, nodeDistances2, self._maxDepth)
			end
		end
	end

	return objectsFound, nodeDistances2
end

function Octree._getRegion(self: OctreeType, px: number, py: number, pz: number)
	return OctreeRegionUtils.findRegion(self._regionHashMap, self._maxRegionSize, px, py, pz)
end

function Octree._getOrCreateRegion(self: OctreeType, px: number, py: number, pz: number)
	return OctreeRegionUtils.getOrCreateRegion(self._regionHashMap, self._maxRegionSize, px, py, pz)
end

return Octree]]></ProtectedString>
							<int64 name="SourceAssetId">17832484743</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042bb</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX2589010E63ED45DA8E14B313F04DCD3E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009676</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_OctreeNode</string>
								<string name="ScriptGuid">{FF14AD8D-7BAA-412A-ABA7-F55E0A9E20A3}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--!native
--[=[
	Basic node interacting with the octree. See [Octree](/api/Octree) for usage.

	```lua
	local octree = Octree.new()
	local node = octree:CreateNode(Vector3.zero, "A")
	print(octree:RadiusSearch(Vector3.zero, 100)) --> { "A" }

	node:Destroy() -- Remove node from octree

	print(octree:RadiusSearch(Vector3.zero, 100)) --> { }
	```
	@class OctreeNode
]=]
local OctreeRegionUtils = require(script.Parent._OctreeRegionUtils)

local OctreeNode = {}
OctreeNode.ClassName = "OctreeNode"
OctreeNode.__index = OctreeNode

type fields = {
	_octree: any,
	_object: any,
	_currentLowestRegion: any,
	_position: any,
	_px: any,
	_py: any,
	_pz: any,
}

export type OctreeNodeType = typeof(setmetatable({} :: fields, OctreeNode))

--[=[
	Creates a new for the given Octree with the object.

	:::warning
	Use Octree:CreateNode() for more consistent results. To use this object directly
	you need to set the position before it's registered which may be unclean.
	:::

	@private
	@param octree Octree
	@param object T
	@return OctreeNode<T>
]=]
function OctreeNode.new(octree: any, object: any): OctreeNodeType
	local self = setmetatable({}, OctreeNode)

	self._octree = octree or error("No octree")
	self._object = object or error("No object")

	self._currentLowestRegion = nil
	self._position = nil

	return self
end

--[=[
	Finds the nearest neighbors to this node within the radius

	```lua
	local octree = Octree.new()
	local node = octree:CreateNode(Vector3.zero, "A")
	octree:CreateNode(Vector3.new(0, 0, 5), "B")
	print(octree:KNearestNeighborsSearch(10, 100)) --> { "A", "B" } { 0, 25 }
	```

	@param k number -- The number to retrieve
	@param radius number -- The radius to search in
	@return { T } -- Objects found, including self
	@return { number } -- Distances squared
]=]
function OctreeNode.KNearestNeighborsSearch(self: OctreeNodeType, k: number, radius: number): ( {any}, { number } )
	return self._octree:KNearestNeighborsSearch(self._position, k, radius)
end

--[=[
	Returns the object stored in the octree

	```lua
	local octree = Octree.new()
	local node = octree:CreateNode(Vector3.zero, "A")
	print(octree:GetObject()) --> "A"
	```

	@return T
]=]
function OctreeNode.GetObject(self: OctreeNodeType)
	return self._object
end

--[=[
	Finds the nearest neighbors to the octree node

	@param radius number -- The radius to search in
	@return { any } -- Objects found
	@return { number } -- Distances squared
]=]
function OctreeNode.RadiusSearch(self: OctreeNodeType, radius: number): ({ any }, { number })
	return self._octree:RadiusSearch(self._position, radius)
end

--[=[
	Retrieves the position

	@return Vector3
]=]
function OctreeNode.GetPosition(self: OctreeNodeType): Vector3
	return self._position
end

--[=[
	Retrieves the as px, py, pz

	@return number -- px
	@return number -- py
	@return number -- pz
]=]
function OctreeNode.GetRawPosition(self: OctreeNodeType): (number, number, number)
	return self._px, self._py, self._pz
end

--[=[
	Sets the position of the octree nodes and updates the octree accordingly

	```lua
	local octree = Octree.new()
	local node = octree:CreateNode(Vector3.zero, "A")
	print(octree:RadiusSearch(Vector3.zero, 100)) --> { "A" }

	node:SetPosition(Vector3.new(1000, 0, 0))
	print(octree:RadiusSearch(Vector3.zero, 100)) --> {}
	```

	@param position Vector3
]=]
function OctreeNode.SetPosition(self: OctreeNodeType,position: Vector3)
	if self._position == position then
		return
	end

	local px, py, pz = position.X, position.Y, position.Z

	self._px = px
	self._py = py
	self._pz = pz
	self._position = position

	if self._currentLowestRegion then
		if OctreeRegionUtils.inRegionBounds(self._currentLowestRegion, px, py, pz) then
			return
		end
	end

	local newLowestRegion = self._octree:GetOrCreateLowestSubRegion(px, py, pz)

	-- Sanity check for debugging
	-- if not OctreeRegionUtils.inRegionBounds(newLowestRegion, px, py, pz) then
	-- 	error("[OctreeNode.SetPosition] newLowestRegion is not in region bounds!")
	-- end

	if self._currentLowestRegion then
		OctreeRegionUtils.moveNode(self._currentLowestRegion, newLowestRegion, self)
	else
		OctreeRegionUtils.addNode(newLowestRegion, self)
	end

	self._currentLowestRegion = newLowestRegion
end

--[=[
	Removes the OctreeNode from the octree
]=]
function OctreeNode.Destroy(self: OctreeNodeType)
	if self._currentLowestRegion then
		OctreeRegionUtils.removeNode(self._currentLowestRegion, self)
	end
end

return OctreeNode]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042bc</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0F7B58C7175F4DC3A4EC1D45FD1B48C1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009677</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_OctreeRegionUtils</string>
								<string name="ScriptGuid">{93583063-2D1B-4ADF-87AB-595BD9AA31D2}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--!native
--[=[
	Octree implementation utilities. Primarily this utility code
	should not be used directly and should be considered private to
	the library.

	Use [Octree](/api/Octree) instead of this library directly.

	@class OctreeRegionUtils
]=]

local EPSILON = 1e-6
local SQRT_3_OVER_2 = math.sqrt(3)/2
local SUB_REGION_POSITION_OFFSET = {
	{ 0.25, 0.25, -0.25 };
	{ -0.25, 0.25, -0.25 };
	{ 0.25, 0.25, 0.25 };
	{ -0.25, 0.25, 0.25 };
	{ 0.25, -0.25, -0.25 };
	{ -0.25, -0.25, -0.25 };
	{ 0.25, -0.25, 0.25 };
	{ -0.25, -0.25, 0.25 };
}

local OctreeRegionUtils = {}

--[=[
	Visualizes the octree region.

	@param region OctreeRegion<T>
	@return MaidTask
]=]
function OctreeRegionUtils.visualize(region)
	local size = region.size
	local position = region.position
	local sx, sy, sz = size[1], size[2], size[3]
	local px, py, pz = position[1], position[2], position[3]

	--local box = Draw.box(Vector3.new(px, py, pz), Vector3.new(sx, sy, sz))
	--box.Transparency = 0.9
	--box.Name = "OctreeRegion_" .. tostring(region.depth)

	--return box
end

--[=[
	A Vector3 equivalent for octrees. This type is primarily internal and
	used for faster access than a Vector3.

	@type OctreeVector3 { [1]: number, [2]: number, [3]: number }
	@within OctreeRegionUtils
]=]

--[=[
	An internal region which stores the data.

	@interface OctreeRegion<T>
	.subRegions { OctreeRegion<T> }
	.lowerBounds OctreeVector3
	.upperBounds OctreeVector3
	.position OctreeVector3
	.size OctreeVector3
	.parent OctreeRegion<T>?
	.parentIndex number
	.depth number
	.nodes { OctreeNode<T> }
	.node_count number
	@within OctreeRegionUtils
]=]

--[=[
	Creates a new OctreeRegion<T>

	@param px number
	@param py number
	@param pz number
	@param sx number
	@param sy number
	@param sz number
	@param parent OctreeRegion<T>?
	@param parentIndex number?
	@return OctreeRegion<T>
]=]
function OctreeRegionUtils.create(px: number, py: number, pz: number, sx: number, sy: number, sz: number, parent: any, parentIndex: any)
	local hsx, hsy, hsz = sx/2, sy/2, sz/2

	local region = {
		subRegions = {
			--topNorthEast
			--topNorthWest
			--topSouthEast
			--topSouthWest
			--bottomNorthEast
			--bottomNorthWest
			--bottomSouthEast
			--bottomSouthWest
		};
		lowerBounds = { px - hsx, py - hsy, pz - hsz };
		upperBounds = { px + hsx, py + hsy, pz + hsz };
		position = { px, py, pz };
		size = { sx, sy, sz }; -- { sx, sy, sz }
		parent = parent;
		depth = parent and (parent.depth + 1) or 1;
		parentIndex = parentIndex;
		nodes = {}; -- [node] = true (contains subchild nodes too)
		node_count = 0;
	}

	-- if region.depth >= 5 then
	-- 	OctreeRegionUtils.visualize(region)
	-- end

	return region
end

--[=[
	Adds a node to the lowest subregion
	@param lowestSubregion OctreeRegion<T>
	@param node OctreeNode
]=]
function OctreeRegionUtils.addNode(lowestSubregion: any, node: any)
	assert(node, "Bad node")

	local current = lowestSubregion
	while current do
		if not current.nodes[node] then
			current.nodes[node] = node
			current.node_count = current.node_count + 1
		end
		current = current.parent
	end
end

--[=[
	Moves a node from one region to another

	@param fromLowest OctreeRegion<T>
	@param toLowest OctreeRegion<T>
	@param node OctreeNode
]=]
function OctreeRegionUtils.moveNode(fromLowest: any, toLowest: any, node: any)
	assert(fromLowest.depth == toLowest.depth, "fromLowest.depth ~= toLowest.depth")
	assert(fromLowest ~= toLowest, "fromLowest == toLowest")

	local currentFrom = fromLowest
	local currentTo = toLowest
	while currentFrom ~= currentTo do
		-- remove from current
		do
			assert(currentFrom.nodes[node], "Not in currentFrom")
			assert(currentFrom.node_count > 0, "No nodes in currentFrom")

			currentFrom.nodes[node] = nil
			currentFrom.node_count = currentFrom.node_count - 1

			-- remove subregion!
			if currentFrom.node_count <= 0 and currentFrom.parentIndex then
				assert(currentFrom.parent, "Bad currentFrom.parent")
				assert(currentFrom.parent.subRegions[currentFrom.parentIndex] == currentFrom, "Not in subregion")
				currentFrom.parent.subRegions[currentFrom.parentIndex] = nil
			end
		end

		-- add to new
		do
			assert(not currentTo.nodes[node], "Failed to add")
			currentTo.nodes[node] = node
			currentTo.node_count = currentTo.node_count + 1
		end

		currentFrom = currentFrom.parent
		currentTo = currentTo.parent
	end
end

--[=[
	Removes a node from the given region

	@param lowestSubregion OctreeRegion<T>
	@param node OctreeNode
]=]
function OctreeRegionUtils.removeNode(lowestSubregion, node)
	assert(node, "Bad node")

	local current = lowestSubregion
	while current do
		assert(current.nodes[node], "Not in current")
		assert(current.node_count > 0, "Current has bad node count")

		current.nodes[node] = nil
		current.node_count = current.node_count - 1

		-- remove subregion!
		if current.node_count <= 0 and current.parentIndex then
			assert(current.parent, "No parent")
			assert(current.parent.subRegions[current.parentIndex] == current, "Not in subregion")
			current.parent.subRegions[current.parentIndex] = nil
		end

		current = current.parent
	end
end


--[=[
	Retrieves the search radius for a given radius given the region
	diameter

	@param radius number
	@param diameter number
	@param epsilon number
	@return number
]=]
function OctreeRegionUtils.getSearchRadiusSquared(radius: number, diameter: number, epsilon: number): number
	local diagonal = SQRT_3_OVER_2*diameter
	local searchRadius = radius + diagonal
	return searchRadius*searchRadius + epsilon
end

-- luacheck: push ignore
--[=[
	Adds all octree nod values to objectsFound

	See basic algorithm:
	https://github.com/PointCloudLibrary/pcl/blob/29f192af57a3e7bdde6ff490669b211d8148378f/octree/include/pcl/octree/impl/octree_search.hpp#L309

	@param region OctreeRegion<T>
	@param radius number
	@param px number
	@param py number
	@param pz number
	@param objectsFound { T }
	@param nodeDistances2 { number }
	@param maxDepth number
]=]
function OctreeRegionUtils.getNeighborsWithinRadius(region: any, radius: number, px: number, py: number, pz: number, objectsFound: any, nodeDistances2: any, maxDepth: number)
	-- luacheck: pop
	assert(maxDepth, "Bad maxDepth")

	local childDiameter = region.size[1]/2
	local searchRadiusSquared = OctreeRegionUtils.getSearchRadiusSquared(radius, childDiameter, EPSILON)

	local radiusSquared = radius*radius

	-- for each child
	for _, childRegion in pairs(region.subRegions) do
		local cposition = childRegion.position
		local cpx, cpy, cpz = cposition[1], cposition[2], cposition[3]

		local ox, oy, oz = px - cpx, py - cpy, pz - cpz
		local dist2 = ox*ox + oy*oy + oz*oz

		-- within search radius
		if dist2 <= searchRadiusSquared then
			if childRegion.depth == maxDepth then
				for node, _ in pairs(childRegion.nodes) do
					local npx, npy, npz = node:GetRawPosition()
					local nox, noy, noz = px - npx, py - npy, pz - npz
					local ndist2 = nox*nox + noy*noy + noz*noz
					if ndist2 <= radiusSquared then
						objectsFound[#objectsFound + 1] = node:GetObject()
						nodeDistances2[#nodeDistances2 + 1] = ndist2
					end
				end
			else
				OctreeRegionUtils.getNeighborsWithinRadius(
					childRegion, radius, px, py, pz, objectsFound, nodeDistances2, maxDepth)
			end
		end
	end
end

--[=[
	Recursively ensures that a subregion exists at a given depth, and returns
	that region for usage.

	@param region OctreeRegion<T> -- Top level region
	@param px number
	@param py number
	@param pz number
	@param maxDepth number
	@return OctreeRegion<T>
]=]
function OctreeRegionUtils.getOrCreateSubRegionAtDepth(region, px, py, pz, maxDepth)
	local current = region
	for _ = region.depth, maxDepth do
		local index = OctreeRegionUtils.getSubRegionIndex(current, px, py, pz)
		local _next = current.subRegions[index]

		-- construct
		if not _next then
			_next = OctreeRegionUtils.createSubRegion(current, index)
			current.subRegions[index] = _next
		end

		-- iterate
		current = _next
	end
	return current
end

--[=[
	Creates a subregion for an octree.
	@param parentRegion OctreeRegion<T>
	@param parentIndex number
	@return OctreeRegion<T>
]=]
function OctreeRegionUtils.createSubRegion(parentRegion: any, parentIndex: number)
	local size = parentRegion.size
	local position = parentRegion.position
	local multiplier = SUB_REGION_POSITION_OFFSET[parentIndex]

	local px = position[1] + multiplier[1]*size[1]
	local py = position[2] + multiplier[2]*size[2]
	local pz = position[3] + multiplier[3]*size[3]
	local sx, sy, sz = size[1]/2, size[2]/2, size[3]/2

	return OctreeRegionUtils.create(px, py, pz, sx, sy, sz, parentRegion, parentIndex)
end

--[=[
	Computes whether a region is in bounds.

	Consider regions to be range [px, y).

	@param region OctreeRegion<T>
	@param px number
	@param py number
	@param pz number
	@return boolean
]=]
function OctreeRegionUtils.inRegionBounds(region: any, px: number, py: number, pz: number)
	local lowerBounds = region.lowerBounds
	local upperBounds = region.upperBounds
	return (
		px >= lowerBounds[1] and px <= upperBounds[1] and
			py >= lowerBounds[2] and py <= upperBounds[2] and
			pz >= lowerBounds[3] and pz <= upperBounds[3]
	)
end

--[=[
	Gets a subregion's internal index.

	@param region OctreeRegion<T>
	@param px number
	@param py number
	@param pz number
	@return number
]=]
function OctreeRegionUtils.getSubRegionIndex(region: any, px: number, py: number, pz: number)
	local index = px > region.position[1] and 1 or 2
	if py <= region.position[2] then
		index = index + 4
	end

	if pz >= region.position[3] then
		index = index + 2
	end
	return index
end

--[=[
	This definitely collides fairly consistently

	See: https://stackoverflow.com/questions/5928725/hashing-2d-3d-and-nd-vectors

	@param cx number
	@param cy number
	@param cz number
	@return number
]=]
function OctreeRegionUtils.getTopLevelRegionHash(cx: number, cy: number, cz: number)
	-- Normally you would modulus this to hash table size, but we want as flat of a structure as possible
	return cx * 73856093 + cy*19351301 + cz*83492791
end

--[=[
	Computes the index for a top level cell given a position

	@param maxRegionSize OctreeVector3
	@param px number
	@param py number
	@param pz number
	@return number -- rpx
	@return number -- rpy
	@return number -- rpz
]=]
function OctreeRegionUtils.getTopLevelRegionCellIndex(maxRegionSize: any, px: number, py: number, pz: number)
	return math.floor(px / maxRegionSize[1] + 0.5),
		math.floor(py / maxRegionSize[2] + 0.5),
		math.floor(pz / maxRegionSize[3] + 0.5)
end

--[=[
	Computes a top-level region's position

	@param maxRegionSize OctreeVector3
	@param cx number
	@param cy number
	@param cz number
	@return number
	@return number
	@return number
]=]
function OctreeRegionUtils.getTopLevelRegionPosition(maxRegionSize: any, cx: number, cy: number, cz: number)
	return maxRegionSize[1] * cx,
		maxRegionSize[2] * cy,
		maxRegionSize[3] * cz
end

--[=[
	Given a top-level region, returns if the region position are equal
	to this region

	@param region OctreeRegion<T>
	@param rpx number
	@param rpy number
	@param rpz number
	@return boolean
]=]
function OctreeRegionUtils.areEqualTopRegions(region: any, rpx: number, rpy: number, rpz: number)
	local position = region.position
	return position[1] == rpx
		and position[2] == rpy
		and position[3] == rpz
end

--[=[
	Given a world space position, finds the current region in the hashmap

	@param regionHashMap { [number]: { OctreeRegion<T> } }
	@param maxRegionSize OctreeVector3
	@param px number
	@param py number
	@param pz number
	@return OctreeRegion3?
]=]
function OctreeRegionUtils.findRegion(regionHashMap: any, maxRegionSize: any, px: number, py: number, pz: number)
	local cx, cy, cz = OctreeRegionUtils.getTopLevelRegionCellIndex(maxRegionSize, px, py, pz)
	local hash = OctreeRegionUtils.getTopLevelRegionHash(cx, cy, cz)

	local regionList = regionHashMap[hash]
	if not regionList then
		return nil
	end

	local rpx, rpy, rpz = OctreeRegionUtils.getTopLevelRegionPosition(maxRegionSize, cx, cy, cz)
	for _, region in pairs(regionList) do
		if OctreeRegionUtils.areEqualTopRegions(region, rpx, rpy, rpz) then
			return region
		end
	end

	return nil
end

--[=[
	Gets the current region for a position, or creates a new one.

	@param regionHashMap { [number]: { OctreeRegion<T> } }
	@param maxRegionSize OctreeVector3
	@param px number
	@param py number
	@param pz number
	@return OctreeRegion<T>
]=]
function OctreeRegionUtils.getOrCreateRegion(regionHashMap: any, maxRegionSize: any, px: number, py: number, pz: number)
	local cx, cy, cz = OctreeRegionUtils.getTopLevelRegionCellIndex(maxRegionSize, px, py, pz)
	local hash = OctreeRegionUtils.getTopLevelRegionHash(cx, cy, cz)

	local regionList = regionHashMap[hash]
	if not regionList then
		regionList = {}
		regionHashMap[hash] = regionList
	end

	local rpx, rpy, rpz = OctreeRegionUtils.getTopLevelRegionPosition(maxRegionSize, cx, cy, cz)
	for _, region in pairs(regionList) do
		if OctreeRegionUtils.areEqualTopRegions(region, rpx, rpy, rpz) then
			return region
		end
	end

	local region = OctreeRegionUtils.create(
		rpx, rpy, rpz,
		maxRegionSize[1], maxRegionSize[2], maxRegionSize[3])
	table.insert(regionList, region)

	return region
end

return OctreeRegionUtils]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042bd</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX2FBEA015974E4582AC600B99070FF0A8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009678</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Timer</string>
							<string name="ScriptGuid">{A29EC813-2870-4322-A92A-AE5AF2ED88C8}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
-- Timer
-- Stephen Leitnick
-- July 28, 2021

--[=[
	@within Timer
	@type CallbackFn () -> ()
	Callback function.
]=]
type CallbackFn = () -> nil

--[=[
	@within Timer
	@type TimeFn () -> number
	Time function.
]=]
type TimeFn = () -> number

local Signal = require(script.Parent._Signal)

local RunService = game:GetService("RunService")

--[=[
	@class Timer

	The Timer class allows for code to run periodically at specified intervals.

	```lua
	local timer = Timer.new(2)
	timer.Tick:Connect(function()
		print("Tock")
	end)
	timer:Start()
	```
]=]
local Timer = {}
Timer.__index = Timer

type self = {
	_runHandle: RBXScriptConnection?,
	Interval: number,
	UpdateSignal: RBXScriptSignal,
	TimeFunction: typeof(time),
	AllowDrift: boolean,
	Tick: Signal.SignalType<() -> ()>
}
export type TimerType = typeof(setmetatable({} :: self, Timer))

--[=[
	@within Timer
	@prop Interval number
	Interval at which the `Tick` event fires.
]=]
--[=[
	@within Timer
	@prop UpdateSignal RBXScriptSignal | Signal
	The signal which updates the timer internally.
]=]
--[=[
	@within Timer
	@prop TimeFunction TimeFn
	The function which gets the current time.
]=]
--[=[
	@within Timer
	@prop AllowDrift boolean
	Flag which indicates if the timer is allowed to drift. This
	is set to `true` by default. This flag must be set before
	calling `Start` or `StartNow`. This flag should only be set
	to `false` if it is necessary for drift to be eliminated.
]=]
--[=[
	@within Timer
	@prop Tick RBXScriptSignal | Signal
	The event which is fired every time the timer hits its interval.
]=]

--[=[
	@return Timer
	
	Creates a new timer.
]=]
function Timer.new(interval: number)
	assert(type(interval) == "number", "Argument #1 to Timer.new must be a number")
	assert(interval >= 0, "Argument #1 to Timer.new must be greater or equal to 0")
	local self = setmetatable({}, Timer)
	self._runHandle = nil
	self.Interval = interval
	self.UpdateSignal = RunService.Heartbeat
	self.TimeFunction = time
	self.AllowDrift = true
	self.Tick = Signal.new()
	return self
end

--[=[
	@return RBXScriptConnection

	Creates a simplified timer which just fires off a callback function at the given interval.

	```lua
	-- Basic:
	Timer.Simple(1, function()
		print("Tick")
	end)

	-- Using other arguments:
	Timer.Simple(1, function()
		print("Tick")
	end, true, RunService.Heartbeat, os.clock)
	```
]=]
function Timer.Simple(
	interval: number,
	callback: CallbackFn,
	startNow: boolean?,
	updateSignal: RBXScriptSignal?,
	timeFn: TimeFn?
)
	local update = updateSignal or RunService.Heartbeat
	local t = timeFn or time
	local nextTick = t() + interval
	if startNow then
		task.defer(callback)
	end
	return update:Connect(function()
		local now = t()
		if now >= nextTick then
			nextTick = now + interval
			task.defer(callback)
		end
	end)
end

--[=[
	Returns `true` if the given object is a Timer.
]=]
function Timer.Is(obj: any): boolean
	return type(obj) == "table" and getmetatable(obj) == Timer
end

function Timer:_startTimer()
	local t = self.TimeFunction
	local nextTick = t() :: number + self.Interval
	self._runHandle = self.UpdateSignal:Connect(function()
		local now = t()
		if now >= nextTick then
			nextTick = now + self.Interval
			self.Tick:Fire()
		end
	end)
end

function Timer:_startTimerNoDrift()
	assert(self.Interval > 0, "Interval must be greater than 0 when AllowDrift is set to false")
	local t = self.TimeFunction
	local n = 1
	local start = t() :: number
	local nextTick = start + self.Interval
	self._runHandle = self.UpdateSignal:Connect(function()
		local now = t()
		while now >= nextTick do
			n += 1
			nextTick = start + (self.Interval * n)
			self.Tick:Fire()
		end
	end)
end

--[=[
	Starts the timer. Will do nothing if the timer is already running.

	```lua
	timer:Start()
	```
]=]
function Timer:Start()
	if self._runHandle then
		return
	end
	if self.AllowDrift then
		self:_startTimer()
	else
		self:_startTimerNoDrift()
	end
end

--[=[
	Starts the timer and fires off the Tick event immediately. Will do
	nothing if the timer is already running.

	```lua
	timer:StartNow()
	```
]=]
function Timer:StartNow()
	if self._runHandle then
		return
	end
	self.Tick:Fire()
	self:Start()
end

--[=[
	Stops the timer. Will do nothing if the timer is already stopped.

	```lua
	timer:Stop()
	```
]=]
function Timer.Stop(self: TimerType)
	if not self._runHandle then
		return
	end
	self._runHandle:Disconnect()
	self._runHandle = nil
end

--[=[
	Returns `true` if the timer is currently running.

	```lua
	if timer:IsRunning() then
		-- Do something
	end
	```
]=]
function Timer:IsRunning(): boolean
	return self._runHandle ~= nil
end

--[=[
	Destroys the timer. This will also stop the timer.
]=]
function Timer:Destroy()
	self.Tick:Destroy()
	self:Stop()
end

return Timer]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042be</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXCDCB671374B545ABA46A8F57CF4107C5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c1e</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Future</string>
							<string name="ScriptGuid">{94BBACC9-F750-4591-9A47-7E2843AF78C7}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local _game = require("../FunctionUtils/_game")
local spawn = _game.spawn

export type Future<T...> = {
	ValueList: { any }?,
	AfterList: { (T...) -> () },
	YieldList: { thread },
	Cancelled: boolean,

	IsComplete: typeof(
		-- Returns a boolean indicating whether the Future is complete.
		function(self: Future<T...>): boolean
			return nil :: any
		end
	),
	IsPending: typeof(
		-- Returns a boolean indicating whether the Future is pending.
		function(self: Future<T...>): boolean
			return nil :: any
		end
	),

	Expect: typeof(
		-- Returns the values of the Future if complete, otherwise it errors with the provided message
		function(self: Future<T...>, Message: string): T...
			
		end
	),
	Unwrap: typeof(
		-- Returns the values of the Future if complete, otherwise it errors.
		function(self: Future<T...>): T...
			
		end
	),
	UnwrapOr: typeof(
		-- Returns the values of the Future if complete, otherwise it returns the provided default values.
		function(self: Future<T...>, ...: T...): T...
			
		end
	),
	UnwrapOrElse: typeof(
		-- Returns the values of the Future if complete, otherwise it calls the provided function and returns the values of the Future returned by the function.
		function(self: Future<T...>, Else: () -> T...): T...
			
		end
	),

	After: typeof(
		-- Calls a function with the values a Future completes with after the future is completed.
		function(self: Future<T...>, Callback: (T...) -> ()): ()
			
		end
	),
	Await: typeof(
		-- Returns the values of the Future if complete, otherwise it yields the current thread until the Future is completed.
		function(self: Future<T...>): T...
			
		end
	),
	Cancel: typeof(
		-- Attempts to cancel the Future. This will not work if the Future is already complete.
		function(self: Future<T...>)
			
		end
	)
}

local function IsComplete<T...>(self: Future<T...>): boolean
	return self.ValueList ~= nil
end

local function IsPending<T...>(self: Future<T...>): boolean
	return self.ValueList == nil
end

local function Expect<T...>(self: Future<T...>, Message: string): T...
	assert(self.ValueList, Message)

	return table.unpack(self.ValueList)
end

local function Unwrap<T...>(self: Future<T...>): T...
	return self:Expect("Attempt to unwrap pending future!")
end

local function UnwrapOr<T...>(self: Future<T...>, ...): T...
	if self.ValueList then
		return table.unpack(self.ValueList)
	else
		return ...
	end
end

local function UnwrapOrElse<T...>(self: Future<T...>, Else: () -> T...): T...
	if self.ValueList then
		return table.unpack(self.ValueList)
	else
		return Else()
	end
end

local function After<T...>(self: Future<T...>, Callback: (T...) -> ())
	if self.Cancelled then
		return
	end
	
	if self.ValueList then
		spawn(Callback, table.unpack(self.ValueList))
	else
		table.insert(self.AfterList, Callback)
	end
end

local function Await<T...>(self: Future<T...>): T...
	if self.Cancelled then
		error(`Cannot :Await() a cancelled Future`, 2)
	end
	
	if self.ValueList then
		return table.unpack(self.ValueList)
	else
		table.insert(self.YieldList, coroutine.running())

		return coroutine.yield()
	end
end

local function Cancel<T...>(self: Future<T...>)
	if self.ValueList then
		-- Already resolved, cannot cancel
		return
	end

	self.Cancelled = true
	
	-- Cancel any threads waiting on this Future
	for _, thread in ipairs(self.YieldList) do
		if coroutine.status(thread) == "suspended" then
			task.cancel(thread)
		end
	end
	
	self.AfterList = {} -- Clear callbacks
	self.YieldList = {} -- Clear yielding threads
end

-- The given function is called in a new thread, and the Future is completed with the return values of the function.
local function Future<T..., A...>(callback: (A...) -> T..., ...: A...): Future<T...>
	local self: Future<T...> = {
		ValueList = nil,
		AfterList = {},
		YieldList = {},

		IsComplete = IsComplete,
		IsPending = IsPending,

		Expect = Expect,
		Unwrap = Unwrap,
		UnwrapOr = UnwrapOr,
		UnwrapOrElse = UnwrapOrElse,
		Cancel = Cancel,
		
		After = After,
		Await = Await,
	} :: any

	spawn(function(self: Future<T...>, callback: (A...) -> T..., ...: A...)
		if self.Cancelled then
			return
		end
		
		local ValueList = { callback(...) }
		self.ValueList = ValueList

		for _, Thread in self.YieldList do
			task.spawn(Thread, table.unpack(ValueList))
		end

		for _, Callback in self.AfterList do
			spawn(Callback, table.unpack(ValueList))
		end
	end, self, callback, ...)

	return self
end

-- This constructor wraps the given function and arguments in a pcall.
-- The returned Future will be completed with the return values of the pcall, including the success boolean.
local function Try<T..., A...>(callback: (A...) -> T..., ...: A...): Future<(boolean, T...)>
	return Future(pcall, callback, ...)
end

-- Waits for all futures to complete and returns a future that resolves with an array of their results.
-- Returns an immediately resolved Future if the future array is empty.
local function All(futures: { Future<...any> }): Future<{ { any } }>
	if #futures == 0 then
		return Future(function()
			return {}
		end)
	end
	return Future(function()
		local results = table.create(#futures)
		local completedCount = 0

		local currentThread = coroutine.running()
		local completed = false

		for i, future in ipairs(futures) do
			future:After(function(...)
				if completed then
					return
				end

				results[i] = { ... }

				completedCount += 1
				if completedCount == #futures then
					completed = true
					if coroutine.status(currentThread) == "suspended" then
						task.spawn(currentThread, results)
					end
				end
			end)
		end
		
		if completed then
			return results
		end
		return coroutine.yield()
	end)
end

return {
	new = Future,
	try = Try,
	all = All
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042bf</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5F98AA22F376488080B35022BA870C51">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc082180130000967a</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Shake</string>
							<string name="ScriptGuid">{59F06013-87EC-4C0C-9B67-880F08F3E8A9}</string>
							<ProtectedString name="Source"><![CDATA[--!native

-- Shake
-- Stephen Leitnick
-- December 09, 2021

local RunService = game:GetService("RunService")

--[=[
	@within Shake
	@type UpdateCallbackFn () -> (position: Vector3, rotation: Vector3, completed: boolean)
]=]
type UpdateCallbackFn = () -> (Vector3, Vector3, boolean)

export type ShakeProperties = {
	Amplitude: number,
	Frequency: number,
	FadeInTime: number?,
	FadeOutTime: number?,
	PositionInfluence: Vector3?,
	RotationInfluence: Vector3?
}

export type ShakeType = {
	Amplitude: number,
	Frequency: number,
	FadeInTime: number,
	FadeOutTime: number,
	SustainTime: number,
	Sustain: boolean,
	PositionInfluence: Vector3,
	RotationInfluence: Vector3,
	TimeFunction: () -> number,

	Start: (self: ShakeType) -> (),
	ApplyProperties: (self: ShakeType, shakeProperties: ShakeProperties) -> (),
	Stop: (self: ShakeType) -> (),
	IsShaking: (self: ShakeType) -> boolean,
	StopSustain: (self: ShakeType) -> (),
	Update: (self: ShakeType) -> (Vector3, Vector3, boolean),
	OnSignal: (
		self: ShakeType,
		signal: RBXScriptSignal,
		callback: (Vector3, Vector3, boolean) -> ()
	) -> RBXScriptConnection,
	BindToRenderStep: (self: ShakeType, name: string, priority: number, callback: (positionOffset: Vector3, rotationOffset: Vector3, done: boolean) -> ()) -> (),
	Clone: (self: ShakeType) -> Shake,
	Destroy: (self: ShakeType) -> (),
}

local rng = Random.new(tick())
local renderId = 0

--[=[
	@class Shake
	Create realistic shake effects, such as camera or object shakes.

	Creating a shake is very simple with this module. For every shake,
	simply create a shake instance by calling `Shake.new()`. From
	there, configure the shake however desired. Once configured,
	call `shake:Start()` and then bind a function to it with either
	`shake:OnSignal(...)` or `shake:BindToRenderStep(...)`.
	
	The shake will output its values to the connected function, and then
	automatically stop and clean up its HANDLERS once completed.

	Shake instances can be reused indefinitely. However, only one shake
	operation per instance can be running. If more than one is needed
	of the same configuration, simply call `shake:Clone()` to duplicate
	it.

	Example of a simple camera shake:
	```lua
	local priority = Enum.RenderPriority.Last.Value

	local shake = Shake.new()
	shake.FadeInTime = 0
	shake.Frequency = 0.1
	shake.Amplitude = 5
	shake.RotationInfluence = Vector3.new(0.1, 0.1, 0.1)

	shake:Start()
	shake:BindToRenderStep(Shake.NextRenderName(), priority, function(pos, rot, isDone)
		camera.CFrame *= CFrame.new(pos) * CFrame.Angles(rot.X, rot.Y, rot.Z)
	end)
	```

	Shakes will automatically stop once the shake has been completed. Shakes can
	also be used continuously if the `Sustain` property is set to `true`.

	Here are some more helpful configuration examples:

	```lua
	local shake = Shake.new()

	-- The magnitude of the shake. Larger numbers means larger shakes.
	shake.Amplitude = 5

	-- The speed of the shake. Smaller frequencies mean faster shakes.
	shake.Frequency = 0.1

	 -- Fade-in time before max amplitude shake. Set to 0 for immediate shake.
	shake.FadeInTime = 0

	-- Fade-out time. Set to 0 for immediate cutoff.
	shake.FadeOutTime = 0

	-- How long the shake sustains full amplitude before fading out
	shake.SustainTime = 1

	-- Set to true to never end the shake. Call shake:StopSustain() to start the fade-out.
	shake.Sustain = true

	-- Multiplies against the shake vector to control the final amplitude of the position.
	-- Can be seen internally as: position = shakeVector * fadeInOut * positionInfluence
	shake.PositionInfluence = Vector3.one

	-- Multiplies against the shake vector to control the final amplitude of the rotation.
	-- Can be seen internally as: position = shakeVector * fadeInOut * rotationInfluence
	shake.RotationInfluence = Vector3.new(0.1, 0.1, 0.1)

	```
]=]
local Shake = {}
Shake.__index = Shake

--[=[
	@within Shake
	@prop Amplitude number
	Amplitude of the overall shake. For instance, an amplitude of `3` would mean the
	peak magnitude for the outputted shake vectors would be about `3`.

	Defaults to `1`.
]=]

--[=[
	@within Shake
	@prop Frequency number
	Frequency of the overall shake. This changes how slow or fast the
	shake occurs.

	Defaults to `1`.
]=]

--[=[
	@within Shake
	@prop FadeInTime number
	How long it takes for the shake to fade in, measured in seconds.

	Defaults to `1`.
]=]

--[=[
	@within Shake
	@prop FadeOutTime number
	How long it takes for the shake to fade out, measured in seconds.

	Defaults to `1`.
]=]

--[=[
	@within Shake
	@prop SustainTime number
	How long it takes for the shake sustains itself after fading in and
	before fading out.
	
	To sustain a shake indefinitely, set `Sustain`
	to `true`, and call the `StopSustain()` method to stop the sustain
	and fade out the shake effect.

	Defaults to `0`.
]=]

--[=[
	@within Shake
	@prop Sustain boolean
	If `true`, the shake will sustain itself indefinitely once it fades
	in. If `StopSustain()` is called, the sustain will end and the shake
	will fade out based on the `FadeOutTime`.

	Defaults to `false`.
]=]

--[=[
	@within Shake
	@prop PositionInfluence Vector3
	This is similar to `Amplitude` but multiplies against each axis
	of the resultant shake vector, and only affects the position vector.

	Defaults to `Vector3.one`.
]=]

--[=[
	@within Shake
	@prop RotationInfluence Vector3
	This is similar to `Amplitude` but multiplies against each axis
	of the resultant shake vector, and only affects the rotation vector.

	Defaults to `Vector3.one`.
]=]

--[=[
	@within Shake
	@prop TimeFunction () -> number
	The function used to get the current time. This defaults to
	`time` during runtime, and `os.clock` otherwise. Usually this
	will not need to be set, but it can be optionally configured
	if desired.
]=]

--[=[
	@return Shake
	Construct a new Shake instance.
]=]
function Shake.new(): ShakeType
	local self = setmetatable({}, Shake)

	self.Amplitude = 1
	self.Frequency = 1
	self.FadeInTime = 1
	self.FadeOutTime = 1
	self.SustainTime = 0
	self.Sustain = false
	self.PositionInfluence = Vector3.one
	self.RotationInfluence = Vector3.one
	self.TimeFunction = if RunService:IsRunning() then time else os.clock

	self._timeOffset = rng:NextNumber(-1e6, 1e6)
	self._startTime = 0
	self._running = false
	self._signalHANDLERS = {}
	self._renderBindings = {}

	return self
end

--[=[
	Apply an inverse square intensity multiplier to the given vector based on the
	distance away from some source. This can be used to simulate shake intensity
	based on the distance the shake is occurring from some source.

	For instance, if the shake is caused by an explosion in the game, the shake
	can be calculated as such:

	```lua
	local function Explosion(positionOfExplosion: Vector3)

		local cam = workspace.CurrentCamera
		local renderPriority = Enum.RenderPriority.Last.Value

		local shake = Shake.new()
		-- Set shake properties here

		local function ExplosionShake(pos: Vector3, rot: Vector3)
			local distance = (cam.CFrame.Position - positionOfExplosion).Magnitude
			pos = Shake.InverseSquare(pos, distance)
			rot = Shake.InverseSquare(rot, distance)
			cam.CFrame *= CFrame.new(pos) * CFrame.Angles(rot.X, rot.Y, rot.Z)
		end

		shake:BindToRenderStep("ExplosionShake", renderPriority, ExplosionShake)

	end
	```
]=]
function Shake.InverseSquare(shake: Vector3, distance: number): Vector3
	if distance < 1 then
		distance = 1
	end
	local intensity = 1 / (distance * distance)
	return shake * intensity
end

--[=[
	Returns a unique render name for every call, which can
	be used with the `BindToRenderStep` method optionally.

	```lua
	shake:BindToRenderStep(Shake.NextRenderName(), ...)
	```
]=]
function Shake.NextRenderName(): string
	renderId += 1
	return ("__shake_%.4i__"):format(renderId)
end

--[=[
	Start the shake effect.

	:::note
	This **must** be called before calling `Update`. As such, it should also be
	called once before or after calling `OnSignal` or `BindToRenderStep` methods.
	:::
]=]
function Shake:Start()
	self._startTime = self.TimeFunction()
	self._running = true
end

--[=[
	Stops the shake effect. If using `OnSignal` or `BindToRenderStep`, those bound
	functions will be disconnected/unbound.

	`Stop` is automatically called when the shake effect is completed _or_ when the
	`Destroy` method is called.
]=]
function Shake:Stop()
	self._running = false

	for _, name in self._renderBindings do
		RunService:UnbindFromRenderStep(name)
	end
	table.clear(self._renderBindings)

	for _, conn in self._signalHANDLERS do
		conn:Disconnect()
	end
	table.clear(self._signalHANDLERS)
end

--[=[
	Returns `true` if the shake instance is currently running,
	otherwise returns `false`.
]=]
function Shake:IsShaking(): boolean
	return self._running
end

--[=[
	Schedules a sustained shake to stop. This works by setting the
	`Sustain` field to `false` and letting the shake effect fade out
	based on the `FadeOutTime` field.
]=]
function Shake:StopSustain()
	local now = self.TimeFunction()
	self.Sustain = false
	self.SustainTime = (now - self._startTime) - self.FadeInTime
end

--[=[
	Calculates the current shake vector. This should be continuously
	called inside a loop, such as `RunService.Heartbeat`. Alternatively,
	`OnSignal` or `BindToRenderStep` can be used to automatically call
	this function.

	Returns a tuple of three values:
	1. `position: Vector3` - Position shake offset
	2. `rotation: Vector3` - Rotation shake offset
	3. `completed: boolean` - Flag indicating if the shake is finished

	```lua
	local hb
	hb = RunService.Heartbeat:Connect(function()
		local offsetPosition, offsetRotation, isDone = shake:Update()
		if isDone then
			hb:Disconnect()
		end
		-- Use `offsetPosition` and `offsetRotation` here
	end)
	```
]=]
function Shake:Update(): (Vector3, Vector3, boolean)
	local done = false

	local now = self.TimeFunction()
	local dur = now - self._startTime

	local noiseInput = ((now + self._timeOffset) / self.Frequency) % 10000

	local multiplierFadeIn = 1
	local multiplierFadeOut = 1
	if dur < self.FadeInTime then
		-- Fade in
		multiplierFadeIn = dur / self.FadeInTime
	end
	if not self.Sustain and dur > self.FadeInTime + self.SustainTime then
		if self.FadeOutTime == 0 then
			done = true
		else
			-- Fade out
			multiplierFadeOut = 1 - (dur - self.FadeInTime - self.SustainTime) / self.FadeOutTime
			if not self.Sustain and dur >= self.FadeInTime + self.SustainTime + self.FadeOutTime then
				done = true
			end
		end
	end
	
	local offset = Vector3.new(
		math.noise(noiseInput, 0) / 2,
		math.noise(0, noiseInput) / 2,
		math.noise(noiseInput, noiseInput) / 2
	) * self.Amplitude * math.min(multiplierFadeIn, multiplierFadeOut)

	if done then
		self:Stop()
	end

	return self.PositionInfluence * offset, self.RotationInfluence * offset, done
end

--[=[
	@param signal Signal | RBXScriptSignal
	@param callbackFn UpdateCallbackFn
	@return Connection | RBXScriptConnection

	Bind the `Update` method to a signal. For instance, this can be used
	to connect to `RunService.Heartbeat`.

	All HANDLERS are cleaned up when the shake instance is stopped
	or destroyed.

	```lua
	local function SomeShake(pos: Vector3, rot: Vector3, completed: boolean)
		-- Shake
	end

	shake:OnSignal(RunService.Heartbeat, SomeShake)
	```
]=]
function Shake:OnSignal(signal, callbackFn: UpdateCallbackFn)
	local conn = signal:Connect(function()
		callbackFn(self:Update())
	end)

	table.insert(self._signalHANDLERS, conn)

	return conn
end

--[=[
	@param name string -- Name passed to `RunService:BindToRenderStep`
	@param priority number -- Priority passed to `RunService:BindToRenderStep`
	@param callbackFn UpdateCallbackFn

	Bind the `Update` method to RenderStep.

	All bound functions are cleaned up when the shake instance is stopped
	or destroyed.

	```lua
	local renderPriority = Enum.RenderPriority.Camera.Value

	local function SomeShake(pos: Vector3, rot: Vector3, completed: boolean)
		-- Shake
	end

	shake:BindToRenderStep("SomeShake", renderPriority, SomeShake)
	```
]=]
function Shake:BindToRenderStep(name: string, priority: number, callbackFn: UpdateCallbackFn)
	RunService:BindToRenderStep(name, priority, function()
		callbackFn(self:Update())
	end)

	table.insert(self._renderBindings, name)
end

function Shake:ApplyProperties(shakeProperties: ShakeProperties)
	for name, value in pairs(shakeProperties) do
		self[name] = value
	end
end

--[=[
	@return Shake
	Creates a new shake with identical properties as
	this one. This does _not_ clone over playing state,
	and thus the cloned instance will be in a stopped
	state.

	A use-case for using `Clone` would be to create a module
	with a list of shake presets. These presets can be cloned
	when desired for use. For instance, there might be presets
	for explosions, recoil, or earthquakes.

	```lua
	--------------------------------------
	-- Example preset module
	local ShakePresets = {}

	local explosion = Shake.new()
	-- Configure `explosion` shake here
	ShakePresets.Explosion = explosion

	return ShakePresets
	--------------------------------------

	-- Use the module:
	local ShakePresets = require(somewhere.ShakePresets)
	local explosionShake = ShakePresets.Explosion:Clone()
	```
]=]
function Shake:Clone()
	local shake = Shake.new()
	local cloneFields = {
		"Amplitude",
		"Frequency",
		"FadeInTime",
		"FadeOutTime",
		"SustainTime",
		"Sustain",
		"PositionInfluence",
		"RotationInfluence",
		"TimeFunction",
	}
	for _, field in cloneFields do
		shake[field] = self[field]
	end
	return shake
end

--[=[
	Alias for `Stop()`.
]=]
function Shake:Destroy()
	self:Stop()
end

return {
	new = Shake.new,
	InverseSquare = Shake.InverseSquare,
	NextRenderName = Shake.NextRenderName,
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042c0</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF1F1B45A153A43659058263AD66AB391">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c20</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_RateLimiter</string>
							<string name="ScriptGuid">{D8CBE891-06DD-43EC-8B3E-A49822DE3459}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 5/30/25
--[[@description:
	Allows tracking of rate limits for different web request APIs.
	Give it rate limit information (when refreshed and how to calculate the total).
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-----------------------------
-- DEPENDENCIES --
-----------------------------
-- path: lib/lib/ModuleUtils/_RateLimiter -> ../FunctionUtils = script.Parent.Parent.FunctionUtils
local FunctionUtils = require(script.Parent.Parent.FunctionUtils)
local t = FunctionUtils.t
-- local siblings
local Signal = require(script.Parent._Signal)
local Trove = require(script.Parent._Trove)
local Future = require(script.Parent._Future)

-----------------------------
-- TYPES --
-----------------------------
-- For all of the properties/fields of an object made from this class.
type fields = {
	_trove: Trove.TroveType,
	_userData: { [any]: any },
	_params: RateLimiterParams,

	_availableTokens: number,
	_maxTokens: number,
	_lastRecalculationTime: number,

	Signals: {
		TokensAdded: Signal.Signal<(added: number, tokensAvailable: number) -> (), (number, number)>,
		TokensRemoved: Signal.Signal<(removed: number, tokensAvailable: number) -> (), (number, number)>,
		LimitChanged: Signal.Signal<(maxLimit: number) -> (), (number)>,
	},
}

export type RateLimiterParams = {
	CalculateMaxLimit: () -> number,
	RefreshIntervalInSeconds: number,
	RecalculationTriggers: { any }, -- signals to notify the limiter of when to CalculateLimit()
}

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}
local MT = {}
MT.__index = MT
export type RateLimiter = typeof(setmetatable({} :: fields, MT))

-- CONSTANTS --

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- CLASS FUNCTIONS --
-----------------------------

function Module.new(params: RateLimiterParams): RateLimiter
	local self = setmetatable({} :: fields, MT) :: RateLimiter
	self._trove = Trove.new()
	self._userData = {}
	self._params = params

	self._availableTokens = params.CalculateMaxLimit()
	self._maxTokens = self._availableTokens
	self._lastRecalculationTime = os.clock()

	self.Signals = {
		TokensAdded = self._trove:Construct(Signal),
		TokensRemoved = self._trove:Construct(Signal),
		LimitChanged = self._trove:Construct(Signal),
	}

	for _, signal in params.RecalculationTriggers do
		self._trove:Connect(signal, function()
			self:_RecalculateLimit()
		end)
	end

	return self
end

function Module:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")

	return getmetatable(object) == MT
end

-----------------------------
-- METHODS --
-----------------------------

function MT.ConsumeToken(self: RateLimiter, tokens: number?): boolean
	local tokens = tokens or 1
	assert(t.number(tokens) and tokens > 0, "invalid tokens")

	if tokens <= self._availableTokens then
		self._availableTokens -= tokens
		self.Signals.TokensRemoved:FireDefer(tokens, self._availableTokens)

		local thread
		thread = self._trove:Add(task.delay(self._params.RefreshIntervalInSeconds, function()
			local newMax = self._params.CalculateMaxLimit()
			self._maxTokens = newMax

			local oldAvailable = self._availableTokens
			self._availableTokens = math.clamp(self._availableTokens + 1, 0, newMax)
			local added = self._availableTokens - oldAvailable

			if added > 0 then
				self.Signals.TokensAdded:FireDefer(added, self._availableTokens)
			end

			self._trove:Remove(thread)
		end))

		return true
	end

	return false
end

-- Waits for the token amount or immediately returns if the tokens are available.
function MT.WaitForToken(self: RateLimiter, tokens: number?)
	local tokens = tokens or 1
	while not self:CanConsume(tokens) do
		local traceback = debug.traceback()
		local thread = task.delay(self._params.RefreshIntervalInSeconds * 2, function()
			warn(`:WaitForToken() is taking a really long time!\n`, traceback)
		end)
		self._trove:Add(thread)
		self.Signals.TokensAdded:Wait()
		self._trove:Remove(thread)
	end
end

-- Waits for the token amount or immediately executes the future if tokens are available.
function MT.WaitForTokenFuture(self: RateLimiter, tokens: number?)
	tokens = tokens or 1
	return Future.new(function(tokens)
		self:WaitForToken(tokens)
	end, tokens)
end

function MT._RecalculateLimit(self: RateLimiter)
	local oldMax = self._maxTokens
	local oldAvailable = self._availableTokens

	local newMax = self._params.CalculateMaxLimit()
	local consumed = oldMax - oldAvailable

	self._maxTokens = newMax
	self._availableTokens = math.max(0, newMax - consumed)

	self._lastRecalculationTime = os.clock()
	self.Signals.LimitChanged:FireDefer(newMax)

	local delta = self._availableTokens - oldAvailable
	if delta > 0 then
		self.Signals.TokensAdded:FireDefer(delta, self._availableTokens)
	elseif delta < 0 then
		self.Signals.TokensRemoved:FireDefer(-delta, self._availableTokens)
	end
end

-----------------------------
-- SETTERS --
-----------------------------

-----------------------------
-- GETTERS --
-----------------------------

function MT.CanConsume(self: RateLimiter, tokens: number?): boolean
	local tokens = tokens or 1
	return self._availableTokens >= tokens
end

function MT.GetMaxTokens(self: RateLimiter): number
	return self._maxTokens
end

function MT.GetAvailableTokens(self: RateLimiter): number
	return self._availableTokens
end

function MT.GetTrove(self: RateLimiter): Trove.TroveType
	return self._trove
end

function MT.GetUserData(self: RateLimiter): { [any]: any }
	return self._userData
end

-----------------------------
-- CLEANUP --
-----------------------------

function MT.Destroy(self: RateLimiter)
	self._trove:Clean()
end

-----------------------------
-- MAIN --
-----------------------------
return Module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042c1</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX7061729CA8BF457D90603C4F2804AB09">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc08218013000096e8</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Bezier</string>
							<string name="ScriptGuid">{65242563-0E7E-43E8-BC70-946A1AA19FE9}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--!native
-- created by bhristt (october 15 2021)
-- bezier module for easy creation of bezier curves
-- updated (october 25 2021)
-- strict mode & types updated by crusherfire (4/17/25)
-- Vector2 support added by ChatGPT (6/25/2025)

-- types
export type BezierPoint = {
	Type: "StaticPoint" | "BasePartPoint";
	Point: Vector3 | Vector2 | BasePart;
}

local Bezier = {}
Bezier.__index = Bezier

type fields = {
	Points: { BezierPoint },
	LengthIterations: number,
	LengthIndeces: any,
	Length: number,
	_connections: { [BasePart]: { RBXScriptConnection } }
}
export type BezierCurve = typeof(setmetatable({} :: fields, Bezier))

-- factorial helper for Bernstein
local function fact(n: number): number
	if n == 0 then
		return 1
	else
		return n * fact(n - 1)
	end
end

-- Bernstein polynomial
local function B(n: number, i: number, t: number): number
	return (fact(n) / (fact(i) * fact(n - i))) * t^i * (1 - t)^(n - i)
end

--[[
	Creates a new Bezier curve.
]]
function Bezier.new(...: (Vector3 | Vector2 | BasePart)): BezierCurve
	local self = setmetatable({}, Bezier)
	self.Points = {}
	self.LengthIterations = 1000
	self.LengthIndeces = {}
	self.Length = 0
	self._connections = {}

	for _, p in pairs({...}) do
		if typeof(p) == "Vector3" or typeof(p) == "Vector2"
			or (typeof(p) == "Instance" and p:IsA("BasePart")) then
			self:AddBezierPoint(p)
		else
			error("Bezier.new() only accepts Vector3, Vector2, or BasePart")
		end
	end

	return self
end

-- add a control point
function Bezier.AddBezierPoint(self: BezierCurve, p: Vector3 | Vector2 | BasePart, index: number?)
	-- validate
	if not (typeof(p) == "Vector3" or typeof(p) == "Vector2"
		or (typeof(p) == "Instance" and p:IsA("BasePart"))) then
		error("Bezier:AddBezierPoint() only accepts Vector3, Vector2, or BasePart")
	end

	local newPoint: BezierPoint = {
		Type = ((typeof(p) == "Instance") and "BasePartPoint" or "StaticPoint") :: any;
		Point = p;
	}

	-- if it's a BasePart, listen for moves/removal
	if newPoint.Type == "BasePartPoint" then
		local part = p :: BasePart
		local connChanged = part.Changed:Connect(function(prop)
			if prop == "Position" then
				self:UpdateLength()
			end
		end)
		local connRemoved
		connRemoved = part.AncestryChanged:Connect(function(_, parent)
			if not parent then
				local idx = table.find(self.Points, newPoint)
				if idx then
					table.remove(self.Points, idx)
				end
				connChanged:Disconnect()
				connRemoved:Disconnect()
			end
		end)
		self._connections[part] = self._connections[part] or {}
		table.insert(self._connections[part], connChanged)
		table.insert(self._connections[part], connRemoved)
	end

	-- insert at index or append
	if index then
		if type(index) ~= "number" then
			error("Bezier:AddBezierPoint() index must be a number")
		end
		table.insert(self.Points, index, newPoint)
	else
		table.insert(self.Points, newPoint)
	end

	self:UpdateLength()
end

-- change an existing control point
function Bezier.ChangeBezierPoint(self: BezierCurve, index: number, p: Vector3 | Vector2 | BasePart)
	if type(index) ~= "number" then
		error("Bezier:ChangeBezierPoint() index must be a number")
	end
	if not (typeof(p) == "Vector3" or typeof(p) == "Vector2"
		or (typeof(p) == "Instance" and p:IsA("BasePart"))) then
		error("Bezier:ChangeBezierPoint() only accepts Vector3, Vector2, or BasePart")
	end

	local entry = self.Points[index]
	if not entry then
		error("Bezier:ChangeBezierPoint() no point at index " .. index)
	end

	-- disconnect old BasePart if needed
	if entry.Type == "BasePartPoint" then
		local oldPart = entry.Point :: BasePart
		for _, conn in ipairs(self._connections[oldPart] or {}) do
			if conn.Connected then
				conn:Disconnect()
			end
		end
		self._connections[oldPart] = nil
	end

	-- assign new
	entry.Type = ((typeof(p) == "Instance") and "BasePartPoint" or "StaticPoint") :: any
	entry.Point = p

	-- hook up new BasePart if needed
	if entry.Type == "BasePartPoint" then
		local part = p :: BasePart
		local connChanged = part.Changed:Connect(function(prop)
			if prop == "Position" then
				self:UpdateLength()
			end
		end)
		local connRemoved
		connRemoved = part.AncestryChanged:Connect(function(_, parent)
			if not parent then
				local idx = table.find(self.Points, entry)
				if idx then
					table.remove(self.Points, idx)
				end
				connChanged:Disconnect()
				connRemoved:Disconnect()
			end
		end)
		self._connections[part] = { connChanged, connRemoved }
	end

	self:UpdateLength()
end

-- retrieve the raw Vector2/Vector3 of a control
function Bezier.GetPoint(self: BezierCurve, i: number): Vector3 | Vector2
	local entry = self.Points[i]
	if not entry then
		error("Bezier:GetPoint() no point at index " .. i)
	end
	if typeof(entry.Point) == "Instance" then
		return (entry.Point :: BasePart).Position
	else
		return entry.Point
	end
end

-- get all controls as a homogeneous array
function Bezier.GetAllPoints(self: BezierCurve): { Vector3 | Vector2 }
	local out = {}
	for i = 1, #self.Points do
		out[i] = self:GetPoint(i)
	end
	return out
end

-- recalc cached length
function Bezier.UpdateLength(self: BezierCurve)
	local pts = self:GetAllPoints()
	if #pts < 2 then
		self.Length = 0
		self.LengthIndeces = {}
		return 0, {}
	end

	local total = 0
	local sums: { any } = {}
	local iters = self.LengthIterations

	for i = 1, iters do
		local t = (i - 1) / (iters - 1)
		local deriv: any = self:CalculateDerivativeAt(t)
		total += deriv.Magnitude * (1 / iters)
		sums[i] = { t, total, deriv }
	end

	self.Length = total
	self.LengthIndeces = sums
	return total, sums
end

-- compute position at parameter t∈[0,1]
function Bezier.CalculatePositionAt(self: BezierCurve, t: number): Vector3 | Vector2
	if type(t) ~= "number" then
		error("Bezier:CalculatePositionAt() requires a number")
	end
	local points = self:GetAllPoints()
	if #points == 0 then
		error("Bezier:CalculatePositionAt() needs at least 1 point")
	end

	local is2D = typeof(points[1]) == "Vector2"
	local c_t = if is2D then Vector2.new() else Vector3.new()

	local n = #points - 1
	for i, p: any in ipairs(points) do
		c_t += B(n, i - 1, t) * p
	end

	return c_t
end

-- compute derivative at t∈[0,1]
function Bezier.CalculateDerivativeAt(self: BezierCurve, t: number): Vector3 | Vector2
	if type(t) ~= "number" then
		error("Bezier:CalculateDerivativeAt() requires a number")
	end
	local points = self:GetAllPoints()
	if #points < 2 then
		error("Bezier:CalculateDerivativeAt() needs at least 2 points")
	end

	local is2D = typeof(points[1]) == "Vector2"
	local prime = if is2D then Vector2.new() else Vector3.new()

	local n = #points
	for i = 1, n - 1 do
		local p0: any, p1: any = points[i], points[i + 1]
		local Q = (n - 1) * (p1 - p0)
		prime += B(n - 2, i - 1, t) * Q
	end

	return prime
end

return Bezier]]></ProtectedString>
							<int64 name="SourceAssetId">7747728449</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042c2</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX892268AC4E6F4F3DB3FD063C7AA1EDD7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc082180130000967d</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_FastCastRedux</string>
							<string name="ScriptGuid">{BA271531-23E8-4870-910D-F1FBE13DF796}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
-- ^ change to strict to crash studio c:

--[[
	Written by Eti the Spirit (18406183)
	
		The latest patch notes can be located here (and do note, the version at the top of this script might be outdated. I have a thing for forgetting to change it):
		>	https://etithespirit.github.io/FastCastAPIDocs/changelog
		
		*** If anything is broken, please don't hesitate to message me! ***
		
		YOU CAN FIND IMPORTANT USAGE INFORMATION HERE: https://etithespirit.github.io/FastCastAPIDocs
		YOU CAN FIND IMPORTANT USAGE INFORMATION HERE: https://etithespirit.github.io/FastCastAPIDocs
		YOU CAN FIND IMPORTANT USAGE INFORMATION HERE: https://etithespirit.github.io/FastCastAPIDocs
		
		YOU SHOULD ONLY CREATE ONE CASTER PER GUN.
		YOU SHOULD >>>NEVER<<< CREATE A NEW CASTER EVERY TIME THE GUN NEEDS TO BE FIRED.
		
		A caster (created with FastCast.new()) represents a "gun".
		When you consider a gun, you think of stats like accuracy, bullet speed, etc. This is the info a caster stores. 
	
	--
	
	This is a library used to create hitscan-based guns that simulate projectile physics.
	
	This means:
		- You don't have to worry about bullet lag / jittering
		- You don't have to worry about keeping bullets at a low speed due to physics being finnicky between clients
		- You don't have to worry about misfires in bullet's Touched event (e.g. where it may going so fast that it doesn't register)
		
	Hitscan-based guns are commonly seen in the form of laser beams, among other things. Hitscan simply raycasts out to a target
	and says whether it hit or not.
	
	Unfortunately, while reliable in terms of saying if something got hit or not, this method alone cannot be used if you wish
	to implement bullet travel time into a weapon. As a result of that, I made this library - an excellent remedy to this dilemma.
	
	FastCast is intended to be require()'d once in a script, as you can create as many casters as you need with FastCast.new()
	This is generally handy since you can store settings and information in these casters, and even send them out to other scripts via events
	for use.
	
	Remember -- A "Caster" represents an entire gun (or whatever is launching your projectiles), *NOT* the individual bullets.
	Make the caster once, then use the caster to fire your bullets. Do not make a caster for each bullet.
--]]

-----------------------------------------------------------
-------------------- MODULE DEFINITION --------------------
-----------------------------------------------------------

local FastCast = {}
FastCast.DebugLogging = false
FastCast.VisualizeCasts = false
FastCast.__index = FastCast
FastCast.__type = "FastCast" -- For compatibility with TypeMarshaller

-- Extra stuff
FastCast.HighFidelityBehavior = {
	Default = 1,
	Always = 3
}

-----------------------------------------------------------
----------------------- STATIC DATA -----------------------
-----------------------------------------------------------
local ActiveCastStatic = require(script._ActiveCast)
local Signal = require(script.Parent._Signal)
local table = require(script._Table)

-- Format params: methodName, ctorName
local ERR_NOT_INSTANCE = "Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"

-- Format params: paramName, expectedType, actualType
local ERR_INVALID_TYPE = "Invalid type for parameter '%s' (Expected %s, got %s)"

-- The name of the folder containing the 3D GUI elements for visualizing casts.
local FC_VIS_OBJ_NAME = "FastCastVisualizationObjects"

-- Format params: N/A
local ERR_OBJECT_DISPOSED = "This Caster has been disposed. It can no longer be used."

-----------------------------------------------------------
--------------------- TYPE DEFINITION ---------------------
-----------------------------------------------------------

-- This will inject all types into this context.
local TypeDefs = require(script.FastCastTypes)
type CanPierceFunction = TypeDefs.CanPierceFunction
type GenericTable = TypeDefs.GenericTable
type Caster = TypeDefs.Caster
type FastCastBehavior = TypeDefs.FastCastBehavior
type CastTrajectory = TypeDefs.CastTrajectory
type CastStateInfo = TypeDefs.CastStateInfo
type CastRayInfo = TypeDefs.CastRayInfo
type ActiveCast = TypeDefs.ActiveCast

-----------------------------------------------------------
----------------------- STATIC CODE -----------------------
-----------------------------------------------------------

-- Tell the ActiveCast factory module what FastCast actually *is*.
ActiveCastStatic.SetStaticFastCastReference(FastCast)

-----------------------------------------------------------
------------------------- EXPORTS -------------------------
-----------------------------------------------------------

-- Constructor.
function FastCast.new(): Caster
	return setmetatable({
		LengthChanged = Signal.new(),
		RayHit = Signal.new(),
		RayPierced = Signal.new(),
		CastTerminating = Signal.new(),
		WorldRoot = workspace
	}, FastCast) :: any
end

-- Create a new ray info object.
-- This is just a utility alias with some extra type checking.
function FastCast.newBehavior(): FastCastBehavior
	-- raycastParams, maxDistance, acceleration, canPierceFunction, cosmeticBulletTemplate, cosmeticBulletContainer, autoIgnoreBulletContainer
	return {
		RaycastParams = nil,
		Acceleration = Vector3.new(),
		MaxDistance = 1000,
		CanPierceFunction = nil,
		HighFidelityBehavior = FastCast.HighFidelityBehavior.Default,
		HighFidelitySegmentSize = 0.5,
		CosmeticBulletTemplate = nil,
		CosmeticBulletProvider = nil,
		CosmeticBulletContainer = nil,
		AutoIgnoreContainer = true
	}
end

local DEFAULT_DATA_PACKET = FastCast.newBehavior()
function FastCast:Fire(origin: Vector3, direction: Vector3, velocity: Vector3 | number, castDataPacket: FastCastBehavior?): ActiveCast
	local castDataPacket = if castDataPacket == nil then DEFAULT_DATA_PACKET else castDataPacket
	
	local cast = ActiveCastStatic.new(self, origin, direction, velocity, castDataPacket)
	cast.RayInfo.WorldRoot = self.WorldRoot
	return cast
end

-- Export
return FastCast]]></ProtectedString>
							<int64 name="SourceAssetId">4453855787</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042c3</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXE9015CFB1A024A34BA99E5F1A6A10388">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc082180130000967e</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_Table</string>
								<string name="ScriptGuid">{9D3DE2DF-4832-4149-ABB5-0A2FC369D39E}</string>
								<ProtectedString name="Source"><![CDATA[--!nocheck
-- shut up jesser

--[[
	To use: local table = require(this)
	(Yes, override table.)

	Written by EtiTheSpirit. Adds custom functions to the `table` value provided by roblox (in normal cases, this would simply modify `table`, but Roblox has disabled that so we need to use a proxy)
	
	CHANGES:
		3 December 2019 @ 11:07 PM CST:
			+ Added table.join
			
			
		21 November 2019 @ 6:50 PM CST:
			+ Added new method bodies to skip/take using Luau's new methods. Drastic speed increases achieved. CREDITS: Halalaluyafail3 (See https://devforum.roblox.com/t/sandboxed-table-system-add-custom-methods-to-table/391177/12?u=etithespirit)
			+ Added table.retrieve as proposed by ^ under the name "table.range" as this name relays what it does a bit better, I think.
			+ Added table.skipAndTake as an alias method.

--]]

local RNG = Random.new()
local RobloxTable = table
local Table = {}

-- Returns true if the table contains the specified value.
Table.contains = function (tbl, value)
	return Table.indexOf(tbl, value) ~= nil -- This is kind of cheatsy but it promises the best performance.
end

-- A combo of table.find and table.keyOf -- This first attempts to find the ordinal index of your value, then attempts to find the lookup key if it can't find an ordinal index.
Table.indexOf = function (tbl, value)
	local fromFind = table.find(tbl, value)
	if fromFind then return fromFind end
	
	return Table.keyOf(tbl, value)
end

-- Returns the key of the specified value, or nil if it could not be found. Unlike IndexOf, this searches every key in the table, not just ordinal indices (arrays)
-- This is inherently slower due to how lookups work, so if your table is structured like an array, use table.find
Table.keyOf = function (tbl, value)
	for index, obj in pairs(tbl) do
		if obj == value then
			return index
		end
	end
	return nil
end

-- Only works on ordinal. yada yada.
Table.insertAndGetIndexOf = function (tbl, value)
	tbl[#tbl + 1] = value
	return #tbl
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Skips *n* objects in the table, and returns a new table that contains indices (n + 1) to (end of table)
Table.skip = function (tbl, n)
	return table.move(tbl, n+1, #tbl, 1, table.create(#tbl-n))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes *n* objects from a table and returns a new table only containing those objects.
Table.take = function (tbl, n)
	return table.move(tbl, 1, n, 1, table.create(n))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes the range of entries in this table in the range [start, finish] and returns that range as a table.
Table.range = function (tbl, start, finish)
	return table.move(tbl, start, finish, 1, table.create(finish - start + 1))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). An alias that calls table.skip(skip), and then takes [take] entries from the resulting table.
Table.skipAndTake = function (tbl, skip, take)
	return table.move(tbl, skip + 1, skip + take, 1, table.create(take))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Selects a random object out of tbl
Table.random = function (tbl)
	return tbl[RNG:NextInteger(1, #tbl)]
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Merges tbl0 and tbl1 together.
Table.join = function (tbl0, tbl1)
	local nt = table.create(#tbl0 + #tbl1)
	local t2 = table.move(tbl0, 1, #tbl0, 1, nt)
	return table.move(tbl1, 1, #tbl1, #tbl0 + 1, nt)
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Removes the specified object from this array.
Table.removeObject = function (tbl, obj)
	local index = Table.indexOf(tbl, obj)
	if index then
		table.remove(tbl, index)
	end
end

return setmetatable({}, {
	__index = function(tbl, index)
		if Table[index] ~= nil then
			return Table[index]
		else
			return RobloxTable[index]
		end
	end;

	__newindex = function(tbl, index, value)
		error("Add new table entries by editing the Module itself.")
	end;
})]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042c4</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF2B52D1105984253B8BDAF9256EDFD68">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc082180130000967f</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_ActiveCast</string>
								<string name="ScriptGuid">{3DF4EA58-1528-43D6-BA7A-A702307D3F7B}</string>
								<ProtectedString name="Source"><![CDATA[--!nocheck
-- ^ change to strict to crash studio c:
-- ActiveCast class type.
-- The ActiveCast type represents a currently running cast.


-----------------------------------------------------------
--------------------- TYPE DEFINITION ---------------------
-----------------------------------------------------------

-- This will inject all types into this context.
local TypeDefs = require(script.Parent.FastCastTypes)

type CanPierceFunction = TypeDefs.CanPierceFunction
type GenericTable = TypeDefs.GenericTable
type Caster = TypeDefs.Caster
type FastCastBehavior = TypeDefs.FastCastBehavior
type CastTrajectory = TypeDefs.CastTrajectory
type CastStateInfo = TypeDefs.CastStateInfo
type CastRayInfo = TypeDefs.CastRayInfo
type ActiveCast = TypeDefs.ActiveCast

local typeof = require(script.Parent._TypeMarshaller)

-----------------------------------------------------------
-------------------- MODULE DEFINITION --------------------
-----------------------------------------------------------

local ActiveCastStatic = {}
ActiveCastStatic.__index = ActiveCastStatic
ActiveCastStatic.__type = "ActiveCast" -- For compatibility with TypeMarshaller

-----------------------------------------------------------
----------------------- STATIC DATA -----------------------
-----------------------------------------------------------
local RunService = game:GetService("RunService")
local table = require(script.Parent._Table)
local FastCast = nil -- Static reference to the FastCast static module.

-- Format params: methodName, ctorName
local ERR_NOT_INSTANCE = "Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"

-- Format params: paramName, expectedType, actualType
local ERR_INVALID_TYPE = "Invalid type for parameter '%s' (Expected %s, got %s)"

-- The name of the folder containing the 3D GUI elements for visualizing casts in debug mode.
local FC_VIS_OBJ_NAME = "FastCastVisualizationObjects"

-- Format params: N/A
local ERR_OBJECT_DISPOSED = "This ActiveCast has been terminated. It can no longer be used."

-- If pierce callback has to run more than this many times, it will register a hit and stop calculating pierces.
-- This only applies for repeated piercings, e.g. the amount of parts that fit within the space of a single cast segment (NOT the whole bullet's trajectory over its entire lifetime)
local MAX_PIERCE_TEST_COUNT = 100
local MAX_RAYCAST_RANGE = 1024

-----------------------------------------------------------
------------------------ UTILITIES ------------------------
-----------------------------------------------------------

-- Looks for a folder within workspace.Terrain that contains elements to visualize casts.
local function GetFastCastVisualizationContainer(): Instance
	local fcVisualizationObjects = workspace.Terrain:FindFirstChild(FC_VIS_OBJ_NAME)
	if fcVisualizationObjects ~= nil then
		return fcVisualizationObjects
	end
	
	fcVisualizationObjects = Instance.new("Folder")
	fcVisualizationObjects.Name = FC_VIS_OBJ_NAME
	fcVisualizationObjects.Archivable = false -- TODO: Keep this as-is? You can't copy/paste it if this is false. I have it false so that it doesn't linger in studio if you save with the debug data in there.
	fcVisualizationObjects.Parent = workspace.Terrain
	return fcVisualizationObjects
end

-----------------------------------------------------------
------------------------ DEBUGGING ------------------------
-----------------------------------------------------------

-- Print that runs only if debug mode is active.
local function PrintDebug(message: string)
	if FastCast.DebugLogging == true then
		print(message)
	end
end

-- Visualizes a ray. This will not run if FastCast.VisualizeCasts is false.
function DbgVisualizeSegment(castStartCFrame: CFrame, castLength: number): ConeHandleAdornment?
	if FastCast.VisualizeCasts ~= true then return nil end
	local adornment = Instance.new("ConeHandleAdornment")
	adornment.Adornee = workspace.Terrain
	adornment.CFrame = castStartCFrame
	adornment.Height = castLength
	adornment.Color3 = Color3.new()
	adornment.Radius = 0.25
	adornment.Transparency = 0.5
	adornment.Parent = GetFastCastVisualizationContainer()
	return adornment
end

-- Visualizes an impact. This will not run if FastCast.VisualizeCasts is false.
function DbgVisualizeHit(atCF: CFrame, wasPierce: boolean): SphereHandleAdornment?
	if FastCast.VisualizeCasts ~= true then return nil end
	local adornment = Instance.new("SphereHandleAdornment")
	adornment.Adornee = workspace.Terrain
	adornment.CFrame = atCF
	adornment.Radius = 0.4
	adornment.Transparency = 0.25
	adornment.Color3 = (wasPierce == false) and Color3.new(0.2, 1, 0.5) or Color3.new(1, 0.2, 0.2)
	adornment.Parent = GetFastCastVisualizationContainer()
	return adornment
end

-----------------------------------------------------------
------------------------ CORE CODE ------------------------
-----------------------------------------------------------

-- Thanks to zoebasil for supplying the velocity and position functions below. (I've modified these functions)
-- I was having a huge issue trying to get it to work and I had overcomplicated a bunch of stuff.
-- GetPositionAtTime is used in physically simulated rays (Where Caster.HasPhysics == true or the specific Fire has a specified acceleration).
-- This returns the location that the bullet will be at when you specify the amount of time the bullet has existed, the original location of the bullet, and the velocity it was launched with.
local function GetPositionAtTime(time: number, origin: Vector3, initialVelocity: Vector3, acceleration: Vector3): Vector3
	local force = Vector3.new((acceleration.X * time^2) / 2,(acceleration.Y * time^2) / 2, (acceleration.Z * time^2) / 2)
	return origin + (initialVelocity * time) + force
end

-- A variant of the function above that returns the velocity at a given point in time.
local function GetVelocityAtTime(time: number, initialVelocity: Vector3, acceleration: Vector3): Vector3
	return initialVelocity + acceleration * time
end

local function GetTrajectoryInfo(cast: ActiveCast, index: number): {[number]: Vector3}
	assert(cast.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	local trajectories = cast.StateInfo.Trajectories
	local trajectory = trajectories[index]
	local duration = trajectory.EndTime - trajectory.StartTime
	
	local origin = trajectory.Origin
	local vel = trajectory.InitialVelocity
	local accel = trajectory.Acceleration
	
	return {GetPositionAtTime(duration, origin, vel, accel), GetVelocityAtTime(duration, vel, accel)}
end

local function GetLatestTrajectoryEndInfo(cast: ActiveCast): {[number]: Vector3}
	assert(cast.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	return GetTrajectoryInfo(cast, #cast.StateInfo.Trajectories)
end

local function CloneCastParams(params: RaycastParams): RaycastParams
	local clone = RaycastParams.new()
	clone.CollisionGroup = params.CollisionGroup
	clone.FilterType = params.FilterType
	clone.FilterDescendantsInstances = params.FilterDescendantsInstances
	clone.IgnoreWater = params.IgnoreWater
	return clone
end

local function SendRayHit(cast: ActiveCast, resultOfCast: RaycastResult, segmentVelocity: Vector3, cosmeticBulletObject: Instance?)
	--cast.RayHit:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)
	cast.Caster.RayHit:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)
end

local function SendRayPierced(cast: ActiveCast, resultOfCast: RaycastResult, segmentVelocity: Vector3, cosmeticBulletObject: Instance?)
	--cast.RayPierced:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)
	cast.Caster.RayPierced:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)
end

local function SendLengthChanged(cast: ActiveCast, lastPoint: Vector3, rayDir: Vector3, rayDisplacement: number, segmentVelocity: Vector3, cosmeticBulletObject: Instance?)
	--cast.LengthChanged:Fire(cast, lastPoint, rayDir, rayDisplacement, segmentVelocity, cosmeticBulletObject)
	cast.Caster.LengthChanged:Fire(cast, lastPoint, rayDir, rayDisplacement, segmentVelocity, cosmeticBulletObject)
end

-- Simulate a raycast by one tick.
local function SimulateCast(cast: ActiveCast, delta: number, expectingShortCall: boolean)
	assert(cast.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	PrintDebug("Casting for frame.")
	local latestTrajectory = cast.StateInfo.Trajectories[#cast.StateInfo.Trajectories]
	
	local origin = latestTrajectory.Origin
	local totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
	local initialVelocity = latestTrajectory.InitialVelocity
	local acceleration = latestTrajectory.Acceleration
	
	local lastPoint = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)
	local lastVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration)
	local lastDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
	
	cast.StateInfo.TotalRuntime += delta
	
	-- Recalculate this.
	totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
	
	local currentTarget = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)
	local segmentVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration) 
	local totalDisplacement = currentTarget - lastPoint -- This is the displacement from where the ray was on the last from to where the ray is now.
	
	local rayDir
	if totalDisplacement.Magnitude > 0 then
		local magnitude = math.clamp(segmentVelocity.Magnitude * delta, 1, MAX_RAYCAST_RANGE) -- avoid spherecast/raycast limits
		rayDir = totalDisplacement.Unit * segmentVelocity.Magnitude * delta
	else
		rayDir = Vector3.new(0, 0, 0) -- avoid NaN Vector3
	end
	local targetWorldRoot = cast.RayInfo.WorldRoot
	
	local resultOfCast
	if cast.RayInfo.SphereRadius then
		resultOfCast = targetWorldRoot:Spherecast(lastPoint, cast.RayInfo.SphereRadius, rayDir, cast.RayInfo.Parameters)
	else
		resultOfCast = targetWorldRoot:Raycast(lastPoint, rayDir, cast.RayInfo.Parameters)
	end
	
	local point = currentTarget
	local part: Instance? = nil
	local material = Enum.Material.Air
	local normal = Vector3.new()
	
	if (resultOfCast ~= nil) then
		point = resultOfCast.Position
		part = resultOfCast.Instance
		material = resultOfCast.Material
		normal = resultOfCast.Normal
	end
	
	local rayDisplacement = (point - lastPoint).Magnitude
	-- For clarity -- totalDisplacement is how far the ray would have traveled if it hit nothing,
	-- and rayDisplacement is how far the ray really traveled (which will be identical to totalDisplacement if it did indeed hit nothing)
	
	SendLengthChanged(cast, lastPoint, rayDir.Unit, rayDisplacement, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
	cast.StateInfo.DistanceCovered += rayDisplacement
	
	local rayVisualization: ConeHandleAdornment? = nil
	if (delta > 0) then
		rayVisualization = DbgVisualizeSegment(CFrame.new(lastPoint, lastPoint + rayDir), rayDisplacement)
	end
	
	
	-- HIT DETECTED. Handle all that garbage, and also handle behaviors 1 and 2 (default behavior, go high res when hit) if applicable.
	-- CAST BEHAVIOR 2 IS HANDLED IN THE CODE THAT CALLS THIS FUNCTION.
	
	if part and part ~= cast.RayInfo.CosmeticBulletObject then
		local start = tick()
		PrintDebug("Hit something, testing now.")
		
		-- SANITY CHECK: Don't allow the user to yield or run otherwise extensive code that takes longer than one frame/heartbeat to execute.
		if (cast.RayInfo.CanPierceCallback ~= nil) then
			if expectingShortCall == false then
				if (cast.StateInfo.IsActivelySimulatingPierce) then
					cast:Terminate()
					error("ERROR: The latest call to CanPierceCallback took too long to complete! This cast is going to suffer desyncs which WILL cause unexpected behavior and errors. Please fix your performance problems, or remove statements that yield (e.g. wait() calls)")
					-- Use error. This should absolutely abort the cast.
				end
			end
			-- expectingShortCall is used to determine if we are doing a forced resolution increase, in which case this will be called several times in a single frame, which throws this error.
			cast.StateInfo.IsActivelySimulatingPierce = true
		end
		------------------------------
		
		if cast.RayInfo.CanPierceCallback == nil or (cast.RayInfo.CanPierceCallback ~= nil and cast.RayInfo.CanPierceCallback(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject) == false) then
			PrintDebug("Piercing function is nil or it returned FALSE to not pierce this hit.")
			cast.StateInfo.IsActivelySimulatingPierce = false
			
			if (cast.StateInfo.HighFidelityBehavior == 2 and latestTrajectory.Acceleration ~= Vector3.new() and cast.StateInfo.HighFidelitySegmentSize ~= 0) then
				cast.StateInfo.CancelHighResCast = false -- Reset this here.
				
				if cast.StateInfo.IsActivelyResimulating then
					cast:Terminate()
					error("Cascading cast lag encountered! The caster attempted to perform a high fidelity cast before the previous one completed, resulting in exponential cast lag. Consider increasing HighFidelitySegmentSize.")
				end
				

				cast.StateInfo.IsActivelyResimulating = true
				
				-- This is a physics based cast and it needs to be recalculated.
				PrintDebug("Hit was registered, but recalculation is on for physics based casts. Recalculating to verify a real hit...")
				
				-- Split this ray segment into smaller segments of a given size.
				-- In 99% of cases, it won't divide evently (e.g. I have a distance of 1.25 and I want to divide into 0.1 -- that won't work)
				-- To fix this, the segments need to be stretched slightly to fill the space (rather than having a single shorter segment at the end)
				
				local numSegmentsDecimal = rayDisplacement / cast.StateInfo.HighFidelitySegmentSize -- say rayDisplacement is 5.1, segment size is 0.5 -- 10.2 segments
				local numSegmentsReal = math.floor(numSegmentsDecimal) -- 10 segments + 0.2 extra segments
				local realSegmentLength = rayDisplacement / numSegmentsReal -- this spits out 0.51, which isn't exact to the defined 0.5, but it's close
				
				-- Now the real hard part is converting this to time.
				local timeIncrement = delta / numSegmentsReal
				for segmentIndex = 1, numSegmentsReal do
					if cast.StateInfo.CancelHighResCast then
						cast.StateInfo.CancelHighResCast = false
						break
					end
					
					local subPosition = GetPositionAtTime(lastDelta + (timeIncrement * segmentIndex), origin, initialVelocity, acceleration)
					local subVelocity = GetVelocityAtTime(lastDelta + (timeIncrement * segmentIndex), initialVelocity, acceleration) 
					local subRayDir = subVelocity * delta
					local subResult
					if cast.RayInfo.SphereRadius then
						subResult = targetWorldRoot:Spherecast(subPosition, cast.RayInfo.SphereRadius, subRayDir, cast.RayInfo.Parameters)
					else
						subResult = targetWorldRoot:Raycast(subPosition, subRayDir, cast.RayInfo.Parameters)
					end
					
					local subDisplacement = (subPosition - (subPosition + subVelocity)).Magnitude
					
					if (subResult ~= nil) then
						local subDisplacement = (subPosition - subResult.Position).Magnitude
						local dbgSeg = DbgVisualizeSegment(CFrame.new(subPosition, subPosition + subVelocity), subDisplacement)
						if (dbgSeg ~= nil) then dbgSeg.Color3 = Color3.new(0.286275, 0.329412, 0.247059) end
						
						if cast.RayInfo.CanPierceCallback == nil or (cast.RayInfo.CanPierceCallback ~= nil and cast.RayInfo.CanPierceCallback(cast, subResult, subVelocity, cast.RayInfo.CosmeticBulletObject) == false) then
							-- Still hit even at high res
							cast.StateInfo.IsActivelyResimulating = false
							
							SendRayHit(cast, subResult, subVelocity, cast.RayInfo.CosmeticBulletObject)
							cast:Terminate()
							local vis = DbgVisualizeHit(CFrame.new(point), false)
							if (vis ~= nil) then vis.Color3 = Color3.new(0.0588235, 0.87451, 1) end
							return
						else
							-- Recalculating hit something pierceable instead.
							SendRayPierced(cast, subResult, subVelocity, cast.RayInfo.CosmeticBulletObject) -- This may result in CancelHighResCast being set to true.
							local vis = DbgVisualizeHit(CFrame.new(point), true)
							if (vis ~= nil) then vis.Color3 = Color3.new(1, 0.113725, 0.588235) end
							if (dbgSeg ~= nil) then dbgSeg.Color3 = Color3.new(0.305882, 0.243137, 0.329412) end
						end
					else
						local dbgSeg = DbgVisualizeSegment(CFrame.new(subPosition, subPosition + subVelocity), subDisplacement)
						if (dbgSeg ~= nil) then dbgSeg.Color3 = Color3.new(0.286275, 0.329412, 0.247059) end
						
					end
				end
				
				-- If the script makes it here, then it wasn't a real hit (higher resolution revealed that the low-res hit was faulty)
				-- Just let it keep going.
				cast.StateInfo.IsActivelyResimulating = false
			elseif (cast.StateInfo.HighFidelityBehavior ~= 1 and cast.StateInfo.HighFidelityBehavior ~= 3) then
				cast:Terminate()
				error("Invalid value " .. (cast.StateInfo.HighFidelityBehavior) .. " for HighFidelityBehavior.")
			else
				-- This is not a physics cast, or recalculation is off.
				PrintDebug("Hit was successful. Terminating.")
				SendRayHit(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
				cast:Terminate()
				DbgVisualizeHit(CFrame.new(point), false)
				return
			end
		else
			PrintDebug("Piercing function returned TRUE to pierce this part.")
			if rayVisualization ~= nil then
				rayVisualization.Color3 = Color3.new(0.4, 0.05, 0.05) -- Turn it red to signify that the cast was scrapped.
			end
			DbgVisualizeHit(CFrame.new(point), true)
			
			local params = cast.RayInfo.Parameters
			local alteredParts = {}
			local currentPierceTestCount = 0
			local originalFilter = params.FilterDescendantsInstances
			local brokeFromSolidObject = false
			while true do
				-- So now what I need to do is redo this entire cast, just with the new filter list
								
				-- Catch case: Is it terrain?
				if resultOfCast.Instance:IsA("Terrain") then
					if material == Enum.Material.Water then
						-- Special case: Pierced on water?
						cast:Terminate()
						error("Do not add Water as a piercable material. If you need to pierce water, set cast.RayInfo.Parameters.IgnoreWater = true instead", 0)
					end
					warn("WARNING: The pierce callback for this cast returned TRUE on Terrain! This can cause severely adverse effects.")
				end
				
				if params.FilterType == Enum.RaycastFilterType.Exclude then
					-- blacklist
					-- DO NOT DIRECTLY TABLE.INSERT ON THE PROPERTY
					local filter = params.FilterDescendantsInstances
					table.insert(filter, resultOfCast.Instance)
					table.insert(alteredParts, resultOfCast.Instance)
					params.FilterDescendantsInstances = filter
				else
					-- whitelist
					-- method implemeneted by custom table system
					-- DO NOT DIRECTLY TABLE.REMOVEOBJECT ON THE PROPERTY
					local filter = params.FilterDescendantsInstances
					table.removeObject(filter, resultOfCast.Instance)
					table.insert(alteredParts, resultOfCast.Instance)
					params.FilterDescendantsInstances = filter
				end
				
				SendRayPierced(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
				
				-- List has been updated, so let's cast again.
				if cast.RayInfo.SphereRadius then
					resultOfCast = targetWorldRoot:Spherecast(lastPoint, cast.RayInfo.SphereRadius, rayDir, cast.RayInfo.Parameters)
				else
					resultOfCast = targetWorldRoot:Raycast(lastPoint, rayDir, cast.RayInfo.Parameters)
				end
				
				-- No hit? No simulation. Break.
				if resultOfCast == nil then
					break
				end
				
				if currentPierceTestCount >= MAX_PIERCE_TEST_COUNT then
					warn("WARNING: Exceeded maximum pierce test budget for a single ray segment (attempted to test the same segment " .. MAX_PIERCE_TEST_COUNT .. " times!)")
					break
				end
				currentPierceTestCount = currentPierceTestCount + 1;
				
				if cast.RayInfo.CanPierceCallback(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject) == false then
					brokeFromSolidObject = true
					break
				end
			end
			
			-- Restore the filter to its default state.
			cast.RayInfo.Parameters.FilterDescendantsInstances = originalFilter
			cast.StateInfo.IsActivelySimulatingPierce = false
			
			if brokeFromSolidObject then
				-- We actually hit something while testing.
				PrintDebug("Broke because the ray hit something solid (" .. tostring(resultOfCast.Instance) .. ") while testing for a pierce. Terminating the cast.")
				SendRayHit(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
				cast:Terminate()
				DbgVisualizeHit(CFrame.new(resultOfCast.Position), false)
				return
			end
			
			-- And exit the function here too.
		end
	end
	
	if (cast.StateInfo.DistanceCovered >= cast.RayInfo.MaxDistance) then
		-- SendRayHit(cast, nil, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
		cast:Terminate()
		DbgVisualizeHit(CFrame.new(currentTarget), false)
	end
end

-----------------------------------------------------------
------------------------- EXPORTS -------------------------
-----------------------------------------------------------

-- Ctor
function ActiveCastStatic.new(caster: Caster, origin: Vector3, direction: Vector3, velocity: Vector3 | number, castDataPacket: FastCastBehavior): ActiveCast
	if typeof(velocity) == "number" then
		velocity = direction.Unit * velocity
	end	
	
	if (castDataPacket.HighFidelitySegmentSize <= 0) then
		error("Cannot set FastCastBehavior.HighFidelitySegmentSize <= 0!", 0)
	end
	
	-- Basic setup
	local cast = {
		Caster = caster,
		
		-- Data that keeps track of what's going on as well as edits we might make during runtime.
		StateInfo = {
			UpdateConnection = nil,
			Paused = false,
			TotalRuntime = 0,
			DistanceCovered = 0,
			HighFidelitySegmentSize = castDataPacket.HighFidelitySegmentSize,
			HighFidelityBehavior = castDataPacket.HighFidelityBehavior,
			IsActivelySimulatingPierce = false,
			IsActivelyResimulating = false,
			CancelHighResCast = false,
			Trajectories = {
				{
					StartTime = 0,
					EndTime = -1,
					Origin = origin,
					InitialVelocity = velocity,
					Acceleration = castDataPacket.Acceleration
				}
			}
		},
		
		-- Information pertaining to actual raycasting.
		RayInfo = {
			Parameters = castDataPacket.RaycastParams,
			WorldRoot = workspace,
			MaxDistance = castDataPacket.MaxDistance or 1000,
			CosmeticBulletObject = castDataPacket.CosmeticBulletTemplate, -- This is intended. We clone it a smidge of the way down.
			CanPierceCallback = castDataPacket.CanPierceFunction,
			SphereRadius = castDataPacket.SphereCastRadius
		},
		
		UserData = {}
	}
	
	if cast.StateInfo.HighFidelityBehavior == 2 then
		cast.StateInfo.HighFidelityBehavior = 3
	end
	
	
	if cast.RayInfo.Parameters ~= nil then
		cast.RayInfo.Parameters = CloneCastParams(cast.RayInfo.Parameters)
	else
		cast.RayInfo.Parameters = RaycastParams.new()
	end

	local usingProvider = false
	if castDataPacket.CosmeticBulletProvider == nil then
		-- The provider is nil. Use a cosmetic object clone.
		if cast.RayInfo.CosmeticBulletObject ~= nil then
			cast.RayInfo.CosmeticBulletObject = cast.RayInfo.CosmeticBulletObject:Clone()
			cast.RayInfo.CosmeticBulletObject.CFrame = CFrame.new(origin, origin + direction)
			cast.RayInfo.CosmeticBulletObject.Parent = castDataPacket.CosmeticBulletContainer
		end
	else
		-- The provider is not nil.
		-- Is it what we want?
		if typeof(castDataPacket.CosmeticBulletProvider) == "PartCache" then
			-- this modded version of typeof is implemented up top.
			-- Aside from that, yes, it's a part cache. Good to go!
			
			if cast.RayInfo.CosmeticBulletObject ~= nil then
				-- They also set the template. Not good. Warn + clear this up.
				warn("Do not define FastCastBehavior.CosmeticBulletTemplate and FastCastBehavior.CosmeticBulletProvider at the same time! The provider will be used, and CosmeticBulletTemplate will be set to nil.")
				cast.RayInfo.CosmeticBulletObject = nil
				castDataPacket.CosmeticBulletTemplate = nil
			end

			cast.RayInfo.CosmeticBulletObject = castDataPacket.CosmeticBulletProvider:GetPart()
			cast.RayInfo.CosmeticBulletObject.CFrame = CFrame.new(origin, origin + direction)
			usingProvider = true
		else
			warn("FastCastBehavior.CosmeticBulletProvider was not an instance of the PartCache module (an external/separate model)! Are you inputting an instance created via PartCache.new? If so, are you on the latest version of PartCache? Setting FastCastBehavior.CosmeticBulletProvider to nil.")
			castDataPacket.CosmeticBulletProvider = nil
		end
	end

	local targetContainer: Instance;
	if usingProvider then
		targetContainer = castDataPacket.CosmeticBulletProvider.CurrentCacheParent
	else
		targetContainer = castDataPacket.CosmeticBulletContainer
	end
	
	if castDataPacket.AutoIgnoreContainer == true and targetContainer ~= nil then
		local ignoreList = cast.RayInfo.Parameters.FilterDescendantsInstances
		if table.find(ignoreList, targetContainer) == nil then
			table.insert(ignoreList, targetContainer)
			cast.RayInfo.Parameters.FilterDescendantsInstances = ignoreList
		end
	end
	
	local event
	if RunService:IsClient() then
		event = RunService.RenderStepped
	else
		event = RunService.Heartbeat
	end
	
	setmetatable(cast, ActiveCastStatic)
	
	cast.StateInfo.UpdateConnection = event:Connect(function (delta)
		if cast.StateInfo.Paused then return end
		
		PrintDebug("Casting for frame.")
		local latestTrajectory = cast.StateInfo.Trajectories[#cast.StateInfo.Trajectories]
		if (cast.StateInfo.HighFidelityBehavior == 3 and latestTrajectory.Acceleration ~= Vector3.new() and cast.StateInfo.HighFidelitySegmentSize > 0) then
			
			local timeAtStart = tick()
			
			if cast.StateInfo.IsActivelyResimulating then
				cast:Terminate()
				error("Cascading cast lag encountered! The caster attempted to perform a high fidelity cast before the previous one completed, resulting in exponential cast lag. Consider increasing HighFidelitySegmentSize.")
			end
			
			cast.StateInfo.IsActivelyResimulating = true
			
			-- Actually want to calculate this early to find displacement
			local origin = latestTrajectory.Origin
			local totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
			local initialVelocity = latestTrajectory.InitialVelocity
			local acceleration = latestTrajectory.Acceleration
			
			local lastPoint = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)
			local lastVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration)
			local lastDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
			
			cast.StateInfo.TotalRuntime += delta
			
			-- Recalculate this.
			totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
			
			local currentPoint = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)
			local currentVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration) 
			local totalDisplacement = currentPoint - lastPoint -- This is the displacement from where the ray was on the last from to where the ray is now.
			
			local rayDir = totalDisplacement.Unit * currentVelocity.Magnitude * delta
			local targetWorldRoot = cast.RayInfo.WorldRoot
			local resultOfCast
			if cast.RayInfo.SphereRadius then
				resultOfCast = targetWorldRoot:Spherecast(lastPoint, cast.RayInfo.SphereRadius, rayDir, cast.RayInfo.Parameters)
			else
				resultOfCast = targetWorldRoot:Raycast(lastPoint, rayDir, cast.RayInfo.Parameters)
			end
			
			local point = currentPoint
			
			if (resultOfCast ~= nil) then
				point = resultOfCast.Position
			end
			
			local rayDisplacement = (point - lastPoint).Magnitude
			
			-- Now undo this. The line below in the for loop will add this time back gradually.
			cast.StateInfo.TotalRuntime -= delta
			
			-- And now that we have displacement, we can calculate segment size.
			local numSegmentsDecimal = rayDisplacement / cast.StateInfo.HighFidelitySegmentSize -- say rayDisplacement is 5.1, segment size is 0.5 -- 10.2 segments
			local numSegmentsReal = math.floor(numSegmentsDecimal) -- 10 segments + 0.2 extra segments
			if (numSegmentsReal == 0) then
				numSegmentsReal = 1
			end
			
			local timeIncrement = delta / numSegmentsReal
			
			for segmentIndex = 1, numSegmentsReal do
				if getmetatable(cast) == nil then return end -- Could have been disposed.
				if cast.StateInfo.CancelHighResCast then
					cast.StateInfo.CancelHighResCast = false
					break
				end
				PrintDebug("[" .. segmentIndex .. "] Subcast of time increment " .. timeIncrement)
				SimulateCast(cast, timeIncrement, true)
			end
			
			if getmetatable(cast) == nil then return end -- Could have been disposed.
			cast.StateInfo.IsActivelyResimulating = false
			
			if (tick() - timeAtStart) > 0.016 * 5 then
				warn("Extreme cast lag encountered! Consider increasing HighFidelitySegmentSize.")
			end
			
		else
			SimulateCast(cast, delta, false)
		end
	end)
	
	return cast
end

function ActiveCastStatic.SetStaticFastCastReference(ref)
	FastCast = ref
end

---- GETTERS AND SETTERS ----

local function ModifyTransformation(cast: ActiveCast, velocity: Vector3?, acceleration: Vector3?, position: Vector3?)
	local trajectories = cast.StateInfo.Trajectories
	local lastTrajectory = trajectories[#trajectories]
	
	-- NEW BEHAVIOR: Don't create a new trajectory if we haven't even used the current one.
	if lastTrajectory.StartTime == cast.StateInfo.TotalRuntime then
		-- This trajectory is fresh out of the box. Let's just change it since it hasn't actually affected the cast yet, so changes won't have adverse effects.
		if (velocity == nil) then
			velocity = lastTrajectory.InitialVelocity
		end
		if (acceleration == nil) then
			acceleration = lastTrajectory.Acceleration
		end
		if (position == nil) then
			position = lastTrajectory.Origin
		end	
		
		lastTrajectory.Origin = position
		lastTrajectory.InitialVelocity = velocity
		lastTrajectory.Acceleration = acceleration
	else
		-- The latest trajectory is done. Set its end time and get its location. 
		lastTrajectory.EndTime = cast.StateInfo.TotalRuntime
		
		local point, velAtPoint = unpack(GetLatestTrajectoryEndInfo(cast))
		
		if (velocity == nil) then
			velocity = velAtPoint
		end
		if (acceleration == nil) then
			acceleration = lastTrajectory.Acceleration
		end
		if (position == nil) then
			position = point
		end	
		table.insert(cast.StateInfo.Trajectories, {
			StartTime = cast.StateInfo.TotalRuntime,
			EndTime = -1,
			Origin = position,
			InitialVelocity = velocity,
			Acceleration = acceleration
		})
		cast.StateInfo.CancelHighResCast = true
	end
end

function ActiveCastStatic:SetVelocity(velocity: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("SetVelocity", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	ModifyTransformation(self, velocity, nil, nil)
end

function ActiveCastStatic:SetAcceleration(acceleration: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("SetAcceleration", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	ModifyTransformation(self, nil, acceleration, nil)
end

function ActiveCastStatic:SetPosition(position: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("SetPosition", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	ModifyTransformation(self, nil, nil, position)
end

function ActiveCastStatic:GetVelocity(): Vector3
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("GetVelocity", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	local currentTrajectory = self.StateInfo.Trajectories[#self.StateInfo.Trajectories]
	return GetVelocityAtTime(self.StateInfo.TotalRuntime - currentTrajectory.StartTime, currentTrajectory.InitialVelocity, currentTrajectory.Acceleration)
end

function ActiveCastStatic:GetAcceleration(): Vector3
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("GetAcceleration", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	local currentTrajectory = self.StateInfo.Trajectories[#self.StateInfo.Trajectories]
	return currentTrajectory.Acceleration
end

function ActiveCastStatic:GetPosition(): Vector3
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("GetPosition", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	local currentTrajectory = self.StateInfo.Trajectories[#self.StateInfo.Trajectories]
	return GetPositionAtTime(self.StateInfo.TotalRuntime - currentTrajectory.StartTime, currentTrajectory.Origin, currentTrajectory.InitialVelocity, currentTrajectory.Acceleration)
end

---- ARITHMETIC ----

function ActiveCastStatic:AddVelocity(velocity: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("AddVelocity", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self:SetVelocity(self:GetVelocity() + velocity)
end

function ActiveCastStatic:AddAcceleration(acceleration: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("AddAcceleration", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self:SetAcceleration(self:GetAcceleration() + acceleration)
end

function ActiveCastStatic:AddPosition(position: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("AddPosition", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self:SetPosition(self:GetPosition() + position)
end

---- STATE MODIFICATION ----

function ActiveCastStatic:Pause()
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("Pause", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self.StateInfo.Paused = true
end

function ActiveCastStatic:Resume()
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("Resume", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self.StateInfo.Paused = false
end

function ActiveCastStatic:Terminate()
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("Terminate", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	
	-- First: Set EndTime on the latest trajectory since it is now done simulating.
	local trajectories = self.StateInfo.Trajectories
	local lastTrajectory = trajectories[#trajectories]
	lastTrajectory.EndTime = self.StateInfo.TotalRuntime
	
	-- Disconnect the update connection.
	self.StateInfo.UpdateConnection:Disconnect()
	
	-- Now fire CastTerminating
	self.Caster.CastTerminating:Fire(self)
	
	-- And now set the update connection object to nil.
	self.StateInfo.UpdateConnection = nil
	
	-- And nuke everything in the table + clear the metatable.
	self.Caster = nil
	self.StateInfo = nil
	self.RayInfo = nil
	self.UserData = nil
	setmetatable(self, nil)
end

return ActiveCastStatic]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042c5</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXAB83F47410F64C319B081E2AD9D9B88B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009680</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">FastCastTypes</string>
								<string name="ScriptGuid">{C75851DA-B4B4-453E-95C2-BD5D85E7654B}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- ^ change to strict to crash studio c:

-- Defines all FC types.
-- Any script that requires this will have these types defined.

--[[
local TypeDefs = require(script.TypeDefinitions)
type CanPierceFunction = TypeDefs.CanPierceFunction
type GenericTable = TypeDefs.GenericTable
type Caster = TypeDefs.Caster
type FastCastBehavior = TypeDefs.FastCastBehavior
type CastTrajectory = TypeDefs.CastTrajectory
type CastStateInfo = TypeDefs.CastStateInfo
type CastRayInfo = TypeDefs.CastRayInfo
type ActiveCast = TypeDefs.ActiveCast
--]]
local Signal = require(script.Parent.Parent._Signal)

-- Represents the function to determine piercing.
export type CanPierceFunction = (ActiveCast, RaycastResult, Vector3) -> boolean

-- Represents any table.
export type GenericTable = {[any]: any}

-- Represents a Caster :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/caster/
export type Caster = {
	WorldRoot: WorldRoot,
	LengthChanged: Signal.SignalType<(activeCast: ActiveCast, lastPoint: Vector3, direction: Vector3, displacement: number, segmentVelocity: Vector3, cosmeticBulletObj: Instance?) -> (), (ActiveCast, Vector3, Vector3, number, Vector3, Instance?)>,
	RayHit: Signal.SignalType<(activeCast: ActiveCast, result: RaycastResult, segmentVelocity: Vector3, cosmeticBulletObj: Instance?) -> (), (ActiveCast, RaycastResult, Vector3, Instance?)>,
	RayPierced: Signal.SignalType<(activeCast: ActiveCast, result: RaycastResult, segmentVelocity: Vector3, cosmeticBulletObj: Instance?) -> (), (ActiveCast, RaycastResult, Vector3, Instance?)>,
	CastTerminating: Signal.SignalType<(activeCast: ActiveCast) -> (), (ActiveCast)>,
	Fire: (self: Caster, origin: Vector3, direction: Vector3, velocity: Vector3 | number, behavior: FastCastBehavior?) -> (ActiveCast)
}

-- Represents a FastCastBehavior :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/fcbehavior/
export type FastCastBehavior = {
	RaycastParams: RaycastParams?,
	MaxDistance: number,
	Acceleration: Vector3,
	HighFidelityBehavior: number,
	HighFidelitySegmentSize: number,
	SphereCastRadius: number?, -- A value that must be greater than 0 that will change the raycast into a spherecast.
	CosmeticBulletTemplate: Instance?,
	CosmeticBulletProvider: any, -- Intended to be a PartCache. Dictated via TypeMarshaller.
	CosmeticBulletContainer: Instance?,
	AutoIgnoreContainer: boolean,
	CanPierceFunction: CanPierceFunction?
}

-- Represents a CastTrajectory :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/casttrajectory/
export type CastTrajectory = {
	StartTime: number,
	EndTime: number,
	Origin: Vector3,
	InitialVelocity: Vector3,
	Acceleration: Vector3
}

-- Represents a CastStateInfo :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/caststateinfo/
export type CastStateInfo = {
	UpdateConnection: RBXScriptSignal,
	HighFidelityBehavior: number,
	HighFidelitySegmentSize: number,
	Paused: boolean,
	TotalRuntime: number,
	DistanceCovered: number,
	IsActivelySimulatingPierce: boolean,
	IsActivelyResimulating: boolean,
	CancelHighResCast: boolean,
	Trajectories: {[number]: CastTrajectory}
}

-- Represents a CastRayInfo :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/castrayinfo/
export type CastRayInfo = {
	Parameters: RaycastParams,
	WorldRoot: WorldRoot,
	MaxDistance: number,
	CosmeticBulletObject: Instance?,
	CanPierceCallback: CanPierceFunction,
	SphereRadius: number?
}

-- Represents an ActiveCast :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/activecast/
export type ActiveCast = {
	Caster: Caster,
	StateInfo: CastStateInfo,
	RayInfo: CastRayInfo,
	UserData: {[any]: any},
	
	GetPosition: (self: ActiveCast) -> (Vector3),
	SetVelocity: (self: ActiveCast, velocity: Vector3) -> (),
	SetAcceleration: (self: ActiveCast, acceleration: Vector3) -> (),
	SetPosition: (self: ActiveCast, position: Vector3) -> (),
	AddVelocity: (self: ActiveCast, velocity: Vector3) -> (),
	AddAcceleration: (self: ActiveCast, acceleration: Vector3) -> (),
	AddPosition: (self: ActiveCast, position: Vector3) -> (),
	Pause: (self: ActiveCast) -> (),
	Resume: (self: ActiveCast) -> (),
	Terminate: (self: ActiveCast) -> ()
}

return {}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042c6</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXBAECE13D329542BC9AC958D39559A19A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009681</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_TypeMarshaller</string>
								<string name="ScriptGuid">{3C90C65C-BDA4-4658-B3F5-3FCDC88A146A}</string>
								<ProtectedString name="Source"><![CDATA[--!nocheck
-- ^ change to strict to crash studio c:

local oldtypeof = typeof
local function typeof(objIn: any): string
	local objType = oldtypeof(objIn)
	if objType ~= "table" then return objType end

	-- Could be a custom type if it's a table.
	local meta = getmetatable(objIn)
	if oldtypeof(meta) ~= "table" then return objType end

	-- Has a metatable that's an exposed table.
	local customType: string? = meta["__type"] -- I want to mandate that this is a string.
	if customType == nil then return objType end

	-- Has a type field
	return customType
end

return typeof]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042c7</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXF7969AA6128D4FBBA5A0B4B0EE6BB5DD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009682</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_PartCache</string>
							<string name="ScriptGuid">{785D6880-8F05-47EF-81A0-63DE91712C7C}</string>
							<ProtectedString name="Source"><![CDATA[--!strict

--[[
	PartCache V4.0 by Xan the Dragon // Eti the Spirit -- RBX 18406183
	Update V4.0 has added Luau Strong Type Enforcement.
	
	Creating parts is laggy, especially if they are supposed to be there for a split second and/or need to be made frequently.
	This module aims to resolve this lag by pre-creating the parts and CFraming them to a location far away and out of sight.
	When necessary, the user can get one of these parts and CFrame it to where they need, then return it to the cache when they are done with it.
	
	According to someone instrumental in Roblox's backend technology, zeuxcg (https://devforum.roblox.com/u/zeuxcg/summary)...
		>> CFrame is currently the only "fast" property in that you can change it every frame without really heavy code kicking in. Everything else is expensive.
		
		- https://devforum.roblox.com/t/event-that-fires-when-rendering-finishes/32954/19
	
	This alone should ensure the speed granted by this module.
		
		
	HOW TO USE THIS MODULE:
	
	Look at the bottom of my thread for an API! https://devforum.roblox.com/t/partcache-for-all-your-quick-part-creation-needs/246641
--]]
local table = require(script._Table)

-----------------------------------------------------------
-------------------- MODULE DEFINITION --------------------
-----------------------------------------------------------

local PartCacheStatic = {}
PartCacheStatic.__index = PartCacheStatic
PartCacheStatic.__type = "PartCache" -- For compatibility with TypeMarshaller

-- TYPE DEFINITION: Part Cache Instance
export type PartCache = typeof(setmetatable({} :: {
	Open: {[number]: BasePart},
	InUse: {[number]: BasePart},
	CurrentCacheParent: Instance,
	Template: BasePart,
	ExpansionSize: number
}, PartCacheStatic))

-----------------------------------------------------------
----------------------- STATIC DATA -----------------------
-----------------------------------------------------------					

-- A CFrame that's really far away. Ideally. You are free to change this as needed.
local CF_REALLY_FAR_AWAY = CFrame.new(0, 10e8, 0)

-- Format params: methodName, ctorName
local ERR_NOT_INSTANCE = "Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"

-- Format params: paramName, expectedType, actualType
local ERR_INVALID_TYPE = "Invalid type for parameter '%s' (Expected %s, got %s)"

-----------------------------------------------------------
------------------------ UTILITIES ------------------------
-----------------------------------------------------------

--Similar to assert but warns instead of errors.
local function assertwarn(requirement: boolean, messageIfNotMet: string)
	if requirement == false then
		warn(messageIfNotMet)
	end
end

--Dupes a part from the template.
local function MakeFromTemplate(template: BasePart, currentCacheParent: Instance): BasePart
	local part: BasePart = template:Clone()
	-- ^ Ignore W000 type mismatch between Instance and BasePart. False alert.
	
	part.CFrame = CF_REALLY_FAR_AWAY
	part.Anchored = true
	part.Parent = currentCacheParent
	return part
end

function PartCacheStatic.new(template: BasePart, numPrecreatedParts: number?, currentCacheParent: Instance?): PartCache
	local newNumPrecreatedParts: number = numPrecreatedParts or 5
	local newCurrentCacheParent: Instance = currentCacheParent or workspace
	
	--PrecreatedParts value.
	--Same thing. Ensure it's a number, ensure it's not negative, warn if it's really huge or 0.
	assert(numPrecreatedParts > 0, "PrecreatedParts can not be negative!")
	assertwarn(numPrecreatedParts ~= 0, "PrecreatedParts is 0! This may have adverse effects when initially using the cache.")
	assertwarn(template.Archivable, "The template's Archivable property has been set to false, which prevents it from being cloned. It will temporarily be set to true.")
	
	local oldArchivable = template.Archivable
	template.Archivable = true
	local newTemplate: BasePart = template:Clone()
	-- ^ Ignore W000 type mismatch between Instance and BasePart. False alert.
	
	template.Archivable = oldArchivable
	template = newTemplate
	
	local object = {
		Open = {},
		InUse = {},
		CurrentCacheParent = newCurrentCacheParent,
		Template = template,
		ExpansionSize = 10
	}
	setmetatable(object, PartCacheStatic)
	
	-- Below: Ignore type mismatch nil | number and the nil | Instance mismatch on the table.insert line.
	for _ = 1, newNumPrecreatedParts do
		table.insert(object.Open, MakeFromTemplate(template, object.CurrentCacheParent))
	end
	object.Template.Parent = nil
	
	return object :: any
	-- ^ Ignore mismatch here too
end

-- Gets a part from the cache, or creates one if no more are available.
function PartCacheStatic:GetPart(): BasePart
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("GetPart", "PartCache.new"))
	
	if #self.Open == 0 then
		warn("No parts available in the cache! Creating [" .. self.ExpansionSize .. "] new part instance(s) - this amount can be edited by changing the ExpansionSize property of the PartCache instance... (This cache now contains a grand total of " .. tostring(#self.Open + #self.InUse + self.ExpansionSize) .. " parts.)")
		for i = 1, self.ExpansionSize, 1 do
			table.insert(self.Open, MakeFromTemplate(self.Template, self.CurrentCacheParent))
		end
	end
	local part = self.Open[#self.Open]
	self.Open[#self.Open] = nil
	table.insert(self.InUse, part)
	return part
end

-- Returns a part to the cache.
function PartCacheStatic:ReturnPart(part: BasePart)
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("ReturnPart", "PartCache.new"))
	
	local index = table.indexOf(self.InUse, part)
	if index ~= nil then
		table.remove(self.InUse, index)
		table.insert(self.Open, part)
		part.CFrame = CF_REALLY_FAR_AWAY
		part.Anchored = true
	else
		error("Attempted to return part \"" .. part.Name .. "\" (" .. part:GetFullName() .. ") to the cache, but it's not in-use! Did you call this on the wrong part?")
	end
end

-- Sets the parent of all cached parts.
function PartCacheStatic:SetCacheParent(newParent: Instance)
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("SetCacheParent", "PartCache.new"))
	assert(newParent:IsDescendantOf(workspace) or newParent == workspace, "Cache parent is not a descendant of Workspace! Parts should be kept where they will remain in the visible world.")
	
	self.CurrentCacheParent = newParent
	for i = 1, #self.Open do
		self.Open[i].Parent = newParent
	end
	for i = 1, #self.InUse do
		self.InUse[i].Parent = newParent
	end
end

-- Adds numParts more parts to the cache.
function PartCacheStatic:Expand(numParts: number): ()
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("Expand", "PartCache.new"))
	if numParts == nil then
		numParts = self.ExpansionSize
	end
	
	for i = 1, numParts do
		table.insert(self.Open, MakeFromTemplate(self.Template, self.CurrentCacheParent))
	end
end

-- Destroys this cache entirely. Use this when you don't need this cache object anymore.
function PartCacheStatic:Dispose()
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("Dispose", "PartCache.new"))
	for i = 1, #self.Open do
		self.Open[i]:Destroy()
	end
	for i = 1, #self.InUse do
		self.InUse[i]:Destroy()
	end
	self.Template:Destroy()
	self.Open = {}
	self.InUse = {}
	self.CurrentCacheParent = nil
	
	self.GetPart = nil
	self.ReturnPart = nil
	self.SetCacheParent = nil
	self.Expand = nil
	self.Dispose = nil
end

return PartCacheStatic]]></ProtectedString>
							<int64 name="SourceAssetId">2904807375</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042c8</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXDB3C73DD979644E4AFFD0CC58DE993DD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009683</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_Table</string>
								<string name="ScriptGuid">{AE3E606D-91BC-4DFF-B708-4D12AF91302E}</string>
								<ProtectedString name="Source"><![CDATA[--!nocheck
--^ It works. Just get the type checker to shut up so that people don't send bug reports :P

--[[
	To use: local table = require(this)
	(Yes, override table.)

	Written by EtiTheSpirit. Adds custom functions to the `table` value provided by roblox (in normal cases, this would simply modify `table`, but Roblox has disabled that so we need to use a proxy)
	
	CHANGES:
		3 December 2019 @ 11:07 PM CST:
			+ Added table.join
			
			
		21 November 2019 @ 6:50 PM CST:
			+ Added new method bodies to skip/take using Luau's new methods. Drastic speed increases achieved. CREDITS: Halalaluyafail3 (See https://devforum.roblox.com/t/sandboxed-table-system-add-custom-methods-to-table/391177/12?u=etithespirit)
			+ Added table.retrieve as proposed by ^ under the name "table.range" as this name relays what it does a bit better, I think.
			+ Added table.skipAndTake as an alias method.

--]]

local RNG = Random.new()
local Table = {}

for index, value in pairs(table) do
	Table[index] = value
end

-- Returns true if the table contains the specified value.
Table.contains = function (tbl, value)
	return Table.indexOf(tbl, value) ~= nil -- This is kind of cheatsy but it promises the best performance.
end

-- A combo of table.find and table.keyOf -- This first attempts to find the ordinal index of your value, then attempts to find the lookup key if it can't find an ordinal index.
Table.indexOf = function (tbl, value)
	local fromFind = table.find(tbl, value)
	if fromFind then return fromFind end
	
	return Table.keyOf(tbl, value)
end

-- Returns the key of the specified value, or nil if it could not be found. Unlike IndexOf, this searches every key in the table, not just ordinal indices (arrays)
-- This is inherently slower due to how lookups work, so if your table is structured like an array, use table.find
Table.keyOf = function (tbl, value)
	for index, obj in pairs(tbl) do
		if obj == value then
			return index
		end
	end
	return nil
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Skips *n* objects in the table, and returns a new table that contains indices (n + 1) to (end of table)
Table.skip = function (tbl, n)
	return table.move(tbl, n+1, #tbl, 1, table.create(#tbl-n))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes *n* objects from a table and returns a new table only containing those objects.
Table.take = function (tbl, n)
	return table.move(tbl, 1, n, 1, table.create(n))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes the range of entries in this table in the range [start, finish] and returns that range as a table.
Table.range = function (tbl, start, finish)
	return table.move(tbl, start, finish, 1, table.create(finish - start + 1))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). An alias that calls table.skip(skip), and then takes [take] entries from the resulting table.
Table.skipAndTake = function (tbl, skip, take)
	return table.move(tbl, skip + 1, skip + take, 1, table.create(take))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Selects a random object out of tbl
Table.random = function (tbl)
	return tbl[RNG:NextInteger(1, #tbl)]
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Merges tbl0 and tbl1 together.
Table.join = function (tbl0, tbl1)
	local nt = table.create(#tbl0 + #tbl1)
	local t2 = table.move(tbl0, 1, #tbl0, 1, nt)
	return table.move(tbl1, 1, #tbl1, #tbl0 + 1, nt)
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Removes the specified object from this array.
Table.removeObject = function (tbl, obj)
	local index = Table.indexOf(tbl, obj)
	if index then
		table.remove(tbl, index)
	end
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Allocates a new table by getting the length of the current table and increasing its capacity by the specified amount.
-- This uses Roblox's table.create function.
Table.expand = function (tbl, byAmount)
	if (byAmount < 0) then
		error("Cannot expand a table by a negative amount of objects.")
	end
	
	local newtbl = table.create(#tbl + byAmount)
	for i = 1, #tbl do
		newtbl[i] = tbl[i]
	end
	return newtbl
end

return Table]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042c9</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX87501E1933054343A7DF3906D4969F8A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009684</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Cache</string>
							<string name="ScriptGuid">{42CABA44-0450-486F-8611-0BE56325EC3B}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 3/7/25
--[[@description:
    Basic cache class with a pre-defined size.
    Has a _lookup table for O(1) key lookups.
]]
-----------------------------
-- TYPES --
-----------------------------
type CacheEntry = {
	Key: any,
	Value: any,
}
type fields = {
	_size: number,
	_cache: { CacheEntry },
	_lookup: { [any]: number }, -- maps key -> index in _cache
}

-----------------------------
-- VARIABLES --
-----------------------------
local CacheClass = {}
local MT = {}
MT.__index = MT
MT.__newindex = function()
	error("Unable to set a new value directly in CacheType object!")
end
export type CacheType = typeof(setmetatable({} :: fields, MT))

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-- Updates the lookup mapping for all cache entries starting at startIndex.
local function updateLookupFrom(self: CacheType, startIndex: number)
	for i = startIndex, #self._cache do
		local entry = self._cache[i]
		self._lookup[entry.Key] = i
	end
end

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Creates a new cache. Default size is 100 elements.
function CacheClass.new(size: number?): CacheType
	size = size or 100
	if typeof(size) ~= "number" or size <= 0 then
		error("Size must be a positive number!")
	end

	local self = {
		_size = size,
		_cache = table.create(size),
		_lookup = {},
	} :: fields

	return setmetatable(self, MT)
end

function MT.Get(self: CacheType, key: any): (any, number?)
	assert(key ~= nil, "Key must be non-nil.")
	local index = self._lookup[key]
	if index then
		return self._cache[index].Value, index
	end
	return nil, nil
end

-- Provide nil value to remove from cache.
function MT.Set(self: CacheType, key: any, value: any)
	assert(key ~= nil, "Key must be non-nil.")
	local isNilValue = (value == nil)
	local _, index = self:Get(key)

	if index then
		-- Remove the entry from its current position.
		local data = table.remove(self._cache, index)
		self._lookup[key] = nil
		updateLookupFrom(self, index :: number)
		if not isNilValue and data then
			data.Value = value
			table.insert(self._cache, data)
			self._lookup[key] = #self._cache
		end
	elseif not isNilValue then
		local data = {
			Key = key,
			Value = value,
		}
		if #self._cache >= self._size then
			-- Remove first element if at capacity.
			local removed = table.remove(self._cache, 1) :: CacheEntry
			self._lookup[removed.Key] = nil
			updateLookupFrom(self, 1)
		end
		table.insert(self._cache, data)
		self._lookup[key] = #self._cache
	end
end

-----------------------------
-- MAIN --
-----------------------------
return CacheClass
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042ca</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXBB2DFF4960AB4593B1BF56DA68D36EC7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc08218013000096ea</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_RandomRotator</string>
							<string name="ScriptGuid">{8BCA85B2-EA1C-421D-80AC-3DE070AF1E71}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 4/25/25
--[[@description:

]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local FunctionUtils = require("../FunctionUtils")
local t = FunctionUtils.t

-----------------------------
-- TYPES --
-----------------------------

type Angles = {
	X: number,
	Y: number,
	Z: number
}

export type PhaseOffsets = {
	X: number,
	Y: number,
	Z: number
}

type fields = {
	_config: RotationConfigStrict,
	_time: number,
	_lastTime: number,
	_startTime: number,
	_initialAngles: Angles,
	_angles: Angles,
	_phase: PhaseOffsets
}

export type RotationConfig = {
	RNG: Random?,
	RotSpeedX: number?,
	RotSpeedY: number?,
	RotSpeedZ: number?,
	VariationFrequency: number?,
	VariationAmplitude: number?,
	VariationPhaseOffset: { X: number?, Y: number?, Z: number? }?, -- X & Z use sine and Y uses cosine
	Clock: ( () -> number )?
}

type RotationConfigStrict = {
	RNG: Random,
	RotSpeedX: number,
	RotSpeedY: number,
	RotSpeedZ: number,
	VariationFrequency: number,
	VariationAmplitude: number,
	VariationPhaseOffset: { X: number?, Y: number?, Z: number? },
	Clock: ( () -> number )
}

-----------------------------
-- VARIABLES --
-----------------------------
local RandomRotator = {}
local MT = {}
MT.__index = MT
export type RandomRotator = typeof(setmetatable({} :: fields, MT))

-- CONSTANTS --
local DEFAULT_CONFIG: RotationConfigStrict = {
	RNG = Random.new(tick()),
	RotSpeedX = 0.02,
	RotSpeedY = 0.02,
	RotSpeedZ = 0.02,
	VariationFrequency = 0.5,
	VariationAmplitude = 0.5,
	VariationPhaseOffset = {},
	Clock = os.clock
}
local TAU = math.pi * 2

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- CLASS FUNCTIONS --
-----------------------------

function RandomRotator.new(config: RotationConfig?): RandomRotator
	local self = setmetatable({} :: fields, MT) :: RandomRotator
	self._config = FunctionUtils.Table.reconcile(config or {}, DEFAULT_CONFIG)
	local config = self._config
	local rng = config.RNG
	local offsets = config.VariationPhaseOffset
	
	self._startTime = config.Clock()
	self._time = self._startTime
	self._lastTime = self._startTime
	self._initialAngles = {
		X = self._config.RNG:NextNumber(0, TAU),
		Y = self._config.RNG:NextNumber(0, TAU),
		Z = self._config.RNG:NextNumber(0, TAU),
	}
	self._angles = table.clone(self._initialAngles)
	self._phase = {
		X = offsets.X or rng:NextNumber(0, TAU),
		Y = offsets.Y or rng:NextNumber(0, TAU),
		Z = offsets.Z or rng:NextNumber(0, TAU),
	}
	
	return self
end

function RandomRotator:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")

	return getmetatable(object) == MT
end

-----------------------------
-- METHODS --
-----------------------------

@native
-- Advances internal time and returns next CFrame rotation
function MT.Update(self: RandomRotator): CFrame
	local config = self._config
	local now = config.Clock()
	local dt = now - self._lastTime
	self._lastTime = now
	self._time = self._time + dt

	local elapsed = self._time - self._startTime
	local varFreq, varAmp = config.VariationFrequency, config.VariationAmplitude
	local randAmp = config.RNG:NextNumber(0.9, 1.1)

	-- per-axis variation
	local vx = math.sin(elapsed * varFreq + self._phase.X) * varAmp * randAmp
	local vy = math.cos(elapsed * varFreq + self._phase.Y) * varAmp * randAmp
	local vz = math.sin(elapsed * varFreq + self._phase.Z) * varAmp * randAmp

	self._angles.X += (config.RotSpeedX + vx) * dt
	self._angles.Y += (config.RotSpeedY + vy) * dt
	self._angles.Z += (config.RotSpeedZ + vz) * dt

	return CFrame.Angles(self._angles.X, self._angles.Y, self._angles.Z)
end

-- Reset timer, angles, and regenerate phases if not user-defined
function MT.Reset(self: RandomRotator)
	local config = self._config
	local rng = config.RNG

	self._startTime = config.Clock()
	self._lastTime = self._startTime
	self._time = self._startTime

	-- reseed angles
	self._angles.X = rng:NextNumber(0, TAU)
	self._angles.Y = rng:NextNumber(0, TAU)
	self._angles.Z = rng:NextNumber(0, TAU)
	self._initialAngles = table.clone(self._angles)

	-- regenerate phase offsets if not fixed by config
	local offsets = config.VariationPhaseOffset
	self._phase.X = offsets.X or rng:NextNumber(0, TAU)
	self._phase.Y = offsets.Y or rng:NextNumber(0, TAU)
	self._phase.Z = offsets.Z or rng:NextNumber(0, TAU)
end

-----------------------------
-- SETTERS --
-----------------------------

-----------------------------
-- GETTERS --
-----------------------------

function MT.GetRotationAt(self: RandomRotator, timestamp: number): CFrame
	local config = self._config
	local elapsed = math.max(0, timestamp - self._startTime)

	local varFreq, varAmp = config.VariationFrequency, config.VariationAmplitude
	local vx = math.sin(elapsed * varFreq + self._phase.X) * varAmp
	local vy = math.cos(elapsed * varFreq + self._phase.Y) * varAmp
	local vz = math.sin(elapsed * varFreq + self._phase.Z) * varAmp

	local ax = self._initialAngles.X + (config.RotSpeedX + vx) * elapsed
	local ay = self._initialAngles.Y + (config.RotSpeedY + vy) * elapsed
	local az = self._initialAngles.Z + (config.RotSpeedZ + vz) * elapsed

	return CFrame.Angles(ax, ay, az)
end

-----------------------------
-- CLEANUP --
-----------------------------

-----------------------------
-- MAIN --
-----------------------------
return RandomRotator]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042cb</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX23F1F9A9417D4F678D6B96F726B80E7F">
						<Properties>
							<BinaryString name="AttributesSerialize">AQAAAAcAAABWZXJzaW9uAgMAAAAxLjQ=</BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">3365651c0460667f0827e42500006334</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Packet</string>
							<string name="ScriptGuid">{7EFA7BD9-DF1D-44BF-BFC9-A82E90866F52}</string>
							<ProtectedString name="Source"><![CDATA[--!strict


-- Requires
local Signal = require(script._Signal)
local Task = require(script._Task)
local Types = require(script._Types)


-- Types
export type Packet<A... = (), B... = ()> = {
	Type:					"Packet",
	Id:						number,
	Name:					string,
	Reads:					{() -> any},
	Writes:					{(any) -> ()},
	ResponseTimeout:		number,
	ResponseTimeoutValue:	any,
	ResponseReads:			{() -> any},
	ResponseWrites:			{(any) -> ()},
	OnServerEvent:			Signal.Signal<(Player, A...)>,
	OnClientEvent:			Signal.Signal<A...>,
	OnServerInvoke:			nil | (player: Player, A...) -> B...,
	OnClientInvoke:			nil | (A...) -> B...,
	Response:				(self: Packet<A..., B...>, B...) -> Packet<A..., B...>,
	Fire:					(self: Packet<A..., B...>, A...) -> B...,
	FireClient:				(self: Packet<A..., B...>, player: Player, A...) -> B...,
	Serialize:				(self: Packet<A..., B...>, A...) -> (buffer, {Instance}?),
	Deserialize:			(self: Packet<A..., B...>, serializeBuffer: buffer, instances: {Instance}?) -> A...,
}


-- Varables
local ParametersToFunctions, TableToFunctions, ReadParameters, WriteParameters, Timeout
local RunService = game:GetService("RunService")
local PlayersService = game:GetService("Players")
local reads, writes, Import, Export, Truncate, Ended = Types.Reads, Types.Writes, Types.Import, Types.Export, Types.Truncate, Types.Ended
local ReadU8, WriteU8, ReadU16, WriteU16 = reads.NumberU8, writes.NumberU8, reads.NumberU16, writes.NumberU16
local Packet = {}			:: Packet<...any, ...any>
local packets = {}			:: {[string | number]: Packet<...any, ...any>}
local playerCursors			: {[Player]: Types.Cursor}
local playerThreads			: {[Player]: {[number]: {Yielded: thread, Timeout: thread}, Index: number}}
local threads				: {[number]: {Yielded: thread, Timeout: thread}, Index: number}
local remoteEvent			: RemoteEvent
local packetCounter			: number
local cursor = {Buffer = buffer.create(128), BufferLength = 128, BufferOffset = 0, Instances = {}, InstancesOffset = 0}


-- Constructor
local function Constructor<A..., B...>(_, name: string, ...: A...)
	local packet = packets[name] :: Packet<A..., B...>
	if packet then return packet end
	local packet = (setmetatable({}, Packet) :: any) :: Packet<A..., B...>
	packet.Name = name
	if RunService:IsServer() then
		packet.Id = packetCounter
		packet.OnServerEvent = Signal() :: Signal.Signal<(Player, A...)>
		remoteEvent:SetAttribute(name, packetCounter)
		packets[packetCounter] = packet
		packetCounter += 1
	else
		packet.Id = remoteEvent:GetAttribute(name)
		--if not packet.Id then
		--	repeat task.wait() packet.Id = remoteEvent:GetAttribute(name) until packet.Id or not RunService:IsRunning()
		--end
		packet.OnClientEvent = Signal() :: Signal.Signal<A...>
		if packet.Id then packets[packet.Id] = packet end
	end
	packet.Reads, packet.Writes = ParametersToFunctions(table.pack(...))
	packets[packet.Name] = packet
	return packet
end


-- Packet
Packet["__index"] = Packet
Packet.Type = "Packet"

function Packet:Response(...)
	self.ResponseTimeout = self.ResponseTimeout or 10
	self.ResponseReads, self.ResponseWrites = ParametersToFunctions(table.pack(...))
	return self
end

function Packet:Fire(...)
	if self.ResponseReads then
		if RunService:IsServer() then error("You must use FireClient(player)", 2) end
		local responseThread
		for i = 1, 128 do
			responseThread = threads[threads.Index]
			if responseThread then threads.Index = (threads.Index + 1) % 128 else break end
		end
		if responseThread then error("Cannot have more than 128 yielded threads", 2) end
		Import(cursor)
		WriteU8(self.Id)
		WriteU8(threads.Index)
		threads[threads.Index] = {Yielded = coroutine.running(), Timeout = Task:Delay(self.ResponseTimeout, Timeout, threads, threads.Index, self.ResponseTimeoutValue)}
		threads.Index = (threads.Index + 1) % 128
		WriteParameters(self.Writes, {...})
		cursor = Export()
		return coroutine.yield()
	else
		Import(cursor)
		WriteU8(self.Id)
		WriteParameters(self.Writes, {...})
		cursor = Export()
	end
end

function Packet:FireClient(player, ...)
	if player.Parent == nil then return end
	if self.ResponseReads then
		local threads = playerThreads[player]
		if threads == nil then threads = {Index = 0} playerThreads[player] = threads end
		local responseThread
		for i = 1, 128 do
			responseThread = threads[threads.Index]
			if responseThread then threads.Index = (threads.Index + 1) % 128 else break end
		end
		if responseThread then error("Cannot have more than 128 yielded threads", 2) return end
		Import(playerCursors[player] or {Buffer = buffer.create(128), BufferLength = 128, BufferOffset = 0, Instances = {}, InstancesOffset = 0})
		WriteU8(self.Id)
		WriteU8(threads.Index)
		threads[threads.Index] = {Yielded = coroutine.running(), Timeout = Task:Delay(self.ResponseTimeout, Timeout, threads, threads.Index, self.ResponseTimeoutValue)}
		threads.Index = (threads.Index + 1) % 128
		WriteParameters(self.Writes, {...})
		playerCursors[player] = Export()
		return coroutine.yield()
	else
		Import(playerCursors[player] or {Buffer = buffer.create(128), BufferLength = 128, BufferOffset = 0, Instances = {}, InstancesOffset = 0})
		WriteU8(self.Id)
		WriteParameters(self.Writes, {...})
		playerCursors[player] = Export()
	end
end

function Packet:Serialize(...)
	Import({Buffer = buffer.create(128), BufferLength = 128, BufferOffset = 0, Instances = {}, InstancesOffset = 0})
	WriteParameters(self.Writes, {...})
	return Truncate()
end

function Packet:Deserialize(serializeBuffer, instances)
	Import({Buffer = serializeBuffer, BufferLength = buffer.len(serializeBuffer), BufferOffset = 0, Instances = instances or {}, InstancesOffset = 0})
	return ReadParameters(self.Reads)
end


-- Functions
function ParametersToFunctions(parameters: {any})
	local readFunctions, writeFunctions = table.create(#parameters), table.create(#parameters)
	for index, parameter in ipairs(parameters) do
		if type(parameter) == "table" then
			readFunctions[index], writeFunctions[index] = TableToFunctions(parameter)
		else
			readFunctions[index], writeFunctions[index] = reads[parameter], writes[parameter]
		end
	end
	return readFunctions, writeFunctions
end

function TableToFunctions(parameters: {any})
	if #parameters == 1 then
		local parameter = parameters[1]
		local ReadFunction, WriteFunction
		if type(parameter) == "table" then
			ReadFunction, WriteFunction = TableToFunctions(parameter)
		else
			ReadFunction, WriteFunction = reads[parameter], writes[parameter]
		end
		local Read = function()
			local length = ReadU16()
			local values = table.create(length)
			for index = 1, length do values[index] = ReadFunction() end
			return values
		end
		local Write = function(values: {any})
			WriteU16(#values)
			for index, value in values do WriteFunction(value) end
		end
		return Read, Write
	else
		local keys = {} for key, value in parameters do table.insert(keys, key) end table.sort(keys)
		local readFunctions, writeFunctions = table.create(#keys), table.create(#keys)
		for index, key in keys do
			local parameter = parameters[key]
			if type(parameter) == "table" then 
				readFunctions[index], writeFunctions[index] = TableToFunctions(parameter)
			else
				readFunctions[index], writeFunctions[index] = reads[parameter], writes[parameter]
			end
		end
		local Read = function()
			local values = {}
			for index, ReadFunction in readFunctions do values[keys[index]] = ReadFunction() end
			return values
		end
		local Write = function(values: {[any]: any})
			for index, WriteFunction in writeFunctions do WriteFunction(values[keys[index]]) end
		end
		return Read, Write
	end
end

function ReadParameters(reads: {() -> any})
	local values = table.create(#reads)
	for index, func in reads do values[index] = func() end
	return table.unpack(values)
end

function WriteParameters(writes: {(any) -> ()}, values: {any})
	for index, func in writes do func(values[index]) end
end

function Timeout(threads: {[number]: {Yielded: thread, Timeout: thread}, Index: number}, threadIndex: number, value: any)
	local responseThreads = threads[threadIndex]
	task.defer(responseThreads.Yielded, value)
	threads[threadIndex] = nil
end


-- Initialize
if RunService:IsServer() then
	playerCursors = {}
	playerThreads = {}
	packetCounter = 0
	remoteEvent = Instance.new("RemoteEvent", script)

	local playerBytes = {}

	local thread = task.spawn(function()
		while true do
			coroutine.yield()
			if cursor.BufferOffset > 0 then
				local truncatedBuffer = buffer.create(cursor.BufferOffset)
				buffer.copy(truncatedBuffer, 0, cursor.Buffer, 0, cursor.BufferOffset)
				if cursor.InstancesOffset == 0 then
					remoteEvent:FireAllClients(truncatedBuffer)
				else
					remoteEvent:FireAllClients(truncatedBuffer, cursor.Instances)
					cursor.InstancesOffset = 0
					table.clear(cursor.Instances)
				end
				cursor.BufferOffset = 0
			end
			for player, cursor in playerCursors do
				local truncatedBuffer = buffer.create(cursor.BufferOffset)
				buffer.copy(truncatedBuffer, 0, cursor.Buffer, 0, cursor.BufferOffset)
				if cursor.InstancesOffset == 0 then
					remoteEvent:FireClient(player, truncatedBuffer)
				else
					remoteEvent:FireClient(player, truncatedBuffer, cursor.Instances)
				end
			end
			table.clear(playerCursors)
			table.clear(playerBytes)
		end
	end)

	local respond = function(packet: Packet, player: Player, threadIndex: number, ...)
		if packet.OnServerInvoke == nil then if RunService:IsStudio() then warn("OnServerInvoke not found for packet:", packet.Name, "discarding event:", ...) end return end
		local values = {packet.OnServerInvoke(player, ...)}
		if player.Parent == nil then return end
		Import(playerCursors[player] or {Buffer = buffer.create(128), BufferLength = 128, BufferOffset = 0, Instances = {}, InstancesOffset = 0})
		WriteU8(packet.Id)
		WriteU8(threadIndex + 128)
		WriteParameters(packet.ResponseWrites, values)
		playerCursors[player] = Export()
	end

	local onServerEvent = function(player: Player, receivedBuffer: buffer, instances: {Instance}?)
		local bytes = (playerBytes[player] or 0) + math.max(buffer.len(receivedBuffer), 800)
		if bytes > 8_000 then if RunService:IsStudio() then warn(player.Name, "is exceeding the data/rate limit; some events may be dropped") end return end
		playerBytes[player] = bytes
		Import({Buffer = receivedBuffer, BufferLength = buffer.len(receivedBuffer), BufferOffset = 0, Instances = instances or {}, InstancesOffset = 0})
		while Ended() == false do
			local packet = packets[ReadU8()]
			if packet.ResponseReads then
				local threadIndex = ReadU8()
				if threadIndex < 128 then
					Task:Defer(respond, packet, player, threadIndex, ReadParameters(packet.Reads))
				else
					threadIndex -= 128
					local responseThreads = playerThreads[player][threadIndex]
					if responseThreads then
						task.cancel(responseThreads.Timeout)
						task.defer(responseThreads.Yielded, ReadParameters(packet.ResponseReads))
						playerThreads[player][threadIndex] = nil
					elseif RunService:IsStudio() then
						warn("Response thread not found for packet:", packet.Name, "discarding response:", ReadParameters(packet.ResponseReads))
					else
						ReadParameters(packet.ResponseReads)
					end
				end
			else
				packet.OnServerEvent:Fire(player, ReadParameters(packet.Reads))
			end
		end
	end

	remoteEvent.OnServerEvent:Connect(function(player: Player, ...)
		local success, errorMessage: string? = pcall(onServerEvent, player, ...)
		if errorMessage and RunService:IsStudio() then warn(player.Name, errorMessage) end
	end)

	PlayersService.PlayerRemoving:Connect(function(player)
		playerCursors[player] = nil
		playerThreads[player] = nil
		playerBytes[player] = nil
	end)

	RunService.Heartbeat:Connect(function(deltaTime) task.defer(thread) end)
else
	threads = {Index = 0}
	remoteEvent = script:WaitForChild("RemoteEvent")
	local totalTime = 0

	local thread = task.spawn(function()
		while true do
			coroutine.yield()
			if cursor.BufferOffset > 0 then
				local truncatedBuffer = buffer.create(cursor.BufferOffset)
				buffer.copy(truncatedBuffer, 0, cursor.Buffer, 0, cursor.BufferOffset)
				if cursor.InstancesOffset == 0 then
					remoteEvent:FireServer(truncatedBuffer)
				else
					remoteEvent:FireServer(truncatedBuffer, cursor.Instances)
					cursor.InstancesOffset = 0
					table.clear(cursor.Instances)
				end
				cursor.BufferOffset = 0
			end
		end
	end)

	local respond = function(packet: Packet, threadIndex: number, ...)
		if packet.OnClientInvoke == nil then warn("OnClientInvoke not found for packet:", packet.Name, "discarding event:", ...) return end
		local values = {packet.OnClientInvoke(...)}
		Import(cursor)
		WriteU8(packet.Id)
		WriteU8(threadIndex + 128)
		WriteParameters(packet.ResponseWrites, values)
		cursor = Export()
	end

	remoteEvent.OnClientEvent:Connect(function(receivedBuffer: buffer, instances: {Instance}?)
		Import({Buffer = receivedBuffer, BufferLength = buffer.len(receivedBuffer), BufferOffset = 0, Instances = instances or {}, InstancesOffset = 0})
		while Ended() == false do
			local packet = packets[ReadU8()]
			if packet.ResponseReads then
				local threadIndex = ReadU8()
				if threadIndex < 128 then
					Task:Defer(respond, packet, threadIndex, ReadParameters(packet.Reads))
				else
					threadIndex -= 128
					local responseThreads = threads[threadIndex]
					if responseThreads then
						task.cancel(responseThreads.Timeout)
						task.defer(responseThreads.Yielded, ReadParameters(packet.ResponseReads))
						threads[threadIndex] = nil
					else
						warn("Response thread not found for packet:", packet.Name, "discarding response:", ReadParameters(packet.ResponseReads))
					end
				end
			else
				packet.OnClientEvent:Fire(ReadParameters(packet.Reads))
			end
		end
	end)

	remoteEvent.AttributeChanged:Connect(function(name)
		local packet = packets[name]
		if packet then
			if packet.Id then packets[packet.Id] = nil end
			packet.Id = remoteEvent:GetAttribute(name)
			if packet.Id then packets[packet.Id] = packet end
		end
	end)

	RunService.Heartbeat:Connect(function(deltaTime)
		totalTime += deltaTime
		if totalTime > 0.016666666666666666 then
			totalTime %= 0.016666666666666666
			task.defer(thread)
		end
	end)
end


return setmetatable(Types.Types, {__call = Constructor})]]></ProtectedString>
							<int64 name="SourceAssetId">104116977416770</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042cc</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXD0160C3BFCC544E3B7862246E49090C2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">3365651c0460667f0827e42500006335</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_Signal</string>
								<string name="ScriptGuid">{1E137948-DAD1-4BAE-803D-D72655D21404}</string>
								<ProtectedString name="Source"><![CDATA[--!strict


-- Requires
local Task = require(script.Parent._Task)


-- Types
export type Signal<A... = ()> = {
	Type:					"Signal",
	Previous:				Connection<A...>,
	Next:					Connection<A...>,
	Fire:					(self: Signal<A...>, A...) -> (),
	Connect:				(self: Signal<A...>, func: (A...) -> ()) -> Connection<A...>,
	Once:					(self: Signal<A...>, func: (A...) -> ()) -> Connection<A...>,
	Wait:					(self: Signal<A...>) -> A...,
}

export type Connection<A... = ()> = {
	Type:					"Connection",
	Previous:				Connection<A...>,
	Next:					Connection<A...>,
	Once:					boolean,
	Function:				(player: Player, A...) -> (),
	Thread:					thread,
	Disconnect:				(self: Connection<A...>) -> (),
}


-- Varables
local Signal = {}			:: Signal<...any>
local Connection = {}		:: Connection<...any>


-- Constructor
local function Constructor<A...>()
	local signal = (setmetatable({}, Signal) :: any) :: Signal<A...>
	signal.Previous = signal :: any
	signal.Next = signal :: any
	return signal
end


-- Signal
Signal["__index"] = Signal
Signal.Type = "Signal"

function Signal:Connect(func)
	local connection = (setmetatable({}, Connection) :: any) :: Connection
	connection.Previous = self.Previous
	connection.Next = self :: any
	connection.Once = false
	connection.Function = func
	self.Previous.Next = connection
	self.Previous = connection
	return connection
end

function Signal:Once(func)
	local connection = (setmetatable({}, Connection) :: any) :: Connection
	connection.Previous = self.Previous
	connection.Next = self :: any
	connection.Once = true
	connection.Function = func
	self.Previous.Next = connection
	self.Previous = connection
	return connection
end

function Signal:Wait()
	local connection = (setmetatable({}, Connection) :: any) :: Connection
	connection.Previous = self.Previous
	connection.Next = self :: any
	connection.Once = true
	connection.Thread = coroutine.running()
	self.Previous.Next = connection
	self.Previous = connection
	return coroutine.yield()
end

function Signal:Fire(...)
	local connection = self.Next
	while connection.Type == "Connection" do
		if connection.Function then Task:Defer(connection.Function, ...) else task.defer(connection.Thread, ...) end
		if connection.Once then connection.Previous.Next = connection.Next connection.Next.Previous = connection.Previous end
		connection = connection.Next
	end
end


-- Connection
Connection["__index"] = Connection
Connection.Type = "Connection"

function Connection:Disconnect()
	self.Previous.Next = self.Next
	self.Next.Previous = self.Previous
end


return Constructor]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042cd</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXCE35014002F044D29155BB804A2A5D09">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">3365651c0460667f0827e42500006336</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_Task</string>
								<string name="ScriptGuid">{6610827D-22F6-4FB8-A066-61B71AB8D251}</string>
								<ProtectedString name="Source"><![CDATA[--!strict


-- Types
export type Task = {
	Type:					"Task",
	Spawn:					(self: Task, func: (...any) -> (), ...any) -> thread,
	Defer:					(self: Task, func: (...any) -> (), ...any) -> thread,
	Delay:					(self: Task, duration: number, func: (...any) -> (), ...any) -> thread,
}


-- Varables
local Call, Thread
local Task = {}				:: Task
local threads = {}			:: {thread}


-- Task
Task.Type = "Task"

function Task:Spawn(func, ...)
	return task.spawn(table.remove(threads) or task.spawn(Thread), func, ...)
end

function Task:Defer(func, ...)
	return task.defer(table.remove(threads) or task.spawn(Thread), func, ...)
end

function Task:Delay(duration, func, ...)
	return task.delay(duration, table.remove(threads) or task.spawn(Thread), func, ...)
end


-- Functions
function Call(func: (...any) -> (), ...)
	func(...)
	table.insert(threads, coroutine.running())
end

function Thread()
	while true do Call(coroutine.yield()) end
end


return Task]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042ce</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE764E09428764A7A82F0986E3209BCE0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">3365651c0460667f0827e42500006337</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_Types</string>
								<string name="ScriptGuid">{EBFC732B-847E-4342-8E48-C0EB790F847A}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--!optimize 2

--[[
	S8		Minimum: -128			Maximum: 127
	S16		Minimum: -32768			Maximum: 32767
	S24		Minimum: -8388608		Maximum: 8388607
	S32		Minimum: -2147483648	Maximum: 2147483647

	U8		Minimum: 0				Maximum: 255
	U16		Minimum: 0				Maximum: 65535
	U24		Minimum: 0				Maximum: 16777215
	U32		Minimum: 0				Maximum: 4294967295

	F16		±2048					[65520]
	F24		±262144					[4294959104]
	F32		±16777216				[170141183460469231731687303715884105728]
	F64		±9007199254740992		[huge]
]]


-- Types
export type Cursor = {
	Buffer:					buffer,
	BufferLength:			number,
	BufferOffset:			number,
	Instances:				{Instance},
	InstancesOffset:		number,
}


-- Varables
local activeCursor			: Cursor
local activeBuffer			: buffer
local bufferLength			: number
local bufferOffset			: number
local instances				: {Instance}
local instancesOffset		: number
local types = {}
local reads = {}
local writes = {}
local anyReads = {}			:: {[any]: () -> any}
local anyWrites = {}		:: {[any]: (any) -> ()}
local enums = Enum:GetEnums() :: {any} -- fix type checking bug
local enumIndices = {} for index, enum in enums do enumIndices[enum] = index end


-- Functions
local function Allocate(bytes: number)
	local targetLength = bufferOffset + bytes
	if bufferLength < targetLength then
		while bufferLength < targetLength do bufferLength *= 2 end
		local newBuffer = buffer.create(bufferLength)
		buffer.copy(newBuffer, 0, activeBuffer, 0, bufferOffset)
		activeCursor.Buffer = newBuffer
		activeBuffer = newBuffer
	end
end

local function ReadS8(): number local value = buffer.readi8(activeBuffer, bufferOffset) bufferOffset += 1 return value end
local function WriteS8(value: number) buffer.writei8(activeBuffer, bufferOffset, value) bufferOffset += 1 end
local function ReadS16(): number local value = buffer.readi16(activeBuffer, bufferOffset) bufferOffset += 2 return value end
local function WriteS16(value: number) buffer.writei16(activeBuffer, bufferOffset, value) bufferOffset += 2 end
local function ReadS24(): number local value = buffer.readbits(activeBuffer, bufferOffset * 8, 24) - 8388608 bufferOffset += 3 return value end
local function WriteS24(value: number) buffer.writebits(activeBuffer, bufferOffset * 8, 24, value + 8388608) bufferOffset += 3 end
local function ReadS32(): number local value = buffer.readi32(activeBuffer, bufferOffset) bufferOffset += 4 return value end
local function WriteS32(value: number) buffer.writei32(activeBuffer, bufferOffset, value) bufferOffset += 4 end
local function ReadU8(): number local value = buffer.readu8(activeBuffer, bufferOffset) bufferOffset += 1 return value end
local function WriteU8(value: number) buffer.writeu8(activeBuffer, bufferOffset, value) bufferOffset += 1 end
local function ReadU16(): number local value = buffer.readu16(activeBuffer, bufferOffset) bufferOffset += 2 return value end
local function WriteU16(value: number) buffer.writeu16(activeBuffer, bufferOffset, value) bufferOffset += 2 end
local function ReadU24(): number local value = buffer.readbits(activeBuffer, bufferOffset * 8, 24) bufferOffset += 3 return value end
local function WriteU24(value: number) buffer.writebits(activeBuffer, bufferOffset * 8, 24, value) bufferOffset += 3 end
local function ReadU32(): number local value = buffer.readu32(activeBuffer, bufferOffset) bufferOffset += 4 return value end
local function WriteU32(value: number) buffer.writeu32(activeBuffer, bufferOffset, value) bufferOffset += 4 end
local function ReadF32(): number local value = buffer.readf32(activeBuffer, bufferOffset) bufferOffset += 4 return value end
local function WriteF32(value: number) buffer.writef32(activeBuffer, bufferOffset, value) bufferOffset += 4 end
local function ReadF64(): number local value = buffer.readf64(activeBuffer, bufferOffset) bufferOffset += 8 return value end
local function WriteF64(value: number) buffer.writef64(activeBuffer, bufferOffset, value) bufferOffset += 8 end
local function ReadString(length: number) local value = buffer.readstring(activeBuffer, bufferOffset, length) bufferOffset += length return value end
local function WriteString(value: string) buffer.writestring(activeBuffer, bufferOffset, value) bufferOffset += #value end
local function ReadBuffer(length: number) local value = buffer.create(length) buffer.copy(value, 0, activeBuffer, bufferOffset, length) bufferOffset += length return value end
local function WriteBuffer(value: buffer) buffer.copy(activeBuffer, bufferOffset, value) bufferOffset += buffer.len(value) end
local function ReadInstance() instancesOffset += 1 return instances[instancesOffset] end
local function WriteInstance(value) instancesOffset += 1 instances[instancesOffset] = value end

local function ReadF16(): number
	local bitOffset = bufferOffset * 8
	bufferOffset += 2
	local mantissa = buffer.readbits(activeBuffer, bitOffset + 0, 10)
	local exponent = buffer.readbits(activeBuffer, bitOffset + 10, 5)
	local sign = buffer.readbits(activeBuffer, bitOffset + 15, 1)
	if mantissa == 0b0000000000 then
		if exponent == 0b00000 then return 0 end
		if exponent == 0b11111 then return if sign == 0 then math.huge else -math.huge end
	elseif exponent == 0b11111 then return 0/0 end
	if sign == 0 then
		return (mantissa / 1024 + 1) * 2 ^ (exponent - 15)
	else
		return -(mantissa / 1024 + 1) * 2 ^ (exponent - 15)
	end
end
local function WriteF16(value: number)
	local bitOffset = bufferOffset * 8
	bufferOffset += 2
	if value == 0 then
		buffer.writebits(activeBuffer, bitOffset, 16, 0b0_00000_0000000000)
	elseif value >= 65520 then
		buffer.writebits(activeBuffer, bitOffset, 16, 0b0_11111_0000000000)
	elseif value <= -65520 then
		buffer.writebits(activeBuffer, bitOffset, 16, 0b1_11111_0000000000)
	elseif value ~= value then
		buffer.writebits(activeBuffer, bitOffset, 16, 0b0_11111_0000000001)
	else
		local sign = 0
		if value < 0 then sign = 1 value = -value end
		local mantissa, exponent = math.frexp(value)
		buffer.writebits(activeBuffer, bitOffset + 0, 10, mantissa * 2048 - 1023.5)
		buffer.writebits(activeBuffer, bitOffset + 10, 5, exponent + 14)
		buffer.writebits(activeBuffer, bitOffset + 15, 1, sign)
	end
end

local function ReadF24(): number
	local bitOffset = bufferOffset * 8
	bufferOffset += 3
	local mantissa = buffer.readbits(activeBuffer, bitOffset + 0, 17)
	local exponent = buffer.readbits(activeBuffer, bitOffset + 17, 6)
	local sign = buffer.readbits(activeBuffer, bitOffset + 23, 1)
	if mantissa == 0b00000000000000000 then
		if exponent == 0b000000 then return 0 end
		if exponent == 0b111111 then return if sign == 0 then math.huge else -math.huge end
	elseif exponent == 0b111111 then return 0/0 end
	if sign == 0 then
		return (mantissa / 131072 + 1) * 2 ^ (exponent - 31)
	else
		return -(mantissa / 131072 + 1) * 2 ^ (exponent - 31)
	end
end
local function WriteF24(value: number)
	local bitOffset = bufferOffset * 8
	bufferOffset += 3
	if value == 0 then
		buffer.writebits(activeBuffer, bitOffset, 24, 0b0_000000_00000000000000000) 
	elseif value >= 4294959104 then
		buffer.writebits(activeBuffer, bitOffset, 24, 0b0_111111_00000000000000000)
	elseif value <= -4294959104 then
		buffer.writebits(activeBuffer, bitOffset, 24, 0b1_111111_00000000000000000)
	elseif value ~= value then
		buffer.writebits(activeBuffer, bitOffset, 24, 0b0_111111_00000000000000001)
	else
		local sign = 0
		if value < 0 then sign = 1 value = -value end
		local mantissa, exponent = math.frexp(value)
		buffer.writebits(activeBuffer, bitOffset + 0, 17, mantissa * 262144 - 131071.5)
		buffer.writebits(activeBuffer, bitOffset + 17, 6, exponent + 30)
		buffer.writebits(activeBuffer, bitOffset + 23, 1, sign)
	end
end


-- Types
types.Any = "Any" :: any
reads.Any = function() return anyReads[ReadU8()]() end
writes.Any = function(value: any) anyWrites[typeof(value)](value) end

types.Nil = ("Nil" :: any) :: nil
reads.Nil = function() return nil end
writes.Nil = function(value: nil) end

types.NumberS8 = ("NumberS8" :: any) :: number
reads.NumberS8 = function() return ReadS8() end
writes.NumberS8 = function(value: number) Allocate(1) WriteS8(value) end

types.NumberS16 = ("NumberS16" :: any) :: number
reads.NumberS16 = function() return ReadS16() end 
writes.NumberS16 = function(value: number) Allocate(2) WriteS16(value) end

types.NumberS24 = ("NumberS24" :: any) :: number
reads.NumberS24 = function() return ReadS24() end 
writes.NumberS24 = function(value: number) Allocate(3) WriteS24(value) end

types.NumberS32 = ("NumberS32" :: any) :: number
reads.NumberS32 = function() return ReadS32() end 
writes.NumberS32 = function(value: number) Allocate(4) WriteS32(value) end

types.NumberU8 = ("NumberU8" :: any) :: number
reads.NumberU8 = function() return ReadU8() end
writes.NumberU8 = function(value: number) Allocate(1) WriteU8(value) end

types.NumberU16 = ("NumberU16" :: any) :: number
reads.NumberU16 = function() return ReadU16() end
writes.NumberU16 = function(value: number) Allocate(2) WriteU16(value) end

types.NumberU24 = ("NumberU24" :: any) :: number
reads.NumberU24 = function() return ReadU24() end 
writes.NumberU24 = function(value: number) Allocate(3) WriteU24(value) end

types.NumberU32 = ("NumberU32" :: any) :: number
reads.NumberU32 = function() return ReadU32() end 
writes.NumberU32 = function(value: number) Allocate(4) WriteU32(value) end

types.NumberF16 = ("NumberF16" :: any) :: number
reads.NumberF16 = function() return ReadF16() end
writes.NumberF16 = function(value: number) Allocate(2) WriteF16(value) end

types.NumberF24 = ("NumberF24" :: any) :: number
reads.NumberF24 = function() return ReadF24() end
writes.NumberF24 = function(value: number) Allocate(3) WriteF24(value) end

types.NumberF32 = ("NumberF32" :: any) :: number
reads.NumberF32 = function() return ReadF32() end
writes.NumberF32 = function(value: number) Allocate(4) WriteF32(value) end

types.NumberF64 = ("NumberF64" :: any) :: number
reads.NumberF64 = function() return ReadF64() end
writes.NumberF64 = function(value: number) Allocate(8) WriteF64(value) end

types.String = ("String" :: any) :: string
reads.String = function() return ReadString(ReadU8()) end
writes.String = function(value: string) local length = #value Allocate(1 + length) WriteU8(length) WriteString(value) end

types.StringLong = ("StringLong" :: any) :: string
reads.StringLong = function() return ReadString(ReadU16()) end
writes.StringLong = function(value: string) local length = #value Allocate(2 + length) WriteU16(length) WriteString(value) end

types.Buffer = ("Buffer" :: any) :: buffer
reads.Buffer = function() return ReadBuffer(ReadU8()) end
writes.Buffer = function(value: buffer) local length = buffer.len(value) Allocate(1 + length) WriteU8(length) WriteBuffer(value) end

types.BufferLong = ("BufferLong" :: any) :: buffer
reads.BufferLong = function() return ReadBuffer(ReadU16()) end
writes.BufferLong = function(value: buffer) local length = buffer.len(value) Allocate(2 + length) WriteU16(length) WriteBuffer(value) end

types.Instance = ("Instance" :: any) :: Instance
reads.Instance = function() return ReadInstance() end
writes.Instance = function(value: Instance) WriteInstance(value) end

types.Boolean8 = ("Boolean8" :: any) :: boolean
reads.Boolean8 = function() return ReadU8() == 1 end
writes.Boolean8 = function(value: boolean) Allocate(1) WriteU8(if value then 1 else 0) end

types.NumberRange = ("NumberRange" :: any) :: NumberRange
reads.NumberRange = function() return NumberRange.new(ReadF32(), ReadF32()) end
writes.NumberRange = function(value: NumberRange) Allocate(8) WriteF32(value.Min) WriteF32(value.Max) end

types.BrickColor = ("BrickColor" :: any) :: BrickColor
reads.BrickColor = function() return BrickColor.new(ReadU16()) end
writes.BrickColor = function(value: BrickColor) Allocate(2) WriteU16(value.Number) end

types.Color3 = ("Color3" :: any) :: Color3
reads.Color3 = function() return Color3.fromRGB(ReadU8(), ReadU8(), ReadU8()) end
writes.Color3 = function(value: Color3) Allocate(3) WriteU8(value.R * 255 + 0.5)  WriteU8(value.G * 255 + 0.5)  WriteU8(value.B * 255 + 0.5) end

types.UDim = ("UDim" :: any) :: UDim
reads.UDim = function() return UDim.new(ReadS16() / 1000, ReadS16()) end
writes.UDim = function(value: UDim) Allocate(4) WriteS16(value.Scale * 1000) WriteS16(value.Offset) end

types.UDim2 = ("UDim2" :: any) :: UDim2
reads.UDim2 = function() return UDim2.new(ReadS16() / 1000, ReadS16(), ReadS16() / 1000, ReadS16()) end
writes.UDim2 = function(value: UDim2) Allocate(8) WriteS16(value.X.Scale * 1000) WriteS16(value.X.Offset) WriteS16(value.Y.Scale * 1000) WriteS16(value.Y.Offset) end

types.Rect = ("Rect" :: any) :: Rect
reads.Rect = function() return Rect.new(ReadF32(), ReadF32(), ReadF32(), ReadF32()) end
writes.Rect = function(value: Rect) Allocate(16) WriteF32(value.Min.X) WriteF32(value.Min.Y) WriteF32(value.Max.X) WriteF32(value.Max.Y) end

types.Vector2S16 = ("Vector2S16" :: any) :: Vector2
reads.Vector2S16 = function() return Vector2.new(ReadS16(), ReadS16()) end
writes.Vector2S16 = function(value: Vector2) Allocate(4) WriteS16(value.X) WriteS16(value.Y) end

types.Vector2F24 = ("Vector2F24" :: any) :: Vector2
reads.Vector2F24 = function() return Vector2.new(ReadF24(), ReadF24()) end
writes.Vector2F24 = function(value: Vector2) Allocate(6) WriteF24(value.X) WriteF24(value.Y) end

types.Vector2F32 = ("Vector2F32" :: any) :: Vector2
reads.Vector2F32 = function() return Vector2.new(ReadF32(), ReadF32()) end
writes.Vector2F32 = function(value: Vector2) Allocate(8) WriteF32(value.X) WriteF32(value.Y) end

types.Vector3S16 = ("Vector3S16" :: any) :: Vector3
reads.Vector3S16 = function() return Vector3.new(ReadS16(), ReadS16(), ReadS16()) end
writes.Vector3S16 = function(value: Vector3) Allocate(6) WriteS16(value.X) WriteS16(value.Y) WriteS16(value.Z) end

types.Vector3F24 = ("Vector3F24" :: any) :: Vector3
reads.Vector3F24 = function() return Vector3.new(ReadF24(), ReadF24(), ReadF24()) end
writes.Vector3F24 = function(value: Vector3) Allocate(9) WriteF24(value.X) WriteF24(value.Y) WriteF24(value.Z) end

types.Vector3F32 = ("Vector3F32" :: any) :: Vector3
reads.Vector3F32 = function() return Vector3.new(ReadF32(), ReadF32(), ReadF32()) end
writes.Vector3F32 = function(value: Vector3) Allocate(12) WriteF32(value.X) WriteF32(value.Y) WriteF32(value.Z) end

types.NumberU4 = ("NumberU4" :: any) :: {number}
reads.NumberU4 = function()
	local bitOffset = bufferOffset * 8
	bufferOffset += 1
	return {
		buffer.readbits(activeBuffer, bitOffset + 0, 4),
		buffer.readbits(activeBuffer, bitOffset + 4, 4)
	}
end
writes.NumberU4 = function(value: {number})
	Allocate(1)
	local bitOffset = bufferOffset * 8
	bufferOffset += 1
	buffer.writebits(activeBuffer, bitOffset + 0, 4, value[1])
	buffer.writebits(activeBuffer, bitOffset + 4, 4, value[2])
end

types.BooleanNumber = ("BooleanNumber" :: any) :: {Boolean: boolean, Number: number}
reads.BooleanNumber = function()
	local bitOffset = bufferOffset * 8
	bufferOffset += 1
	return {
		Boolean = buffer.readbits(activeBuffer, bitOffset + 0, 1) == 1,
		Number = buffer.readbits(activeBuffer, bitOffset + 1, 7),
	}
end
writes.BooleanNumber = function(value: {Boolean: boolean, Number: number})
	Allocate(1)
	local bitOffset = bufferOffset * 8
	bufferOffset += 1
	buffer.writebits(activeBuffer, bitOffset + 0, 1, if value.Boolean then 1 else 0)
	buffer.writebits(activeBuffer, bitOffset + 1, 7, value.Number)
end

types.Boolean1 = ("Boolean1" :: any) :: {boolean}
reads.Boolean1 = function()
	local bitOffset = bufferOffset * 8
	bufferOffset += 1
	return {
		buffer.readbits(activeBuffer, bitOffset + 0, 1) == 1,
		buffer.readbits(activeBuffer, bitOffset + 1, 1) == 1,
		buffer.readbits(activeBuffer, bitOffset + 2, 1) == 1,
		buffer.readbits(activeBuffer, bitOffset + 3, 1) == 1,
		buffer.readbits(activeBuffer, bitOffset + 4, 1) == 1,
		buffer.readbits(activeBuffer, bitOffset + 5, 1) == 1,
		buffer.readbits(activeBuffer, bitOffset + 6, 1) == 1,
		buffer.readbits(activeBuffer, bitOffset + 7, 1) == 1,
	}
end
writes.Boolean1 = function(value: {boolean})
	Allocate(1)
	local bitOffset = bufferOffset * 8
	bufferOffset += 1
	buffer.writebits(activeBuffer, bitOffset + 0, 1, if value[1] then 1 else 0)
	buffer.writebits(activeBuffer, bitOffset + 1, 1, if value[2] then 1 else 0)
	buffer.writebits(activeBuffer, bitOffset + 2, 1, if value[3] then 1 else 0)
	buffer.writebits(activeBuffer, bitOffset + 3, 1, if value[4] then 1 else 0)
	buffer.writebits(activeBuffer, bitOffset + 4, 1, if value[5] then 1 else 0)
	buffer.writebits(activeBuffer, bitOffset + 5, 1, if value[6] then 1 else 0)
	buffer.writebits(activeBuffer, bitOffset + 6, 1, if value[7] then 1 else 0)
	buffer.writebits(activeBuffer, bitOffset + 7, 1, if value[8] then 1 else 0)
end

types.CFrameF24U8 = ("CFrameF24U8" :: any) :: CFrame
reads.CFrameF24U8 = function()
	return CFrame.fromEulerAnglesXYZ(ReadU8() / 40.58451048843331, ReadU8() / 40.58451048843331, ReadU8() / 40.58451048843331)
		+ Vector3.new(ReadF24(), ReadF24(), ReadF24())
end
writes.CFrameF24U8 = function(value: CFrame)
	local rx, ry, rz = value:ToEulerAnglesXYZ()
	Allocate(12)
	WriteU8(rx * 40.58451048843331 + 0.5) WriteU8(ry * 40.58451048843331 + 0.5) WriteU8(rz * 40.58451048843331 + 0.5)
	WriteF24(value.X) WriteF24(value.Y) WriteF24(value.Z)
end

types.CFrameF32U8 = ("CFrameF32U8" :: any) :: CFrame
reads.CFrameF32U8 = function()
	return CFrame.fromEulerAnglesXYZ(ReadU8() / 40.58451048843331, ReadU8() / 40.58451048843331, ReadU8() / 40.58451048843331)
		+ Vector3.new(ReadF32(), ReadF32(), ReadF32())
end
writes.CFrameF32U8 = function(value: CFrame)
	local rx, ry, rz = value:ToEulerAnglesXYZ()
	Allocate(15)
	WriteU8(rx * 40.58451048843331 + 0.5) WriteU8(ry * 40.58451048843331 + 0.5) WriteU8(rz * 40.58451048843331 + 0.5)
	WriteF32(value.X) WriteF32(value.Y) WriteF32(value.Z)
end

types.CFrameF32U16 = ("CFrameF32U16" :: any) :: CFrame
reads.CFrameF32U16 = function()
	return CFrame.fromEulerAnglesXYZ(ReadU16() / 10430.219195527361, ReadU16() / 10430.219195527361, ReadU16() / 10430.219195527361)
		+ Vector3.new(ReadF32(), ReadF32(), ReadF32())
end
writes.CFrameF32U16 = function(value: CFrame)
	local rx, ry, rz = value:ToEulerAnglesXYZ()
	Allocate(18)
	WriteU16(rx * 10430.219195527361 + 0.5) WriteU16(ry * 10430.219195527361 + 0.5) WriteU16(rz * 10430.219195527361 + 0.5)
	WriteF32(value.X) WriteF32(value.Y) WriteF32(value.Z)
end

types.Region3 = ("Region3" :: any) :: Region3
reads.Region3 = function()
	return Region3.new(
		Vector3.new(ReadF32(), ReadF32(), ReadF32()),
		Vector3.new(ReadF32(), ReadF32(), ReadF32())
	)
end
writes.Region3 = function(value: Region3)
	local halfSize = value.Size / 2
	local minimum = value.CFrame.Position - halfSize
	local maximum = value.CFrame.Position + halfSize
	Allocate(24)
	WriteF32(minimum.X) WriteF32(minimum.Y) WriteF32(minimum.Z)
	WriteF32(maximum.X) WriteF32(maximum.Y) WriteF32(maximum.Z)
end

types.NumberSequence = ("NumberSequence" :: any) :: NumberSequence
reads.NumberSequence = function()
	local length = ReadU8()
	local keypoints = table.create(length)
	for index = 1, length do
		table.insert(keypoints, NumberSequenceKeypoint.new(ReadU8() / 255, ReadU8() / 255, ReadU8() / 255))
	end
	return NumberSequence.new(keypoints)
end
writes.NumberSequence = function(value: NumberSequence)
	local length = #value.Keypoints
	Allocate(1 + length * 3)
	WriteU8(length)
	for index, keypoint in value.Keypoints do
		WriteU8(keypoint.Time * 255 + 0.5) WriteU8(keypoint.Value * 255 + 0.5) WriteU8(keypoint.Envelope * 255 + 0.5)
	end
end

types.ColorSequence = ("ColorSequence" :: any) :: ColorSequence
reads.ColorSequence = function()
	local length = ReadU8()
	local keypoints = table.create(length)
	for index = 1, length do
		table.insert(keypoints, ColorSequenceKeypoint.new(ReadU8() / 255, Color3.fromRGB(ReadU8(), ReadU8(), ReadU8())))
	end
	return ColorSequence.new(keypoints)
end
writes.ColorSequence = function(value: ColorSequence)
	local length = #value.Keypoints
	Allocate(1 + length * 4)
	WriteU8(length)
	for index, keypoint in value.Keypoints do
		WriteU8(keypoint.Time * 255 + 0.5)
		WriteU8(keypoint.Value.R * 255 + 0.5) WriteU8(keypoint.Value.G * 255 + 0.5) WriteU8(keypoint.Value.B * 255 + 0.5)
	end
end


types.EnumItem = ("EnumItem" :: any) :: EnumItem
reads.EnumItem = function()
	local bitOffset = bufferOffset * 8
	bufferOffset += 3
	return enums[buffer.readbits(activeBuffer, bitOffset + 0, 12)]:FromValue(buffer.readbits(activeBuffer, bitOffset + 12, 12))
end
writes.EnumItem = function(value: EnumItem)
	Allocate(3)
	local bitOffset = bufferOffset * 8
	bufferOffset += 3
	buffer.writebits(activeBuffer, bitOffset + 0, 12, enumIndices[value.EnumType])
	buffer.writebits(activeBuffer, bitOffset + 12, 12, value.Value)
end

local characterIndices = {}
local characters = require(script._Characters)
for index, value in characters do characterIndices[value] = index end
local characterBits = math.ceil(math.log(#characters + 1, 2))
local characterBytes = characterBits / 8
types.Characters = ("Characters" :: any) :: string
reads.Characters = function()
	local length = ReadU8()
	local characterArray = table.create(length)
	local bitOffset = bufferOffset * 8
	bufferOffset += math.ceil(length * characterBytes)
	for index = 1, length do
		table.insert(characterArray, characters[buffer.readbits(activeBuffer, bitOffset, characterBits)])
		bitOffset += characterBits
	end
	return table.concat(characterArray)
end
writes.Characters = function(value: string)
	local length = #value
	local bytes = math.ceil(length * characterBytes)
	Allocate(1 + bytes)
	WriteU8(length)
	local bitOffset = bufferOffset * 8
	for index = 1, length do
		buffer.writebits(activeBuffer, bitOffset, characterBits, characterIndices[value:sub(index, index)])
		bitOffset += characterBits
	end
	bufferOffset += bytes
end

local staticIndices = {}
local statics = require(script._Static1)
for index, static in statics do staticIndices[static] = index end
types.Static1 = ("Static1" :: any) :: any
reads.Static1 = function() return statics[ReadU8()] end
writes.Static1 = function(value: any) Allocate(1) WriteU8(staticIndices[value] or 0) end

local staticIndices = {}
local statics = require(script._Static2)
for index, static in statics do staticIndices[static] = index end
types.Static2 = ("Static2" :: any) :: any
reads.Static2 = function() return statics[ReadU8()] end
writes.Static2 = function(value: any) Allocate(1) WriteU8(staticIndices[value] or 0) end

local staticIndices = {}
local statics = require(script._Static3)
for index, static in statics do staticIndices[static] = index end
types.Static3 = ("Static3" :: any) :: any
reads.Static3 = function() return statics[ReadU8()] end
writes.Static3 = function(value: any) Allocate(1) WriteU8(staticIndices[value] or 0) end


-- Any Types
anyReads[0] = function() return nil end
anyWrites["nil"] = function(value: nil) Allocate(1) WriteU8(0) end

anyReads[1] = function() return -ReadU8() end
anyReads[2] = function() return -ReadU16() end
anyReads[3] = function() return -ReadU24() end
anyReads[4] = function() return -ReadU32() end
anyReads[5] = function() return ReadU8() end
anyReads[6] = function() return ReadU16() end
anyReads[7] = function() return ReadU24() end
anyReads[8] = function() return ReadU32() end
anyReads[9] = function() return ReadF32() end
anyReads[10] = function() return ReadF64() end
anyWrites.number = function(value: number)
	if value % 1 == 0 then
		if value < 0 then
			if value > -256 then
				Allocate(2) WriteU8(1) WriteU8(-value)
			elseif value > -65536 then
				Allocate(3) WriteU8(2) WriteU16(-value)
			elseif value > -16777216 then
				Allocate(4) WriteU8(3) WriteU24(-value)
			elseif value > -4294967296 then
				Allocate(5) WriteU8(4) WriteU32(-value)
			else
				Allocate(9) WriteU8(10) WriteF64(value)
			end
		else
			if value < 256 then
				Allocate(2) WriteU8(5) WriteU8(value)
			elseif value < 65536 then
				Allocate(3) WriteU8(6) WriteU16(value)
			elseif value < 16777216 then
				Allocate(4) WriteU8(7) WriteU24(value)
			elseif value < 4294967296 then
				Allocate(5) WriteU8(8) WriteU32(value)
			else
				Allocate(9) WriteU8(10) WriteF64(value)
			end
		end
	elseif value > -1048576 and value < 1048576 then
		Allocate(5) WriteU8(9) WriteF32(value)
	else
		Allocate(9) WriteU8(10) WriteF64(value)
	end
end

anyReads[11] = function() return ReadString(ReadU8()) end
anyWrites.string = function(value: string) local length = #value Allocate(2 + length) WriteU8(11) WriteU8(length) WriteString(value) end

anyReads[12] = function() return ReadBuffer(ReadU8()) end
anyWrites.buffer = function(value: buffer) local length = buffer.len(value) Allocate(2 + length) WriteU8(12) WriteU8(length) WriteBuffer(value) end

anyReads[13] = function() return ReadInstance() end
anyWrites.Instance = function(value: Instance) Allocate(1) WriteU8(13) WriteInstance(value) end

anyReads[14] = function() return ReadU8() == 1 end
anyWrites.boolean = function(value: boolean) Allocate(2) WriteU8(14) WriteU8(if value then 1 else 0) end

anyReads[15] = function() return NumberRange.new(ReadF32(), ReadF32()) end
anyWrites.NumberRange = function(value: NumberRange) Allocate(9) WriteU8(15) WriteF32(value.Min) WriteF32(value.Max) end

anyReads[16] = function() return BrickColor.new(ReadU16()) end
anyWrites.BrickColor = function(value: BrickColor) Allocate(3) WriteU8(16) WriteU16(value.Number) end

anyReads[17] = function() return Color3.fromRGB(ReadU8(), ReadU8(), ReadU8()) end
anyWrites.Color3 = function(value: Color3) Allocate(4) WriteU8(17) WriteU8(value.R * 255 + 0.5)  WriteU8(value.G * 255 + 0.5)  WriteU8(value.B * 255 + 0.5) end

anyReads[18] = function() return UDim.new(ReadS16() / 1000, ReadS16()) end
anyWrites.UDim = function(value: UDim) Allocate(5) WriteU8(18) WriteS16(value.Scale * 1000) WriteS16(value.Offset) end

anyReads[19] = function() return UDim2.new(ReadS16() / 1000, ReadS16(), ReadS16() / 1000, ReadS16()) end
anyWrites.UDim2 = function(value: UDim2) Allocate(9) WriteU8(19) WriteS16(value.X.Scale * 1000) WriteS16(value.X.Offset) WriteS16(value.Y.Scale * 1000) WriteS16(value.Y.Offset) end

anyReads[20] = function() return Rect.new(ReadF32(), ReadF32(), ReadF32(), ReadF32()) end
anyWrites.Rect = function(value: Rect) Allocate(17) WriteU8(20) WriteF32(value.Min.X) WriteF32(value.Min.Y) WriteF32(value.Max.X) WriteF32(value.Max.Y) end

anyReads[21] = function() return Vector2.new(ReadF32(), ReadF32()) end
anyWrites.Vector2 = function(value: Vector2) Allocate(9) WriteU8(21) WriteF32(value.X) WriteF32(value.Y) end

anyReads[22] = function() return Vector3.new(ReadF32(), ReadF32(), ReadF32()) end
anyWrites.Vector3 = function(value: Vector3) Allocate(13) WriteU8(22) WriteF32(value.X) WriteF32(value.Y) WriteF32(value.Z) end

anyReads[23] = function()
	return CFrame.fromEulerAnglesXYZ(ReadU16() / 10430.219195527361, ReadU16() / 10430.219195527361, ReadU16() / 10430.219195527361)
		+ Vector3.new(ReadF32(), ReadF32(), ReadF32())
end
anyWrites.CFrame = function(value: CFrame)
	local rx, ry, rz = value:ToEulerAnglesXYZ()
	Allocate(19)
	WriteU8(23)
	WriteU16(rx * 10430.219195527361 + 0.5) WriteU16(ry * 10430.219195527361 + 0.5) WriteU16(rz * 10430.219195527361 + 0.5)
	WriteF32(value.X) WriteF32(value.Y) WriteF32(value.Z)
end

anyReads[24] = function()
	return Region3.new(
		Vector3.new(ReadF32(), ReadF32(), ReadF32()),
		Vector3.new(ReadF32(), ReadF32(), ReadF32())
	)
end
anyWrites.Region3 = function(value: Region3)
	local halfSize = value.Size / 2
	local minimum = value.CFrame.Position - halfSize
	local maximum = value.CFrame.Position + halfSize
	Allocate(25)
	WriteU8(24)
	WriteF32(minimum.X) WriteF32(minimum.Y) WriteF32(minimum.Z)
	WriteF32(maximum.X) WriteF32(maximum.Y) WriteF32(maximum.Z)
end

anyReads[25] = function()
	local length = ReadU8()
	local keypoints = table.create(length)
	for index = 1, length do
		table.insert(keypoints, NumberSequenceKeypoint.new(ReadU8() / 255, ReadU8() / 255, ReadU8() / 255))
	end
	return NumberSequence.new(keypoints)
end
anyWrites.NumberSequence = function(value: NumberSequence)
	local length = #value.Keypoints
	Allocate(2 + length * 3)
	WriteU8(25)
	WriteU8(length)
	for index, keypoint in value.Keypoints do
		WriteU8(keypoint.Time * 255 + 0.5) WriteU8(keypoint.Value * 255 + 0.5) WriteU8(keypoint.Envelope * 255 + 0.5)
	end
end

anyReads[26] = function()
	local length = ReadU8()
	local keypoints = table.create(length)
	for index = 1, length do
		table.insert(keypoints, ColorSequenceKeypoint.new(ReadU8() / 255, Color3.fromRGB(ReadU8(), ReadU8(), ReadU8())))
	end
	return ColorSequence.new(keypoints)
end
anyWrites.ColorSequence = function(value: ColorSequence)
	local length = #value.Keypoints
	Allocate(2 + length * 4)
	WriteU8(26)
	WriteU8(length)
	for index, keypoint in value.Keypoints do
		WriteU8(keypoint.Time * 255 + 0.5)
		WriteU8(keypoint.Value.R * 255 + 0.5) WriteU8(keypoint.Value.G * 255 + 0.5) WriteU8(keypoint.Value.B * 255 + 0.5)
	end
end

anyReads[27] = function()
	local bitOffset = bufferOffset * 8
	bufferOffset += 3
	return enums[buffer.readbits(activeBuffer, bitOffset + 0, 12)]:FromValue(buffer.readbits(activeBuffer, bitOffset + 12, 12))
end
anyWrites.EnumItem = function(value: EnumItem)
	Allocate(4)
	WriteU8(27)
	local bitOffset = bufferOffset * 8
	bufferOffset += 3
	buffer.writebits(activeBuffer, bitOffset + 0, 12, enumIndices[value.EnumType])
	buffer.writebits(activeBuffer, bitOffset + 12, 12, value.Value)
end

anyReads[28] = function()
	local value = {}
	while true do
		local typeId = ReadU8()
		if typeId == 0 then return value else value[anyReads[typeId]()] = anyReads[ReadU8()]() end
	end
end
anyWrites.table = function(value: {[any]: any})
	Allocate(1)
	WriteU8(28)
	for index, value in value do anyWrites[typeof(index)](index) anyWrites[typeof(value)](value) end
	Allocate(1)
	WriteU8(0)
end


return {
	Import = function(cursor: Cursor)
		activeCursor = cursor
		activeBuffer = cursor.Buffer
		bufferLength = cursor.BufferLength
		bufferOffset = cursor.BufferOffset
		instances = cursor.Instances
		instancesOffset = cursor.InstancesOffset
	end,
	
	Export = function()
		activeCursor.BufferLength = bufferLength
		activeCursor.BufferOffset = bufferOffset
		activeCursor.InstancesOffset = instancesOffset
		return activeCursor
	end,
	
	Truncate = function()
		local truncatedBuffer = buffer.create(bufferOffset)
		buffer.copy(truncatedBuffer, 0, activeBuffer, 0, bufferOffset)
		if instancesOffset == 0 then return truncatedBuffer else return truncatedBuffer, instances end
	end,
	
	Ended = function()
		return bufferOffset >= bufferLength
	end,
	
	Types = types,
	Reads = reads,
	Writes = writes,
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042cf</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXC4B193D47EFF4397B68A5A17A2EFEF36">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">3365651c0460667f0827e42500006338</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">_Characters</string>
									<string name="ScriptGuid">{7890487E-802E-4413-8F96-70385859F3B3}</string>
									<ProtectedString name="Source"><![CDATA[return {[0] = -- Recommended character array lengths: 2, 4, 8, 16, 32, 64, 128, 256
	" ", ".", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D",
	"E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
	"U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j",
	"k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042d0</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD76A30DEABDD40DCA917E2B4F601B43E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">3365651c0460667f0827e42500006339</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">_Static1</string>
									<string name="ScriptGuid">{0A769D17-FA47-4C72-A669-AA72C30FAACC}</string>
									<ProtectedString name="Source"><![CDATA[return {
	"DataStore Failed To Load",
	"Another Static String",
	math.pi,
	123456789,
	Vector3.new(1, 2, 3),
	"You can have upto 255 static values of any type"
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042d1</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXAFB3C2A22A9541A2878518BEEEB5135D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">3365651c0460667f0827e4250000633a</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">_Static2</string>
									<string name="ScriptGuid">{028F8585-216C-4206-9F43-0A0AC7E24912}</string>
									<ProtectedString name="Source"><![CDATA[return {
	"DataStore Failed To Load",
	"Another Static String",
	math.pi,
	123456789,
	Vector3.new(1, 2, 3),
	"You can have upto 255 static values of any type"
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042d2</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE6911999A37248D2A71E8E4EC1ED5063">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">3365651c0460667f0827e4250000633b</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">_Static3</string>
									<string name="ScriptGuid">{B577CFBB-2E80-47A5-8153-1A6950E1C6CA}</string>
									<ProtectedString name="Source"><![CDATA[return {
	"DataStore Failed To Load",
	"Another Static String",
	math.pi,
	123456789,
	Vector3.new(1, 2, 3),
	"You can have upto 255 static values of any type"
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042d3</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX3F063410284041A993B89B8D2FB73A42">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">56b97311fad4bf91073f139600006143</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Proxy</string>
							<string name="ScriptGuid">{C18B4BF3-E066-4652-9CC4-D23E52B635B2}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 11/7/24
--[[@description:
	
]]
-----------------------------
-- SERVICES --
-----------------------------

-----------------------------
-- DEPENDENCIES --
-----------------------------
local Signal = require(script.Parent._Signal)

-----------------------------
-- TYPES --
-----------------------------
-- This is for all of the properties of an object made from this class for type annotation purposes.
type fields<T = { [any]: any }> = {
	Signals: {
		Indexed: Signal.Signal<(index: any) -> (), (any)>,
		NewIndex: Signal.Signal<(index: any, value: any) -> (), (any, any)>,
	},
	_proxy: proxyTable<T>,

	-- Returns the proxy for indexing.
	Get: (self: Proxy<T>) -> T,

	-- Returns the original table used for the proxy.
	GetOrig: (self: Proxy<T>) -> T,

	Destroy: (self: Proxy<T>) -> (),
}

-----------------------------
-- VARIABLES --
-----------------------------
local Proxy = {}
local MT = {
	__newindex = function()
		error("Attempted to add/modify field in Proxy", 2)
	end,
}
MT.__index = MT
local ProxyMT = {}

export type Proxy<T> = typeof(setmetatable({} :: fields<T>, MT))

type proxyTable<T = { [any]: any }> = typeof(setmetatable(
	{} :: {
		__ref: Proxy<T>,
		__t: T,
	},
	ProxyMT
))

-- CONSTANTS --

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Creates a proxy for the given table.
-- Any accesses or new indexes are observed and corresponding events are fired.
function Proxy.new<T>(t: T): Proxy<T>
	assert(typeof(t) == "table", "Expected table value")
	local self = {}

	self.Signals = {
		Indexed = Signal.new(),
		NewIndex = Signal.new(),
	}
	self._proxy = setmetatable({
		__ref = self,
		__t = t,
	}, ProxyMT)

	return setmetatable(self, MT) :: any
end

function Proxy:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")

	return getmetatable(object).__index == MT
end

-- Returns the proxy for indexing.
function MT:Get()
	return self._proxy
end

-- Returns the original table.
function MT:GetOrig()
	return rawget(self._proxy, "__t")
end

function MT:Destroy()
	setmetatable(self :: any, nil)
	table.clear(self :: any)
end

function ProxyMT.__index(proxyTable: any, key: any)
	local origTable = rawget(proxyTable, "__t")
	local result = origTable[key]
	local proxyObj = rawget(proxyTable, "__ref") :: Proxy<any>
	proxyObj.Signals.Indexed:Fire(key)
	return result
end

function ProxyMT.__newindex(proxyTable: any, key: any, value: any)
	local origTable = rawget(proxyTable, "__t")
	local proxyObj = rawget(proxyTable, "__ref") :: Proxy<any>
	origTable[key] = value
	proxyObj.Signals.NewIndex:Fire(key, value)
end

-----------------------------
-- MAIN --
-----------------------------
return Proxy
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042d5</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXBF45BA2416D946338D65C31601974884">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">626fc90b6bf0d334074c1ece00006c25</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Quaternion</string>
							<string name="ScriptGuid">{AA2AD482-866C-4BCF-BC5B-F6700B6E2B8E}</string>
							<ProtectedString name="Source"><![CDATA[--!native
--!strict
--[[
    Source: https://github.com/probablytukars/LuaQuaternion
    [MIT LICENSE]
]]

local Quaternion = {
	_type = "Quaternion",
	_TO_STRING_CHAR = nil
}

type CachedProperties = {
	unit: Quaternion?,
	magnitude: number?
}

type t_quaternion = {
	-- Constructors

	new: (qX: number?, qY: number?, qZ: number?, qW: number?) -> Quaternion,
	fromAxisAngle: (axis: Vector3, angle: number) -> Quaternion,
	fromAxisAngleFast: (axis: Vector3, angle: number) -> Quaternion,
	fromEulerVector: (eulerVector: Vector3) -> Quaternion,
	fromCFrame: (cframe: CFrame) -> Quaternion,
	fromCFrameFast: (cframe: CFrame) -> Quaternion,
	fromMatrix: (vX: Vector3, vY: Vector3, vZ: Vector3?) -> Quaternion,
	fromMatrixFast: (vX: Vector3, vY: Vector3, vZ: Vector3?) -> Quaternion,
	lookAt: (from: Vector3, lookAt: Vector3, up: Vector3?) -> Quaternion,
	fromEulerAnglesXYZ: (rx: number, ry: number, rz: number) -> Quaternion,
	Angles: (rx: number, ry: number, rz: number) -> Quaternion,
	fromEulerAnglesYXZ: (rx: number, ry: number, rz: number) -> Quaternion,
	fromOrientation: (rx: number, ry: number, rz: number) -> Quaternion,
	fromEulerAngles: (
		rx: number, ry: number, rz: number, rotationOrder: Enum.RotationOrder?
	) -> Quaternion,
	fromVector: (vector: Vector3, W: number?) -> Quaternion,
	RandomQuaternion: (seed: number) -> () -> Quaternion,


	-- Constants

	identity: Quaternion,
	zero: Quaternion,


	-- Properties

	X: number,
	Y: number,
	Z: number,
	W: number,
	_cached: CachedProperties,
	Unit: Quaternion,
	Magnitude: number,


	-- Math operations

	Add: (q0: Quaternion, q1: Quaternion) -> Quaternion,
	Sub: (q0: Quaternion, q1: Quaternion) -> Quaternion,
	Mul: (q0: Quaternion, q1: Quaternion) -> Quaternion,
	Scale: (q0: Quaternion, scale: number) -> Quaternion,
	MulCFrameR: (q0: Quaternion, cframe: CFrame) -> CFrame,
	MulCFrameL: (q0: Quaternion, cframe: CFrame) -> CFrame,
	RotateVector: (q0: Quaternion, vector: Vector3) -> Vector3,
	CombineImaginary: (q0: Quaternion, vector: Vector3) -> Quaternion,
	Div: (op0: Quaternion, op1: Quaternion) -> Quaternion,
	ScaleInv: (q0: Quaternion, scale: number) -> Quaternion,
	Unm: (q0: Quaternion) -> Quaternion,
	Pow: (q0: Quaternion, power: number) -> Quaternion,
	Len: (q0: Quaternion) -> number,
	Lt: (q0: Quaternion, q1: Quaternion) -> boolean,
	Le: (q0: Quaternion, q1: Quaternion) -> boolean,
	Eq: (q0: Quaternion, q1: Quaternion) -> boolean,


	-- Methods

	Exp: (q0: Quaternion) -> Quaternion,
	ExpMap: (q0: Quaternion, q1: Quaternion) -> Quaternion,
	ExpMapSym: (q0: Quaternion, q1: Quaternion) -> Quaternion,
	Log: (q0: Quaternion) -> Quaternion,
	LogMap: (q0: Quaternion, q1: Quaternion) -> Quaternion,
	LogMapSym: (q0: Quaternion, q1: Quaternion) -> Quaternion,
	Length: (q0: Quaternion) -> number,
	LengthSquared: (q0: Quaternion) -> number,
	Hypot: (q0: Quaternion) -> number,
	Normalize: (q0: Quaternion) -> Quaternion,
	IsUnit: (q0: Quaternion, epsilon: number) -> boolean,
	Dot: (q0: Quaternion, q1: Quaternion) -> number,
	Conjugate: (q0: Quaternion) -> Quaternion,
	Inverse: (q0: Quaternion) -> Quaternion,
	Negate: (q0: Quaternion) -> Quaternion,
	Difference: (q0: Quaternion, q1: Quaternion) -> Quaternion,
	Distance: (q0: Quaternion, q1: Quaternion) -> number,
	DistanceSym: (q0: Quaternion, q1: Quaternion) -> number,
	DistanceChord: (q0: Quaternion, q1: Quaternion) -> number,
	DistanceAbs: (q0: Quaternion, q1: Quaternion) -> number,
	Slerp: (q0: Quaternion, q1: Quaternion, alpha: number) -> Quaternion,
	IdentitySlerp: (q1: Quaternion, alpha: number) -> Quaternion,
	SlerpFunction: (q0: Quaternion, q1: Quaternion)
	-> (alpha: number) -> Quaternion,
	Intermediates: (
		q0: Quaternion, q1: Quaternion, n: number, includeEndpoints: boolean?
	) -> {Quaternion},
	Derivative: (q0: Quaternion, rate: Vector3) -> Quaternion,
	Integrate: (q0: Quaternion, rate: Vector3, timestep: number) -> Quaternion,
	AngularVelocity: (q0: Quaternion, q1: Quaternion, timestep: number) -> Vector3,
	MinimalRotation: (q0: Quaternion, q1: Quaternion) -> Quaternion,
	ApproxEq: (q0: Quaternion, q1: Quaternion, epsilon: number) -> boolean,
	IsNaN: (q0: Quaternion) -> boolean,


	-- Deconstructors

	ToCFrame: (q0: Quaternion, position: Vector3?) -> CFrame,
	ToAxisAngle: (q0: Quaternion) -> (Vector3, number),
	ToEulerVector: (q0: Quaternion) -> Vector3,
	ToEulerAnglesXYZ: (q0: Quaternion) -> (number, number, number),
	ToEulerAnglesYXZ: (q0: Quaternion) -> (number, number, number),
	ToOrientation: (q0: Quaternion) -> (number, number, number),
	ToEulerAngles: (
		q0: Quaternion, rotationOrder: Enum.RotationOrder?
	) -> (number, number, number),
	ToMatrix: (q0: Quaternion) ->
	(
		number, number, number, 
		number, number, number,
		number, number, number
	) ,
	ToMatrixVectors: (q0: Quaternion) -> (Vector3, Vector3, Vector3),
	Vector: (q0: Quaternion) -> Vector3,
	Scalar: (q0: Quaternion) -> number,
	Imaginary: (q0: Quaternion) -> Quaternion,
	GetComponents: (q0: Quaternion) -> (number, number, number, number),
	components: (q0: Quaternion) -> (number, number, number, number),
	ToString: (q0: Quaternion, decimalPlaces: number?) -> string,
}

export type Quaternion = typeof(setmetatable({} :: t_quaternion, Quaternion))

local EPSILON = 5e-7

--[=[
    @class Quaternion
    @grouporder ["Constructors", "Methods", "Deconstructors", "Math Operations"]
    
    Quaternions represent rotations in 3D space.
    
    It is important to note that quaternions have double cover, meaning 
    that `q0` and `-q0` encode the same rotation.
    
    
    This class is **immutable** which means once a quaternion has been
    created, its components cannot be changed. All methods create new
    quaternions.
    
    
    Some helpful tips for rearranging quaternion formulas:
    
    When rearraning a formula to solve for a specific value, it will involve
    using inverses and mulitplication, the order is very important as
    multiplication is non-commutative.
    
    
    For example, given `a b = c`
    
    
    To solve for `b`,
    
    Multiply both sides by `a^-1` on the left sides of the equation:
    
    `a^-1 a b = a^-1 c`
    
    This simplifies to:
    
    `b = a^-1 c`.
    
    
    To solve for `a`,
    
    Multiply both sides by `b^-1` on the right sides of the equation:
    
    `a b b^-1 = c b^-1`
    
    This simplifies to:
    
    `a = c b^-1`.
    
    
    Another important rule to remember is the following:
    
    `a^-1 b^-1 = (b a)^-1`.
    
    `a b^-1 = (b^-1 a)^-1`.
    
    In general, this means flip the order, inverse each individual,
    and then inverse them as a group.
    
    
    Given the formula `a b c d = e` where `a`,`b`,`c`,`d`, and `e` are
    quaternions.
    
    Using rules from earlier:
    
    
    Solving for `a`:
    
    `a = e d^-1 c^-1 b^-1`
    
    Or more commonly written as:
    
    `a = e (b c d)^-1`
    
    
    Solving for `b`:
    
    `b = a^-1 e (c d)^-1`
    
    
    Solving for `c`:
    
    `c = (a b)^-1 e d`
    
    
    Solving for `d`:
    
    `d = (a b c)^-1 e`
    
    
    Quaternion multiplication is associative, so the following is equivalent:
    
    `(a b) c = a (b c)`
     
    
    Using these rules, you should be able to rearrange any formula to solve
    for the desired quaternion.
    
    
    Note that often you might not want the exact quaternion but instead the
    negated version (which represents the same rotation), as that rotation
    would actually end up being shorter than the exact quaternion.
    
    In this case `a:Inverse() \* b` can be written as `a:Difference(b)`.
]=]
--[=[
    @prop X number
--]=]
--[=[
    @prop Y number
--]=]
--[=[
    @prop Z number
--]=]
--[=[
    @prop W number
--]=]
--[=[
    @prop Unit Quaternion
    
    A quaternion with unit length. Result is cached.
]=]
--[=[
    @prop Magnitude number
    
    Returns the magnitude of the quaternion.
    Result is cached.
]=]
--[=[
    @prop identity Quaternion
    
    An identity quaternion with no rotation. 
    This is constant and should be accessed through the Quaternion class 
    rather than an individual Quaternion object.
]=]
--[=[
    @prop zero Quaternion
    
    The zero quaternion, this does not represent any 
    rotation as it has a magnitude of zero. This is a constant and should 
    be  accessed through the Quaternion class rather than an individual 
    Quaternion object.
]=]


-- Internal functions for type checking and throwing errors

local function GetType(obj: any): string
	if obj == nil then return "nil" end
	local objMetatable = getmetatable(obj)
	if type(objMetatable) == "table" and objMetatable._type ~= nil then
		return tostring(objMetatable._type)
	else
		return typeof(obj)
	end
end

local function _safeUnit(vector: Vector3, default: Vector3): Vector3
	if vector.Magnitude > EPSILON then
		return vector.Unit
	else
		return default
	end
end

--[=[
    @function
    @group Constructors
    
    Creates a new quaternion with X, Y, Z, W values, where the 
    X, Y, Z are the imaginary components and the W component is the real 
    component.
]=]
local function new(qX: number?, qY: number?, qZ: number?, qW: number?): Quaternion
	local self = setmetatable({
		X = qX or 0,
		Y = qY or 0,
		Z = qZ or 0,
		W = qW or 1,
		_cached = {}
	} :: t_quaternion, Quaternion)

	table.freeze(self)

	return self
end

Quaternion.new = new
Quaternion.identity = new(0, 0, 0, 1)
Quaternion.zero = new(0, 0, 0, 0)

-- Private Methods

local function _Orthonormalize(rightVector: Vector3, upVector: Vector3, backVector: Vector3): (Vector3, Vector3, Vector3)
	local xBasis = _safeUnit(rightVector, Vector3.xAxis)
	local _upVector = _safeUnit(upVector, Vector3.yAxis)

	local zBasis = xBasis:Cross(_upVector)
	if zBasis.Magnitude > EPSILON then
		zBasis = zBasis.Unit
	else
		zBasis = xBasis:Cross(Vector3.yAxis)
		if zBasis.Magnitude > EPSILON then
			zBasis = zBasis.Unit
		else
			zBasis = Vector3.xAxis
		end
	end

	local yBasis = zBasis:Cross(xBasis).Unit
	if zBasis:Dot(backVector) < 0 then
		zBasis = -zBasis
	end
	return xBasis, yBasis, zBasis
end


local function _fromOrthonormalizedMatrix(vX: Vector3, vY: Vector3, vZ: Vector3): Quaternion
	local m00, m10, m20 = vX.X, vX.Y, vX.Z
	local m01, m11, m21 = vY.X, vY.Y, vY.Z
	local m02, m12, m22 = vZ.X, vZ.Y, vZ.Z

	local trace = m00 + m11 + m22

	local qX, qY, qZ, qW

	if trace > 0 then
		local S = math.sqrt(trace + 1) * 2
		qX = (m21 - m12) / S;
		qY = (m02 - m20) / S; 
		qZ = (m10 - m01) / S; 
		qW = 0.25 * S;
	elseif m00 > m11 and m00 > m22 then
		local S = math.sqrt(1 + m00 - m11 - m22) * 2
		qX = 0.25 * S;
		qY = (m01 + m10) / S; 
		qZ = (m02 + m20) / S; 
		qW = (m21 - m12) / S;
	elseif m11 > m22 then
		local S = math.sqrt(1 + m11 - m00 - m22) * 2
		qX = (m01 + m10) / S; 
		qY = 0.25 * S;
		qZ = (m12 + m21) / S; 
		qW = (m02 - m20) / S;
	else
		local S = math.sqrt(1 + m22 - m00 - m11) * 2
		qX = (m02 + m20) / S;
		qY = (m12 + m21) / S;
		qZ = 0.25 * S;
		qW = (m10 - m01) / S;
	end

	return new(qX, qY, qZ, qW)
end

-- Public Methods

--[=[
    @function
    @group Constructors
    
    Creates a quaternion from an axis and angle. 
    Will always return a valid unit quaternion. Normalizes axis.
]=]
local function fromAxisAngle(axis: Vector3, angle: number): Quaternion
	axis = _safeUnit(axis, Vector3.xAxis)

	local ha = angle / 2
	local sha = math.sin(ha)

	local X = sha * axis.X
	local Y = sha * axis.Y
	local Z = sha * axis.Z
	local W = math.cos(ha)

	return new(X, Y, Z, W)
end

Quaternion.fromAxisAngle = fromAxisAngle

--[=[
    @function
    @group Constructors
    
    Creates a quaternion from an axis and angle. 
    Assumes axis is already normalized.
]=]
local function fromAxisAngleFast(axis: Vector3, angle: number): Quaternion
	local ha = angle / 2
	local sha = math.sin(ha)
	local shaxis = axis * sha
	local X = shaxis.X
	local Y = shaxis.Y
	local Z = shaxis.Z
	local W = math.cos(ha)

	return new(X, Y, Z, W)
end


Quaternion.fromAxisAngleFast = fromAxisAngleFast

--[=[
    @function
    @group Constructors
    
    Creates a quaternion from a euler (compact axis-angles) vector. 
    Will always return a valid unit quaternion.
]=]
local function fromEulerVector(eulerVector: Vector3): Quaternion
	local angle = eulerVector.Magnitude
	if angle > 0 then
		local axis = eulerVector / angle
		return fromAxisAngleFast(axis, angle)
	else
		return Quaternion.identity
	end
end

Quaternion.fromEulerVector = fromEulerVector


--[=[
    @function
    @group Constructors
    
    Creates a quaternion from a CFrame. 
    Will always return a valid unit quaternion.
]=]
local function fromCFrame(cframe: CFrame): Quaternion
	local axis, angle = cframe:Orthonormalize():ToAxisAngle()
	return fromAxisAngle(axis, angle)
end

Quaternion.fromCFrame = fromCFrame

--[=[
    @function
    @group Constructors
    
    Creates a quaternion from a CFrame. 
    Assumes that the CFrame has already been orthonormalized, otherwise its
    possible that this will return a quaternion with NaN values.
]=]
local function fromCFrameFast(cframe: CFrame): Quaternion
	local axis, angle = cframe:ToAxisAngle()
	return fromAxisAngleFast(axis, angle)
end

Quaternion.fromCFrameFast = fromCFrameFast

--[=[
    @function
    @group Constructors
    
    Creates a quaternion from three vectors describing a rotation
    matrix.
    Will always return a valid unit quaternion.
]=]
local function fromMatrix(vX: Vector3, vY: Vector3, vZ: Vector3?): Quaternion
	local vXo, vYo = vX, vY
	local vZo = if vZ then vZ else vX:Cross(vY)
	return _fromOrthonormalizedMatrix(_Orthonormalize(vXo, vYo, vZo))
end

Quaternion.fromMatrix = fromMatrix

--[=[
    @function
    @group Constructors
    
    Creates a quaternion from three vectors describing a rotation
    matrix.
    Assumes the matrix is already orthonormalized, if not orthonormalized, it
    can return NaN or invalid Quaternion.
]=]
local function fromMatrixFast(vX: Vector3, vY: Vector3, vZ: Vector3?): Quaternion
	local vXo, vYo = vX.Unit, vY.Unit
	local vZo = if vZ then vZ else vX:Cross(vY).Unit
	return _fromOrthonormalizedMatrix(vXo, vYo, vZo)
end

Quaternion.fromMatrixFast = fromMatrixFast

--[=[
    @function
    @group Constructors
    
    Returns a quaternion looking at Vector3 `lookAt`, from the
    Vector3 `from`, with an optional upVector Vector3 `up`. Maintains
    the same functionality as Roblox's `CFrame.lookAt`.
    Will always return a valid unit quaternion.
]=]
local function lookAt(from: Vector3, lookAt: Vector3, up: Vector3?): Quaternion
	local lookVector = _safeUnit(lookAt - from, Vector3.zAxis)
	local _up = _safeUnit(up or Vector3.yAxis, Vector3.yAxis)

	local rightVector = lookVector:Cross(_up)
	if rightVector.Magnitude > EPSILON then
		local rightVector = rightVector.Unit
		local upVector = rightVector:Cross(lookVector).Unit
		return _fromOrthonormalizedMatrix(rightVector, upVector, -lookVector)
	end

	local selectVector = lookVector:Cross(Vector3.xAxis)
	if selectVector.Magnitude > EPSILON then
		local rightVector = selectVector.Unit
		local upVector = rightVector:Cross(lookVector).Unit
		return _fromOrthonormalizedMatrix(rightVector, upVector, -lookVector)
	end

	local upVector = Vector3.zAxis:Cross(lookVector)
	local upSign = upVector:Dot(Vector3.yAxis)
	upVector *= upSign
	local rightVector = lookVector:Cross(upVector)
	return _fromOrthonormalizedMatrix(rightVector, upVector, -lookVector)
end

Quaternion.lookAt = lookAt

--[=[
    @function
    @group Constructors
    
    Creates a quaternion using angles `rx`, `ry`, and `rz` in
    radians. Rotation is applied in Z, Y, X order.
]=]
local function fromEulerAnglesXYZ(rx: number, ry: number, rz: number): Quaternion
	local xCos = math.cos(rx / 2)
	local xSin = math.sin(rx / 2)
	local yCos = math.cos(ry / 2)
	local ySin = math.sin(ry / 2)
	local zCos = math.cos(rz / 2)
	local zSin = math.sin(rz / 2)

	local xSinyCos = xSin * yCos
	local xCosySin = xCos * ySin
	local xCosyCos = xCos * yCos
	local xSinySin = xSin * ySin

	local qX = xSinyCos * zCos + xCosySin * zSin
	local qY = xCosySin * zCos - xSinyCos * zSin
	local qZ = xCosyCos * zSin + xSinySin * zCos
	local qW = xCosyCos * zCos - xSinySin * zSin

	return new(qX, qY, qZ, qW)
end

Quaternion.fromEulerAnglesXYZ = fromEulerAnglesXYZ


--[=[
    @function
    @group Constructors
    @alias fromEulerAnglesXYZ
]=]
Quaternion.Angles = fromEulerAnglesXYZ

--[=[
    @function
    @group Constructors
    
    Creates a quaternion using angles `rx`, `ry`, and `rz` in
    radians. Rotation is applied in Z, X, Y order.
]=]
local function fromEulerAnglesYXZ(rx: number, ry: number, rz: number): Quaternion 
	local xCos = math.cos(rx / 2)
	local xSin = math.sin(rx / 2)
	local yCos = math.cos(ry / 2)
	local ySin = math.sin(ry / 2)
	local zCos = math.cos(rz / 2)
	local zSin = math.sin(rz / 2)

	local xSinyCos = xSin * yCos
	local xCosySin = xCos * ySin
	local xCosyCos = xCos * yCos
	local xSinySin = xSin * ySin

	local qX = xSinyCos * zCos + xCosySin * zSin
	local qY = xCosySin * zCos - xSinyCos * zSin
	local qZ = xCosyCos * zSin - xSinySin * zCos
	local qW = xCosyCos * zCos + xSinySin * zSin

	return new(qX, qY, qZ, qW)
end



Quaternion.fromEulerAnglesYXZ = fromEulerAnglesYXZ


--[=[
    @function
    @group Constructors
    @alias fromEulerAnglesYXZ
]=]
Quaternion.fromOrientation = fromEulerAnglesYXZ

--[=[
    @function
    @group Constructors
    
    Creates a quaternion using angles `rx`, `ry`, and `rz` in
    radians. Rotation is applied in the order given by `rotationOrder`.
]=]
local function fromEulerAngles(rx: number, ry: number, rz: number, rotationOrder: Enum.RotationOrder?): Quaternion 
	local l_rotationOrder = rotationOrder or Enum.RotationOrder.XYZ

	local xCos = math.cos(rx / 2)
	local yCos = math.cos(ry / 2)
	local zCos = math.cos(rz / 2)

	local xSin = math.sin(rx / 2)
	local ySin = math.sin(ry / 2)
	local zSin = math.sin(rz / 2)

	local xSinyCos = xSin * yCos
	local xCosySin = xCos * ySin
	local xCosyCos = xCos * yCos
	local xSinySin = xSin * ySin

	local qX, qY, qZ, qW

	local order = l_rotationOrder.Name
	if order == "XYZ" then
		qX = xSinyCos * zCos + xCosySin * zSin;
		qY = xCosySin * zCos - xSinyCos * zSin;
		qZ = xCosyCos * zSin + xSinySin * zCos;
		qW = xCosyCos * zCos - xSinySin * zSin;
	elseif order == "YXZ" then
		qX = xSinyCos * zCos + xCosySin * zSin;
		qY = xCosySin * zCos - xSinyCos * zSin;
		qZ = xCosyCos * zSin - xSinySin * zCos;
		qW = xCosyCos * zCos + xSinySin * zSin;
	elseif order == "ZXY" then
		qX = xSinyCos * zCos - xCosySin * zSin;
		qY = xCosySin * zCos + xSinyCos * zSin;
		qZ = xCosyCos * zSin + xSinySin * zCos;
		qW = xCosyCos * zCos - xSinySin * zSin;
	elseif order == "ZYX" then
		qX = xSinyCos * zCos - xCosySin * zSin;
		qY = xCosySin * zCos + xSinyCos * zSin;
		qZ = xCosyCos * zSin - xSinySin * zCos;
		qW = xCosyCos * zCos + xSinySin * zSin;
	elseif order == "YZX" then
		qX = xSinyCos * zCos + xCosySin * zSin;
		qY = xCosySin * zCos + xSinyCos * zSin;
		qZ = xCosyCos * zSin - xSinySin * zCos;
		qW = xCosyCos * zCos - xSinySin * zSin;
	elseif order == "XZY" then
		qX = xSinyCos * zCos - xCosySin * zSin;
		qY = xCosySin * zCos - xSinyCos * zSin;
		qZ = xCosyCos * zSin + xSinySin * zCos;
		qW = xCosyCos * zCos + xSinySin * zSin;
	end

	return new(qX, qY, qZ, qW)
end

Quaternion.fromEulerAngles = fromEulerAngles

--[=[
    @function
    @group Constructors
    
    Creates a quaternion from a vector, where the imaginary
    components of the quaternion are set by the vector components.
    Can also set the `W` component with the second argument, which defaults
    to zero.
]=]
local function fromVector(vector: Vector3, W: number?): Quaternion
	return new(vector.X, vector.Y, vector.Z, W or 0)
end

Quaternion.fromVector = fromVector

--[=[
    @function
    @group Constructors
    
    Returns a function which will return a new random quaternion every
    time that it is called.
]=]
local function RandomQuaternion(seed: number): () -> Quaternion
	local seed = seed or 1
	local random = Random.new(seed)

	local tau = 2 * math.pi
	local sqrt = math.sqrt
	local sin = math.sin
	local cos = math.cos
	return function()
		local u = random:NextNumber(0, 1)
		local v = random:NextNumber(0, 1)
		local w = random:NextNumber(0, 1)

		local omu = 1 - u
		local squ = sqrt(u)
		local sqmu = sqrt(omu)

		local tpv = tau * v
		local tpw = tau * w

		local qX = sqmu * sin(tpv)
		local qY = sqmu * cos(tpv)
		local qZ = squ * sin(tpw)
		local qW = squ * cos(tpw)
		return new(qX, qY, qZ, qW)

	end
end

Quaternion.RandomQuaternion = RandomQuaternion

--[=[
    @operator add
    @operand1 Quaternion
    @operand2 Quaternion
    @return Quaternion
    @group Math Operations
    
    Adds the the second quaternion to the first quaternion using 
    component-wise addition.
]=]

--[=[
    @operator sub
    @operand1 Quaternion
    @operand2 Quaternion
    @return Quaternion
    @group Math Operations
    
    Subtracts the the second quaternion from the first quaternion
    using component-wise subtraction.
]=]

--[=[
    @operator mul
    @operand1 Quaternion
    @operand2 Quaternion
    @return Quaternion
    @group Math Operations
    
    Multiplies the first quaternion by the second quaternion using
    the Hamilton product. The order of multiplication is crucial, and in 
    nearly all cases, (where q0 and q1 are quaternions) q0 \* q1 is not 
    equal to q1 \* q0.
]=]

--[=[
    @operator div
    @operand1 Quaternion
    @operand2 Quaternion
    @return Quaternion
    @group Math Operations
    
    Multiplies the the first quaternion by the inverse of the
    second quaternion. Equivalent to `q0 * q1:Inverse()`.
]=]

--[=[
    @operator unm
    @operand1 Quaternion
    @return Quaternion
    @group Math Operations
    
    Negates each component of the Quaternion.
]=]

--[=[
    @operator pow
    @operand1 Quaternion
    @operand2 number
    @return Quaternion
    @group Math Operations
    
    Raises quaternion by the given power. Has the effect of
    scaling a rotation around the identity quaternion. For example,
    if a quaternion `q0` represents a rotation of 60 degrees around the
    X axis, doing `q0 ^ 0.5` will return a quaternion with a rotation of
    of 30 degrees around the X axis. Doing `q0 ^ 2` will return a rotation
    of 120 degrees around the X axis. The power can be any real number.
]=]

--[=[
    @operator eq
    @operand1 Quaternion
    @operand2 Quaternion
    @return Quaternion
    @group Math Operations
    
    Checks if each component of one quaternion is exactly equal
    to the components of another quaternion.
]=]

--[=[
    @operator lt
    @operand1 Quaternion
    @operand2 Quaternion
    @return boolean
    @group Math Operations
    
    Returns true if the first Quaternion has a smaller length than the
    second Quaternion.
]=]

--[=[
    @operator le
    @operand1 Quaternion
    @operand2 Quaternion
    @return boolean
    @group Math Operations
    
    Returns true if the first quaternion has a smaller or equal
    length than the second Quaternion.
]=]

--[=[
    @operator gt
    @operand1 Quaternion
    @operand2 Quaternion
    @return boolean
    @group Math Operations
    
    Returns true if the first quaternion has a greater length than the second Quaternion.
]=]

--[=[
    @operator ge
    @operand1 Quaternion
    @operand2 Quaternion
    @return boolean
    @group Math Operations
    
    Returns true if the first quaternion has a greater or equal length than the second Quaternion.
]=]

--[=[
    @operator len
    @operand1 Quaternion
    @return number
    @group Math Operations
    
    The length of the quaternion.
]=] 

local function Add(q0: Quaternion, q1: Quaternion): Quaternion
	return new(q0.X + q1.X, q0.Y + q1.Y, q0.Z + q1.Z, q0.W + q1.W)
end

Quaternion.__add = Add
Quaternion.Add = Add

local function Sub(q0: Quaternion, q1: Quaternion): Quaternion
	return new(q0.X - q1.X, q0.Y - q1.Y, q0.Z - q1.Z, q0.W - q1.W)
end

Quaternion.__sub = Sub
Quaternion.Sub = Sub

local function Mul(q0: Quaternion, q1: Quaternion): Quaternion
	local q0X, q0Y, q0Z, q0W = q0.X, q0.Y, q0.Z, q0.W
	local q1X, q1Y, q1Z, q1W = q1.X, q1.Y, q1.Z, q1.W
	return new(
		q0W * q1X + q0X * q1W + q0Y * q1Z - q0Z * q1Y,
		q0W * q1Y - q0X * q1Z + q0Y * q1W + q0Z * q1X,
		q0W * q1Z + q0X * q1Y - q0Y * q1X + q0Z * q1W,
		q0W * q1W - q0X * q1X - q0Y * q1Y - q0Z * q1Z
	)
end

Quaternion.__mul = Mul
Quaternion.Mul = Mul


--[=[
    @function
    @group Math Operations
    
    Scale the components of the quaternion by a number.
]=]
local function Scale(q0: Quaternion, scale: number): Quaternion
	return new(q0.X * scale, q0.Y * scale, q0.Z * scale, q0.W * scale)
end

Quaternion.Scale = Scale

--[=[
    @function
    @group Math Operations
    
    Multiply a quaternion with a cframe, in the order quaternion * cframe.
]=]
local function MulCFrameR(q0: Quaternion, cframe: CFrame): CFrame
	return q0:ToCFrame() * cframe
end

Quaternion.MulCFrameR = MulCFrameR

--[=[
    @function
    @group Math Operations
    
    Multiply a quaternion with a cframe, in the order cframe * quaternion.
]=]
local function MulCFrameL(q0: Quaternion, cframe: CFrame): CFrame
	return cframe * q0:ToCFrame()
end

Quaternion.MulCFrameL = MulCFrameL

--[=[
    @function
    @group Math Operations
    
    Rotate a vector by a quaternion.
]=]
local function RotateVector(q0: Quaternion, vector: Vector3): Vector3
	return Mul(q0 * fromVector(vector), q0:Conjugate()):Vector()
end

Quaternion.RotateVector = RotateVector

--[=[
    @function
    @group Math Operations
    
    Constructs a quaternion from the vector with the vector as imaginary components, and multiplies with the given
    quaternion.
]=]
local function CombineImaginary(q0: Quaternion, vector: Vector3): Quaternion
	return Mul(fromVector(vector), q0)
end

Quaternion.CombineImaginary = CombineImaginary


local function Div(op0: Quaternion, op1: Quaternion): Quaternion
	return Mul(op0, op1:Inverse())
end

Quaternion.__div = Div
Quaternion.Div = Div


--[=[
    @function
    @group Math Operations
    
    Divide each component of the quaternion by some scale value.
]=]
local function ScaleInv(q0: Quaternion, scale: number): Quaternion
	return new(q0.X / scale, q0.Y / scale, q0.Z / scale, q0.W / scale)
end

Quaternion.ScaleInv = ScaleInv


local function unm(q0: Quaternion): Quaternion
	return new(-q0.X, -q0.Y, -q0.Z, -q0.W)
end

Quaternion.__unm = unm
Quaternion.Unm = unm
Quaternion.Negate = unm

local function Pow(q0: Quaternion, number: number)
	if number == -1 then return q0:Inverse() end

	local aW, aX, aY, aZ = q0.W, q0.X, q0.Y, q0.Z

	local im = aX*aX + aY*aY + aZ*aZ
	local aMag = math.sqrt(aW*aW + im)
	local aIm = math.sqrt(im)
	local cMag = aMag ^ number

	if aIm <= EPSILON * aMag then
		return Quaternion.new(0, 0, 0, cMag)
	end

	local rx = aX / aIm
	local ry = aY / aIm
	local rz = aZ / aIm

	local cAng = number * math.atan2(aIm, aW)
	local cCos = math.cos(cAng)
	local cSin = math.sin(cAng)
	local cMagcSin = cMag * cSin

	local cW = cMag*cCos
	local cX = cMagcSin * rx
	local cY = cMagcSin * ry
	local cZ = cMagcSin * rz

	return Quaternion.new(cX, cY, cZ, cW)
end

Quaternion.__pow = Pow
Quaternion.Pow = Pow

local function eq(q0: Quaternion, q1: Quaternion): boolean
	local op0type = GetType(q0)
	local op1type = GetType(q1)

	if (op0type == "Quaternion" and op1type == op0type) then
		return q0.X == q1.X and q0.Y == q1.Y and q0.Z == q1.Z and q0.W == q1.W
	else
		return false
	end
end

Quaternion.__eq = eq
Quaternion.Eq = eq

local function lt(q0: Quaternion, q1:Quaternion)
	local q0l = q0:Length()
	local q1l = q1:Length()

	return q0l < q1l
end

Quaternion.__lt = lt
Quaternion.Lt = lt

local function le(q0: Quaternion, q1:Quaternion)
	local q0l = q0:Length()
	local q1l = q1:Length()

	return q0l <= q1l
end

Quaternion.__le = le
Quaternion.Le = le

--[=[
    @method
    @group Methods
    
    The exponential of a quaternion.
]=]
local function Exp(q0: Quaternion): Quaternion
	local qX, qY, qZ, qW = q0.X, q0.Y, q0.Z, q0.W

	local m = math.exp(qW)
	local vv = qX*qX + qY*qY + qZ*qZ
	if vv > 0 then
		local v = vv ^ 0.5
		local s = m * math.sin(v) / v
		return new(qX * s, qY * s, qZ * s, m * math.cos(v))
	else
		return new(0, 0, 0, m)
	end
end

Quaternion.Exp = Exp

--[=[
    @method
    @group Methods
    
    The exponential map on the Riemannian manifold described by
    the quaternion space.
]=]
local function ExpMap(q0: Quaternion, q1: Quaternion): Quaternion
	return Mul(q0, Exp(q1))
end

Quaternion.ExpMap = ExpMap

--[=[
    @method
    @group Methods
    
    The symmetrized exponential map on the quaternion Riemannian
    manifold.
]=]
local function ExpMapSym(q0: Quaternion, q1: Quaternion): Quaternion
	local sqrtQ = Pow(q0, 0.5)
	return Mul(Mul(sqrtQ, Exp(q1)), sqrtQ)
end

Quaternion.ExpMapSym = ExpMapSym

--[=[
    @method
    @group Methods
    
    The logarithm of a quaternion.
]=]
local function Log(q0: Quaternion): Quaternion
	local qX, qY, qZ, qW = q0.X, q0.Y, q0.Z, q0.W

	local vv = qX*qX + qY*qY + qZ*qZ
	local mm = qW*qW + vv
	if mm > 0 then
		if vv > 0 then
			local m = mm ^ 0.5
			local s = math.acos(qW / m) / (vv ^ 0.5)
			return new(qX * s, qY * s, qZ * s, math.log(m))
		else
			return new(0, 0, 0, math.log(mm)/2)
		end
	else
		return new(0, 0, 0, -math.huge)
	end
end

Quaternion.Log = Log

--[=[
    @method
    @group Methods
    
    The logarithm map on the quaternion Riemannian manifold.
]=]
local function LogMap(q0: Quaternion, q1: Quaternion): Quaternion
	return Log(Mul(q0:Inverse(), q1))
end

Quaternion.LogMap = LogMap

--[=[
    @method
    @group Methods
    
    The symmetrized logarithm map on the quaternion Riemannian 
    manifold.
]=]
local function LogMapSym(q0: Quaternion, q1: Quaternion): Quaternion
	local invSqrtq0 = Pow(q0, -0.5)
	return Log(Mul(Mul(invSqrtq0, q1), invSqrtq0))
end

Quaternion.LogMapSym = LogMapSym

--[=[
    @method
    @group Methods
    
    The length of the quaternion.
]=]
local function Length(q0: Quaternion): number 
	local qX, qY, qZ, qW = q0.X, q0.Y, q0.Z, q0.W
	return (qX * qX + qY * qY + qZ * qZ + qW * qW) ^ 0.5
end

Quaternion.Length = Length
Quaternion.__len = Length

--[=[
    @method
    @group Methods
    
    The sum of the squares length of the quaternion.
]=]
local function LengthSquared(q0: Quaternion): number
	local qX, qY, qZ, qW = q0.X, q0.Y, q0.Z, q0.W
	return qX * qX + qY * qY + qZ * qZ + qW * qW
end

Quaternion.LengthSquared = LengthSquared

--[=[
    @method
    @group Methods
    
    A numerically stable way to get the length of a quaternion.
]=]
local function Hypot(q0: Quaternion): number
	local qX, qY, qZ, qW = q0.X, q0.Y, q0.Z, q0.W
	local maxComp = math.max(qX, qY, qZ, qW)
	if maxComp > 0 then
		local normalizedQ = ScaleInv(q0, maxComp)
		local length = Length(normalizedQ) * maxComp

		return length
	end
	return 0
end

Quaternion.Hypot = Hypot

--[=[
    @method
    @group Methods
    
    The normalized quaternion with a length of one. Passing the
    zero Quaternion into this will return the identity Quaternion.
]=]
local function Normalize(q0: Quaternion): Quaternion
	local length = Length(q0)
	if length > 0 then
		return ScaleInv(q0, length)
	else
		return Quaternion.identity
	end
end

Quaternion.Normalize = Normalize

--[=[
    @method
    @group Methods
    
    Returns true if the given quaternion has a length close to
    one, within 1 +- epsilon range.
]=]
local function IsUnit(q0: Quaternion, epsilon: number): boolean
	local l_epsilon = epsilon or EPSILON
	return math.abs(1 - Length(q0)) < l_epsilon
end

Quaternion.IsUnit = IsUnit

--[=[
    @method
    @group Deconstructors
    
    Returns a CFrame with the same rotation as the given 
    quaternion. If a position is supplied, the CFrame will have that
    position. The given quaternion will be normalized.
]=]
local function ToCFrame(q0: Quaternion, position: Vector3?): CFrame
	q0 = Normalize(q0)

	local vectorPos = position or Vector3.new()
	return CFrame.new(
		vectorPos.X, vectorPos.Y, vectorPos.Z, 
		q0.X, q0.Y, q0.Z, q0.W
	)
end

Quaternion.ToCFrame = ToCFrame

--[=[
    @method
    @group Methods
    
    Returns the dot product between two quaternions.
]=]
local function Dot(q0: Quaternion, q1: Quaternion): number
	return q0.X * q1.X + q0.Y * q1.Y + q0.Z * q1.Z + q0.W * q1.W
end

Quaternion.Dot = Dot

--[=[
    @method
    @group Methods
    
    The conjugate of the Quaternion. The imaginary components are
    negated.
]=]
local function Conjugate(q0: Quaternion): Quaternion
	return new(-q0.X, -q0.Y, -q0.Z, q0.W)
end

Quaternion.Conjugate = Conjugate

--[=[
    @method
    @group Methods
    
    The inverse of the Quaternion. Mulitplying a quaternion by
    its own inverse will result in the identity Quaternion.
]=]
local function Inverse(q0: Quaternion): Quaternion
	local qX, qY, qZ, qW = q0.X, q0.Y, q0.Z, q0.W
	local length = qX * qX + qY * qY + qZ * qZ + qW * qW

	return new(-q0.X / length, -q0.Y/ length, -q0.Z / length, q0.W / length)
end

Quaternion.Inverse = Inverse

--[=[
    @method
    @group Methods
    
    Returns the negated version of the given quaternion.
]=]
local function Negate(q0: Quaternion): Quaternion
	return new(-q0.X, -q0.Y, -q0.Z, -q0.W)
end

Quaternion.Negate = Negate
Quaternion.__unm = Negate

--[=[
    @method
    @group Methods
    
    Returns the quaternion which has the minimal rotation to get
    from `q0` to `q1` using the double cover property of quaternions.
    If `q2 = q0:Difference(q1)`, then `q0 \* q2 = q1`, or `q0 \* q2 = -q1` 
    (the same rotation). If you don't want to take advantage of the double 
    cover property, then you can do `q2 = q0 \* q1:Inverse()`, where
    `q0 \* q2 = q1` all of the time.
]=]
local function Difference(q0: Quaternion, q1: Quaternion): Quaternion
	if Dot(q0, q1) < 0 then
		q0 = unm(q0)
	end
	return Mul(Inverse(q0), q1)
end

Quaternion.Difference = Difference

--[=[
    @method
    @group Methods
    
    Returns the intrinsic geodesic distance between two 
    quaternions. Output will be in the range 0-2pi for unit quaternions.
]=]
local function Distance(q0: Quaternion, q1: Quaternion): number
	return Length(LogMap(q0, q1)) * 2
end

Quaternion.Distance = Distance

--[=[
    @method
    @group Methods
    
    Returns the symmetrized geodesic distance between two 
    quaternions. Output will be in the range 0-pi for unit quaternions.
]=]
local function DistanceSym(q0: Quaternion, q1: Quaternion): number
	return Length(Log(Difference(q0, q1))) * 2
end

Quaternion.DistanceSym = DistanceSym

--[=[
    @method
    @group Methods
    
    Returns the chord distance of the shortest path/arc between 
    two quaternions.
]=]
local function DistanceChord(q0: Quaternion, q1: Quaternion): number
	return math.sin(DistanceSym(q0, q1) / 2) * 2
end

Quaternion.DistanceChord = DistanceChord

--[=[
    @method
    @group Methods
    
    Returns the absolute distance between two 
    quaternions, accounting for sign ambiguity.
]=]
local function DistanceAbs(q0: Quaternion, q1: Quaternion): number
	local q0minusq1 = Sub(q0, q1)
	local q0plusq1 = Add(q0, q1)
	local dMinus = Length(q0minusq1)
	local dPlus = Length(q0plusq1)

	if dMinus < dPlus then
		return dMinus
	end
	return dPlus
end

Quaternion.DistanceAbs = DistanceAbs

--[=[
    @method
    @group Methods
    
    Returns a quaternion along the great circle arc between two
    existing quaternion endpoints lying on the unit radius hypersphere.
    Alpha can be any real number.
]=]
local function Slerp(q0: Quaternion, q1: Quaternion, alpha: number): Quaternion
	q0 = Normalize(q0)
	q1 = Normalize(q1)

	local dot = Dot(q0, q1)

	if dot < 0 then
		q0 = unm(q0)
		dot = -dot
	end

	if dot >= 1 then
		return Normalize(Add(q0, Scale(Sub(q1, q0), alpha)))
	end

	local theta0 = math.acos(dot)
	local sinTheta0 = math.sin(theta0)

	local theta = theta0 * alpha
	local sinTheta = math.sin(theta)

	local s0 = math.cos(theta) - dot * sinTheta / sinTheta0
	local s1 = sinTheta / sinTheta0
	return Normalize(Add(Scale(q0, s0), Scale(q1, s1)))
end

Quaternion.Slerp = Slerp

--[=[
    @method
    @group Methods
    
    Returns a quaternion along the great circle arc between the
    identity quaternion and the given quaternion lying on the unit radius
    hypersphere. Alpha can be any real number.
    
    Equivalent to `Quaternion.identity:Slerp(q0, alpha)` but much faster.
]=]
local function IdentitySlerp(q0: Quaternion, alpha: number): Quaternion
	if (q0.W < 0) then
		return -Pow(-q0, alpha)
	end
	return Pow(q0, alpha)
end

Quaternion.IdentitySlerp = IdentitySlerp

--[=[
    @method
    @group Methods
    
    Returns a function which can be used to calculate a quaternion
    along the great circle arc between the two given quaternions lying on
    the unit radius hypersphere. For example:
    `slerp = q0:SlerpFunction(q1)`, and then `q2 = slerp(alpha)`.
]=]
local function SlerpFunction(q0: Quaternion, q1: Quaternion): (alpha: number) -> Quaternion
	q0 = Normalize(q0)
	q1 = Normalize(q1)

	local dot = Dot(q0, q1)

	if dot < 0 then
		q0 = unm(q0)
		dot = -dot
	end

	if dot >= 1 then
		local subQ = Sub(q1, q0)

		return function(alpha: number)
			return Normalize(Add(q0, Scale(subQ, alpha)))
		end
	end

	local theta0 = math.acos(dot)
	local sinTheta0 = math.sin(theta0)

	return function(alpha: number)
		local theta = theta0 * alpha
		local sinTheta = math.sin(theta)

		local s0 = math.cos(theta) - dot * sinTheta / sinTheta0
		local s1 = sinTheta / sinTheta0
		return Normalize(Add(Scale(q0, s0), Scale(q1, s1)))
	end
end

Quaternion.SlerpFunction = SlerpFunction

--[=[
    @method
    @group Methods
    
    Generates an iterable sequence of n evenly spaces quaternion
    rotations between any two existing quaternion endpoints lying on the
    unit radius hypersphere.
]=]
local function Intermediates(q0: Quaternion, q1: Quaternion, n: number, includeEndpoints: boolean?): {Quaternion}
	includeEndpoints = includeEndpoints or false

	local stepSize = 1 / (n + 1)
	local steps = 
		if includeEndpoints
		then {q0}
		else {}

	local slerpFunc = SlerpFunction(q0, q1)

	for i = 1, n do
		local qi = slerpFunc(stepSize * i)
		table.insert(steps, qi)
	end

	if includeEndpoints then
		table.insert(steps, q1)
	end

	return steps
end

Quaternion.Intermediates = Intermediates

--[=[
    @method
    @group Methods
    
    The instantaneous quaternion derivative representing a 
    quaternion rotating at a 3D rate vector `rate`.
]=]
local function Derivative(q0: Quaternion, rate: Vector3): Quaternion
	return Mul(Scale(q0, 0.5), fromVector(rate))
end

Quaternion.Derivative = Derivative

--[=[
    @method
    @group Methods
    
    Advance a time varying Quaternion to its value at a time
    `timestep` in the future. The solution is closed form given the
    assumption that rate is constant over the interval of length 
    `timestep`.
]=]
local function Integrate(q0: Quaternion, rate: Vector3, timestep: number): Quaternion
	q0 = Normalize(q0)

	local rotationVector = (rate * timestep)
	local rotationMag = rotationVector.Magnitude
	if rotationMag > 0 then
		local axis = rotationVector / rotationMag
		local angle = rotationMag
		local q1 = fromAxisAngle(axis, angle)
		return Normalize(Mul(q0, q1))
	else
		return q0
	end
end

Quaternion.Integrate = Integrate

--[=[
    @method
    @group Methods
    
    Get the euler (compact axis-angles) vector which represents the angular 
    velocity from `q0` to `q1` over the given `timestep`.
    If `timestep` is zero or negative, the zero vector is returned.
]=]
local function AngularVelocity(q0: Quaternion, q1: Quaternion, timestep: number): Vector3
	if timestep > 0 then
		local q2 = q0:Difference(q1)
		return q2:ToEulerVector() / timestep
	end
	return Vector3.new()
end

Quaternion.AngularVelocity = AngularVelocity

--[=[
    @method
    @group Methods
    
    This function returns the Quaternion which represents the shortest
    arc rotation between `q0` and `q1` upVector (in matrix form).
    To get the new quaternion which has the same upVector as `q1`, multiply
    as `q2 * q0`, where `q2` is the derived Quaternion from this method.
]=]
local function MinimalRotation(q0: Quaternion, q1: Quaternion): Quaternion
	local _, sup, _ = q0:ToMatrixVectors()
	local _, tup, _ = q1:ToMatrixVectors()
	local rotationAxis = sup:Cross(tup)
	local rotationAngle = math.atan2(rotationAxis.Magnitude, sup:Dot(tup))
	return fromAxisAngle(rotationAxis, rotationAngle)
end

Quaternion.MinimalRotation = MinimalRotation

--[=[
    @method
    @group Methods
    
    Returns true if the symmetrized geodesic distance is less
    than `epsilon`.
]=]
local function ApproxEq(q0: Quaternion, q1: Quaternion, epsilon: number?): boolean 
	local l_epsilon = epsilon or EPSILON
	return DistanceSym(q0, q1) < l_epsilon
end

Quaternion.ApproxEq = ApproxEq

--[=[
    @method
    @group Methods
    
    Returns true if any component of the quaternion is NaN.
]=]
local function IsNaN(q0: Quaternion): boolean
	local qX, qY, qZ, qW = q0.X, q0.Y, q0.Z, q0.W
	return qX ~= qX or qY ~= qY or qZ ~= qZ or qW ~= qW
end

Quaternion.IsNaN = IsNaN

local function _toRotationMatrix(q0: Quaternion)
	q0 = Normalize(q0)
	local qX, qY, qZ, qW = q0.X, q0.Y, q0.Z, q0.W

	local sqX = qX * qX
	local sqY = qY * qY
	local sqZ = qZ * qZ
	local sqW = qW * qW

	local m00 = sqX - sqY - sqZ + sqW
	local m11 = -sqX + sqY - sqZ + sqW
	local m22 = -sqX - sqY + sqZ + sqW 

	local qXqY = qX * qY
	local qZqW = qZ * qW
	local m10 = 2 * (qXqY + qZqW)
	local m01 = 2 * (qXqY - qZqW)

	local qXqZ = qX * qZ
	local qYqW = qY * qW
	local m20 = 2 * (qXqZ - qYqW)
	local m02 = 2 * (qXqZ + qYqW)

	local qYqZ = qY * qZ
	local qXqW = qX * qW
	local m21 = 2 * (qYqZ + qXqW)
	local m12 = 2 * (qYqZ - qXqW)

	return m00, m01, m02, m10, m11, m12, m20, m21, m22
end

--[=[
    @method
    @group Deconstructors
    
    Converts quaternion to axis angle representation. Quaternion
    is normalized before conversion.
]=]
local function ToAxisAngle(q0: Quaternion): (Vector3, number)
	q0 = Normalize(q0)
	local qX, qY, qZ, qW = q0.X, q0.Y, q0.Z, q0.W

	local angle = 2 * math.acos(qW);
	local s = math.sqrt(1 - qW * qW);

	if s < EPSILON then
		return Vector3.new(qX, qY, qZ), angle
	else
		return Vector3.new(qX / s, qY / s, qZ / s), angle
	end
end

Quaternion.ToAxisAngle = ToAxisAngle

--[=[
    @method
    @group Deconstructors
    
    Converts quaternion to euler (compact axis-angles) vector representation. 
    Quaternion is normalized before conversion.
]=]
local function ToEulerVector(q0: Quaternion): Vector3
	q0 = Normalize(q0)
	local qX, qY, qZ, qW = q0.X, q0.Y, q0.Z, q0.W

	local angle = 2 * math.acos(qW);
	local s = math.sqrt(1 - qW * qW);

	if s < EPSILON then
		return Vector3.new(qX, qY, qZ) * angle
	else
		return Vector3.new(qX / s, qY / s, qZ / s) * angle
	end
end

Quaternion.ToEulerVector = ToEulerVector

--[=[
    @method
    @group Deconstructors
    
    Converts quaternion to it's matrix representation in 
    `m00, m01, m02, m10, m11, m12, m20, m21, m22` order as a tuple. 
    Quaternion is normalized before conversion.
]=]
local function ToMatrix(q0: Quaternion): (number, number, number, number, number, number,number, number, number) 
	return _toRotationMatrix(q0)
end

Quaternion.ToMatrix = ToMatrix

--[=[
    @method
    @group Deconstructors
    
    Converts quaternion to it's matrix representation with three
    vectors, each representation a column of the rotation matrix.
    Quaternion is normalized before conversion.
    Returns RightVector, UpVector, BackVector.
]=]
local function ToMatrixVectors(q0: Quaternion): (Vector3, Vector3, Vector3) 
	local m00, m01, m02, m10, m11, m12, m20, m21, m22 = _toRotationMatrix(q0)

	--Right, Up, Back
	return Vector3.new(m00, m10, m20), Vector3.new(m01, m11, m21), Vector3.new(m02, m12, m22)
end

Quaternion.ToMatrixVectors = ToMatrixVectors

--[=[
    @method
    @group Deconstructors
    
    Returns the imaginary components of the quaternion as a Vector.
]=]
local function Vector(q0: Quaternion): Vector3 
	return Vector3.new(q0.X, q0.Y, q0.Z)
end

Quaternion.Vector = Vector

--[=[
    @method
    @group Deconstructors
    
    Returns a new quaternion with the same real component as
    the given quaternion, but with the imaginary components set to zero.
]=]
local function Real(q0: Quaternion): Quaternion 
	return new(0, 0, 0, q0.W)
end

Quaternion.Real = Real

--[=[
    @method
    @group Deconstructors
    
    Returns a new quaternion with the same imaginary components as
    the given quaternion, but with the real component set to zero.
]=]
local function Imaginary(q0: Quaternion): Quaternion 
	return new(q0.X, q0.Y, q0.Z, 0)
end

Quaternion.Imaginary = Imaginary

--[=[
    @method
    @group Deconstructors
    
    Converts the quaternion to euler angles representation in
    X, Y, Z order. Quaternion is normalized before conversion.
]=]
local function ToEulerAnglesXYZ(q0: Quaternion): (number, number, number) 
	q0 = Normalize(q0)
	local qX, qY, qZ, qW = q0.X, q0.Y, q0.Z, q0.W
	local rX, rY, rZ

	local test = qY * qW + qX * qZ
	if math.abs(test) > 0.5 - EPSILON then
		local sign = test > 0 and 1 or -1
		rX = sign * 2 * math.atan2(qZ, qW)
		rY = sign * math.pi / 2
		rZ = 0
		return rX, rY, rZ
	end

	local sqy = qY * qY
	rX = math.atan2(2 * (qX * qW - qY * qZ), 1 - 2 * (qX * qX + sqy))
	rY = math.asin(2 * test)
	rZ = math.atan2(2 * (qZ * qW - qX * qY), 1 - 2 * (qZ * qZ + sqy))

	return rX, rY, rZ
end

local function ToEulerAnglesXZY(q0: Quaternion): (number, number, number)
	q0 = Normalize(q0)
	local qX, qY, qZ, qW = q0.X, q0.Y, q0.Z, q0.W
	local rX, rY, rZ

	local test = qZ * qW - qX * qY
	if math.abs(test) > 0.5 - EPSILON then
		local sign = test >= 0 and 1 or -1
		rX = sign * 2 * -math.atan2(qY, qW)
		rY = 0
		rZ = sign * math.pi / 2 
		return rX, rY, rZ
	end

	local sqz = qZ * qZ
	rX = math.atan2(2 * (qX * qW + qY * qZ), 1 - 2 * (qX * qX + sqz))
	rY = math.atan2(2 * (qX * qZ + qY * qW), 1 - 2 * (qY * qY + sqz))
	rZ = math.asin(2 * test)

	return rX, rY, rZ
end

--[=[
    @method
    @group Deconstructors
    
    Converts the quaternion to euler angles representation in
    Y, X, Z order. Quaternion is normalized before conversion.
]=]
local function ToEulerAnglesYXZ(q0: Quaternion): (number, number, number) 
	q0 = Normalize(q0)
	local qX, qY, qZ, qW = q0.X, q0.Y, q0.Z, q0.W
	local rX, rY, rZ

	local test = qX * qW - qY * qZ
	if math.abs(test) > 0.5 - EPSILON then
		local sign = test >= 0 and 1 or -1
		rX = sign * math.pi / 2
		rY = sign * 2 * -math.atan2(qZ, qW)
		rZ = 0
		return rX, rY, rZ
	end

	local sqx = qX * qX
	rX = math.asin(2 * test)
	rY = math.atan2(2 * (qX * qZ + qY * qW), 1 - 2 * (qY * qY + sqx))
	rZ = math.atan2(2 * (qX * qY + qZ * qW), 1 - 2 * (qZ * qZ + sqx))

	return rX, rY, rZ
end

local function ToEulerAnglesYZX(q0: Quaternion): (number, number, number) 
	q0 = Normalize(q0)
	local qX, qY, qZ, qW = q0.X, q0.Y, q0.Z, q0.W
	local rX, rY, rZ

	local test = qZ * qW + qX * qY
	if math.abs(test) > 0.5 - EPSILON then
		local sign = test >= 0 and 1 or -1
		rX = 0
		rY = sign * 2 * math.atan2(qX, qW)
		rZ = sign * math.pi / 2
		return rX, rY, rZ
	end

	local sqz = qZ * qZ
	rX = math.atan2(2 * (qX * qW - qY * qZ), 1 - 2 * (qX * qX + sqz))
	rY = math.atan2(2 * (qY * qW - qX * qZ), 1 - 2 * (qY * qY + sqz))
	rZ = math.asin(2 * test)

	return rX, rY, rZ
end

local function ToEulerAnglesZXY(q0: Quaternion): (number, number, number) 
	q0 = Normalize(q0)
	local qX, qY, qZ, qW = q0.X, q0.Y, q0.Z, q0.W
	local rX, rY, rZ

	local test = qX * qW + qY * qZ
	if math.abs(test) > 0.5 - EPSILON then
		local sign = test >= 0 and 1 or -1
		rX = sign * math.pi / 2
		rY = 0
		rZ = sign * 2 * math.atan2(qY, qW)
		return rX, rY, rZ
	end

	local sqx = qX * qX
	rX = math.asin(2 * test)
	rY = math.atan2(2 * (qY * qW - qX * qZ), 1 - 2 * (qY * qY + sqx))
	rZ = math.atan2(2 * (qZ * qW - qX * qY), 1 - 2 * (qZ * qZ + sqx))

	return rX, rY, rZ
end

local function ToEulerAnglesZYX(q0: Quaternion): (number, number, number) 
	q0 = Normalize(q0)
	local qX, qY, qZ, qW = q0.X, q0.Y, q0.Z, q0.W
	local rX, rY, rZ

	local test = qY * qW - qX * qZ
	if math.abs(test) > 0.5 - EPSILON then
		local sign = test >= 0 and 1 or -1
		rX = 0
		rY = sign * math.pi / 2
		rZ = sign * 2 * -math.atan2(qX, qW)
		return rX, rY, rZ
	end

	local sqy = qY * qY
	rX = math.atan2(2 * (qX * qW + qY * qZ), 1 - 2 * (qX * qX + sqy))
	rY = math.asin(2 * test)
	rZ = math.atan2(2 * (qX * qY + qZ * qW), 1 - 2 * (qZ * qZ + sqy))

	return rX, rY, rZ
end

local TO_EULER_ANGLES_MAP = {
	["XYZ"] = ToEulerAnglesXYZ,
	["XZY"] = ToEulerAnglesXZY,
	["YZX"] = ToEulerAnglesYZX,
	["YXZ"] = ToEulerAnglesYXZ,
	["ZXY"] = ToEulerAnglesZXY,
	["ZYX"] = ToEulerAnglesZYX
}

--[=[
    @method
    @group Deconstructors
    
    Converts the quaternion to euler angles representation.
    Quaternion is normalized before conversion. The result is dependent
    on the given `rotationOrder`. Defaults to "XYZ".
]=]
local function ToEulerAngles(q0: Quaternion, rotationOrder: Enum.RotationOrder?): (number, number, number)
	local l_rotationOrder = rotationOrder or Enum.RotationOrder.XYZ
	return TO_EULER_ANGLES_MAP[l_rotationOrder.Name](q0)
end


Quaternion.ToEulerAngles = ToEulerAngles
Quaternion.ToEulerAnglesXYZ = ToEulerAnglesXYZ
Quaternion.ToEulerAnglesYXZ = ToEulerAnglesYXZ

--[=[
    @method
    @group Deconstructors
    @alias ToEulerAnglesYXZ
]=]
Quaternion.ToOrientation = ToEulerAnglesYXZ

--[=[
    @method
    @group Deconstructors
    
    Returns the components of the quaternion in X, Y, Z, W order.
]=]
local function GetComponents(q0: Quaternion): (number, number, number, number)
	return q0.X, q0.Y, q0.Z, q0.W
end

Quaternion.GetComponents = GetComponents

--[=[
    @method
    @group Deconstructors
    @alias GetComponents
]=]
Quaternion.components = GetComponents

local function round(number: number, decimalPlaces: number?): string
	if decimalPlaces then
		decimalPlaces = math.max(0, decimalPlaces)
		local formatString = string.format("%%.%df", decimalPlaces)
		local roundedNumberString = string.format(formatString, number)
		return roundedNumberString
	end
	return tostring(number)
end

--[=[
    @method
    @group Deconstructors
    
    Converts quaternion to string representation. If
    `decimalPlaces` is given, each component in the string will be rounded
    to the given places.
]=]
local function ToString(q0: Quaternion, decimalPlaces: number?): string
	if Quaternion._TO_STRING_CHAR then
		decimalPlaces = Quaternion._TO_STRING_CHAR
	end
	return 
		round(q0.X, decimalPlaces) .. ", "
		.. round(q0.Y, decimalPlaces) .. ", "
		.. round(q0.Z, decimalPlaces) .. ", "
		.. round(q0.W, decimalPlaces)
end

Quaternion.__tostring = ToString
Quaternion.ToString = ToString


function Quaternion.__index(q0, key)
	local functionIndex = Quaternion[key]
	if functionIndex then
		return functionIndex
	end
	local lower = string.lower(key)
	local cached = rawget(q0, "_cached")
	if lower == "unit" then
		if not cached.unit then
			local norm = Normalize(q0)
			cached.unit = norm
			return norm
		end
		return cached.unit
	elseif lower == "magnitude" then
		if not cached.magnitude then
			local mag = Length(q0)
			cached.magnitude = mag
			return mag
		end
		return cached.magnitude
	end
	return nil
end

function Quaternion.__newindex(_, key)
	error(tostring(key) .. " cannot be assigned to")
end

table.freeze(Quaternion)

return Quaternion

--[==[
    Sources:
    [1]: https://github.com/KieranWynn/pyquaternion/blob/master/pyquaternion
        /quaternion.py
    [2]: https://www.euclideanspace.com/maths/geometry/rotations/conversions
    [3]: https://github.com/Quenty/NevermoreEngine/blob/main/src/qframe/src
        /Shared/QFrame.lua
    [4]: https://github.com/Quenty/NevermoreEngine/blob/main/src/quaternion/src
        /Shared/Quaternion.lua
    [5]: https://www.andre-gaschler.com/rotationconverter/
    [6]: https://stackoverflow.com/questions/31600717
    [7]: https://stackoverflow.com/questions/1171849/
--]==]
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042d6</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFB79AC9446A64E95AA9F338D90DD1F6F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">4fc8b00e38e35d3d07c1075e00006c58</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Batcher</string>
							<string name="ScriptGuid">{26A21E9C-0F92-46DC-A7D4-617DE1B1ACB0}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: CoderActual & crusherfire
--@date: 2/14/2025
--[[@description:
	Batches data together and dispatches after a defined time of yielding.
	This is useful for when, for example, you fire the same remote event multiple times in a single frame (like for VFX).
	It would be more performant to batch the remote data together and then send it all at once through one remote event call!
	
	~--~ EXAMPLE ~--~
	local vfxBatcher = ModuleUtils.Batcher.new(-1)
	
	vfxBatcher:Queue(function(userData: BatchedVFXData)
		for _, player in ipairs(players) do
			if not userData[player] then
				userData[player] = {}
			end
			if not userData[player][vfxName] then
				userData[player][vfxName] = {}
			end
			table.insert(userData[player][vfxName], args)
		end
	end)
	
	vfxBatcher:OnFlushed(function(userData: BatchedVFXData)
		for player, vfxWithArgs in pairs(userData) do
			bulkFromServerEvent:FireClient(player, vfxWithArgs)
		end
	end)
]]

-----------------------------
-- SERVICES --
-----------------------------
local RunService = game:GetService("RunService")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local Trove = require(script.Parent._Trove)

-----------------------------
-- TYPES --
-----------------------------
-- This is for all of the properties of an object made from this class for type annotation purposes.
type self = {
	_trove: Trove.TroveType,
	_delayDuration: number,
	_onFlushed: OnFlushedFunc?,
	_userData: UserData,
	_flushScheduled: boolean,
}

type UserData = { [any]: any }
export type OnFlushedFunc = (userData: UserData) -> ()

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}
local MT = {}
MT.__index = MT
export type Batcher = typeof(setmetatable({} :: self, MT))

-- CONSTANTS --
-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------
-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Creates a new batcher.
-- <strong>duration</strong>: Defines how the batcher should yield before flushing.
-- <strong>-2</strong> delays to next heartbeat (task.wait),
-- <strong>-1</strong> delays to end of invocation cycle (task.defer),
-- <strong>0</strong> delays to next frame (RunService.RenderStepped:Wait())
function Module.new(duration: number?): Batcher
	local self = setmetatable({} :: self, MT)

	duration = if duration then duration else -1 :: number
	assert(typeof(duration) == "number", "Expected number for duration!")

	self._trove = Trove.new()
	self._delayDuration = duration
	self._userData = {}
	self._flushScheduled = false

	return self
end

function Module:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")

	return getmetatable(object).__index == MT
end

-- Gets the user data for the current batch cycle.
-- User data is automatically cleared when the batcher flushes.
function MT.GetUserData(self: Batcher)
	return self._userData
end

-- Calls <code>callback</code> immediately, allowing you to structure <code>userData</code>.
-- Schedules a flush if one isn't already.
function MT.Queue(self: Batcher, callback: (userData: UserData) -> ())
	assert(self._onFlushed, "No function exists to handle batch dispatches!")
	callback(self:GetUserData())
	if not self:IsFlushScheduled() then
		self._flushScheduled = true
		if self._delayDuration == -2 then
			-- yields for next heartbeat
			self._trove:Add(task.spawn(function()
				task.wait()
				self:_Flush()
			end))
		elseif self._delayDuration == -1 then
			-- yields to end of invocation cycle
			self._trove:Add(task.defer(function()
				self:_Flush()
			end))
		elseif self._delayDuration == 0 then
			-- yields to next frame
			self._trove:Add(task.spawn(function()
				RunService.RenderStepped:Wait()
				self:_Flush()
			end))
		else
			-- yields based on delay duration
			self._trove:Add(task.delay(self._delayDuration, function()
				self:_Flush()
			end))
		end
	end
end

-- Flushes the batched user data and resets it.
function MT._Flush(self: Batcher)
	assert(self._onFlushed, "No function exists to handle batch dispatches!")
	self._onFlushed(self:GetUserData())
	self._flushScheduled = false
	self._userData = {}
end

-- Sets the function that gets called when the batch is flushed.
-- Only one callback exists at a time.
function MT.OnFlushed(self: Batcher, onFlushed: OnFlushedFunc)
	self._onFlushed = onFlushed
end

function MT.IsFlushScheduled(self: Batcher): boolean
	return self._flushScheduled
end

function MT.Destroy(self: Batcher)
	self._trove:Clean()
end
-----------------------------
-- MAIN --
-----------------------------
return Module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042d7</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX88E5269E9A914C6C8C435FD1A2C4CABE">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">376e68f5e8f15bf80730089000005f84</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Spring</string>
							<string name="ScriptGuid">{B6B4C2D8-1A4D-40F0-8F40-FF39E5338480}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--[[
    Source: https://github.com/probablytukars/LuaQuaternion
    Based on: https://github.com/Quenty/NevermoreEngine/tree/main/src/spring
    [MIT LICENSE]
    
    Impulse() fixed by @crusherfire
--]]

local ERROR_FORMAT = "%q is not a valid member of Spring."

export type nlerpable = number | Vector2 | Vector3

local Spring = {_type = "Spring"}

type t_Spring<T = nlerpable> = {
	new: (initial: T, damping: number, speed: number, clock: () -> number) -> Spring<T>,
	Reset: (target: T?) -> nil,
	Impulse: (self: Spring<T>, velocity: T) -> nil,
	TimeSkip: (self: Spring<T>, delta: number) -> nil,
	IsAtRest: (self: Spring<T>, tolerance: number?) -> boolean,
	
	Position: T,
	p: T,
	Velocity: T,
	v: T,
	Target: T,
	t: T,
	Damping: number,
	d: number,
	Speed: number,
	s: number,
	Clock: () -> number,

	_clock: () -> number,
	_time: number,
	_position: T,
	_velocity: T,
	_target: T,
	_damping: number,
	_speed: number,
	_initial: T,
}

export type Spring<T = nlerpable> = t_Spring<T>

-- get the numeric “magnitude” for number vs Vector2/3
local function mag(x): number
	if type(x) == "number" then
		return math.abs(x)
	else
		-- Vector2 and Vector3 both have a .Magnitude
		return (x :: any).Magnitude
	end
end

--[=[
    @class Spring
    @grouporder ["Constructors", "Methods"]
    
    This class represents a spring, which can handle any object which is
    n-lerpable (numbers, Vector3s, etc).
    
    This is lazily evaluated meaning it only updates when indexed.
]=]
--[=[
    @prop Position nlerpable
    
    The current position at the given clock time. 
    Assigning the position will change the spring to have that position.
]=]
--[=[
    @prop p nlerpable
    @alias Position
]=]
--[=[
    @prop Velocity nlerpable
    
    The current velocity. Assigning the velocity will change the spring to have 
    that velocity.
]=]
--[=[
    @prop v nlerpable
    @alias Velocity
]=]
--[=[
    @prop Target nlerpable
    
    The current target. Assigning the target will change the spring to have 
    that target.
]=]
--[=[
    @prop t nlerpable
    @alias Target
]=]
--[=[
    @prop Damping number
    
    The current damper, defaults to 1. At 1 the spring is critically damped. 
    At less than 1, it will be underdamped, and thus, bounce, and at over 1, 
    it will be critically damped.
]=]
--[=[
    @prop d number
    @alias Damping
]=]
--[=[
    @prop Speed number
    
    The speed, defaults to 1, but should be between [0, infinity)
]=]
--[=[
    @prop s number
    @alias Speed
]=]
--[=[
    @prop Clock
]=]


--[=[
    @function
    @group Constructors
    
    Constructs a new Spring at the position and target specified, of type <T>.
]=]
function Spring.new<T>(initial: T, damping: number?, speed: number?, clock: (() -> number)?): t_Spring<T>
	local l_damping = damping or 1
	local l_speed = speed or 1
	local l_clock = clock or os.clock

	local self = {
		_clock = l_clock;
		_time = l_clock();
		_position = initial;
		_velocity = ((initial :: any) * 0) :: T;
		_target = initial;
		_damping = l_damping;
		_speed = l_speed;
		_initial = initial;
	}

	return setmetatable(self, Spring) :: any
end

--[=[
    @method
    @group Methods
    
    Resets the springs' position and target to the target value provided, or 
    to the initial value the spring was created with if target is not specified.
    Sets the velocity to zero.
]=]
local function Reset(self: Spring, target: nlerpable?)
	local now = self._clock()
	local setTo = target or self._initial
	self._position = setTo
	self._target = setTo
	self._velocity = 0 * (setTo :: any)
	self._time = now
end

Spring.Reset = Reset

--[=[
    @method
    @group Methods
    
    Impulses the spring, increasing velocity by the amount given.
    This is useful to make something shake.
]=]
local function Impulse<T>(self: Spring<T>, velocity: T)
	self.Velocity = (self.Velocity :: any) + velocity
end

Spring.Impulse = Impulse

local function _positionVelocity(self: Spring, now: number)
	local currentPosition = self._position
	local currentVelocity = self._velocity
	local targetPosition = self._target
	local dampingFactor = self._damping
	local speed = self._speed

	local deltaTime = speed * (now - self._time)
	local dampingSquared = dampingFactor * dampingFactor

	local angFreq, sinTheta, cosTheta
	if dampingSquared < 1 then
		angFreq = math.sqrt(1 - dampingSquared)
		local exponential = math.exp(-dampingFactor * deltaTime) / angFreq
		cosTheta = exponential * math.cos(angFreq * deltaTime)
		sinTheta = exponential * math.sin(angFreq * deltaTime)
	elseif dampingSquared == 1 then
		angFreq = 1
		local exponential = math.exp(-dampingFactor * deltaTime) / angFreq
		cosTheta, sinTheta = exponential, exponential * deltaTime
	else
		angFreq = math.sqrt(dampingSquared - 1)
		local angFreq2 = 2 * angFreq
		local u = math.exp((-dampingFactor + angFreq) * deltaTime) / angFreq2
		local v = math.exp((-dampingFactor - angFreq) * deltaTime) / angFreq2
		cosTheta, sinTheta = u + v, u - v
	end

	local pullToTarget = 1 - (angFreq * cosTheta + dampingFactor * sinTheta)
	local velPosPush = sinTheta / speed
	local velPushRate = speed * sinTheta
	local velocityDecay = angFreq * cosTheta - dampingFactor * sinTheta

	local positionDifference = targetPosition :: any - currentPosition

	local newPosition = 
		currentPosition + 
		positionDifference * pullToTarget + 
		currentVelocity :: any * velPosPush

	local newVelocity =
		positionDifference * velPushRate +
		currentVelocity :: any * velocityDecay

	return newPosition, newVelocity
end

--[=[
    @method
    @group Methods

    Returns true if the spring's current position is within `tolerance` of its
    target, and its velocity is also below `tolerance`, i.e. effectively at rest.
    @param tolerance? number — how close is “close enough”? defaults to 1e-3.
    @within Spring
]=]
local function IsAtRest(self: Spring<nlerpable>, tolerance: number?)
	local tolerance = tolerance or 1e-3
	local now = self._clock()
	-- compute the up-to-date position & velocity without mutating state
	local pos, vel = _positionVelocity(self, now)

	-- displacement from target
	local disp = (pos :: any) - (self._target :: any)

	return mag(disp) <= tolerance and mag(vel) <= tolerance
end

Spring.IsAtRest = IsAtRest


--[=[
    @method
    @group Methods
    Instantly skips the spring forwards by the given time.
]=]
local function TimeSkip(self: Spring, delta: number)
	local now = self._clock()
	local position, velocity = _positionVelocity(self, now+delta)
	self._position = position
	self._velocity = velocity
	self._time = now
end

Spring.TimeSkip = TimeSkip


function Spring.__index(self: Spring, index)
	if Spring[index] then
		return Spring[index]
	elseif index == "Position" or index == "p" then
		local position, _ = _positionVelocity(self, self._clock())
		return position
	elseif index == "Velocity" or index == "v" then
		local _, velocity = _positionVelocity(self, self._clock())
		return velocity
	elseif index == "Target" or index == "t" then
		return self._target
	elseif index == "Damping" or index == "d" then
		return self._damping
	elseif index == "Speed" or index == "s" then
		return self._speed
	elseif index == "Clock" then
		return self._clock
	end
	error(string.format(ERROR_FORMAT, tostring(index)), 2)
end

function Spring.__newindex(self: Spring, index, value: any)
	local now = self._clock()
	if index == "Position" or index == "p" then
		local _, velocity = _positionVelocity(self, now)
		self._position = value
		self._velocity = velocity
		self._time = now
	elseif index == "Velocity" or index == "v" then
		local position, _ = _positionVelocity(self, now)
		self._position = position
		self._velocity = value
		self._time = now
	elseif index == "Target" or index == "t" then
		local position, velocity = _positionVelocity(self, now)
		self._position = position
		self._velocity = velocity
		self._target = value
		self._time = now
	elseif index == "Damping" or index == "d" then
		local position, velocity = _positionVelocity(self, now)
		self._position = position
		self._velocity = velocity
		self._damping = value
		self._time = now
	elseif index == "Speed" or index == "s" then
		local position, velocity = _positionVelocity(self, now)
		self._position = position
		self._velocity = velocity
		self._speed = value < 0 and 0 or value
		self._time = now
	elseif index == "Clock" then
		local position, velocity = _positionVelocity(self, now)
		self._position = position
		self._velocity = velocity
		self._clock = value
		self._time = value()
	else
		error(string.format(ERROR_FORMAT, tostring(index)), 2)
	end
end

return Spring]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042d8</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX878536CD0D7940F196A707187150BE22">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">376e68f5e8f15bf80730089000005fa4</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_SpringUtils</string>
							<string name="ScriptGuid">{EC682B1E-3F0D-4654-BC37-1F1D05C9E8FF}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--[=[
	Utility functions that are related to the Spring object
	@class SpringUtils
]=]

local EPSILON = 1e-6

local LinearValue = require(script._LinearValue)
local Spring = require(script.Parent._Spring)

local SpringUtils = {}

--[=[
	Utility function that returns whether or not a spring is animating based upon
	velocity and closeness to target, and as the second value, the value that should be
	used.

	@param spring Spring<T>
	@param epsilon number? -- Optional epsilon
	@return boolean, T
]=]
function SpringUtils.animating(spring: Spring.Spring<any>, epsilon): (boolean, any)
	epsilon = epsilon or EPSILON

	local position = spring.Position
	local target = spring.Target

	local animating
	if type(target) == "number" then
		animating = math.abs(spring.Position - spring.Target) > epsilon
			or math.abs(spring.Velocity) > epsilon
	else
		local rbxtype = typeof(target)
		if rbxtype == "Vector3" or rbxtype == "Vector2" or LinearValue.isLinear(target) then
			animating = (spring.Position - spring.Target).magnitude > epsilon
				or spring.Velocity.magnitude > epsilon
		else
			error("Unknown type")
		end
	end

	if animating then
		return true, position
	else
		-- We need to return the target so we use the actual target value (i.e. pretend like the spring is asleep)
		return false, target
	end
end

--[=[
	Add to spring position to adjust for velocity of target. May have to set clock to time().

	@param velocity T
	@param dampen number
	@param speed number
	@return T
]=]
function SpringUtils.getVelocityAdjustment(velocity: any, dampen: number, speed: number): any
	assert(velocity, "Bad velocity")
	assert(dampen, "Bad dampen")
	assert(speed, "Bad speed")

	return velocity*(2*dampen/speed)
end

--[=[
	Converts an arbitrary value to a LinearValue if Roblox has not defined this value
	for multiplication and addition.

	@param value T
	@return LinearValue<T> | T
]=]
function SpringUtils.toLinearIfNeeded(value)
	return LinearValue.toLinearIfNeeded(value)
end

--[=[
	Extracts the base value out of a packed linear value if needed.

	@param value LinearValue<T> | any
	@return T | any
]=]
function SpringUtils.fromLinearIfNeeded(value)
	return LinearValue.fromLinearIfNeeded(value)
end

return SpringUtils]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042d9</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX6593DE1E2057424FBBC12AA69BF58FED">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">376e68f5e8f15bf80730089000005fc3</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_LinearValue</string>
								<string name="ScriptGuid">{1B7326ED-5A7D-43C9-A655-E4B16570F4A1}</string>
								<ProtectedString name="Source"><![CDATA[--!nonstrict
--[=[
	Represents a value that can operate in linear space

	@class LinearValue
]=]

local DuckTypeUtils = require(script.Parent.Parent._DuckTypeUtils)

local LinearValue = {}
LinearValue.ClassName = "LinearValue"
LinearValue.__index = LinearValue

export type LinearValue = typeof(setmetatable({}, LinearValue))

--[=[
	Constructs a new LinearValue object.

	@param constructor (number ...) -> T
	@param values ({ number })
	@return LinearValue<T>
]=]
function LinearValue.new(constructor, values)
	return setmetatable({
		_constructor = constructor;
		_values = values;
	}, LinearValue)
end

--[=[
	Returns whether or not a value is a LinearValue object.

	@param value any -- A value to check
	@return boolean -- True if a linear value, false otherwise
]=]
function LinearValue.isLinear(value)
	return DuckTypeUtils.isImplementation(LinearValue, value)
end

local function convertUDim2(scaleX, offsetX, scaleY, offsetY)
	-- Roblox UDim2.new(0, 9.999, 0, 9.999) rounds to UDim2.new(0, 9, 0, 9) which means small floating point
	-- errors can cause shaking UI.

	return UDim2.new(scaleX, math.round(offsetX), scaleY, math.round(offsetY))
end

local function convertUDim(scale, offset)
	-- Roblox UDim.new(0, 9.999) rounds to UDim.new(0, 9) which means small floating point
	-- errors can cause shaking UI.

	return UDim.new(scale, math.round(offset))
end

local function convertBoolean(value)
	return value ~= 0
end

--[=[
	Converts an arbitrary value to a LinearValue if Roblox has not defined this value
	for multiplication and addition.

	@param value T
	@return LinearValue<T> | T
]=]
function LinearValue.toLinearIfNeeded(value)
	if typeof(value) == "Color3" then
		return LinearValue.new(Color3.new, {value.R, value.G, value.B})
	elseif typeof(value) == "UDim2" then
		return LinearValue.new(convertUDim2, {value.X.Scale, math.round(value.X.Offset), value.Y.Scale, math.round(value.Y.Offset)})
	elseif typeof(value) == "UDim" then
		return LinearValue.new(convertUDim, {value.Scale, math.round(value.Offset)})
	elseif type(value) == "boolean" then
		return LinearValue.new(convertBoolean, { value and 1 or 0 })
	else
		return value
	end
end

--[=[
	Extracts the base value out of a packed linear value if needed.

	@param value LinearValue<T> | any
	@return T | any
]=]
function LinearValue.fromLinearIfNeeded(value)
	if LinearValue.isLinear(value) then
		return value:ToBaseValue()
	else
		return value
	end
end

--[=[
	Converts the value back to the base value

	@return T
]=]
function LinearValue:ToBaseValue()
	return self._constructor(unpack(self._values))
end

local function operation(func)
	return function(a, b)
		if LinearValue.isLinear(a) and LinearValue.isLinear(b) then
			assert(a._constructor == b._constructor, "a is not the same type of linearValue as b")

			local values = {}
			for i=1, #a._values do
				values[i] = func(a._values[i], b._values[i])
			end
			return LinearValue.new(a._constructor, values)
		elseif LinearValue.isLinear(a) then
			if type(b) == "number" then
				local values = {}
				for i=1, #a._values do
					values[i] = func(a._values[i], b)
				end
				return LinearValue.new(a._constructor, values)
			else
				error("Bad type (b)")
			end
		elseif LinearValue.isLinear(b) then
			if type(a) == "number" then
				local values = {}
				for i=1, #b._values do
					values[i] = func(a, b._values[i])
				end
				return LinearValue.new(b._constructor, values)
			else
				error("Bad type (a)")
			end
		else
			error("Neither value is a linearValue")
		end
	end
end

--[=[
	Returns the magnitude of the linear value.

	@return number -- The magnitude of the linear value.
]=]
function LinearValue:GetMagnitude()
	local dot = 0
	for i=1, #self._values do
		local value = self._values[i]
		dot = dot + value*value
	end
	return math.sqrt(dot)
end

--[=[
	Returns the magnitude of the linear value.

	@prop magnitude number
	@readonly
	@within LinearValue
]=]
function LinearValue.__index(self: LinearValue, key)
	if LinearValue[key] then
		return LinearValue[key]
	elseif key == "magnitude" then
		return self:GetMagnitude()
	else
		return nil
	end
end

LinearValue.__add = operation(function(a, b)
	return a + b
end)

LinearValue.__sub = operation(function(a, b)
	return a - b
end)

LinearValue.__mul = operation(function(a, b)
	return a * b
end)

LinearValue.__div = operation(function(a, b)
	return a / b
end)

function LinearValue:__eq(a, b)
	if LinearValue.isLinear(a) and LinearValue.isLinear(b) then
		if #a._values ~= #b._values then
			return false
		end

		for i=1, #a._values do
			if a._values[i] ~= b._values[i] then
				return false
			end
		end

		return true
	else
		return false
	end
end


return LinearValue]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042da</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXAE655DA08FCE4F67B74A4ECF43C47758">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">376e68f5e8f15bf80730089000005fe2</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_DuckTypeUtils</string>
							<string name="ScriptGuid">{FC59F8C6-5D54-49D4-B044-6B001DEF6817}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--[=[
	Utility method to check interface is equivalent for two implementations

	@class DuckTypeUtils
]=]

local DuckTypeUtils = {}

--[=[
	Returns true if a template is similar to a target

	@param template table
	@param target any
	@return boolean
]=]
function DuckTypeUtils.isImplementation(template: any, target: any): boolean
	assert(type(template) == "table", "Bad template")

	return type(target) == "table"
		and (getmetatable(target) == template or DuckTypeUtils._checkInterface(template, target))
end

function DuckTypeUtils._checkInterface(template, target)
	local targetMetatable = getmetatable(target)
	local templateMetatable = getmetatable(template)
	if targetMetatable and type(targetMetatable.__index) == "function" then
		-- Indexing into this target could cause an error. Treat it differently and fast-fail
		if templateMetatable then
			return templateMetatable.__index == targetMetatable.__index
		end

		return false
	end

	for key, value in pairs(template) do
		if type(value) == "function" and type(target[key]) ~= "function" then
			return false
		end
	end

	-- must do: Prevent infinite recursion potential
	if templateMetatable and type(templateMetatable.__index) == "table" then
		return DuckTypeUtils._checkInterface(templateMetatable.__index, target)
	end

	return true
end

return DuckTypeUtils]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042db</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX1FBCF00B0E5342BF967D3E9399EA4D48">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006746</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Binder</string>
							<string name="ScriptGuid">{010A9491-9BD4-44DE-B2CB-ADA6959D081F}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 11/8/24
--[[@description:
	Binds a class to a collection service tag.
]]
-----------------------------
-- SERVICES --
-----------------------------
local CollectionService = game:GetService("CollectionService")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local Trove = require(script.Parent._Trove)
local Signal = require(script.Parent._Signal)

-----------------------------
-- TYPES --
-----------------------------
-- This is for all of the properties of an object made from this class for type annotation purposes.
type self = {
	Signals: {
		ObjectAdded: Signal.Signal<(instance: Instance, obj: any) -> (), (Instance, any)>, -- Fired when a new object is created
		ObjectRemoving: Signal.Signal<(instance: Instance, obj: any) -> (), (Instance, any)>, -- Fired right before an object is destroyed
	},

	_trove: Trove.TroveType,
	_bindTrove: Trove.TroveType,
	_tag: string,
	_class: any,
	_constructor: string,
	_objects: { [Instance]: any },

	_addedSignal: RBXScriptSignal,
	_removedSignal: RBXScriptSignal,
}

-----------------------------
-- VARIABLES --
-----------------------------
local Binder = {}
local MT = {}
MT.__index = MT
export type Binder = typeof(setmetatable({} :: self, MT))

-- CONSTANTS --

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

local function doConstruction(self: Binder, instance: Instance)
	local object = self._class[self._constructor](instance)
	self._objects[instance] = self._trove:Add(object)
	self.Signals.ObjectAdded:Fire(instance, object)
end

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Creates a new binder for the given tag.
-- The provided <code>class</code must have a constructor & and a destroy method for the objects.
-- <strong>constructor</strong>: Define the constructor in the given <code>class</code> if it's not <code>.new()</code>.
function Binder.new(tag: string, class: any, constructor: string?): Binder
	assert(typeof(class) == "table", "Expected class!")
	constructor = constructor or "new"
	assert(class[constructor], "Class does not contain a constructor!")

	local myTrove = Trove.new()
	local self = {
		_trove = myTrove,
		_bindTrove = myTrove:Construct(Signal),
		Signals = {
			ObjectAdded = myTrove:Construct(Signal),
			ObjectRemoving = myTrove:Construct(Signal),
		},
		_tag = tag,
		_class = class,
		_constructor = constructor,
		_objects = {},
		_addedSignal = CollectionService:GetInstanceAddedSignal(tag),
		_removedSignal = CollectionService:GetInstanceAddedSignal(tag),
	} :: self

	return setmetatable(self, MT)
end

function Binder:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")

	return getmetatable(object).__index == MT
end

-- Begins listening to the CollectionService & initializes all current instances in the game with the Binder's tag.
-- <strong>canCreate</strong>: An optional predicate function for filtering out certain instances from being passed to the class when first initializing.
-- This is useful when, for example, you only want to initialize the instance when it's parented to a certain service.
function MT.Bind(self: Binder, canCreate: ((instance: Instance) -> boolean)?)
	self._bindTrove:Connect(self._addedSignal, function(instance)
		doConstruction(self, instance)
	end)
	self._bindTrove:Connect(self._removedSignal, function(instance)
		local object = self._objects[instance] :: any
		if not object.Destroy then
			warn(`Object: {object} does not contain a destroy method!`)
		end
		self._objects[instance] = nil
		self._trove:Remove(object)
	end)

	for _, instance in CollectionService:GetTagged(self._tag) do
		if canCreate and not canCreate(instance) then
			continue
		end
		if self._objects[instance] then
			-- Already initialized
			continue
		end
		task.spawn(doConstruction, self, instance)
	end
end

-- Stops listening to the CollectionService.
function MT.Unbind(self: Binder)
	self._bindTrove:Clean()
end

function MT.GetAllObjects(self: Binder): { [Instance]: any }
	return self._objects
end

-- Cleans up all connections and destroys all objects created by the binder.
function MT.Destroy(self: Binder)
	self._trove:Clean()
	setmetatable(self :: any, nil)
	table.clear(self :: any)
end

-----------------------------
-- MAIN --
-----------------------------
return Binder
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042dc</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX89666700B70240799E676BBB82374BCF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc08218013000096eb</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Respawner</string>
							<string name="ScriptGuid">{23F397A0-9618-4423-BCE1-4CDA21B53CE5}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: C0DERACTU4L
--@date: 9/2/2024
--[[@description:
	Respawner class for models 
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local Trove = require("./_Trove")

-----------------------------
-- TYPES --
-----------------------------
-- This is for all of the properties of an object made from this class for type annotation purposes.
type self = {
	_trove: Trove.TroveType,
	
	_instance: PVInstance,
	_humanoid: Humanoid?,
	_instanceCache: PVInstance,
	_instanceParentCache: Instance,
	_respawnTime: number,
}

-----------------------------
-- VARIABLES --
-----------------------------
local Respawner = {}
local MT = {}
MT.__index = MT

export type Respawner = typeof(setmetatable({} :: self, MT))

local respawnCache = {}

-- CONSTANTS --
local DEFAULT_RESPAWN_TIME = 10
local INSTANCE_CACHE_LOCATION = ReplicatedStorage

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

function Respawner.new(instance: Instance, respawnTime: number?): Respawner
	assert(instance and instance:IsA("PVInstance"), "Expected instance to be of type PV Instance")
	local self = setmetatable({} :: self, MT)

	self._trove = Trove.new()

	self._instance = instance
	self._instanceCache = self._instance:Clone()
	self._instanceCache:RemoveTag("Respawnable")
	self._instanceCache.Parent = INSTANCE_CACHE_LOCATION
	self._instanceParentCache = if self._instance.Parent and self._instance.Parent:IsA("Instance") then self._instance.Parent else workspace
	self._respawnTime = if respawnTime then respawnTime else DEFAULT_RESPAWN_TIME
	
	self._humanoid = self._instance:FindFirstChildWhichIsA("Humanoid")

	if self._humanoid then
		self._trove:Add(self._humanoid.Died:Once(function()
			task.wait(self._respawnTime)
			self._instance:Destroy()
		end))
	end
	
	self._trove:Connect(self._instance.Destroying, function()
		if not self._humanoid then
			task.wait(self._respawnTime)
		end
		self:Respawn()
	end)
	
	table.insert(respawnCache, self)
	return self
end

function Respawner:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")

	return getmetatable(object) == MT
end

function Respawner:GetObjectFromInstance(instance): Respawner?
	for _, cachedObject in ipairs(respawnCache) do
		if cachedObject._instance == instance then
			return cachedObject
		end
	end
	return nil
end

function MT.Respawn(self: Respawner)
	self._trove:Clean()
	self._instance = self._instanceCache:Clone()
	self._instance.Parent = self._instanceParentCache
	self._humanoid = self._instance:FindFirstChildWhichIsA("Humanoid")
	
	self._trove:Connect(self._instance.Destroying, function()
		if not self._humanoid then
			task.wait(self._respawnTime)
		end
		self:Respawn()
	end)
	
	if self._humanoid then
		self._trove:Add(self._humanoid.Died:Once(function()
			task.wait(self._respawnTime)
			self._instance:Destroy()
		end))
	end
end

function MT.Destroy(self: Respawner)
	self._trove:Clean()
	table.remove(respawnCache, table.find(respawnCache, self))
	setmetatable(self :: any, nil)
	table.clear(self :: any)
end

-----------------------------
-- MAIN --
-----------------------------
return Respawner]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042dd</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8CA8020F120C4A78B0F3807CBC844ECB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c3c</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Zone</string>
							<string name="ScriptGuid">{54B5A4A8-31C3-4188-A4CC-0A0430825CEA}</string>
							<ProtectedString name="Source"><![CDATA[--!optimize 2
--!strict

local zoneTypes = script.ZoneTypes

local Types = require(script.Types)
local SimpleZone = require(script.SimpleZone)

export type LessSimpleZone<U, T...> = Types.LessSimpleZone<U, T...>
export type Zone = SimpleZone.Zone

export type QueryOptions = SimpleZone.QueryOptions
export type Box = SimpleZone.Box

return table.freeze {
	fromBoxes = require(zoneTypes.BoxesZone),
	fromParts = require(zoneTypes.PartsZone),
	fromBasePartsVertices = require(zoneTypes.BasePartsVertexZone),
	
	SimpleZone = SimpleZone,
	QueryOptions = SimpleZone.QueryOptions,
	Geometry = require(script.Geometry)
}]]></ProtectedString>
							<int64 name="SourceAssetId">132563954794838</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042de</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX230318ED4264433B8802802E79EE4B9A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c43</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Types</string>
								<string name="ScriptGuid">{9374F96F-330F-428A-96D4-129B9061A608}</string>
								<ProtectedString name="Source"><![CDATA[local main = script.Parent

local Zone = require(main.SimpleZone)

type LessSimpleZoneInternal<U, T...> = {
	UpdateVolume: typeof(
		--[[
			Updates the volume of this <code>Zone</code>.
		]]
		function(self: LessSimpleZone<U, T...>, ...: T...)
		end
	),
	GetRandomPoint: typeof(
		--[[
			Gets a random point within this <code>Zone</code>.
		]]
		function(self: LessSimpleZone<U, T...>): vector
		end
	),
	IsPointWithinZone: typeof(
		--[[
			Checks if <code>point</code> is located within this <code>Zone</code>.
		]]
		function(self: LessSimpleZone<U, T...>, point: vector): (boolean, U?)
		end
	),
	IsBoxWithinZone: typeof(
		--[[
			Checks if <code>box</code> is within this <code>Zone</code>.
		]]
		function(self: LessSimpleZone<U, T...>, cframe: CFrame, size: vector): (boolean, U?)
		end
	),
	CombineWith: typeof(
		--[[
			Combines this <code>Zone</code>s volume with <code>other</code>.
		]]
		function(self: LessSimpleZone<U, T...>, other: LessSimpleZone<U, T...>)
		end
	),
	
	ZoneType: string,
	Volume: any
}

export type LessSimpleZone<U, T...> = Zone.Zone & LessSimpleZoneInternal<U, T...>

return nil]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042df</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX959BD19CDEDA42F19A4C637B82EBB1BD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c44</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Geometry</string>
								<string name="ScriptGuid">{4AAF2578-1532-4644-9DB7-FB83AAFD1655}</string>
								<ProtectedString name="Source"><![CDATA[--!native
--!optimize 2

--[[
	Cool geometry helper module :)
	Author: athar_adv
]]

local Vertices = require(script.Vertices)
local BVH = require(script.BVH)

export type Box = BVH.Box
export type BoxNode = BVH.BoxNode

local Geometry = {
	Vertices = Vertices,
	BVH = BVH
}

local dot = vector.dot
local cross = vector.cross
local magn = vector.magnitude

local function tpart(pos: Vector3)
	local part = Instance.new("Part")
	part.Position = pos
	part.Material = Enum.Material.Neon
	part.Anchored = true
	part.Size = Vector3.one
	part.Name = "TEST_PART"
	part.Parent = workspace
	return part
end

local function isCollinear(p1: vector, p2: vector, p3: vector, p4: vector)
	local volume = dot(p2 - p1, cross(p3 - p1, p4 - p1))
	return math.abs(volume) < 1e-6 -- Tolerance for floating point comparison
end

local function barycentricinbounds(p: vector, a: vector, b: vector, c: vector)
	local v0 = b - a
	local v1 = c - a
	local v2 = p - a
	
	local d00 = dot(v0, v0)
	local d01 = dot(v0, v1)
	local d11 = dot(v1, v1)
	local d20 = dot(v2, v0)
	local d21 = dot(v2, v1)
	
	local denom = d00 * d11 - d01 * d01
	
	local v = (d11 * d20 - d01 * d21) / denom;
	local w = (d00 * d21 - d01 * d20) / denom;
	local u = 1 - v - w;
	
	return u >= 0 and v >= 0 and u <= 1 and v <= 1 and u + v <= 1
end

type PointInShapeFunctions = {
	[string]: (point: vector, part: Part) -> boolean
}

type BoxInShapeFunctions = {
	[string]: (cframe: CFrame, size: vector, part: Part) -> boolean
}

local BoxInShapeFns: BoxInShapeFunctions = {
	Block = function(boxCFrame, boxSize, part)
		return Geometry.doBoxesIntersect(boxCFrame, boxSize, part.CFrame, part.ExtentsSize)
	end,
	
	Cylinder = function(boxCFrame, boxSize, part)
		if not Geometry.doBoxesIntersect(boxCFrame, boxSize, part.CFrame, part.ExtentsSize) then
			return false
		end
		local pos = part.Position
		local cf = part.CFrame
		local size = part.ExtentsSize

		local height = size.X
		local radius = size.Y / 2
		
		local lPoint = cf:PointToObjectSpace(boxCFrame.Position)
		
		local axisAligned = pos + (cf.XVector.Unit * lPoint.X)
		
		return Geometry.doesBoxIntersectSphere(axisAligned, radius, boxCFrame, boxSize)
	end,
	
	Ball = function(boxCFrame, boxSize, part)
		return Geometry.doesBoxIntersectSphere(part.Position, part.ExtentsSize.Y, boxCFrame, boxSize)
	end,
	
	Wedge = function(boxCFrame, boxSize, part)
		error("Wedge for IsBoxWithinShape is not supported.")
	end,
	
	CornerWedge = function(boxCFrame, boxSize, part)
		error("CornerWedge for IsBoxWithinShape is not supported.")
	end,
}

local PointInShapeFns: PointInShapeFunctions = {
	Block = function(point, part)
		return Geometry.isPointInBox(part.CFrame, part.ExtentsSize, point)
	end,

	Cylinder = function(point, part)
		local pos = part.Position
		local cf = part.CFrame
		local size = part.ExtentsSize
		
		local height = size.X
		local radius = size.Y / 2 
		
		local lPoint = cf:PointToObjectSpace(point)
		
		local axisAligned = pos + (cf.XVector.Unit * lPoint.X)
		
		return magn(axisAligned - point) <= radius
	end,

	Ball = function(point, part)
		local radius = part.ExtentsSize.X / 2 
		local center = part.Position
		
		return magn(point - center) <= radius
	end,

	Wedge = function(point, part)
		local pos = part.Position
		local cf = part.CFrame
		local size = part.ExtentsSize

		local s2 = size / 2

		local xvec = cf.XVector.Unit * s2.X
		local yvec = cf.YVector.Unit * s2.Y
		local zvec = cf.ZVector.Unit * s2.Z

		-- Backwards, right, up
		local a = pos + xvec + zvec + yvec
		-- Backwards, right, down
		local b = pos + xvec + zvec - yvec
		-- Forwards, right, down
		local c = pos + xvec - zvec - yvec
		
		point = cf:PointToWorldSpace(cf:PointToObjectSpace(point) * vector.create(0, 1, 1) + vector.create(size.X/2, 0, 0))
		
		return barycentricinbounds(point, a, b, c)
	end,

	CornerWedge = function(point, part)
		local pos = part.Position
		local cf = part.CFrame
		local size = part.ExtentsSize

		local s2 = size / 2

		local xvec = cf.XVector.Unit * s2.X
		local yvec = cf.YVector.Unit * s2.Y
		local zvec = cf.ZVector.Unit * s2.Z
		
		-- Top for both
		-- Forwards, right, up
		local a = pos + xvec - zvec + yvec
		
		-- Bottom for both
		-- Forwards, right, down
		local b = pos + xvec - zvec - yvec
		
		local c = pos - xvec - zvec - yvec
		local d = pos + xvec + zvec - yvec
		
		-- This is done to put the point in the plane of the triangles
		local fpoint = cf:PointToWorldSpace(cf:PointToObjectSpace(point) * vector.create(1, 1, 0) - vector.create(0, 0, size.Z/2))
		local spoint = cf:PointToWorldSpace(cf:PointToObjectSpace(point) * vector.create(0, 1, 1) + vector.create(size.X/2, 0, 0))
		
		return barycentricinbounds(fpoint, a, b, c) and barycentricinbounds(spoint, a, b, d)
	end,
}

function Geometry.doBoxesIntersect(boxACframe: CFrame, boxASize: vector, boxBCFrame: CFrame, boxBSize: vector): boolean
	-- Transform boxB into boxA's local space
	local AtoB = boxACframe:ToObjectSpace(boxBCFrame)

	-- Get half sizes
	local boxAHalfSize = boxASize / 2
	local boxBHalfSize = boxBSize / 2

	-- Get the translation vector
	local translation = AtoB.Position

	-- Get the rotation vectors 
	local r = AtoB.RightVector
	local u = AtoB.UpVector
	local l = -AtoB.LookVector  -- Negative because of how Roblox defines LookVector

	-- Test separation along boxA's local axes (X, Y, Z)
	if math.abs(translation.X) > boxAHalfSize.X + 
		boxBHalfSize.X * math.abs(r.X) + 
		boxBHalfSize.Y * math.abs(u.X) + 
		boxBHalfSize.Z * math.abs(l.X) then
		return false
	end

	if math.abs(translation.Y) > boxAHalfSize.Y + 
		boxBHalfSize.X * math.abs(r.Y) + 
		boxBHalfSize.Y * math.abs(u.Y) + 
		boxBHalfSize.Z * math.abs(l.Y) then
		return false
	end

	if math.abs(translation.Z) > boxAHalfSize.Z + 
		boxBHalfSize.X * math.abs(r.Z) + 
		boxBHalfSize.Y * math.abs(u.Z) + 
		boxBHalfSize.Z * math.abs(l.Z) then
		return false
	end

	-- Test separation along boxB's local axes (RightVector, UpVector, LookVector)
	if math.abs(dot(translation, r)) > 
		boxAHalfSize.X * math.abs(r.X) + 
			boxAHalfSize.Y * math.abs(r.Y) + 
			boxAHalfSize.Z * math.abs(r.Z) + 
			boxBHalfSize.X then
		return false
	end

	if math.abs(dot(translation, u)) > 
		boxAHalfSize.X * math.abs(u.X) + 
			boxAHalfSize.Y * math.abs(u.Y) + 
			boxAHalfSize.Z * math.abs(u.Z) + 
			boxBHalfSize.Y then
		return false
	end

	if math.abs(dot(translation, l)) > 
		boxAHalfSize.X * math.abs(l.X) + 
			boxAHalfSize.Y * math.abs(l.Y) + 
			boxAHalfSize.Z * math.abs(l.Z) + 
			boxBHalfSize.Z then
		return false
	end

	-- Test separation along the 9 cross products (edge cross edge)

	-- X axis of boxA crossed with each axis of boxB
	if math.abs(translation.Z * r.Y - translation.Y * r.Z) > 
		boxAHalfSize.Y * math.abs(r.Z) + 
			boxAHalfSize.Z * math.abs(r.Y) + 
			boxBHalfSize.Y * math.abs(l.X) + 
			boxBHalfSize.Z * math.abs(u.X) then
		return false
	end

	if math.abs(translation.Z * u.Y - translation.Y * u.Z) > 
		boxAHalfSize.Y * math.abs(u.Z) + 
			boxAHalfSize.Z * math.abs(u.Y) + 
			boxBHalfSize.X * math.abs(l.X) + 
			boxBHalfSize.Z * math.abs(r.X) then
		return false
	end

	if math.abs(translation.Z * l.Y - translation.Y * l.Z) > 
		boxAHalfSize.Y * math.abs(l.Z) + 
			boxAHalfSize.Z * math.abs(l.Y) + 
			boxBHalfSize.X * math.abs(u.X) + 
			boxBHalfSize.Y * math.abs(r.X) then
		return false
	end

	-- Y axis of boxA crossed with each axis of boxB
	if math.abs(translation.X * r.Z - translation.Z * r.X) > 
		boxAHalfSize.X * math.abs(r.Z) + 
			boxAHalfSize.Z * math.abs(r.X) + 
			boxBHalfSize.Y * math.abs(l.Y) + 
			boxBHalfSize.Z * math.abs(u.Y) then
		return false
	end

	if math.abs(translation.X * u.Z - translation.Z * u.X) > 
		boxAHalfSize.X * math.abs(u.Z) + 
			boxAHalfSize.Z * math.abs(u.X) + 
			boxBHalfSize.X * math.abs(l.Y) + 
			boxBHalfSize.Z * math.abs(r.Y) then
		return false
	end

	if math.abs(translation.X * l.Z - translation.Z * l.X) > 
		boxAHalfSize.X * math.abs(l.Z) + 
			boxAHalfSize.Z * math.abs(l.X) + 
			boxBHalfSize.X * math.abs(u.Y) + 
			boxBHalfSize.Y * math.abs(r.Y) then
		return false
	end

	-- Z axis of boxA crossed with each axis of boxB
	if math.abs(translation.Y * r.X - translation.X * r.Y) > 
		boxAHalfSize.X * math.abs(r.Y) + 
			boxAHalfSize.Y * math.abs(r.X) + 
			boxBHalfSize.Y * math.abs(l.Z) + 
			boxBHalfSize.Z * math.abs(u.Z) then
		return false
	end

	if math.abs(translation.Y * u.X - translation.X * u.Y) > 
		boxAHalfSize.X * math.abs(u.Y) + 
			boxAHalfSize.Y * math.abs(u.X) + 
			boxBHalfSize.X * math.abs(l.Z) + 
			boxBHalfSize.Z * math.abs(r.Z) then
		return false
	end

	if math.abs(translation.Y * l.X - translation.X * l.Y) > 
		boxAHalfSize.X * math.abs(l.Y) + 
			boxAHalfSize.Y * math.abs(l.X) + 
			boxBHalfSize.X * math.abs(u.Z) + 
			boxBHalfSize.Y * math.abs(r.Z) then
		return false
	end

	-- If no separating axis was found, the boxes intersect
	return true
end

function Geometry.doesBoxIntersectSphere(
	spherePos: vector,
	radius: number,
	boxCFrame: CFrame,
	boxSize: vector
): boolean
	local localSpherePos = boxCFrame:PointToObjectSpace(spherePos)
	local boxHalfSize = boxSize/2
	local closestPoint = Vector3.new(
		math.clamp(localSpherePos.X, -boxHalfSize.X, boxHalfSize.X),
		math.clamp(localSpherePos.Y, -boxHalfSize.Y, boxHalfSize.Y),
		math.clamp(localSpherePos.Z, -boxHalfSize.Z, boxHalfSize.Z)
	)
	
	local distance = magn(localSpherePos - closestPoint)
	return distance <= radius
end

function Geometry.isPointInShape(point: vector, part: Part)
	local shapecheck = PointInShapeFns[part.Shape.Name]
	if not shapecheck then
		error(`Shape check function not found for {part}`)
	end

	return shapecheck(point, part)
end

function Geometry.isBoxInShape(cframe: CFrame, size: vector, part: Part)
	local shapecheck = BoxInShapeFns[part.Shape.Name]
	if not shapecheck then
		error(`Shape check function not found for {part}`)
	end
	
	return shapecheck(cframe, size, part)
end

function Geometry.getBoundingBox(points: {vector}): (CFrame, vector)
	if #points == 0 then
		error("The points array cannot be empty.")
	end

	-- Initialize min and max with the first point
	local minX, minY, minZ = points[1].X, points[1].Y, points[1].Z
	local maxX, maxY, maxZ = points[1].X, points[1].Y, points[1].Z

	for _, point in points do
		minX = math.min(minX, point.X)
		minY = math.min(minY, point.Y)
		minZ = math.min(minZ, point.Z)

		maxX = math.max(maxX, point.X)
		maxY = math.max(maxY, point.Y)
		maxZ = math.max(maxZ, point.Z)
	end
	
	local center = vector.create(
		(minX + maxX) / 2,
		(minY + maxY) / 2,
		(minZ + maxZ) / 2
	)
	
	local size = vector.create(
		maxX - minX,
		maxY - minY,
		maxZ - minZ
	)
	
	return CFrame.new(center), size
end

function Geometry.getRandomPointInSimplex(RANDOM_POINT_DIMENSION, points)
	if #points < 2 then
		error("Not enough points to form a simplex.")
	end

	local selectedVertices = {}
	local indices = {}
	local weights = {}
	local totalWeight = 0

	while #selectedVertices < RANDOM_POINT_DIMENSION + 1 do
		local index = math.random(1, #points)
		if indices[index] then continue end

		local point = points[index]
		selectedVertices[#selectedVertices + 1] = point
		indices[index] = true

		-- Generate and accumulate random weight
		local weight = math.random()
		weights[#weights + 1] = weight
		totalWeight += weight
	end

	-- Compute the random point as a weighted sum of the selected points
	local randomPoint = vector.zero
	for i = 1, RANDOM_POINT_DIMENSION + 1 do
		randomPoint = randomPoint + selectedVertices[i] * (weights[i] / totalWeight)
	end

	return randomPoint
end

function Geometry.isPointInTetrahedron(p: vector, a: vector, b: vector, c: vector, d: vector)
	local pa = p - a
	local pb = p - b

	local ca = c - a
	local ba = b - a
	local da = d - a
	local cb = c - b
	local db = d - b

	local n1 = cross(ba, ca)
	local n2 = cross(ba, da)
	local n3 = cross(ca, da)
	local n4 = cross(cb, db)

	local g = (a + b + c + d) / 4

	local ga = g - a
	local gb = g - b

	local alpha1 = dot(ga, n1)
	local alpha2 = dot(ga, n2)
	local alpha3 = dot(ga, n3)
	local alpha4 = dot(gb, n4)

	if alpha1 > 0 then
		n1 = -n1
	end
	if alpha2 > 0 then
		n2 = -n2
	end
	if alpha3 > 0 then
		n3 = -n3
	end
	if alpha4 > 0 then
		n4 = -n4
	end

	-- Compute dot products for the point p with the normals
	local beta1 = dot(pa, n1)
	local beta2 = dot(pa, n2)
	local beta3 = dot(pa, n3)
	local beta4 = dot(pb, n4)

	return beta1 < 0 and beta2 < 0 and beta3 < 0 and beta4 < 0
end

function Geometry.generateTetrahedrons(points)
	local tetrahedrons = {}
	
	-- Use the first point as a reference to create tetrahedrons
	local basePoint = points[1]
	for i = 2, #points - 2 do
		for j = i + 1, #points - 1 do
			for k = j + 1, #points do
				local a, b, c = points[i], points[j], points[k]

				if isCollinear(basePoint, a, b, c) then
					continue
				end

				table.insert(tetrahedrons, { basePoint, a, b, c })
			end
		end
	end

	return tetrahedrons
end

function Geometry.getBoxesVerticesForParts(Vertices, parts: {Part})
	local boxes = {}
	local points = {}
	local partToPointIndex = {}

	for _, part in parts do
		if not part:IsA("Part") then
			error("PartsZone.new() must be fed a pure array of parts.")
		end

		local shape = part.Shape.Name
		local vget = Vertices[shape]

		if not vget then
			error(`Shape {shape} could not be converted into points.`)
		end

		local vgroup = vget(part)
		
		table.insert(points, vgroup)
		table.insert(partToPointIndex, part)

		table.insert(boxes, {
			cframe = part.CFrame,
			size = part.ExtentsSize,
			part = part,
		})
	end

	return boxes, points, partToPointIndex
end

function Geometry.isPointInBox(cframe: CFrame, size: vector, point: vector)
	local halfSize = size / 2
	local localPoint = cframe:PointToObjectSpace(point)

	local withinX = math.abs(localPoint.X) <= halfSize.X
	local withinY = math.abs(localPoint.Y) <= halfSize.Y
	local withinZ = math.abs(localPoint.Z) <= halfSize.Z
	
	return withinX and withinY and withinZ
end

local function isPointInBoxWithHalfSize(point, boxCFrame, halfSize)
	local localPoint = boxCFrame:PointToObjectSpace(point)

	return math.abs(localPoint.X) <= halfSize.X and
		math.abs(localPoint.Y) <= halfSize.Y and
		math.abs(localPoint.Z) <= halfSize.Z
end

function Geometry.areAnyItemPointsInBox(world: {Instance}, boxCFrame: CFrame, boxSize: vector): boolean
	local halfSize = boxSize/2

	for _, item in world do
		if not isPointInBoxWithHalfSize(item.Position, boxCFrame, halfSize) then continue end

		return true
	end
	return false
end

return Geometry]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042e0</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXA2079607AA054A4D847871BEBABE519B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c45</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Vertices</string>
									<string name="ScriptGuid">{5B20B255-221A-49DB-BCBB-8689345F8751}</string>
									<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native

return {
	Block = function(part: Part)
		local pos = part.Position
		local cf = part.CFrame
		local size = part.Size

		local s2 = size/2

		local xvec = cf.XVector.Unit * s2.X
		local yvec = cf.YVector.Unit * s2.Y
		local zvec = cf.ZVector.Unit * s2.Z

		-- Define vertices (just position calculations)
		local a = pos + xvec + yvec + zvec
		local b = pos + xvec + yvec - zvec
		local c = pos + xvec - yvec + zvec
		local d = pos + xvec - yvec - zvec
		local e = pos - xvec + yvec + zvec
		local f = pos - xvec + yvec - zvec
		local g = pos - xvec - yvec + zvec
		local h = pos - xvec - yvec - zvec

		return {a, b, c, d, e, f, g, h}
	end,
	Wedge = function(part: Part)
		local pos = part.Position
		local cf = part.CFrame
		local size = part.Size

		local s2 = size / 2

		local xvec = cf.XVector.Unit * s2.X
		local yvec = cf.YVector.Unit * s2.Y
		local zvec = cf.ZVector.Unit * s2.Z

		-- Backwards, right, up
		local a = pos + xvec + zvec + yvec
		-- Backwards, left, up
		local b = pos - xvec + zvec + yvec
		-- Backwards, right, down
		local c = pos + xvec + zvec - yvec
		-- Backwards, left, down
		local d = pos - xvec + zvec - yvec
		-- Forwards, right, down
		local e = pos + xvec - zvec - yvec
		-- Forwards, left, down
		local f = pos - xvec - zvec - yvec
		
		return {a, b, c, d, e, f}
	end,
	CornerWedge = function(part: Part)
		local pos = part.Position
		local cf = part.CFrame
		local size = part.Size

		local s2 = size / 2

		local xvec = cf.XVector.Unit * s2.X
		local yvec = cf.YVector.Unit * s2.Y
		local zvec = cf.ZVector.Unit * s2.Z
		
		-- Forwards, right, up
		local a = pos + xvec - zvec + yvec
		-- Forwards, right, down
		local b = pos + xvec - zvec - yvec
		-- Forwards, left, down
		local c = pos - xvec - zvec - yvec
		-- Backwards, right, down
		local d = pos + xvec + zvec - yvec
		-- Backwards, left, down
		local e = pos - xvec + zvec - yvec
		
		return {a, b, c, d, e}
	end,
	Cylinder = function(part: Part)
		local pos = part.Position
		local cf = part.CFrame
		local size = part.ExtentsSize

		-- Correct height and radius calculations based on the part size
		local height = size.X  -- Height is the X dimension (side-facing)
		local radius = size.Y / 2  -- Radius is half of the Y dimension

		-- Calculate the top and bottom centers based on the part's orientation
		local topCenter = pos + cf.XVector * height / 2  -- Top center is above the part by half the height
		local bottomCenter = pos - cf.XVector * height / 2  -- Bottom center is below the part by half the height

		-- Number of vertices around the circumference
		local numVertices = 8  -- You can adjust this for more/less vertices

		local vertices = {}

		-- Create top circle vertices
		for i = 0, numVertices - 1 do
			local angle = (i / numVertices) * math.pi * 2
			local x = math.cos(angle) * radius
			local z = math.sin(angle) * radius
			-- Position the top circle vertices around the XZ plane, based on the cylinder's orientation
			local topVertex = topCenter + cf.ZVector * z + cf.YVector * x
			table.insert(vertices, topVertex)
		end

		-- Create bottom circle vertices
		for i = 0, numVertices - 1 do
			local angle = (i / numVertices) * math.pi * 2
			local x = math.cos(angle) * radius
			local z = math.sin(angle) * radius
			-- Position the bottom circle vertices around the XZ plane, based on the cylinder's orientation
			local bottomVertex = bottomCenter + cf.ZVector * z + cf.YVector * x
			table.insert(vertices, bottomVertex)
		end

		return vertices
	end,
	Ball = function(part: Part)
		local pos = part.Position
		local cf = part.CFrame
		local size = part.ExtentsSize

		local radius = size.X / 2
		
		local numSlices = 8
		local numStacks = 4

		local vertices = {}
		
		for stack = 0, numStacks do
			local phi = math.pi * (stack / numStacks)
			local y = math.cos(phi) * radius
			local ringRadius = math.sin(phi) * radius

			for slice = 0, numSlices - 1 do
				local theta = 2 * math.pi * (slice / numSlices)
				local x = math.cos(theta) * ringRadius
				local z = math.sin(theta) * ringRadius
				
				local vertex = pos + cf.XVector * x + cf.YVector * y + cf.ZVector * z
				table.insert(vertices, vertex)
			end
		end

		return vertices
	end,
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042e1</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX389A7CE0C00442EF981DCCC8F311C013">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c46</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">BVH</string>
									<string name="ScriptGuid">{AC5F251D-234F-474C-B71B-D9DA7F3D62ED}</string>
									<ProtectedString name="Source"><![CDATA[--!optimize 2
--!strict
--!native

--[[
	Utility module to create a Bounding Volume Hierarchy
	from an array of boxes.
]]

local getBoundingBoxFromBoxes = require(script.Parent.Parent.SimpleZone.Utility.getBoundingBoxFromBoxes)

export type Box = {
	cframe: CFrame, 
	size: vector,
	part: BasePart?
}

export type BoxNode = {
	cframe: CFrame,
	size: vector,
	left: BoxNode?,
	right: BoxNode?,
	part: BasePart?
}

local cfget: (cf: CFrame, prop: string) -> any do
	xpcall(function()
		return (CFrame.identity::any)[""]
	end, function()
		cfget = debug.info(2, "f")
	end)
end

local function traverseBVH(root: BoxNode, callback: (box: BoxNode, stop: () -> ()) -> boolean)
	local stack = {root}
	local stackSize = 1
	local stopFlag = false

	local function stop()
		table.clear(stack)
		stopFlag = true
	end
	
	while stackSize > 0 do
		local node = table.remove(stack)
		if not node then break end
		stackSize -= 1
		
		local shouldContinue = callback(node, stop)
		if not shouldContinue then continue	end
		if stopFlag then break end

		if node.right then
			stackSize += 1
			stack[stackSize] = node.right
		end
		
		if node.left then
			stackSize += 1
			stack[stackSize] = node.left
		end
	end
end

local function determine(parent: BoxNode, name: string, boxes: {Box})
	if #boxes > 1 then
		local cframe, size = getBoundingBoxFromBoxes(boxes)
		parent[name] = {
			cframe = cframe,
			size = size,
			--volume = size.x * size.y * size.z
		}

		split(parent[name], boxes)
	elseif #boxes == 1 then
		local box = boxes[1]
		parent[name] = {
			cframe = box.cframe,
			size = box.size,
			--volume = box.size.x * box.size.y * box.size.z,
			part = box.part,
		}
	end
end

function split(parent: BoxNode, boxes: {Box})
	local size = parent.size
	local longestAxis

	if size.x >= size.y and size.x >= size.z then
		longestAxis = "X"
	elseif size.y >= size.x and size.y >= size.z then
		longestAxis = "Y"
	elseif size.z >= size.y and size.z >= size.x then
		longestAxis = "Z"
	end
	
	table.sort(boxes, function(a, b)
		return cfget(a.cframe, longestAxis) < cfget(b.cframe, longestAxis)
	end)

	local len = #boxes
	local mid = len//2

	local leftBoxes = table.create(mid)
	local rightBoxes = table.create(mid)
	table.move(boxes, 1, mid, 1, leftBoxes)
	table.move(boxes, mid + 1, len, 1, rightBoxes)

	determine(parent, "left", leftBoxes)
	determine(parent, "right", rightBoxes)
end

local function createBVH(boxes: {Box}): (BoxNode)
	if #boxes == 0 then
		return {
			cframe = CFrame.new(0, 0, 0),
			size = vector.create(0, 0, 0)
		}
	end

	local cframe, size = getBoundingBoxFromBoxes(boxes)

	local root = {
		cframe = cframe,
		size = size
	}

	split(root, boxes)

	return root
end

local function needsUpdate(oldBox: Box, newBox: Box, threshold: number)
	-- Check if the box has moved significantly
	local distance = vector.magnitude((oldBox.cframe.Position - newBox.cframe.Position)::any)
	local sizeChange = vector.magnitude(oldBox.size - newBox.size)

	-- Update if position changed more than threshold or size changed significantly
	return distance > threshold or sizeChange > threshold
end

local function updateBVHNode(node: BoxNode?, oldBoxes: {Box}, newBoxes: {Box}, threshold: number)
	if not node then return false end
	
	-- Leaf node
	if node.part then
		local oldBox = {
			cframe = node.cframe,
			size = node.size,
			--volume = node.volume,
			part = node.part
		}

		-- Find corresponding new box
		local newBox
		for _, box in newBoxes do
			if box.part == node.part then
				newBox = box
				break
			end
		end

		-- If part found and needs update
		if newBox and needsUpdate(oldBox, newBox, threshold) then
			node.cframe = newBox.cframe
			node.size = newBox.size
			--node.volume = newBox.volume
			return true
		end
		return false
	end

	-- Internal node
	local leftUpdated = updateBVHNode(node.left, oldBoxes, newBoxes, threshold)
	local rightUpdated = updateBVHNode(node.right, oldBoxes, newBoxes, threshold)

	-- If either child updated, recalculate bounds
	if leftUpdated or rightUpdated then
		-- Get combined bounds of children
		local leftBounds = node.left and {
			cframe = node.left.cframe,
			size = node.left.size,
			--volume = node.left.volume
		}
		local rightBounds = node.right and {
			cframe = node.right.cframe,
			size = node.right.size,
			--volume = node.right.volume
		}

		if leftBounds and rightBounds then
			local leftPos: vector = leftBounds.cframe.Position :: any
			local rightPos: vector = rightBounds.cframe.Position :: any
			
			local minBounds = vector.create(
				math.min(leftPos.x - leftBounds.size.x/2, rightPos.x - rightBounds.size.x/2),
				math.min(leftPos.y - leftBounds.size.y/2, rightPos.y - rightBounds.size.y/2),
				math.min(leftPos.z - leftBounds.size.z/2, rightPos.z - rightBounds.size.z/2)
			)

			local maxBounds = vector.create(
				math.max(leftPos.x + leftBounds.size.x/2, rightPos.x + rightBounds.size.x/2),
				math.max(leftPos.y + leftBounds.size.y/2, rightPos.y + rightBounds.size.y/2),
				math.max(leftPos.z + leftBounds.size.z/2, rightPos.z + rightBounds.size.z/2)
			)
			local size = maxBounds - minBounds
			local center = (minBounds + maxBounds) / 2

			node.cframe = CFrame.new(center::any)
			node.size = size
			--node.volume = size.x * size.y * size.z
		elseif leftBounds then
			node.cframe = leftBounds.cframe
			node.size = leftBounds.size
			--node.volume = leftBounds.volume
		elseif rightBounds then
			node.cframe = rightBounds.cframe
			node.size = rightBounds.size
			--node.volume = rightBounds.volume
		end

		return true
	end

	return false
end

local function updateBVH(bvh: BoxNode, oldBoxes: {Box}, newBoxes: {Box}, threshold: number?)
	local threshold = threshold or 0.1
	
	if bvh.size == vector.zero and #newBoxes > 0 then
		local newBVH = createBVH(newBoxes)
		bvh.cframe = newBVH.cframe
		bvh.size = newBVH.size
		bvh.left = newBVH.left
		bvh.right = newBVH.right

		return true, bvh
	end
	
	local success = updateBVHNode(bvh, oldBoxes, newBoxes, threshold)
	return success, bvh
end

local function visualize(bvh)
	traverseBVH(bvh, function(box)
		local part = Instance.new("Part")
		part.Anchored = true
		part.Transparency = 0.9
		part.CastShadow = false
		part.CFrame = box.cframe
		part.Size = box.size::any
		part.Parent = workspace

		part.CanCollide = false
		part.CanQuery = false

		if not box.right and not box.left then
			part.Color = Color3.fromRGB(255, 0, 0)
		end

		return true
	end)
end

return {
	createBVH = createBVH,
	traverseBVH = traverseBVH,
	updateBVH = updateBVH,
	visualize = visualize,
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042e2</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX2B480B0FB972463D85B637129DAF5A6E">
							<Properties>
								<BinaryString name="AttributesSerialize">AQAAABsAAABDbGllbnRPbmx5RGV0ZWN0TG9jYWxQbGF5ZXIDAQ==</BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c47</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SimpleZone</string>
								<string name="ScriptGuid">{CFF071F2-49E7-4ED9-BBAD-9F067A754196}</string>
								<ProtectedString name="Source"><![CDATA[--!optimize 2
--!strict
--?module-ancestors {script, script.Utility}

--[[
	Zone Module (open source ver 2)
	
	Author: athar_adv
]]

local RunService 			= game:GetService('RunService')
local Players 				= game:GetService('Players')
local ServerStorage			= game:GetService('ServerStorage')
local ReplicatedStorage		= game:GetService('ReplicatedStorage')

local IS_CLIENT				= RunService:IsClient()

local utility				= script.Utility
local templates				= script.Templates

local Signal 				= require(utility.SimpleSignal)
local t						= require(utility.t)
local UtilityFunctions		= require(utility.UtilityFunctions)
local getBoundingBox		= require(utility.getBoundingBoxFromBoxes)

local SearchFor 			= require(script.SearchFor)
local Tracker				= require(script.Tracker)
local Zones					= require(script.Zones)

local characterObjects		= Tracker.characterObjects

local t_assert				= t.t_assert

local updateClassStorage	= UtilityFunctions.updateClassStorage
local copyToQuerySpace		= UtilityFunctions.copyToQuerySpace
local removeFromQuerySpace	= UtilityFunctions.removeFromQuerySpace
local T_TYPES				= UtilityFunctions.TTypes

local getBoxesFromParts		= UtilityFunctions.getBoxesFromParts

local workerTemplate		= IS_CLIENT and templates.ClientWorker or templates.ServerWorker

export type Metadata  = {[any]: any}
export type QueryOptions = {
	FireMode: "OnEnter"|"OnExit"|"Both"|"None",
	TrackItemEnabled: boolean,
	StoreByClass: boolean,
	AcceptMetadata: boolean,
	UpdateInterval: number,
	InSeperateQuerySpace: boolean,
	Static: boolean,
	QuerySpace: {
		Space: QuerySpace,
		World: WorldRoot
	}?
}

export type Box = {
	cframe: CFrame,
	size: Vector3
}
export type QuerySpace = {
	dynamic: {
		index: {BasePart},
		replicas: {BasePart}
	},

	static: {
		index: {BasePart},
		replicas: {BasePart}
	}
}
export type QueryInfo = {
	QueryParams: OverlapParams | (zone: Zone) -> OverlapParams, 
	QueryOptions: QueryOptions
}

local PART_WHITELIST = {
	Shape = true
}
local PART_BLACKLIST = {
	CFrame = true,
	Position = true,
	Orientation = true
}

-- A folder to store actors
local actorContainer	= Instance.new("Folder")
actorContainer.Name		= "SimpleZoneActors"
actorContainer.Parent 	= IS_CLIENT and Players.LocalPlayer.PlayerScripts or ServerStorage

-- A folder to store WorldModels
local worldContainer			= Instance.new("Folder")
worldContainer.Name		= `SimpleZoneQuerySpaces({IS_CLIENT and "Client" or "Server"})`
worldContainer.Parent	= IS_CLIENT and ReplicatedStorage or ServerStorage

local PartQueryJumpTable: {[string]: (_: WorldRoot, _: BasePart, _: OverlapParams?) -> {BasePart}} = {
	Block = function(worldModel, part, params)
		debug.profilebegin("INDEX_SIZE")
		local result = worldModel:GetPartBoundsInBox(part.CFrame, part.Size, params)
		debug.profileend()
		return result
	end,
	Ball = function(worldModel, part, params)
		return worldModel:GetPartBoundsInRadius(part.Position, part.ExtentsSize.Y, params)
	end
}

-- Create a new <code>QueryOptions</code> object.
local function queryop_new(): QueryOptions
	return {
		FireMode = "Both",
		TrackItemEnabled = false,
		StoreByClass = false,
		AcceptMetadata = false,
		UpdateInterval = 0,
		InSeperateQuerySpace = false,
		Static = true,
	}
end

local function assertQueryOp(queryOp: QueryOptions)
	t_assert("queryOp", queryOp, UtilityFunctions.QueryOptionsValidator, "QueryOptions")
end

local function getTracked(self: Zone, item): any
	for v in self.Tracked do
		if item:IsDescendantOf(v) then
			return v
		end
	end
	return nil
end

local function getItem(self: Zone, data: any): (any, Player?)
	local querySpace = self.QuerySpace
	local queryOptions = self.QueryOptions
	
	local item: any = (typeof(data) == "table" and queryOptions.AcceptMetadata) and data.item or data
	if querySpace ~= nil then
		local index = table.find(querySpace.dynamic.replicas, item)
		if index then
			item = querySpace.dynamic.index[index]
		end
	end
	
	return (queryOptions.TrackItemEnabled and getTracked(self, item)) or item, characterObjects[item]
end

local Zone = {}

--[[
	Updates the items of the <code>Zone</code> and fires events.
]]
function Zone.Update(self: Zone, params: OverlapParams?, onEnter: boolean?, onExit: boolean?): ()
	if type(self.Query) ~= "function" then
		self:UnbindFromHeartbeat()
		error(`Expected 'function' for Zone.Query, got '{typeof(self.Query)}'`)
	end
	
	local datas = self:Query(params)
	if typeof(datas) ~= "table" then
		self:UnbindFromHeartbeat()
		error(`Expected '\{any\}' for the ReturnType of Zone.Query, got '{typeof(datas)}'`)
	end
	
	local queryOptions = self.QueryOptions
	local storeByClass = queryOptions.StoreByClass
	local acceptMetadata = queryOptions.AcceptMetadata
	
	local lookup = {}
	local plrlookup = {}
	
	for _, data in datas do
		if lookup[data] then continue end
		local item, plr = getItem(self, data)
		-- As of version 157, the player and body parts are now seperated so they can be detected individually
		if plr and not plrlookup[plr] then
			plrlookup[plr] = true
			table.insert(datas, plr)
		end
		
		if lookup[item] then continue end
		lookup[item] = true

		if self.Items[item] then continue end
		
		local isTable = typeof(data) == "table"
		local metadata = isTable and data.metadata or true
		
		self.Items[item] = acceptMetadata and metadata or true
		
		if storeByClass then
			updateClassStorage(self, item, true)
		end
		if not onEnter then continue end
		
		self.ItemEntered:Fire(item, 
			if acceptMetadata and isTable then metadata else nil
		)
	end
	for item, metadata in self.Items do
		if lookup[item] then continue end
		local metadata = self.Items[item]
		self.Items[item] = nil
		
		if storeByClass then
			updateClassStorage(self, item, false)
		end
		if not onExit then continue end
		local isTable = type(metadata) == "table"
		
		self.ItemExited:Fire(item, 
			if acceptMetadata and isTable then metadata :: {[any]: any} else nil
		)
	end
end

--[[
	Stops the automatic query of the <code>Zone</code>.
]]
function Zone.UnbindFromHeartbeat(self: Zone): ()
	Zones.deregisterZone(self)
	table.clear(self.Items)
end

--[[
	(<strong>IMPORTANT</strong>)
	Starts the automatic query of the <code>Zone</code>.
	If <code>params</code> is provided, then all queries will be done using it.
	Otherwise, a function returning an <code>OverlapParams</code> to include all player characters will be used instead.
	Returns the <code>QueryInfo</code> which is used when querying the <code>Zone</code>.
]]
function Zone.BindToHeartbeat(self: Zone, params: (OverlapParams | (zone: Zone) -> OverlapParams)?): QueryInfo
	assert(params == nil or typeof(params) == "OverlapParams" or type(params) == "function", "params must be OverlapParams, function or nothing.")
	self:UnbindFromHeartbeat()
	
	local tbl = {
		QueryParams = params or UtilityFunctions.defaultParamGenerator,
		QueryOptions = self.QueryOptions
	} :: QueryInfo
	
	Zones.registerZone(self, tbl)
	
	return tbl
end

--[[
	If a descendant of <code>item</code> is found during query, <code>item</code> is returned instead of the descendant.
]]
function Zone.TrackItem(self: Zone, item: Instance): ()
	assert(typeof(item) == "Instance", `Bad item argument: {item} must be an instance.`)
	
	local trackItemEnabled = self.QueryOptions.TrackItemEnabled
	if not trackItemEnabled then
		warn("TrackItemEnabled is not enabled, cannot call Zone:TrackItem(...)")
		return
	end
	if self.Tracked[item] then
		warn(`Item {item} is already being tracked.`)
		return
	end
	self.Tracked[item] = true
	
	local connections = self.TrackerConnections
	connections[item] = item.Destroying:Once(function()
		connections[item] = nil
		self:UntrackItem(item)
	end)
end

--[[
	Untracks an item tracked by <code>Zone:TrackItem(...)</code>.
]]
function Zone.UntrackItem(self: Zone, item: Instance): ()
	assert(typeof(item) == "Instance", `Bad item argument: {item} must be an instance.`)
	
	if not self.Tracked[item] then
		warn(`Item {item} is not currently being tracked.`)
		return
	end
	self.Tracked[item] = nil
	
	local connections = self.TrackerConnections
	if connections[item] then
		connections[item]:Disconnect()
		connections[item] = nil
	end
end

--[[
	Gets all items contained within the zone which are of <code>class</code> class/type.
]]
function Zone.GetItemsWhichAreA(self: Zone, class: string): {any}
	assert(typeof(class) == "string", "Bad class argument: class must be a string.")
	
	if not self.QueryOptions.StoreByClass then
		warn("StoreByClass is not enabled, cannot call Zone:GetItemsWhichAreA(...)")
		return {}
	end
	
	return self.StoredClasses[class] or {}
end

--[[
	Queries the <code>Zone</code> for <code>Instance</code>s with the specified properties.
	
	If <code>mode</code> is <code>"And"</code>, then it will only return <code>Instance</code>s that fully match the properties.
	Else if <code>mode</code> is <code>"Or"</code>, then it will return <code>Instance</code>s that match atleast one of the properties.
]]
function Zone.SearchFor(self: Zone, properties: {{Name: string, Value: any, Type: ("Attribute" | "Tag")?}}, mode: "And" | "Or"): {BasePart}?
	t_assert("properties", properties, t.array(t.interface {
		Name = t.string,
		Value = t.optional(t.any),
		Type = t.optional(t.string)
	}) "{| {Name: string, Value: any, Type: 'Tag' | 'Attribute'} |}")
	t_assert("mode", mode, t.union(t.literal("And"), t.literal("Or")))
	assert(type(self.Query) == "function", `Expected 'function' for Zone.Query, got '{typeof(self.Query)}'`)
	
	local parts = self:Query()
	
	return SearchFor(
		parts,
		properties,
		mode
	)
end

type ListenerDatatype =  
	| string 
	| "LocalPlayer" 
	| "Player" 
	| "BasePart"
	| "BodyPart"

--[[
	Calls <code>fn</code> when an item of class <code>datatype</code> enters/exits the <code>Zone</code>.
]]
function Zone.ListenTo(self: Zone, datatype: ListenerDatatype, mode: "Entered"|"Exited", fn: (item: Instance, metadata: Metadata?) -> ()): RBXScriptConnection
	if datatype == "LocalPlayer" and not IS_CLIENT then
		error("Can only listen to LocalPlayer on the client.")
	end
	t_assert("datatype", datatype, "string")
	t_assert("mode", mode, t.union(t.literal("Entered"), t.literal("Exited")), "'Entered' | 'Exited'")
	t_assert("fn", fn, "callback")
	
	return self[`Item{mode}`]:Connect(function(item: Instance, metadata: Metadata?)
		if datatype ~= "LocalPlayer" and datatype ~= "BodyPart" then
			if not item:IsA(datatype) then return end
		elseif datatype == "LocalPlayer" then
			if item ~= Players.LocalPlayer then return end
		elseif datatype == "BodyPart" then
			if item.Parent and not item.Parent:FindFirstChildWhichIsA("Humanoid") then return end
		end

		fn(item, metadata)
	end)
end

--[[
	Copies an array of <code>BaseParts</code> to be replicated inside the query space. Returns the replicas
]]
function Zone.CopyToQuerySpace(self: Zone, parts: {BasePart}, static: boolean?, propertyReplicationWhitelist: {[string]: boolean}?): {BasePart}
	assert(self.QueryOptions.InSeperateQuerySpace, "InSeperateQuerySpace is not enabled")
	t_assert("parts", parts, T_TYPES.instArray, "{Instance}")
	t_assert("static", static, t.optional(t.boolean), "boolean?")
	t_assert("propertyReplicationWhitelist", propertyReplicationWhitelist, t.optional(t.map(t.string, t.boolean)), "{[string]: boolean}?")

	local returnedReplicas = table.create(#parts)
	for _, part in parts do
		copyToQuerySpace(self, part, static, propertyReplicationWhitelist, PART_BLACKLIST, returnedReplicas)
	end

	return returnedReplicas
end

--[[
	Removes all replicas of an array of <code>BaseParts</code> from the query space.
]]
function Zone.RemoveFromQuerySpace(self: Zone, originalParts: {BasePart}): ()
	assert(self.QueryOptions.InSeperateQuerySpace, "InSeperateQuerySpace is not enabled")
	t_assert("parts", originalParts, T_TYPES.instArray, "{Instance}")

	for _, part in originalParts do
		removeFromQuerySpace(self, part)
	end
end

--[[
	Gets all replicas of an array of <code>BaseParts</code>, optionally specifying if they are static or not so the function knows where to look.
]]
function Zone.GetReplicasOf(self: Zone, parts: {BasePart}, static: boolean?): {BasePart}
	assert(self.QueryOptions.InSeperateQuerySpace, "InSeperateQuerySpace is not enabled")
	t_assert("parts", parts, T_TYPES.instArray, "{Instance}")
	t_assert("static", static, t.optional(t.boolean), "boolean?")

	local querySpace = self.QuerySpace
	if not querySpace then return {} end
	local replicas = {}

	for i, part in parts do
		local zonePlace = static and querySpace.static or querySpace.dynamic
		local index = table.find(zonePlace.index, part)
		if index then
			table.insert(replicas, zonePlace.replicas[index])
		end
	end

	return replicas
end

--[[
	Makes this <code>Zone</code> use the query space of the <code>otherZone</code>, keeping the old one which can be restored by passing <code>otherZone</code> as "self".
]]
function Zone.UseQuerySpaceOf(self: Zone, otherZone: Zone | "self"): ()
	assert(self.QueryOptions.InSeperateQuerySpace, "InSeperateQuerySpace is not enabled")
	assert(otherZone ~= nil, "Bad otherZone argument")

	local queryOp = self.QueryOptions
	assert(not (not queryOp.InSeperateQuerySpace and otherZone == "self"), 
		"Cannot use query space of self because zone was not created in a seperate query space.")

	local querySpace, worldModel
	if otherZone == "self" then
		querySpace = self.OwnQuerySpace or self.QuerySpace
		worldModel = self.WorldRoot
	else
		querySpace = otherZone.QuerySpace
		worldModel = otherZone.WorldRoot
	end

	self.OwnQuerySpace = otherZone ~= "self" and self.QuerySpace or nil

	self.QuerySpace = querySpace
	self.WorldRoot = worldModel
end

--[[
	Overwrites this <code>Zone</code>s query space with the one of <code>otherZone</code>.
]]
function Zone.OverwriteQuerySpace(self: Zone, otherZone: Zone): ()
	assert(self.QueryOptions.InSeperateQuerySpace, "InSeperateQuerySpace is not enabled")
	assert(otherZone ~= nil, "Bad otherZone argument")

	local querySpace = self.QuerySpace
	if not querySpace then return end

	self:RemoveFromQuerySpace(querySpace.dynamic.index)
	self:RemoveFromQuerySpace(querySpace.static.index)
	self.WorldRoot:Destroy()

	self.QuerySpace = otherZone.QuerySpace
	self.WorldRoot = otherZone.WorldRoot
end

--[[
	Disconnects all connections related to this <code>Zone</code> and cleans up any associated <code>Instance</code> references.
]]
function Zone.Destroy(self: Zone): ()
	self:UnbindFromHeartbeat()
	
	local bin = self.Trash
	local tracked = self.TrackerConnections
	local replica = self.ReplicaConnections
	
	for _, v in bin do
		if typeof(v) == "Instance" then
			v:Destroy()
		elseif typeof(v) == "RBXScriptConnection" then
			v:Disconnect()
		end
	end
	for _, v in tracked do
		v:Disconnect()
	end
	for _, v in replica do
		for _, w in v do
			if not w then continue end
			w:Disconnect()
		end
	end
	
	task.defer(function()
		self.ItemEntered:Destroy()
		self.ItemExited:Destroy()
	end)
end

type ZoneImpl = {
	Query: typeof(
		--[[
			A replaceable callback function that the <code>Zone</code> calls whenever querying the <code>Zone</code>.
		]]
		function(self: Zone, params: OverlapParams?): {any}
			return {}
		end
	),
	
	TrackerConnections: {[any]: RBXScriptConnection},
	ReplicaConnections: {[any]: {RBXScriptConnection?}},

	Items: {[any]: boolean | Metadata},
	StoredClasses: {[string]: {any}},
	Tracked: {[any]: boolean},
	Trash: {any},
	
	QueryOptions: QueryOptions,
	QuerySpace: QuerySpace?,
	OwnQuerySpace: QuerySpace?,
	LastUpdate: number,

	WorldRoot: WorldRoot,

	ItemExited: Signal.RBXScriptSignal<Instance, Metadata?>,
	ItemEntered: Signal.RBXScriptSignal<Instance, Metadata?>
}

export type Zone = typeof(Zone) & ZoneImpl

local function zone_new<T>(queryOp: QueryOptions, ...)
	local bin = {...}
	local zone = {
		-- Tables with [Instance]: RBXScriptConnection pairs to track connections
		TrackerConnections	= {},
		ReplicaConnections	= {},
		
		-- Main
		Items 			= {},
		StoredClasses	= {},
		Tracked			= {},
		Trash			= bin,
		QueryOptions 	= queryOp,
		LastUpdate		= os.clock(),
		
		WorldRoot		= workspace,
		
		ItemEntered 	= Signal.new(),
		ItemExited 		= Signal.new(),
		
		Update 				= Zone.Update,
		BindToHeartbeat 	= Zone.BindToHeartbeat,
		UnbindFromHeartbeat = Zone.UnbindFromHeartbeat,
		TrackItem			= Zone.TrackItem,
		UntrackItem			= Zone.UntrackItem,
		GetItemsWhichAreA	= Zone.GetItemsWhichAreA,
		SearchFor			= Zone.SearchFor,
		ListenTo			= Zone.ListenTo,
		
		CopyToQuerySpace	= Zone.CopyToQuerySpace,
		RemoveFromQuerySpace= Zone.RemoveFromQuerySpace,
		GetReplicasOf		= Zone.GetReplicasOf,
		UseQuerySpaceOf		= Zone.UseQuerySpaceOf,
		OverwriteQuerySpace = Zone.OverwriteQuerySpace,
		
		Destroy				= Zone.Destroy
	} :: Zone
	
	if queryOp.InSeperateQuerySpace and queryOp.QuerySpace == nil then
		local model = Instance.new("WorldModel")
		model.Name = "SimpleZone_QuerySpace"
		model.Parent = worldContainer
		table.insert(bin, model)
		
		-- Internal query space
		zone.WorldRoot = model
		zone.QuerySpace = {
			dynamic = {
				index = {},
				replicas = {}
			},
			
			static = {
				index = {},
				replicas = {}
			},
		}
	elseif queryOp.QuerySpace ~= nil then
		assert(queryOp.QuerySpace.World ~= nil and queryOp.QuerySpace.Space ~= nil, "Missing world/space fields for QuerySpace")
		zone.WorldRoot = queryOp.QuerySpace.World
		zone.QuerySpace = queryOp.QuerySpace.Space
	end
	
	return zone
end

-- Creates a new <code>Zone</code> based on a <code>BasePart</code>.
local function zone_fromPart(part: BasePart, queryOp: QueryOptions?): Zone
	t_assert("part", part, t.instance("BasePart"), "BasePart")
	
	local queryOp = queryOp or queryop_new()
	assertQueryOp(queryOp)
	
	local zone = zone_new(queryOp)
	if queryOp.InSeperateQuerySpace then
		part = copyToQuerySpace(zone, part, queryOp.Static, PART_WHITELIST, PART_BLACKLIST)
	end
	
	function zone:Query(params)
		local worldModel = self.WorldRoot
		if part:IsA("Part") then
			local fn = PartQueryJumpTable[part.Shape.Name]
			return fn and fn(worldModel, part, params) or worldModel:GetPartsInPart(part, params)
		end
		
		return worldModel:GetPartsInPart(part, params)
	end
	
	return zone
end

-- Creates a new <code>Zone</code> based on an bounding box.
local function zone_fromBox(cframe: CFrame, size: Vector3, queryOp: QueryOptions?): Zone
	t_assert("cframe", cframe, "CFrame")
	t_assert("size", size, "vector")
	
	local queryOp = queryOp or queryop_new()
	assertQueryOp(queryOp)
	
	local zone = zone_new(queryOp)
	
	function zone:Query(params)
		return self.WorldRoot:GetPartBoundsInBox(cframe, size, params)
	end
	
	return zone
end

-- Creates a new <code>Zone</code> based on an array of bounding boxes.
local function zone_fromBoxes(boxes: {Box}, queryOp: QueryOptions?): Zone
	t_assert("boxes", boxes, T_TYPES.boxArray, "{Box}")
	
	local queryOp = queryOp or queryop_new()
	assertQueryOp(queryOp)
	
	local zone = zone_new(queryOp)
	
	function zone:Query(params)
		local queryOp = self.QueryOptions
		local querySpace = self.QuerySpace
		local worldModel = self.WorldRoot
		local result: any = {}
		
		for _, box in boxes do
			local query = worldModel:GetPartBoundsInBox(box.cframe, box.size::any, params)
			if #query == 0 then continue end
			
			if self.QueryOptions.AcceptMetadata then
				for _, item in query do
					table.insert(result, {item = item, metadata = {box = box}})
				end
			else
				table.move(query, 1, #query, #result + 1, result)
			end
		end

		return result
	end
	
	return zone
end

-- Creates a new <code>Zone</code> based on an array of <code>BaseParts</code>.
local function zone_fromParts(parts: {BasePart}, queryOp: QueryOptions?): Zone
	t_assert("parts", parts, T_TYPES.partArray, "{BasePart}")
	
	local queryOp = queryOp or queryop_new()
	assertQueryOp(queryOp)
	
	local boxes: {Box}
	
	local zone = zone_new(queryOp)
	if queryOp.InSeperateQuerySpace then
		local replicas = zone:CopyToQuerySpace(parts, queryOp.Static, PART_WHITELIST)
		boxes = getBoxesFromParts(replicas)
	else
		boxes = getBoxesFromParts(parts)
	end
	
	local cf, size = getBoundingBox(boxes)
	
	function zone:Query(params)
		debug.profilebegin("SimpleZone::FromParts")
		local querySpace = self.QuerySpace
		local queryOp = self.QueryOptions
		local worldModel = self.WorldRoot

		local zonePlace = if querySpace ~= nil then (queryOp.Static and querySpace.static or querySpace.dynamic) else nil
		local result: {any} = {}
		
		local wholeCheck = worldModel:GetPartBoundsInBox(cf, size::any, params)
		if #wholeCheck == 0 then
			debug.profileend()
			return result 
		end
		
		for _, part in parts do
			local query: {BasePart}
			if part:IsA("Part") then
				local fn = PartQueryJumpTable[part.Shape.Name]
				query = fn and fn(worldModel, part, params) or worldModel:GetPartsInPart(part, params)
			else
				query = worldModel:GetPartsInPart(part, params)
			end

			if queryOp.AcceptMetadata then
				if queryOp.InSeperateQuerySpace and zonePlace then
					local index = table.find(zonePlace.replicas, part)
					if index then
						part = zonePlace.index[index]
					end
				end
				
				for _, item in query do
					table.insert(result, {item = item, metadata = {part = part}})
				end
			else
				table.move(query, 1, #query, #result + 1, result)
			end
		end
		debug.profileend()

		return result
	end
	
	return zone
end

-- Creates a new <code>Zone</code> based on a <code>part</code>. Does queries in parallel.
local function zone_fromPartParallel(part: BasePart, queryOp: QueryOptions?): Zone
	t_assert("part", part, t.instance("BasePart"), "BasePart")
	
	local queryOp = queryOp or queryop_new()
	assertQueryOp(queryOp)
	
	local worker = workerTemplate:Clone()
	worker.Parent = actorContainer

	local resultEvent = worker.Result

	local zone = zone_new(queryOp, worker)
	if queryOp.InSeperateQuerySpace then
		part = copyToQuerySpace(zone, part, queryOp.Static, PART_WHITELIST, PART_BLACKLIST)
	end
	
	function zone:Query(params)
		local worldModel = self.WorldRoot
		task.defer(worker.SendMessage, worker, "Query", worldModel, params, part)
		return resultEvent.Event:Wait()
	end
	
	return zone
end

-- Creates a new <code>Zone</code> using a custom query function <code>queryFn</code>.
local function zone_fromCustom(queryFn: (self: Zone, params: OverlapParams?) -> {{item: any, metadata: Metadata} | any | Instance}, queryOp: QueryOptions?): Zone
	assert(queryFn ~= nil, "Bad queryFn argument.")
	local queryOp = queryOp or queryop_new()
	assertQueryOp(queryOp)
	
	local zone = zone_new(queryOp)
	zone.Query = queryFn
	
	return zone
end

-- holy christ
local zone_new_overload: 
	typeof(zone_fromPart) & typeof(zone_fromBox) & typeof(zone_fromParts) & typeof(zone_fromBoxes) 
= function(a: {BasePart} | {Box} | CFrame | Instance, b: (QueryOptions | Vector3)?, c: QueryOptions?)
	
	if #(a::any) > 0 then
		if typeof((a :: {BasePart})[1]) == "Instance" and (a :: {BasePart})[1]:IsA("BasePart") then
			return zone_fromParts(a :: {BasePart}, b :: QueryOptions?)
		elseif typeof((a :: {Box})[1]) == "table" then
			return zone_fromBoxes(a :: {Box}, b :: QueryOptions?)
		else
			error("Unable to find an overload.")
		end
	end
	
	if typeof(a) == "CFrame" and typeof(b) == "Vector3" then
		return zone_fromBox(a, b, c)
	elseif typeof(a) == "Instance" and a:IsA("BasePart") then
		return zone_fromPart(a, b)
	else
		error("Unable to find an overload.")
	end
end

local lpOnly = script:GetAttribute("ClientOnlyDetectLocalPlayer")
if lpOnly and RunService:IsClient() then
	Tracker.onPlayerAdded(Players.LocalPlayer)
else
	Tracker.startPlayerTracking()
end
Tracker.startItemTracking()

return table.freeze {
	new = zone_new_overload,
	fromBox = zone_fromBox,
	fromPart = zone_fromPart,
	fromParts = zone_fromParts,
	fromBoxes = zone_fromBoxes,
	fromCustom = zone_fromCustom,
	fromPartParallel = zone_fromPartParallel,
	
	QueryOptions = {
		new = queryop_new
	}
}]]></ProtectedString>
								<int64 name="SourceAssetId">134706316606844</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042e3</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX7D91BE790CDC499DB96D8FC7208C9724">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c48</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SearchFor</string>
									<string name="ScriptGuid">{A94E011A-4EB3-4932-986D-41B979AE21C7}</string>
									<ProtectedString name="Source"><![CDATA[local function splitRecursiveProperty(name: string)
	local instanceSplit = name:split(".")
	
	name = instanceSplit[1]
	
	return name, #instanceSplit > 1 and table.concat(instanceSplit, ".", 2, #instanceSplit)
end

local function propertyChecker(part, mode, checkCondition, properties)
	for _, info in properties do
		local name = info.Name
		local value = info.Value
		local t = info.Type
		
		local name, recursiveProperty = splitRecursiveProperty(name)

		-- If a part contains a parent of the same name, it will recursively search that part until the last property is found (example, Foo_Parent_Parent_Name = "Bar")
		if name == "Parent" and recursiveProperty then
			local parts = SearchFor({part.Parent}, {{Name = recursiveProperty, Value = value, Type = t}}, mode)
			checkCondition(table.find(parts, part.Parent) ~= nil)
			continue
		end
		-- If a part contains a child of the same name, it will recursively search that part until the last property is found (example, Foo_Bar_Baz_Name = "Bar")
		if part:FindFirstChild(name) and recursiveProperty then
			local parts = SearchFor({part:FindFirstChild(name)}, {{Name = recursiveProperty, Value = value, Type = t}}, mode)
			checkCondition(table.find(parts, part.Parent) ~= nil)
			continue
		end
		if t == "Tag" then
			checkCondition(part:HasTag(name))
			continue
		end
		if t == "Attribute" then
			local condition = part:GetAttribute(name) == value

			checkCondition(condition)
			continue
		end
		checkCondition(part[name] == value)
	end
end

function SearchFor(tableToSort, properties: any, mode: "And" | "Or")
	assert(mode ~= nil and (mode == "Or" or mode == "And"), "Bad mode argument.")
	
	local qualifiedParts = {}

	for i, part: BasePart in tableToSort do
		local doesNotMatch = false
		
		local function checkCondition(condition: any)
			if condition and mode == "Or" then
				table.insert(qualifiedParts, part)
			elseif not condition and mode == "And" then
				doesNotMatch = true
			end
		end
		
		propertyChecker(part, mode, checkCondition, properties)

		if not doesNotMatch and mode == "And" then
			table.insert(qualifiedParts, part)
		end
	end
	
	return qualifiedParts
end

return SearchFor]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042e4</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX7356574CBC6D461AB102B59EF00632AF">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c50</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Zones</string>
									<string name="ScriptGuid">{077830E3-1E95-4964-BF45-EAABB007B4B1}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
--!optimize 2

local RunService = game:GetService('RunService')

local main = script.Parent

local Zones = {
	ActiveZones = {},
	TotalZoneVolume = 0,
}

function Zones.registerZone(zone: any, options: any)
	Zones.ActiveZones[zone] = options
end

function Zones.deregisterZone(zone: any)
	Zones.ActiveZones[zone] = nil
end

RunService.PostSimulation:Connect(function(dt)
	for zone, params in Zones.ActiveZones do
		local queryOp = params.QueryOptions
		
		local now = os.clock()
		if now - zone.LastUpdate < queryOp.UpdateInterval then
			continue
		end
		zone.LastUpdate = now
		
		local fmode = queryOp.FireMode
		local onEnter = (fmode == "OnEnter" or fmode == "Both") and (fmode::any) ~= "None"
		local onExit = (fmode == "OnExit" or fmode == "Both") and (fmode::any) ~= "None"
		
		if queryOp.InSeperateQuerySpace then
			local worldModel: WorldRoot = zone.WorldRoot
			local querySpace = zone.QuerySpace
			if not querySpace then warn("a") return end
			local dynamic = querySpace.dynamic
			
			local cframes = table.create(#dynamic.replicas)
			
			for index, part in dynamic.index do
				cframes[index] = part.CFrame
			end
			worldModel:BulkMoveTo(dynamic.replicas, cframes, Enum.BulkMoveMode.FireCFrameChanged)
		end
		
		local overlapParams
		local queryParams = params.QueryParams
		
		if typeof(queryParams) == "function" then
			overlapParams = queryParams(zone)
		else
			overlapParams = queryParams
		end
		zone:Update(overlapParams, onEnter, onExit)
	end
end)

return Zones]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042e5</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBEC7B9ACE36D4A8E8CEE09BC86BD52EC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c58</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Tracker</string>
									<string name="ScriptGuid">{B66D57EB-583B-47A9-A3D1-907E83EE8F0E}</string>
									<ProtectedString name="Source"><![CDATA[--!optimize 2
--!strict

local Players = game:GetService('Players')

local partToPlayer: {[BasePart]: Player} = {}
local connectionTracker: {[Player]: {RBXScriptConnection}} = {}
local characterAddedConnections: { [Player]: RBXScriptConnection } = {}
-- All items to be queried
local items: {BasePart} = {}
-- Cache part volume so we don't have to recompute it every time an instance is added/removed from the workspace
local itemVolumeMap: { [BasePart]: number } = {}
local itemIndex: { [BasePart]: number } = {}
local sizeChangedConnections: { [BasePart]: RBXScriptConnection } = {}
local canQueryConnections: { [BasePart]: RBXScriptConnection } = {}

local totalVolume = 0

local function computeVolume(part: BasePart): number
	local size = part.Size
	return size.X * size.Y * size.Z
end

local function addTrackedPart(part: BasePart, owner: Player?)
	if itemIndex[part] then
		return
	end
	
	local volume = computeVolume(part)
	itemVolumeMap[part] = volume
	totalVolume += volume
	
	local itemsLength = #items
	local newIndex = itemsLength + 1
	items[newIndex] = part
	itemIndex[part] = newIndex
	
	if owner then
		partToPlayer[part] = owner
	end
	
	sizeChangedConnections[part] = part:GetPropertyChangedSignal("Size"):Connect(function()
		local oldVolume = itemVolumeMap[part] or 0
		local newVolume = computeVolume(part)
		itemVolumeMap[part] = newVolume
		totalVolume += (newVolume - oldVolume)
	end)
end

local function removeTrackedPart(part: BasePart)
	-- ALWAYS clean up any potential connections
	local sizeConn = sizeChangedConnections[part]
	if sizeConn then
		sizeConn:Disconnect()
		sizeChangedConnections[part] = nil
	end
	local queryConn = canQueryConnections[part]
	if queryConn then
		queryConn:Disconnect()
		canQueryConnections[part] = nil
	end
	
	local index = itemIndex[part]
	if not index then
		return
	end
	
	totalVolume -= itemVolumeMap[part] or 0
	itemVolumeMap[part] = nil
	
	local itemsLength = #items
	local lastPart = items[itemsLength]
	items[index] = lastPart
	itemIndex[lastPart] = index
	
	items[itemsLength] = nil
	itemIndex[part] = nil
	partToPlayer[part] = nil
end

local function watchCanQuery(part: BasePart, owner: Player?)
	if canQueryConnections[part] then
		return
	end
	
	canQueryConnections[part] = part:GetPropertyChangedSignal("CanQuery"):Connect(function()
		if part.CanQuery then
			addTrackedPart(part, owner)
		else
			removeTrackedPart(part)
		end
	end)
end

local function handleCharacterUpdate(player: Player, character: Model)
	for _, v in connectionTracker[player] do
		v:Disconnect()
	end
	table.clear(connectionTracker[player])
	for part, owner in partToPlayer do
		if owner ~= player then continue end
		removeTrackedPart(part)
	end
	
	for _, descendant in character:GetDescendants() do
		if not descendant:IsA("BasePart") then continue end
		watchCanQuery(descendant, player)
		if descendant.CanQuery then
			addTrackedPart(descendant, player)
		end
	end
	
	table.insert(connectionTracker[player], character.DescendantAdded:Connect(function(descendant)
		if not descendant:IsA("BasePart") then return end
		watchCanQuery(descendant, player)
		if descendant.CanQuery then
			addTrackedPart(descendant, player)
		end
	end))
	
	table.insert(connectionTracker[player], character.DescendantRemoving:Connect(function(descendant)
		if not descendant:IsA("BasePart") then return end
		removeTrackedPart(descendant)
	end))
end

local function onPlayerAdded(player)
	connectionTracker[player] = {}
	
	characterAddedConnections[player] = player.CharacterAdded:Connect(function(character)
		handleCharacterUpdate(player, character)
	end)
	
	if player.Character then
		handleCharacterUpdate(player, player.Character)
	end
end

local function onPlayerRemoving(player)
	for _, v in connectionTracker[player] do
		v:Disconnect()
	end
	connectionTracker[player] = nil
	local connection = characterAddedConnections[player]
	if connection then
		connection:Disconnect()
		characterAddedConnections[player] = nil
	end
	
	for part, owner in partToPlayer do
		if owner ~= player then continue end
		removeTrackedPart(part)
	end
end

local function startPlayerTracking()
	local playerAdded = Players.PlayerAdded:Connect(onPlayerAdded)
	local playerRemoving = Players.PlayerRemoving:Connect(onPlayerRemoving)
	
	for _, player in Players:GetPlayers() do
		onPlayerAdded(player)
	end

	return playerAdded, playerRemoving
end

local function startItemTracking()
	workspace.DescendantAdded:Connect(function(descendant: BasePart)
		if not descendant:IsA("BasePart") then return end
		watchCanQuery(descendant)
		if descendant.CanQuery then
			addTrackedPart(descendant)
		end
	end)
	workspace.DescendantRemoving:Connect(function(descendant: BasePart)
		if not descendant:IsA("BasePart") then return end
		removeTrackedPart(descendant)
	end)
end

local function getTotalVolume()
	return totalVolume
end

return {
	characterObjects = partToPlayer,
	startPlayerTracking = startPlayerTracking,
	startItemTracking = startItemTracking,
	
	onPlayerAdded = onPlayerAdded,
	onPlayerRemoving = onPlayerRemoving,
	
	getTotalVolume = getTotalVolume,
	
	items = items
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042e6</UniqueId>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBX9F66C35E494C4962ABF39D92A0E8B9CD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c49</UniqueId>
									<string name="Name">Utility</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042e7</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXA6CFBBE5FCF74BAB9FAF08A557BD7F7E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c4a</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">UtilityFunctions</string>
										<string name="ScriptGuid">{34E062F8-4485-4D12-9402-667280ACAD24}</string>
										<ProtectedString name="Source"><![CDATA[--!optimize 2
--!strict

local Players = game:GetService("Players")

local t = require(script.Parent.t)

local QUERY_SPACE_VALIDATOR = t.interface {
	dynamic = t.interface {
		index = t.array(t.instance("BasePart")),
		replicas = t.array(t.instance("BasePart"))
	},

	static = t.interface {
		index = t.array(t.instance("BasePart")),
		replicas = t.array(t.instance("BasePart"))
	}
}
local QUERY_OPTIONS_VALIDATOR = t.interface {
	FireMode = t.union(
		t.literal("OnEnter"),
		t.literal("OnExit"),
		t.literal("Both"),
		t.literal("None")
	),
	TrackItemEnabled = t.boolean,
	StoreByClass = t.boolean,
	AcceptMetadata = t.boolean,
	UpdateInterval = t.number,
	InSeperateQuerySpace = t.boolean,
	Static = t.boolean,
	QuerySpace = t.optional(t.interface {
		Space = QUERY_SPACE_VALIDATOR,
		World = t.instance("WorldRoot")
	})
}

local T_TYPES = {
	boxArray = t.array(t.interface {
		cframe = t.CFrame,
		size = t.vector
	}),
	partArray = t.array(t.instance("BasePart")),
	instArray = t.array(t.Instance)
}

local rbxget: (inst: Instance, prop: string) -> any do
	xpcall(function()
		return game[""]
	end, function()
		rbxget = debug.info(2, "f")
	end)
end

local rbxset: (inst: Instance, prop: string, value: any) -> () do
	xpcall(function()
		game[""] = nil
	end, function()
		rbxset = debug.info(2, "f")
	end)
end

local function getParamsForPlayerCharacters(zone)
	local params = OverlapParams.new()
	params.FilterType = Enum.RaycastFilterType.Include

	local characters = {}
	for _, player in Players:GetPlayers() do
		if not player.Character then continue end
		table.insert(characters, player.Character)
		if zone.QueryOptions.InSeperateQuerySpace then
			local replicas = zone:GetReplicasOf(player.Character:GetChildren())
			table.move(replicas, 1, #replicas, #characters + 1, characters)
		end
	end

	params.FilterDescendantsInstances = characters
	return params
end

local function updateClassStorage(self: any, item, isEntering: boolean)
	local vtype = typeof(item)
	local class = vtype == "Instance" and item.ClassName or vtype

	if isEntering then
		-- Add item to class storage
		local classes = self.StoredClasses[class]
		if not classes then
			classes = {}
			self.StoredClasses[class] = classes
		end
		classes[#classes + 1] = item
	else
		-- Remove item from class storage
		local classes = self.StoredClasses[class]
		if classes then
			local index = table.find(classes, item)
			if index then
				table.remove(classes, index)
				if #classes == 0 then
					self.StoredClasses[class] = nil
				end
			end
		end
	end
end

local function removeFromQuerySpace(self: any, part: BasePart)
	if not part:IsA("BasePart") then return end
	local querySpace = self.QuerySpace
	if not querySpace then return end

	local connections = self.ReplicaConnections

	for _, c in connections[part] do
		if not c then continue end
		c:Disconnect()
	end

	local index: number?, tbl
	local staticIndex = table.find(querySpace.static.index, part)
	if staticIndex then
		index = staticIndex
		tbl = querySpace.static
	else
		index = table.find(querySpace.dynamic.index, part)
		tbl = querySpace.dynamic
	end
	if not index then return end

	table.remove(tbl.index, index)
	table.remove(tbl.replicas, index)
end

local function copyToQuerySpace(self: any, part: BasePart, static: boolean?, propertyReplicationWhitelist: any, partBlacklist: any, returnedReplicas: {}?)
	if not part:IsA("BasePart") then return end
	local querySpace = self.QuerySpace
	if not querySpace then return end

	local worldModel = self.WorldRoot
	local connections = self.ReplicaConnections

	local indexTable = static and querySpace.static.index or querySpace.dynamic.index
	local replicas = static and querySpace.static.replicas or querySpace.dynamic.replicas

	--local returnedReplicas = table.create(#parts)
	local index = #replicas + 1

	local replica = Instance.fromExisting(part)
	replica.Name = `REPLICA[{index}]({part.Name})`
	replica.Anchored = true
	replica.Parent = worldModel

	indexTable[index] = part
	replicas[index] = replica

	connections[part] = {
		if propertyReplicationWhitelist ~= nil then part.Changed:Connect(function(property)
			if partBlacklist[property] then return end
			if not propertyReplicationWhitelist[property] then return end
			
			rbxset(replica, property, rbxget(part, property))
		end) else nil,
		part.Destroying:Once(function()
			removeFromQuerySpace(self, part)
		end)
	}

	if returnedReplicas then
		table.insert(returnedReplicas, replica)
	end
	return replica
end

local function getBoxesFromParts(parts): {any}
	local boxes = {}
	for _, part in parts do
		local pos = part.Position
		local size = part.Size
		table.insert(boxes, {
			cframe = part.CFrame.Rotation + pos,
			size = size,
			part = part
		})
	end

	return boxes
end

return {
	QuerySpaceValidator = QUERY_SPACE_VALIDATOR,
	QueryOptionsValidator = QUERY_OPTIONS_VALIDATOR,
	TTypes = T_TYPES,
	
	defaultParamGenerator = getParamsForPlayerCharacters,
	updateClassStorage = updateClassStorage,
	removeFromQuerySpace = removeFromQuerySpace,
	copyToQuerySpace = copyToQuerySpace,
	getBoxesFromParts = getBoxesFromParts
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042e8</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXCD3DF3738E5B463C9626594AACA95241">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c4b</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">t</string>
										<string name="ScriptGuid">{AE1CB51A-DAEE-4D6B-896C-76E9AFD119F7}</string>
										<ProtectedString name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

local t = {}

function t.t_assert<T>(paramName: string, v: T, expected: string | (...any) -> boolean, typeName: string?): T
	if typeof(expected) == "string" then
		assert(t[expected](v), `Expected '{expected}' for '{paramName}', got '{typeof(v)}' ({v})`)
	elseif typeof(expected) == "function" then
		assert(expected(v), `Expected '{typeName or "unknown"}' for '{paramName}', got '{typeof(v)}' ({v})`)
	end
	return v
end

function t.type(typeName)
	return function(value)
		local valueType = type(value)
		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end

function t.typeof(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false, "any expected, got nil"
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = t.typeof("boolean")

--[[**
	ensures Lua primitive buffer type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.buffer = t.typeof("buffer")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = t.typeof("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = t.typeof("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = t.typeof("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = t.typeof("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = t.typeof("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = t.type("userdata")

--[[**
	ensures Lua primitive vector type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.vector = t.type("vector")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false, "unexpected NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value ~= value then
			return true
		else
			return false, "unexpected non-NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = t.typeof("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = t.typeof("BrickColor")

--[[**
	ensures Roblox CatalogSearchParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CatalogSearchParams = t.typeof("CatalogSearchParams")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = t.typeof("CFrame")

--[[**
	ensures Roblox Content type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Content = t.typeof("Content")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = t.typeof("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = t.typeof("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = t.typeof("ColorSequenceKeypoint")

--[[**
	ensures Roblox DateTime type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DateTime = t.typeof("DateTime")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = t.typeof("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = t.typeof("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = t.typeof("EnumItem")

--[[**
	ensures Roblox Enums type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enums = t.typeof("Enums")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = t.typeof("Faces")

--[[**
	ensures Roblox FloatCurveKey type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.FloatCurveKey = t.typeof("FloatCurveKey")

--[[**
	ensures Roblox Font type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Font = t.typeof("Font")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = t.typeof("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = t.typeof("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = t.typeof("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = t.typeof("NumberSequenceKeypoint")

--[[**
	ensures Roblox OverlapParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.OverlapParams = t.typeof("OverlapParams")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = t.typeof("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = t.typeof("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = t.typeof("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = t.typeof("Ray")

--[[**
	ensures Roblox RaycastParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastParams = t.typeof("RaycastParams")

--[[**
	ensures Roblox RaycastResult type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastResult = t.typeof("RaycastResult")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = t.typeof("RBXScriptConnection")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = t.typeof("RBXScriptSignal")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = t.typeof("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = t.typeof("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = t.typeof("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = t.typeof("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = t.typeof("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = t.typeof("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = t.typeof("Vector2")

--[[**
	ensures Roblox Vector2int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2int16 = t.typeof("Vector2int16")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = t.typeof("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = t.typeof("Vector3int16")

--[[**
	ensures value is any of the given literal values

	@param literals The literals to check against

	@returns A function that will return true if the condition is passed
**--]]
function t.literalList(literals)
	-- optimization for primitive types
	local set = {}
	for _, literal in ipairs(literals) do
		set[literal] = true
	end
	return function(value)
		if set[value] then
			return true
		end
		for _, literal in ipairs(literals) do
			if literal == value then
				return true
			end
		end

		return false, "bad type for literal list"
	end
end

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false, string.format("expected %s, got %s", tostring(literal), tostring(value))
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.unionList(literals)
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success, errMsg = t.number(value)
	if not success then
		return false, errMsg or ""
	end

	if value % 1 == 0 then
		return true
	else
		return false, string.format("integer expected, got %s", value)
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if value >= min then
			return true
		else
			return false, string.format("number >= %s expected, got %s", min, value)
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg
		end

		if value <= max then
			return true
		else
			return false, string.format("number <= %s expected, got %s", max, value)
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if min < value then
			return true
		else
			return false, string.format("number > %s expected, got %s", min, value)
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if value < max then
			return true
		else
			return false, string.format("number < %s expected, got %s", max, value)
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess, stringErrMsg = t.string(value)
		if not stringSuccess then
			return false, stringErrMsg
		end

		if string.match(value, pattern) == nil then
			return false, string.format("%q failed to match pattern %q", value, pattern)
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success, errMsg = check(value)
		if success then
			return true
		else
			return false, string.format("(optional) %s", errMsg or "")
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success, errMsg = check(args[i])
			if success == false then
				return false, string.format("Bad tuple index #%s:\n\t%s", i, errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key in pairs(value) do
			local success, errMsg = check(key)
			if success == false then
				return false, string.format("bad key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key, val in pairs(value) do
			local success, errMsg = check(val)
			if success == false then
				return false, string.format("bad value for key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess, keyErr = keyChecker(value)
		if not keySuccess then
			return false, keyErr or ""
		end

		local valueSuccess, valueErr = valueChecker(value)
		if not valueSuccess then
			return false, valueErr or ""
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)
			if keySuccess == false then
				return false, string.format("[array] %s", keyErrMsg or "")
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false, string.format("[array] key %s must be sequential", tostring(key))
				end
			end

			local valueSuccess, valueErrMsg = valuesCheck(value)
			if not valueSuccess then
				return false, string.format("[array] %s", valueErrMsg or "")
			end

			return true
		end
	end

--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)
			if keySuccess == false then
				return false, string.format("[strictArray] %s", keyErrMsg or "")
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false, string.format("[strictArray] Array size exceeds limit of %d", #valueTypes)
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess, typeErrMsg = typeFn(value[idx])
				if not typeSuccess then
					return false, string.format("[strictArray] Array index #%d - %s", idx, typeErrMsg)
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
--[[**
		creates a union type

		@param checks The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.unionList(checks)
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end
			
			return false, "bad type for union"
		end
	end

--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		return t.unionList({ ... })
	end

--[[**
		Alias for t.union
	**--]]
	t.some = t.union

--[[**
		creates an intersection type

		@param checks The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersectionList(checks)
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success, errMsg = check(value)
				if not success then
					return false, errMsg or ""
				end
			end

			return true
		end
	end

--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		return t.intersectionList({ ... })
	end

--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end

			return true
		end
	end

--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false, string.format("[interface] unexpected field %q", tostring(key))
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if not value:IsA(className) then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		if childrenCheck then
			local childrenSuccess, childrenErrMsg = childrenCheck(value)
			if not childrenSuccess then
				return false, childrenErrMsg
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if not value:IsA(className) then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		if childrenCheck then
			local childrenSuccess, childrenErrMsg = childrenCheck(value)
			if not childrenSuccess then
				return false, childrenErrMsg
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess, enumItemErrMsg = t.EnumItem(value)
		if not enumItemSuccess then
			return false, enumItemErrMsg
		end

		if value.EnumType == enum then
			return true
		else
			return false, string.format("enum of %s expected, got enum of %s", tostring(enum), tostring(value.EnumType))
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The function to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess, instanceErrMsg = t.Instance(value)
			if not instanceSuccess then
				return false, instanceErrMsg or ""
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false, string.format("Cannot process multiple children with the same name %q", name)
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success, errMsg = check(childrenByName[name])
				if not success then
					return false, string.format("[%s.%s] %s", value:GetFullName(), name, errMsg or "")
				end
			end

			return true
		end
	end
end

return t]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042e9</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX3E7D1E8B98004EB2941B20B21ADFA2BB">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c4c</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">SimpleSignal</string>
										<string name="ScriptGuid">{D9909886-D77E-4E54-AA70-540751B92A45}</string>
										<ProtectedString name="Source"><![CDATA[--!optimize 2
--!strict
--!native

--[[ SimpleSignal ]]

-- Author: athar_adv

local Types = require(script.Types)

export type SignalConnection = Types.SignalConnection
export type SimpleSignal<T...=(any)> = Types.SimpleSignal<T...>

export type RBXScriptConnection = SignalConnection
export type RBXScriptSignal<T...=(any)> = SimpleSignal<T...>

-- Key for accessing the private field of connections
local CONNECTION_PRIVATE = {}

local T_ASSERT_FORMAT = "Expected '%s' for '%s', got '%s'"
local DESTROYED_MSG = "Cannot use a destroyed signal."
local SUSPENDED = "suspended"

-- ConnectParallel will error if not called from an Actor context
local IS_PARALLEL_CONTEXT = pcall(function()
	local c = game.Destroying:ConnectParallel(function()end)
	c:Disconnect()
end)

local function call(c: SignalConnection, ...)
	local private = c[CONNECTION_PRIVATE]
	
	local parallel = private.IsParallel
	local old = private.MainThread
	private.MainThread = nil
	
	if parallel then task.desynchronize() end
	private.Fn(...)
	if parallel then task.synchronize() end
	
	if c.Connected then
		private.MainThread = old
	end
end

local function mainThreadWorker(c: SignalConnection, a, ...)
	-- Initial call if arguments are provided (so coroutine.resume doesn't have to be called twice)
	if a then
		call(c, a, ...)
	end
	
	while c.Connected do
		call(c, coroutine.yield())
	end
end

local function connection_disconnect(self: SignalConnection): ()
	if not self.Connected then return end
	self.Connected = false
	local private = self[CONNECTION_PRIVATE]
	
	local t = private.MainThread
	if t then
		task.cancel(t)
	end
	private.MainThread = nil

	local connections = private.Connections
	local l = #connections
	local pos = private.Index

	if l == pos then
		connections[l] = nil
		return
	end
	local last = connections[l]
	last[CONNECTION_PRIVATE].Index = pos

	connections[pos], connections[l] = last, nil
end

local function signal_connect<T...>(self: SimpleSignal<T...>, fn: (T...) -> ()): SignalConnection
	assert(not self.Destroyed, DESTROYED_MSG)
	assert(type(fn) == "function", T_ASSERT_FORMAT:format("function", "fn", tostring(fn)))
	
	local connections = self.Connections
	local index = #connections + 1

	local connection: SignalConnection = {
		Connected = true,
		Disconnect = connection_disconnect,
		
		[CONNECTION_PRIVATE] = {
			Fn = fn,
			Connections = connections,
			Index = index,
			IsParallel = false
		}
	}
	-- Ensure the thread has a reference to the connection
	local t = task.defer(mainThreadWorker, connection)

	connection[CONNECTION_PRIVATE].MainThread = t
	table.insert(connections, connection)
	
	return connection
end
-- Essentially the same as connect, just setting the isParallel flag and asserting if inside an Actor context
local function signal_connectParallel<T...>(self: SimpleSignal<T...>, fn: (T...) -> ()): SignalConnection
	assert(not self.Destroyed, DESTROYED_MSG)
	assert(type(fn) == "function", T_ASSERT_FORMAT:format("function", "fn", tostring(fn)))
	assert(IS_PARALLEL_CONTEXT, "Scripts that connect in parallel must be rooted under an Actor.")
	
	local c = self:Connect(fn)
	c[CONNECTION_PRIVATE].IsParallel = true
	
	return c
end

local function signal_once<T...>(self: SimpleSignal<T...>, fn: (T...) -> ()): SignalConnection
	assert(not self.Destroyed, DESTROYED_MSG)
	assert(type(fn) == "function", `Function expected, got {fn}`)

	local connection
	connection = self:Connect(function(...)
		connection:Disconnect()
		fn(...)
	end)

	return connection
end

local function signal_disconnectAll<T...>(self: SimpleSignal<T...>): ()
	assert(not self.Destroyed, DESTROYED_MSG)
	
	local connections = self.Connections
	local l = #connections

	for _, connection in connections do
		local priv = connection[CONNECTION_PRIVATE]
		connection.Connected = false
		
		local t = priv.MainThread
		if not t then continue end

		task.cancel(t)
		priv.MainThread = nil
	end
	table.clear(connections)
end

local function signal_fire<T...>(self: SimpleSignal<T...>, ...: T...): ()
	assert(not self.Destroyed, DESTROYED_MSG)
	
	local connections = self.Connections
	local l = #connections
	if l == 0 then return end
	
	for i = l, 1, -1 do
		local connection = connections[i]
		local priv = connection[CONNECTION_PRIVATE]
		
		local t = priv.MainThread
		-- If the main thread is done being used, it can simply be reused (fast path)
		if t ~= nil then
			task.spawn(t, ...)
			continue
		end
		-- If the main thread is still being used (aka yielding), 
		-- create a new one and set it as the new main thread (slow path)
		local t = task.spawn(mainThreadWorker, connection, ...)
		priv.MainThread = t
	end
end

local function signal_wait<T...>(self: SimpleSignal<T...>): T...
	assert(not self.Destroyed, DESTROYED_MSG)
	
	local running = coroutine.running()

	local connection
	connection = self:Connect(function(...)
		connection:Disconnect()
		task.spawn(running, ...)
	end)

	return coroutine.yield()
end

local function signal_destroy<T...>(self: SimpleSignal<T...>): ()
	assert(not self.Destroyed, DESTROYED_MSG)
	
	self:DisconnectAll()
	self.Destroyed = true
end

--[[
	Create a new <code>SimpleSignal</code> object.
]]
local function signal_new<T...>(): SimpleSignal<T...>
	return {
		Connections = {},
		Destroyed = false,

		Destroy = signal_destroy,
		Connect = signal_connect,
		ConnectParallel = signal_connectParallel,

		Fire = signal_fire,
		Once = signal_once,
		Wait = signal_wait,
		DisconnectAll = signal_disconnectAll
	}
end

return {
	new = signal_new
}]]></ProtectedString>
										<int64 name="SourceAssetId">101015633699544</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042ea</UniqueId>
									</Properties>
									<Item class="ModuleScript" referent="RBXFAFCD259E6D14313BC48D2D48D8FFEBC">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c4d</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">LICENSE</string>
											<string name="ScriptGuid">{AAFA4CC4-8F1F-4060-BDEC-D1A1026FB810}</string>
											<ProtectedString name="Source"><![CDATA[--[[
	This module is distributed under a modified MIT license
	
	Copyright (c) 2025 athar_adv

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
]]


return nil]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042eb</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXC2FC0877607843599EAEB751A8E1DC62">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c4e</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Types</string>
											<string name="ScriptGuid">{1951BE4A-7EBE-423C-B663-FE00C2DC8805}</string>
											<ProtectedString name="Source"><![CDATA[--!strict

export type SignalConnection = {
	Disconnect: typeof(
		--[[
			Disconnects the connection from the event.
		]]
		function(self: SignalConnection)end
	),
	Connected: boolean,
	
	-- Private members
	[{}]: {
		MainThread: thread?,
		Fn: (...any) -> (),
		Connections: {SignalConnection},
		Index: number,
		IsParallel: boolean
	}
}

-- Function types are made using typeof() to preserve doc comments
export type SimpleSignal<T...> = {
	Destroy: typeof(
		--[[
		Destroys this event object.
		]]
		function(self: SimpleSignal<T...>): () end
	),
	Connect: typeof(
		--[[
		Connects the given function to the event and returns an <code>SignalConnection</code> that represents it.
		
		<strong>fn</strong>: The function to connect to the event.
		]]
		function(self: SimpleSignal<T...>, fn: (T...) -> ()): SignalConnection 
			return {}::SignalConnection 
		end
	),
	ConnectParallel: typeof(
		--[[
		Connects the given function to the event (running it in a seperate core) and returns an <code>SignalConnection</code> that represents it.
		
		<strong>fn</strong>: The function to connect to the event.
		]]
		function(self: SimpleSignal<T...>, fn: (T...) -> ()): SignalConnection 
			return {}::SignalConnection 
		end
	),
	Once: typeof(
		--[[
		Connects the given function to the event (for a single invocation) and returns an <code>SignalConnection</code> that represents it.
		
		<strong>fn</strong>: The function to connect to the event.
		]]
		function(self: SimpleSignal<T...>, fn: (T...) -> ()): SignalConnection 
			return {}::SignalConnection 
		end
	),
	Fire: typeof(
		--[[
		Upon firing, all <code>SignalConnections</code> connected to this event will be called.
		
		<strong>T...</strong>: The arguments to pass to connected functions.
		]]
		function(self: SimpleSignal<T...>, ...:T...): () end
	),
	DisconnectAll: typeof(
		--[[
		Disconnects all <code>SignalConnections</code> currently connected to the event.
		]]
		function(self: SimpleSignal<T...>): () end
	),
	Wait: typeof(
		--[[
		Yields the current thread until the signal fires
		and returns the arguments provided by the signal.
		]]
		function(self: SimpleSignal<T...>): T... end
	),
	
	Connections: {SignalConnection},
	Destroyed: boolean
}

return nil]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042ec</UniqueId>
										</Properties>
									</Item>
								</Item>
								<Item class="ModuleScript" referent="RBX0FF3A1BDE59F43408202F784C6FA7FA9">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c4f</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">getBoundingBoxFromBoxes</string>
										<string name="ScriptGuid">{62656C55-97CA-4FA3-ADA0-D36580ABD70C}</string>
										<ProtectedString name="Source"><![CDATA[local function getBoundingBoxFromBoxes(boxes)
	local minBounds = vector.create(math.huge, math.huge, math.huge)
	local maxBounds = vector.create(-math.huge, -math.huge, -math.huge)

	for _, box in boxes do
		local cframe, size = box.cframe, box.size
		local halfSize = size * 0.5
		local corners = {
			cframe.Position + vector.create(-halfSize.x, -halfSize.y, -halfSize.z),
			cframe.Position + vector.create(halfSize.x, -halfSize.y, -halfSize.z),
			cframe.Position + vector.create(-halfSize.x, halfSize.y, -halfSize.z),
			cframe.Position + vector.create(halfSize.x, halfSize.y, -halfSize.z),
			cframe.Position + vector.create(-halfSize.x, -halfSize.y, halfSize.z),
			cframe.Position + vector.create(halfSize.x, -halfSize.y, halfSize.z),
			cframe.Position + vector.create(-halfSize.x, halfSize.y, halfSize.z),
			cframe.Position + vector.create(halfSize.x, halfSize.y, halfSize.z),
		}

		for _, corner in corners do
			minBounds = vector.create(
				math.min(minBounds.x, corner.x),
				math.min(minBounds.y, corner.y),
				math.min(minBounds.z, corner.z)
			)
			maxBounds = vector.create(
				math.max(maxBounds.x, corner.x),
				math.max(maxBounds.y, corner.y),
				math.max(maxBounds.z, corner.z)
			)
		end
	end
	local size = maxBounds - minBounds
	local center = (minBounds + maxBounds) / 2
	local boundingCFrame = CFrame.new(center::any)

	return boundingCFrame, size
end

return getBoundingBoxFromBoxes]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042ed</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBXB3F465F715B44B0883B79989F6A77636">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c51</UniqueId>
									<string name="Name">Templates</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042ee</UniqueId>
								</Properties>
								<Item class="Folder" referent="RBXA905F2896C45475FBC4A76A8B455E53E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">ServerWorker</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b6b</UniqueId>
									</Properties>
									<Item class="Script" referent="RBXE3532D87ED7E4491AA7C8C90FC8733B1">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Disabled">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Worker</string>
											<token name="RunContext">0</token>
											<string name="ScriptGuid">{F7EA98CF-6457-4B51-B1B3-49C336149275}</string>
											<ProtectedString name="Source"><![CDATA[local actor = script.Parent
local resultEvent = actor.Result

local PartQueryJumpTable: {[string]: (_: WorldRoot, _: BasePart, _: OverlapParams?) -> {BasePart}} = {
	Block = function(worldModel, part, params)
		return worldModel:GetPartBoundsInBox(part.CFrame, part.Size, params)
	end,
	Ball = function(worldModel, part, params)
		return worldModel:GetPartBoundsInRadius(part.Position, part.ExtentsSize.Y, params)
	end,
}

actor:BindToMessageParallel("Query", function(worldModel, params: OverlapParams, part: BasePart)
	local query
	if part:IsA("Part") then
		local fn = PartQueryJumpTable[part.Shape.Name]
		query = fn and fn(worldModel, part, params) or worldModel:GetPartsInPart(part, params)
	else
		query = worldModel:GetPartsInPart(part, params)
	end
	task.defer(resultEvent.Fire, resultEvent, query)
end)]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b6c</UniqueId>
										</Properties>
									</Item>
								</Item>
								<Item class="Folder" referent="RBX0969F43DFC2147E48EDC9E4443804602">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">ClientWorker</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b87</UniqueId>
									</Properties>
									<Item class="LocalScript" referent="RBX77677E5B03984D1691CB40D84B6B0AFC">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Disabled">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Worker</string>
											<token name="RunContext">0</token>
											<string name="ScriptGuid">{C35D947D-ADD4-4E44-98C1-FD5222C1A66F}</string>
											<ProtectedString name="Source"><![CDATA[local actor = script.Parent
local resultEvent = actor.Result

local PartQueryJumpTable: {[string]: (_: WorldRoot, _: BasePart, _: OverlapParams?) -> {BasePart}} = {
	Block = function(worldModel, part, params)
		return worldModel:GetPartBoundsInBox(part.CFrame, part.Size, params)
	end,
	Ball = function(worldModel, part, params)
		return worldModel:GetPartBoundsInRadius(part.Position, part.ExtentsSize.Y, params)
	end,
}

actor:BindToMessageParallel("Query", function(worldModel, params: OverlapParams, part: BasePart)
	local query
	if part:IsA("Part") then
		local fn = PartQueryJumpTable[part.Shape.Name]
		query = fn and fn(worldModel, part, params) or worldModel:GetPartsInPart(part, params)
	else
		query = worldModel:GetPartsInPart(part, params)
	end
	task.defer(resultEvent.Fire, resultEvent, query)
end)]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b88</UniqueId>
										</Properties>
									</Item>
								</Item>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX5F38B0EC010E45A9976B68EAC46BEE12">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c3d</UniqueId>
								<string name="Name">ZoneTypes</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042f5</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXCAF0041A40EF4D4EA488512EC3D7C529">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c3e</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">PartsZone</string>
									<string name="ScriptGuid">{0135C552-B62D-4CED-BCAC-15F411A0AD0A}</string>
									<ProtectedString name="Source"><![CDATA[--!optimize 2
--!strict

local main = script.Parent.Parent
local module = main.SimpleZone

local Types = require(main.Types)
local Zone = require(module)
local Geometry = require(main.Geometry)

local PartQueryFunction = require(script.PartQueryFunction)

local BVH = Geometry.BVH
local UtilityFunctions = require(module.Utility.UtilityFunctions)
local t = require(module.Utility.t)

local t_assert = t.t_assert
local T_TYPES = UtilityFunctions.TTypes

local Vertices = Geometry.Vertices

local RANDOM_POINT_DIMENSION = 3

@native
local function getVolume(parts: {Part})
	local boxes, points, partToPointIndex = Geometry.getBoxesVerticesForParts(Vertices, parts)
	local bvh = BVH.createBVH(boxes)
	
	return {
		partToPointIndex = partToPointIndex,
		points = points,
		boxes = boxes,
		parts = parts,
		bvh = bvh
	}
end

type Box = Geometry.Box
export type PartsZone = Types.LessSimpleZone<Part, {Part}>

local PartsZone = {}

@native function PartsZone.UpdateVolume(self: PartsZone, parts: {Part})
	t_assert("parts", parts, T_TYPES.partArray, "{Part}")
	
	local boxes, points, partToPointIndex = Geometry.getBoxesVerticesForParts(Vertices, parts)
	
	local volume = self.Volume
	local success, updated = BVH.updateBVH(volume.bvh, volume.boxes, boxes)
	
	if not success then return end
	
	self.Volume = {
		partToPointIndex = partToPointIndex,
		points = points,
		boxes = boxes,
		parts = parts,
		bvh = updated
	}
end

@native function PartsZone.GetRandomPoint(self: PartsZone): vector
	local points = self.Volume.points

	local randomvgroup = points[math.random(1, #points)]

	return Geometry.getRandomPointInSimplex(RANDOM_POINT_DIMENSION, randomvgroup)
end

@native function PartsZone.IsPointWithinZone(self: PartsZone, point: vector)
	t_assert("point", point, "vector")
	
	local bvh = self.Volume.bvh
	
	if not Geometry.isPointInBox(bvh.cframe, bvh.size, point) then
		return false
	end
	
	local isPointWithinZone = false
	local part = nil
	
	BVH.traverseBVH(bvh, function(box, stop)
		if isPointWithinZone then
			return false
		end
		if not Geometry.isPointInBox(box.cframe, box.size, point) then
			return false
		end
		-- If not yet at a leaf node, keep going
		if box.left or box.right then
			return true
		end
		assert(box.part ~= nil and box.part:IsA("Part"), "invalid part type, expected Part")
		
		-- Is a leaf node
		if not Geometry.isPointInShape(point, box.part) then
			return false
		end
		
		isPointWithinZone = true
		part = box.part
		stop()
		return false
	end)
	return isPointWithinZone, part
end

@native function PartsZone.IsBoxWithinZone(self: PartsZone, cframe: CFrame, size: vector)
	t_assert("cframe", cframe, "CFrame")
	t_assert("size", size, "vector")
	
	local bvh = self.Volume.bvh
	if not Geometry.doBoxesIntersect(cframe, size, bvh.cframe, bvh.size) then
		return false
	end

	local isPointWithinZone = false
	local part = nil
	
	BVH.traverseBVH(bvh, function(box, stop)
		if isPointWithinZone then
			return false
		end
		if not Geometry.doBoxesIntersect(cframe, size, box.cframe, box.size) then
			return false
		end
		-- If not yet at a leaf node, keep going
		if box.left or box.right then
			return true
		end
		assert(box.part ~= nil and box.part:IsA("Part"), "invalid part type, expected Part")
		-- Is a leaf node
		if not Geometry.isBoxInShape(cframe, size, box.part) then
			return false
		end

		isPointWithinZone = true
		part = box.part
		stop()
		return false
	end)
	return isPointWithinZone, part
end

@native function PartsZone.CombineWith(self: PartsZone, other)
	assert(other.ZoneType == "Parts", "Can only merge Boxes zones with other Boxes zones.")
	local otherV = other.Volume

	local thisParts = self.Volume.parts
	local mergedParts = table.move(otherV.parts, 1, #otherV.parts, #thisParts+1, thisParts)

	self:UpdateVolume(mergedParts)
end

-- Creates a new <code>Zone</code> based on an array of Parts.
local function pz_new(parts: {Part}, queryOp: Zone.QueryOptions?)
	local volume = getVolume(parts)
	
	local zone = Zone.fromCustom(PartQueryFunction :: any, queryOp) :: PartsZone
	zone.UpdateVolume 		= PartsZone.UpdateVolume
	zone.GetRandomPoint 	= PartsZone.GetRandomPoint
	zone.IsPointWithinZone 	= PartsZone.IsPointWithinZone
	zone.IsBoxWithinZone 	= PartsZone.IsBoxWithinZone
	zone.CombineWith 		= PartsZone.CombineWith
	
	zone.ZoneType 			= "Parts"
	zone.Volume 			= volume
	
	return zone
end

return pz_new]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042f6</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXC2C3CEE58B6A44B2BA070AEB3FBCA06B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c3f</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">PartQueryFunction</string>
										<string name="ScriptGuid">{6F594743-657A-4212-922F-968BF559786E}</string>
										<ProtectedString name="Source"><![CDATA[--!optimize 2
--!strict

local main = script.Parent.Parent.Parent
local module = main.SimpleZone

local Tracker = require(module.Tracker)
local Types = require(main.Types)

local PartQueryJumpTable: {[string]: (_: WorldRoot, _: BasePart, _: OverlapParams?) -> {BasePart}} = {
	Block = function(worldModel, part, params)
		return worldModel:GetPartBoundsInBox(part.CFrame, part.Size, params)
	end,
	Ball = function(worldModel, part, params)
		return worldModel:GetPartBoundsInRadius(part.Position, part.ExtentsSize.Y, params)
	end
}

return function(self: Types.LessSimpleZone<any>, params)
	debug.profilebegin("LessSimpleZone::PartQueryFunction")
	local querySpace = self.QuerySpace
	local queryOp = self.QueryOptions
	local worldModel = self.WorldRoot
	
	local zonePlace = if querySpace ~= nil then (queryOp.Static and querySpace.static or querySpace.dynamic) else nil
	
	local boxes = self.Volume.boxes
	local parts = self.Volume.parts
	local bvh = self.Volume.bvh
	
	local result: {any} = {}
	
	local totalZoneVolume = 0
	for _, v in boxes do
		local size = v.size
		totalZoneVolume += size.X * size.Y * size.Z
	end
	local totalVolume = Tracker.getTotalVolume() - totalZoneVolume
	
	if totalVolume > totalZoneVolume then
		local wholeCheck = worldModel:GetPartBoundsInBox(bvh.cframe, bvh.size, params)
		if #wholeCheck == 0 then
			debug.profileend()
			return result
		end
		
		for _, part in parts do
			local query: {BasePart}
			if part:IsA("Part") then
				local fn = PartQueryJumpTable[part.Shape.Name]
				query = fn and fn(worldModel, part, params) or worldModel:GetPartsInPart(part, params)
			else
				query = worldModel:GetPartsInPart(part, params)
			end
			
			if queryOp.AcceptMetadata then
				if queryOp.InSeperateQuerySpace and zonePlace then
					local index = table.find(zonePlace.replicas, part)
					if index then
						part = zonePlace.index[index]
					end
				end
				
				for _, item in query do
					table.insert(result, {item = item, metadata = {part = part}})
				end
			else
				table.move(query, 1, #query, #result + 1, result)
			end
		end
	else
		for _, item in Tracker.items do
			local succ, part
			if self.ZoneType == "Parts" then
				succ, part = self:IsBoxWithinZone(item.CFrame, item.Size::any)
				if not succ then continue end
			else
				succ, part = self:IsPointWithinZone(item.Position::any)
				if not succ then continue end
			end
			if queryOp.AcceptMetadata then
				table.insert(result, {item = item, metadata = {part = part}})
			else
				table.insert(result, item)
			end
		end
	end
	debug.profileend()
	
	return result
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042f7</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBXA528190DEE2648C5A0FD2135F021EE6A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c40</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">BasePartsVertexZone</string>
									<string name="ScriptGuid">{A776EA26-4EE9-44FE-9F15-7A34753D0FE8}</string>
									<ProtectedString name="Source"><![CDATA[--!optimize 2
--!strict

local main = script.Parent.Parent
local module = main.SimpleZone

local Types = require(main.Types)
local Zone = require(module)
local Geometry = require(main.Geometry)

local PartQueryFunction = require(script.Parent.PartsZone.PartQueryFunction)

local BVH = Geometry.BVH
local UtilityFunctions = require(module.Utility.UtilityFunctions)
local t = require(module.Utility.t)

local t_assert = t.t_assert
local T_TYPES = UtilityFunctions.TTypes

local RANDOM_POINT_DIMENSION = 3

type Box = Geometry.Box

@native
local function getVolume(parts: {BasePart}, vertices: {Vector3})
	local tetrahedrons = Geometry.generateTetrahedrons(vertices)
	local boxes: {Box} = {}
	
	for _, part in parts do
		table.insert(boxes, {
			cframe = part.CFrame,
			size = (part.Size :: any) :: vector,
			part = part
		})
	end
	for i, tetra in tetrahedrons do
		local tbl = {}
		tbl.t = tetra
		tbl.bound = {Geometry.getBoundingBox(tetra)}
		tetrahedrons[i] = tbl
	end
	
	local bvh = BVH.createBVH(boxes)
	
	return {
		parts = parts,
		points = vertices,
		tetrahedrons = tetrahedrons,
		boxes = boxes,
		bvh = bvh
	}
end

export type BasePartsVertexZone =  Types.LessSimpleZone<{bound: {CFrame & Vector3}, t: {Vector3}}, ({BasePart}, {Vector3})>

local BasePartsVertexZone = {}

@native function BasePartsVertexZone.UpdateVolume(self: BasePartsVertexZone, parts: {BasePart}, vertices: {Vector3})
	t_assert("parts", parts, T_TYPES.partArray, "{BasePart}")
	
	local tetrahedrons = Geometry.generateTetrahedrons(vertices)
	local boxes = {}

	for _, part in parts do
		table.insert(boxes, {
			cframe = part.CFrame,
			size = part.Size,
			part = part
		})
	end
	for i, tetra in tetrahedrons do
		local tbl = {}
		tbl.t = tetra
		tbl.bound = {Geometry.getBoundingBox(tetra)}
		tetrahedrons[i] = tbl
	end
	
	local volume = self.Volume
	local success, updated = BVH.updateBVH(volume.bvh, volume.boxes, boxes::any)
	
	if not success then return end
	
	self.Volume = {
		parts = parts,
		points = vertices,
		tetrahedrons = tetrahedrons,
		boxes = boxes,
		bvh = updated
	}
end

@native function BasePartsVertexZone.GetRandomPoint(self: BasePartsVertexZone)
	local points = self.Volume.points

	local randomvgroup = points[math.random(1, #points)]

	return Geometry.getRandomPointInSimplex(RANDOM_POINT_DIMENSION, randomvgroup)
end

@native function BasePartsVertexZone.IsPointWithinZone(self: BasePartsVertexZone, point: vector)
	t_assert("point", point, "vector")
	
	for _, tetra in self.Volume.tetrahedrons do
		local bound = tetra.bound
		local cf, size = bound[1], bound[2]
		
		local halfSize = size / 2
		local localPoint = cf:PointToObjectSpace(point)

		local withinX = math.abs(localPoint.X) <= halfSize.X
		local withinY = math.abs(localPoint.Y) <= halfSize.Y
		local withinZ = math.abs(localPoint.Z) <= halfSize.Z

		if not (withinX and withinY and withinZ) then
			return false
		end
		if not Geometry.isPointInTetrahedron(point, unpack(tetra.t)) then continue end
		
		return true, tetra
	end
	return false
end

@native function BasePartsVertexZone.IsBoxWithinZone(self: BasePartsVertexZone, cframe: CFrame, size: vector)
	t_assert("cframe", cframe, "CFrame")
	t_assert("size", size, "vector")
	
	error("BasePartsVertexZone:IsBoxWithinZone() is not implemented yet.")
	return false, nil
end

@native function BasePartsVertexZone.CombineWith(self: BasePartsVertexZone, other)
	assert(other.ZoneType == "BasePartsVertex", "Can only merge Boxes zones with other Boxes zones.")
	local otherV = other.Volume

	local thisparts = self.Volume.parts
	local thisPoints = self.Volume.points
	local mergedParts = table.move(otherV.parts, 1, #otherV.parts, #thisparts+1, thisparts)
	local mergedPoints = table.move(otherV.points, 1, #otherV.points, #thisPoints+1, thisPoints)

	self:UpdateVolume(mergedParts, mergedPoints)
end

-- Creates a new <code>Zone</code> using an array of BaseParts and vertices defining the bounds of each one.
local function bvz_new(parts: {BasePart}, vertices: {Vector3}, queryOp: Zone.QueryOptions?)
	local volume = getVolume(parts, vertices)

	local zone = Zone.fromCustom(PartQueryFunction :: any, queryOp) :: BasePartsVertexZone
	zone.UpdateVolume 		= BasePartsVertexZone.UpdateVolume
	zone.GetRandomPoint 	= BasePartsVertexZone.GetRandomPoint
	zone.IsPointWithinZone 	= BasePartsVertexZone.IsPointWithinZone
	zone.IsBoxWithinZone 	= BasePartsVertexZone.IsBoxWithinZone
	zone.CombineWith 		= BasePartsVertexZone.CombineWith

	zone.ZoneType 			= "BasePartsVertex"
	zone.Volume 			= volume

	return zone
end

return bvz_new]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042f8</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXEBD8235B20BD4036B1AEB491B06E2FF0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c41</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">BoxesZone</string>
									<string name="ScriptGuid">{CEBD22CC-82EA-4A24-B24E-480A15D451BE}</string>
									<ProtectedString name="Source"><![CDATA[--!optimize 2
--!strict

local main = script.Parent.Parent
local module = main.SimpleZone

local Types = require(main.Types)
local Zone = require(module)
local Geometry = require(main.Geometry)

local BoxQueryFunction = require(script.BoxQueryFunction)

local BVH = Geometry.BVH
local UtilityFunctions = require(module.Utility.UtilityFunctions)
local t = require(module.Utility.t)

local t_assert = t.t_assert
local T_TYPES = UtilityFunctions.TTypes

type Box = Geometry.Box
type BoxNode = Geometry.BoxNode

@native
local function initializeVolume(boxes: {Box})
	local bvh = BVH.createBVH(boxes)
	local leaves = {}

	BVH.traverseBVH(bvh, function(box)
		if not box.left and not box.right then
			table.insert(leaves, box)
			return false
		end
		return true
	end)

	return {
		bvh = bvh,
		leaves = leaves
	}
end

export type BoxesZone = Types.LessSimpleZone<BoxNode, {Box}>

local BoxesZone = {}

@native function BoxesZone.UpdateVolume(self: BoxesZone, boxes: {Box})
	t_assert("boxes", boxes, T_TYPES.boxArray, "{Box}")
	
	local volume = self.Volume
	local success, updated = BVH.updateBVH(volume.bvh, volume.boxes, boxes)
	
	-- It means no changes could be made
	if not success then return end
	
	local leaves = {}

	BVH.traverseBVH(updated, function(box)
		if not box.left and not box.right then
			table.insert(leaves, box)
			return false
		end
		return true
	end)
	
	self.Volume = {
		bvh = updated,
		boxes = boxes,
		leaves = leaves
	}
end

@native function BoxesZone.GetRandomPoint(self: BoxesZone): vector
	local leafNodes = self.Volume.leaves

	assert(#leafNodes > 0, "No leaf nodes found in BVH")
	
	local randomLeaf = leafNodes[math.random(1, #leafNodes)]
	local cframe, size = randomLeaf.cframe, randomLeaf.size

	local randomX = math.random() * size.X - size.X / 2
	local randomY = math.random() * size.Y - size.Y / 2
	local randomZ = math.random() * size.Z - size.Z / 2

	local randomPoint = cframe:PointToWorldSpace(vector.create(randomX, randomY, randomZ))

	return randomPoint
end

@native function BoxesZone.IsPointWithinZone(self: BoxesZone, point: vector)
	t_assert("point", point, "vector")
	
	local bvh = self.Volume.bvh
	if not Geometry.isPointInBox(bvh.cframe, bvh.size, point) then
		return false
	end
	local found = false
	local foundBox = nil
	
	BVH.traverseBVH(bvh, function(box, stop)
		if found then
			return false
		end
		if not Geometry.isPointInBox(box.cframe, box.size, point) then
			return false
		end
		if box.left or box.right then
			return true
		end
		found = true
		foundBox = box
		
		stop() -- Point is within a leaf node, no need to continue
		return false
	end)
	
	return found, foundBox
end

@native function BoxesZone.IsBoxWithinZone(self: BoxesZone, cframe: CFrame, size: vector)
	t_assert("cframe", cframe, "CFrame")
	t_assert("size", size, "vector")
	
	local found = false
	local foundBox = nil
	
	local bvh = self.Volume.bvh
	if not Geometry.doBoxesIntersect(cframe, size, bvh.cframe, bvh.size) then
		return false
	end
	
	BVH.traverseBVH(bvh, function(node, stop)
		if found then
			return false
		end
		if not Geometry.doBoxesIntersect(cframe, size, node.cframe, node.size) then
			return false
		end
		-- If it's an internal node, continue traversing
		if node.left or node.right then
			return true
		end
		
		-- Found a leaf node intersection
		found = true
		foundBox = node

		stop() -- Stop traversal
		return false
	end)

	return found, foundBox
end

@native function BoxesZone.CombineWith(self: BoxesZone, other)
	assert(other.ZoneType == "Boxes", "Can only merge Boxes zones with other Boxes zones.")
	local otherV = other.Volume

	local thisBoxes = self.Volume.boxes
	local mergedBoxes = table.move(otherV.boxes, 1, #otherV.boxes, #thisBoxes+1, thisBoxes)

	self:UpdateVolume(mergedBoxes)
end

-- Creates a <code>Zone</code> based on an array of bounding boxes utilizing a BVH structure for optimal efficiency.
local function bz_new(boxes: {Box}, queryOp: Zone.QueryOptions?)
	local volume = initializeVolume(boxes)

	local zone = Zone.fromCustom(BoxQueryFunction :: any, queryOp) :: BoxesZone
	zone.UpdateVolume 		= BoxesZone.UpdateVolume
	zone.GetRandomPoint 	= BoxesZone.GetRandomPoint
	zone.IsPointWithinZone 	= BoxesZone.IsPointWithinZone
	zone.IsBoxWithinZone 	= BoxesZone.IsBoxWithinZone
	zone.CombineWith 		= BoxesZone.CombineWith

	zone.ZoneType 			= "Boxes"
	zone.Volume 			= volume

	return zone
end

return bz_new]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042f9</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXA3CC1748B9F6408EB299486D16381419">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c42</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">BoxQueryFunction</string>
										<string name="ScriptGuid">{E1FC04AB-F912-4EE9-A2FB-689A14108921}</string>
										<ProtectedString name="Source"><![CDATA[--!optimize 2
--!strict

local main = script.Parent.Parent.Parent
local module = main.SimpleZone

local Tracker = require(module.Tracker)
local Types = require(main.Types)

return function(self: Types.LessSimpleZone<any>, params)
	debug.profilebegin("LessSimpleZone::BoxQueryFunction")
	local queryOp = self.QueryOptions
	local querySpace = self.QuerySpace
	local worldModel = self.WorldRoot
	
	local boxes = self.Volume.boxes
	local bvh = self.Volume.bvh
	local result: {any} = {}
	
	local totalZoneVolume = 0
	for _, v in boxes do
		local size = v.size
		totalZoneVolume += size.X * size.Y * size.Z
	end
	local totalVolume = Tracker.getTotalVolume() - totalZoneVolume
	
	if totalVolume > totalZoneVolume then
		local wholeCheck = worldModel:GetPartBoundsInBox(bvh.cframe, bvh.size, params)
		if #wholeCheck == 0 then
			debug.profileend()
			return result
		end
		
		for _, box in boxes do
			local query = worldModel:GetPartBoundsInBox(box.cframe, box.size::any, params)
			if #query == 0 then continue end

			if self.QueryOptions.AcceptMetadata then
				for _, item in query do
					table.insert(result, {item = item, metadata = {box = box}})
				end
			else
				table.move(query, 1, #query, #result + 1, result)
			end
		end
	else
		for _, item in Tracker.items do
			local succ, box = self:IsBoxWithinZone(item.CFrame, item.Size::any)
			if not succ then continue end
			if queryOp.AcceptMetadata then
				table.insert(result, {item = item, metadata = {box = box}})
			else
				table.insert(result, item)
			end
		end
	end
	debug.profileend()
	
	return result
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042fa</UniqueId>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX2F6AA710313D4F96A9EBBD6734CF9FE2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">7deed65f364e39630743c3f00001876c</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Logger</string>
							<string name="ScriptGuid">{DBE04FD9-3005-4E5C-8F6F-B7AE0A94AE11}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 11/11/24
--[[@description:
	Creates a new logger object that can print, warn, assert, and error with a prefix given through the constructor.
	By default, prints do not occur on production servers unless specified through the constructor.
]]
-----------------------------
-- SERVICES --
-----------------------------
local RunService = game:GetService("RunService")

-----------------------------
-- DEPENDENCIES --
-----------------------------

-----------------------------
-- TYPES --
-----------------------------
-- This is for all of the properties of an object made from this class for type annotation purposes.
type self = {
	_prefix: string,
	_printsOnProduction: boolean,
}

-----------------------------
-- VARIABLES --
-----------------------------
local Logger = {}
local MT = {}
MT.__index = MT
export type LoggerType = typeof(setmetatable({} :: self, MT))

-- CONSTANTS --
local DEFAULT_LEVEL = 1

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Creates a new logger that will send console messages with the given <code>prefix</code>.
-- <strong>withBrackets</strong>: Should brackets be wrapped around the prefix? True by default.
-- <strong>printsOnProduction</strong>: Should :print() happen on production servers? False by default.
function Logger.new(prefix: string, withBrackets: boolean?, printsOnProduction: boolean?): LoggerType
	assert(typeof(prefix) == "string", "Expected string for prefix.")
	local self = setmetatable({} :: self, MT)
	
	local withBrackets = if typeof(withBrackets) ~= "nil" then withBrackets else true
	
	self._prefix = if withBrackets then `[{prefix}]:` else `{prefix}:`
	self._printsOnProduction = printsOnProduction or false
	
	return self
end

function Logger:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")

	return getmetatable(object).__index == MT
end

-- <strong>traceback</strong>: Should the full traceback be included?
function MT.print(self: LoggerType, msg: any, traceback: boolean?)
	if not RunService:IsStudio() and not self._printsOnProduction then
		return
	end
	print(self._prefix, msg, if traceback then `\n{debug.traceback()}` else "")
end

-- <strong>traceback</strong>: Should the full traceback be included?
function MT.warn(self: LoggerType, msg: any, traceback: boolean?)
	warn(self._prefix, msg, if traceback then `\n{debug.traceback()}` else "")
end

-- <strong>traceback</strong>: Should the full traceback be included?
function MT.assert(self: LoggerType, expression: any, err: any, traceback: boolean?)
	if not expression then
		self:error(err, traceback)
	end
end

-- An improved version over <code>assert()</code> to avoid string concatenation unless the expression is evaluated to false.
-- <strong>traceback</strong>: Should the full traceback be included?
-- <strong>toFormat</strong>: The string to be used in <code>string.format()</code>
-- <strong>...</strong>: Any strings to be formatted into <strong>toFormat</strong>
function MT.assertFormatted(self: LoggerType, expression: any, traceback: boolean?, toFormat: string, ...: string)
	if not expression then
		self:error(string.format(toFormat, ...), traceback)
	end
end

-- <strong>traceback</strong>: Should the full traceback be included?
function MT.assertWarn(self: LoggerType, expression: any, msg: any, traceback: boolean?)
	if not expression then
		self:warn(msg, traceback)
	end
end

-- <strong>traceback</strong>: Should the full traceback be included?
function MT.error(self: LoggerType, err: any, traceback: boolean?)
	error(`{self._prefix} {err}{if traceback then `\n{debug.traceback()}` else ""}`)
end

function MT.Destroy(self: LoggerType)
	setmetatable(self :: any, nil)
	table.clear(self :: any)
end

-----------------------------
-- MAIN --
-----------------------------
return Logger]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042fb</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5E813279D7284475837FA64CD93C4138">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">626fc90b6bf0d334074c1ece00006c06</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_QuaternionSpring</string>
							<string name="ScriptGuid">{A22CD541-23BF-4615-8564-7D8FABDA268D}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--[[
    Source: https://github.com/probablytukars/LuaQuaternion
    Based on: https://github.com/Quenty/NevermoreEngine/tree/main/src/spring
    [MIT LICENSE]
    
    Impulse() fixed by @crusherfire
]]

local Quaternion = require(script.Parent._Quaternion)
type Quaternion = Quaternion.Quaternion
local ERROR_FORMAT = "%q is not a valid member of QuaternionSpring."

local QuaternionSpring = {_type = "QuaternionSpring"}

type t_QuaternionSpring = {
	new: (initial: Quaternion, damping: number, speed: number, clock: () -> number) -> QuaternionSpring,
	Reset: (target: Quaternion?) -> nil,
	Impulse: (self: QuaternionSpring, velocity: Vector3) -> nil,
	TimeSkip: (self: QuaternionSpring, delta: number) -> nil,

	Position: Quaternion,
	p: Quaternion,
	Velocity: Vector3,
	v: Vector3,
	Target: Quaternion,
	t: Quaternion,
	Damping: number,
	d: number,
	Speed: number,
	s: number,
	Clock: () -> number,

	_clock: () -> number,
	_time: number,
	_position:  Quaternion,
	_velocity:  Vector3,
	_target:  Quaternion,
	_damping:  number,
	_speed:  number,
	_initial:  Quaternion,
}

export type QuaternionSpring = typeof(setmetatable({} :: t_QuaternionSpring, QuaternionSpring))

--[=[
    @class QuaternionSpring
    @grouporder ["Constructors", "Methods"]
    
    This class represents a rotational spring using Quaternions.
    Velocity is a Vector3 where the magnitude is the angle, and the unit
    is the axis (if angle is > 0).
    
    This is lazily evaluated meaning it only updates when indexed.
--]=]
--[=[
    @prop Position nlerpable
    
    The current position (rotation) at the given clock time. 
    Assigning the position will change the spring to have that position.
--]=]
--[=[
    @prop p nlerpable
    @alias Position
--]=]
--[=[
    @prop Velocity nlerpable
    
    The current velocity. Assigning the velocity will change the spring to have 
    that velocity. The velocity should be in the axis with angle magnitude
    format, where the magnitude represents the angle, and the unit of that
    vector (if magnitude is > 0) represents the axis of rotation.
    The zero vector represents no velocity.
--]=]
--[=[
    @prop v nlerpable
    @alias Velocity
--]=]
--[=[
    @prop Target nlerpable
    
    The current target. Assigning the target will change the spring to have 
    that target.
--]=]
--[=[
    @prop t nlerpable
    @alias Target
--]=]
--[=[
    @prop Damping number
    
    The current damper, defaults to 1. At 1 the spring is critically damped. 
    At less than 1, it will be underdamped, and thus, bounce, and at over 1, 
    it will be critically damped.
--]=]
--[=[
    @prop d number
    @alias Damping
--]=]
--[=[
    @prop Speed number
    
    The speed, defaults to 1, but should be between [0, infinity)
--]=]
--[=[
    @prop s number
    @alias Speed
--]=]
--[=[
    @prop Clock
]=]


--[=[
    @function
    @group Constructors
    
    Constructs a new Quaternion Spring at the position and target specified.
]=]
function QuaternionSpring.new(initial: Quaternion?, damping: number?, speed: number?, clock: (() -> number)?): QuaternionSpring
	local l_initial = initial or Quaternion.identity
	local l_damping = damping or 1
	local l_speed = speed or 1
	local l_clock = clock or os.clock

	local self = {
		_clock = l_clock,
		_time = l_clock(),
		_position = l_initial,
		_velocity = Vector3.zero,
		_target = l_initial,
		_damping = l_damping,
		_speed = l_speed,
		_initial = l_initial
	}

	return setmetatable(self :: t_QuaternionSpring, QuaternionSpring)
end

--[=[
    @method
    @group Methods
    
    Resets the springs' position and target to the target value provided, or 
    to the initial value the spring was created with if target is not specified.
    Sets the velocity to zero.
]=]

local function Reset(self: QuaternionSpring, target: Quaternion?)
	local setTo = target or self._initial
	self._position = setTo
	self._target = setTo
	self._velocity = Vector3.zero
end

QuaternionSpring.Reset = Reset

--[=[
    @method
    @group Methods
    
    Impulses the spring, increasing velocity by the amount given.
    This is useful to make something shake. Note that the velocity
    will be a rotation vector, such that the axis is the direction
    and the magnitude is the angle (compact axis-angle).
]=]




local function Impulse(self: QuaternionSpring, velocity: Vector3)
	self.Velocity = self.Velocity + velocity
end

QuaternionSpring.Impulse = Impulse


local function _positionVelocity(self: QuaternionSpring, now: number)
	local currentRotation = self._position
	local currentVelocity = self._velocity
	local targetRotation = self._target
	local dampingFactor = self._damping
	local speed = self._speed

	local deltaTime = speed * (now - self._time)
	local dampingSquared = dampingFactor * dampingFactor

	local angFreq, sinTheta, cosTheta
	if dampingSquared < 1 then
		angFreq = math.sqrt(1 - dampingSquared)
		local exponential = math.exp(-dampingFactor * deltaTime) / angFreq
		cosTheta = exponential * math.cos(angFreq * deltaTime)
		sinTheta = exponential * math.sin(angFreq * deltaTime)
	elseif dampingSquared == 1 then
		angFreq = 1
		local exponential = math.exp(-dampingFactor * deltaTime)
		cosTheta, sinTheta = exponential, exponential * deltaTime
	else
		angFreq = math.sqrt(dampingSquared - 1)
		local angFreq2 = 2 * angFreq
		local u = math.exp((-dampingFactor + angFreq) * deltaTime) / angFreq2
		local v = math.exp((-dampingFactor - angFreq) * deltaTime) / angFreq2
		cosTheta, sinTheta = u + v, u - v
	end

	local pullToTarget = 1 - (angFreq * cosTheta + dampingFactor * sinTheta)
	local velPosPush = sinTheta / speed
	local velPushRate = speed * sinTheta
	local velocityDecay = angFreq * cosTheta - dampingFactor * sinTheta

	local posQuat = currentRotation:Slerp(targetRotation, pullToTarget)
	local newPosition = posQuat:Integrate(currentVelocity, velPosPush)

	local difQuat = currentRotation:Difference(targetRotation)
	local axis, angle = difQuat:ToAxisAngle()
	local velPush = (axis * angle) * velPushRate
	local velDecay = currentVelocity * velocityDecay

	local newVelocity = velPush + velDecay

	return newPosition, newVelocity
end

--[=[
    @method
    @group Methods
    Instantly skips the spring forwards by the given time.
]=]
local function TimeSkip(self: QuaternionSpring, delta: number)
	local now = self._clock()
	local position, velocity = _positionVelocity(self, now+delta)
	self._position = position
	self._velocity = velocity
	self._time = now
end

QuaternionSpring.TimeSkip = TimeSkip

function QuaternionSpring.__index(self: QuaternionSpring, index: string)
	if QuaternionSpring[index] then
		return QuaternionSpring[index]
	elseif index == "Position" or index == "p" then
		local position, _ = _positionVelocity(self, self._clock())
		return position
	elseif index == "Velocity" or index == "v" then
		local _, velocity = _positionVelocity(self, self._clock())
		return velocity
	elseif index == "Target" or index == "t" then
		return self._target
	elseif index == "Damping" or index == "d" then
		return self._damping
	elseif index == "Speed" or index == "s" then
		return self._speed
	elseif index == "Clock" then
		return self._clock
	end
	error(string.format(ERROR_FORMAT, tostring(index)), 2)
end

function QuaternionSpring.__newindex(self: QuaternionSpring, index: string, value: any)
	local now = self._clock()
	if index == "Position" or index == "p" then
		local _, velocity = _positionVelocity(self, now)
		self._position = value
		self._velocity = velocity
		self._time = now
	elseif index == "Velocity" or index == "v" then
		local position, _ = _positionVelocity(self, now)
		self._position = position
		self._velocity = value
		self._time = now
	elseif index == "Target" or index == "t" then
		local position, velocity = _positionVelocity(self, now)
		self._position = position
		self._velocity = velocity
		self._target = value
		self._time = now
	elseif index == "Damping" or index == "d" then
		local position, velocity = _positionVelocity(self, now)
		self._position = position
		self._velocity = velocity
		self._damping = value
		self._time = now
	elseif index == "Speed" or index == "s" then
		local position, velocity = _positionVelocity(self, now)
		self._position = position
		self._velocity = velocity
		self._speed = value < 0 and 0 or value
		self._time = now
	elseif index == "Clock" then
		local position, velocity = _positionVelocity(self, now)
		self._position = position
		self._velocity = velocity
		self._clock = value
		self._time = value()
	else
		error(string.format(ERROR_FORMAT, tostring(index)), 2)
	end
end


return QuaternionSpring
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042fc</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB0778F80ED204626811A21D5C555AC60">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">13126a7112cfb03c0768b7c5000062fe</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_TypedRemote</string>
							<string name="ScriptGuid">{9AF3A4D6-2C6C-4672-B486-D0C8F1E51460}</string>
							<ProtectedString name="Source"><![CDATA[--!strict

type Signal<T...> = {
	Connect: (self: Signal<T...>, fn: (T...) -> ()) -> RBXScriptConnection,
	ConnectParallel: (self: Signal<T...>, fn: (T...) -> ()) -> RBXScriptConnection,
	Once: (self: Signal<T...>, fn: (T...) -> ()) -> RBXScriptConnection,
	Wait: (self: Signal<T...>) -> T...,
}

type PlayerSignal<T...> = {
	Connect: (self: PlayerSignal<T...>, fn: (player: Player, T...) -> ()) -> RBXScriptConnection,
	ConnectParallel: (self: PlayerSignal<T...>, fn: (player: Player, T...) -> ()) -> RBXScriptConnection,
	Once: (self: PlayerSignal<T...>, fn: (player: Player, T...) -> ()) -> RBXScriptConnection,
	Wait: (self: PlayerSignal<T...>) -> (Player, T...),
}

--[=[
	@within TypedRemote
	@interface Event<T...>
	.OnClientEvent Signal<T...>,
	.OnServerEvent PlayerSignal<T...>,
	.FireClient (self: Event<T...>, player: Player, T...) -> (),
	.FireAllClients (self: Event<T...>, T...) -> (),
	.FireServer (self: Event<T...>, T...) -> (),
]=]
export type Event<ServerReceive..., ClientReceive...> = Instance & {
	OnClientEvent: Signal<ClientReceive...>,
	OnServerEvent: PlayerSignal<ServerReceive...>,
	FireClient: (self: Event<ServerReceive..., ClientReceive...>, player: Player, ClientReceive...) -> (),
	FireAllClients: (self: Event<ServerReceive..., ClientReceive...>, ClientReceive...) -> (),
	FireServer: (self: Event<ServerReceive..., ClientReceive...>, ServerReceive...) -> (),
}

--[=[
	@within TypedRemote
	@interface Function<T..., R...>
	.InvokeServer (self: Function<T..., R...>, T...) -> R...,
	.OnServerInvoke (player: Player, T...) -> R...,
]=]
export type Function<T..., R...> = Instance & {
	InvokeServer: (self: Function<T..., R...>, T...) -> R...,
	OnServerInvoke: (player: Player, T...) -> R...,
}

local IS_SERVER = game:GetService("RunService"):IsServer()

--[=[
	@class TypedRemote

	Simple networking package that helps create typed RemoteEvents and RemoteFunctions.

	```lua
	-- ReplicatedStorage.Network (ModuleScript)

	local TypedRemote = require(ReplicatedStorage.Packages.TypedRemote)

	-- Get the RF and RE instance creators, which create RemoteEvents/RemoteFunctions
	-- within the given parent (the script in this case):
	local RF, RE = TypedRemote.parent(script)

	-- Redeclare the TypedRemote types for simplicity:
	type RF<T..., R...> = TypedRemote.Function<T..., R...>
	type RE<T...> = TypedRemote.Event<T...>

	-- Define network table:
	return {
		-- RemoteEvent that takes two arguments - a string and a number:
		MyEvent = RE("MyEvent") :: RE<string, number>,

		-- RemoteFunction that takes two arguments (boolean, string) and returns a number:
		MyFunc = RF("MyFunc") :: RF<(boolean, string), (number)>,
	}
	```

	```lua
	-- Example usage of the above Network module:

	local Network = require(ReplicatedStorage.Network)

	-- If you type this out, intellisense will help with what the function signature should be:
	Network.MyEvent.OnClientEvent:Connect(function(player, str, num)
		-- Foo
	end)
	```

	In most cases, the `TypedRemote.parent()` function will be used to create the memoized
	RemoteFunction and RemoteEvent builder functions. From there, call the given functions
	with the desired name per remote.

	The `TypedRemote.func` and `TypedRemote.event` functions can also be used, but the
	parent must be supplied to each call, hence the helpful `parent()` memoizer.
]=]
local TypedRemote = {}

--[=[
	@return ((name: string) -> RemoteFunction, (name: string) -> RemoteEvent)

	Creates a memoized version of the `func` and `event` functions that include the `parent`
	in each call.

	```lua
	-- Create RF and RE functions that use the current script as the instance parent:
	local RF, RE = TypedRemote.parent(script)

	local remoteFunc = RF("RemoteFunc")
	```
]=]
function TypedRemote.parent(parent: Instance)
	return function(name: string)
		return TypedRemote.func(name, parent)
	end, function(name: string)
		return TypedRemote.event(name, parent)
	end, function(name: string)
		return TypedRemote.unreliable(name, parent)
	end
end

--[=[
	Creates a RemoteFunction with `name` and parents it inside of `parent`.
	
	If the `parent` argument is not included or is `nil`, then it defaults to the parent of
	this TypedRemote ModuleScript.
]=]
function TypedRemote.func(name: string, parent: Instance?): RemoteFunction
	local rf: RemoteFunction
	if IS_SERVER then
		rf = Instance.new("RemoteFunction")
		rf.Name = name
		rf.Parent = if parent then parent else script
	else
		rf = (if parent then parent else script):WaitForChild(name, 30)
		assert(rf and rf:IsA("RemoteFunction"), "Expected remote function! Did you forget to require Network on server?")
	end
	return rf
end

--[=[
	Creates a RemoteEvent with `name` and parents it inside of `parent`.
	
	If the `parent` argument is not included or is `nil`, then it defaults to the parent of
	this TypedRemote ModuleScript.
]=]
function TypedRemote.event(name: string, parent: Instance?): RemoteEvent
	local re: RemoteEvent
	if IS_SERVER then
		re = Instance.new("RemoteEvent")
		re.Name = name
		re.Parent = if parent then parent else script
	else
		re = (if parent then parent else script):WaitForChild(name, 30)
		assert(re and re:IsA("RemoteEvent"), "Expected remote event! Did you forget to require Network on server?")
	end
	return re
end

function TypedRemote.unreliable(name: string, parent: Instance?): UnreliableRemoteEvent
	local re: UnreliableRemoteEvent
	if IS_SERVER then
		re = Instance.new("UnreliableRemoteEvent")
		re.Name = name
		re.Parent = if parent then parent else script
	else
		re = (if parent then parent else script):WaitForChild(name, 30)
		assert(re and re:IsA("UnreliableRemoteEvent"), "Expected unreliable remote event! Did you forget to require Network on server?")
	end
	return re
end

table.freeze(TypedRemote)

return TypedRemote]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042fd</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX7527C694A86E4EE8B93F983F0D2309D3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">7cb24506c28392f306c597bc000068e6</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_TypedBindable</string>
							<string name="ScriptGuid">{39533374-DBB0-4564-B8E5-06D4BD65A129}</string>
							<ProtectedString name="Source"><![CDATA[--!strict

type Signal<T...> = {
	Connect: (self: Signal<T...>, fn: (T...) -> ()) -> RBXScriptConnection,
	ConnectParallel: (self: Signal<T...>, fn: (T...) -> ()) -> RBXScriptConnection,
	Once: (self: Signal<T...>, fn: (T...) -> ()) -> RBXScriptConnection,
	Wait: (self: Signal<T...>) -> T...,
}

--[=[
	@within TypedRemote
	@interface Event<T...>
	.OnClientEvent Signal<T...>,
	.OnServerEvent PlayerSignal<T...>,
	.FireClient (self: Event<T...>, player: Player, T...) -> (),
	.FireAllClients (self: Event<T...>, T...) -> (),
	.FireServer (self: Event<T...>, T...) -> (),
]=]
export type Event<T...> = Instance & {
	Event: Signal<T...>,
	Fire: (self: Event<T...>, T...) -> (),
}

--[=[
	@within TypedRemote
	@interface Function<T..., R...>
	.InvokeServer (self: Function<T..., R...>, T...) -> R...,
	.OnServerInvoke (player: Player, T...) -> R...,
]=]
export type Function<T..., R...> = Instance & {
	Invoke: (self: Function<T..., R...>, T...) -> R...,
	OnInvoke: (T...) -> R...,
}

local IS_SERVER = game:GetService("RunService"):IsServer()

local TypedBindable = {}

--[=[
	@return ((name: string) -> BindableFunction, (name: string) -> BindableEvent)

	Creates a memoized version of the `func` and `event` functions that include the `parent`
	in each call.

	```lua
	-- Create RF and RE functions that use the current script as the instance parent:
	local RF, RE = TypedRemote.parent(script)

	local remoteFunc = RF("RemoteFunc")
	```
]=]
function TypedBindable.parent(parent: Instance)
	return function(name: string)
		return TypedBindable.func(name, parent)
	end, function(name: string)
		return TypedBindable.event(name, parent)
	end
end

--[=[
	Creates a BindableFunction with `name` and parents it inside of `parent`.
	
	If the `parent` argument is not included or is `nil`, then it defaults to the parent of
	this TypedRemote ModuleScript.
]=]
function TypedBindable.func(name: string, parent: Instance): BindableFunction
	local rf: BindableFunction
	rf = Instance.new("BindableFunction")
	rf.Name = name
	rf.Parent = if parent then parent else script
	return rf
end

--[=[
	Creates a BindableEvent with `name` and parents it inside of `parent`.
	
	If the `parent` argument is not included or is `nil`, then it defaults to the parent of
	this TypedRemote ModuleScript.
]=]
function TypedBindable.event(name: string, parent: Instance?): BindableEvent
	local re: BindableEvent
	re = Instance.new("BindableEvent")
	re.Name = name
	re.Parent = if parent then parent else script
	return re
end

table.freeze(TypedBindable)

return TypedBindable]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042fe</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXEA284B251FAA42C8B32554701F72E548">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">339e857ed4bf1bf507724d6e0000f083</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_TimeKeeper</string>
							<string name="ScriptGuid">{AA678196-66C8-4D31-966B-265A26E31E32}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 10/8/24
--[[@description:
	Provides signals that fire when the year, month, day, hour, and minute changes.
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local Signal = require(script.Parent._Signal)
local Trove = require(script.Parent._Trove)
-- path: lib/lib/ModuleUtils/_TimeKeeper -> ../FunctionUtils = script.Parent.Parent.FunctionUtils
local FunctionUtils = require(script.Parent.Parent.FunctionUtils)

-----------------------------
-- TYPES --
-----------------------------
-- ../GlobalTypes -> script.Parent.Parent.GlobalTypes
local GlobalTypes = require(script.Parent.Parent.GlobalTypes)
-- This is for all of the properties of an object made from this class for type annotation purposes.
type self = {
	_trove: Trove.TroveType,
	_previousTimestamp: DateTime,
	_startDateTime: DateTime,

	Signals: {
		-- Fires when year, month, day, hour, minute, or second changes.
		TimeChanged: Signal.Signal<
			(previous: UniversalTimestamp, current: UniversalTimestamp) -> (),
			(UniversalTimestamp, UniversalTimestamp)
		>,

		YearChanged: Signal.Signal<(previous: number, current: number) -> (), (number, number)>,
		MonthChanged: Signal.Signal<(previous: number, current: number) -> (), (number, number)>,
		DayChanged: Signal.Signal<(previous: number, current: number) -> (), (number, number)>,
		HourChanged: Signal.Signal<(previous: number, current: number) -> (), (number, number)>,
		MinuteChanged: Signal.Signal<(previous: number, current: number) -> (), (number, number)>,
		SecondChanged: Signal.Signal<(previous: number, current: number) -> (), (number, number)>,
	},
}

export type UniversalTimestamp = GlobalTypes.UniversalTimestamp

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}
local MT = {}
MT.__index = MT
export type TimeKeeper = typeof(setmetatable({} :: self, MT))

-- CONSTANTS --

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------
local dateTimeNow = DateTime.now

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Creates and returns a TimeKeeper.
-- Optionally provide your own starting point.
function Module.new(startingPoint: DateTime?): TimeKeeper
	local self = setmetatable({} :: self, MT)
	self._trove = Trove.new()
	local timeNow = dateTimeNow()
	self._previousTimestamp = timeNow
	self._startDateTime = (startingPoint or timeNow)

	self.Signals = {
		TimeChanged = self._trove:Construct(Signal),
		YearChanged = self._trove:Construct(Signal),
		MonthChanged = self._trove:Construct(Signal),
		DayChanged = self._trove:Construct(Signal),
		HourChanged = self._trove:Construct(Signal),
		MinuteChanged = self._trove:Construct(Signal),
		SecondChanged = self._trove:Construct(Signal),
	}

	self._trove:Connect(RunService.Heartbeat, function()
		local now = dateTimeNow()
		local currentTimestamp = now:ToUniversalTime()
		local previousTimestamp = self._previousTimestamp:ToUniversalTime()
		local changed = false

		if previousTimestamp.Year ~= currentTimestamp.Year then
			changed = true
			self.Signals.YearChanged:Fire(previousTimestamp.Year, currentTimestamp.Year)
		end

		if previousTimestamp.Month ~= currentTimestamp.Month then
			changed = true
			self.Signals.MonthChanged:Fire(previousTimestamp.Month, currentTimestamp.Month)
		end

		if previousTimestamp.Day ~= currentTimestamp.Day then
			changed = true
			self.Signals.DayChanged:Fire(previousTimestamp.Day, currentTimestamp.Day)
		end

		if previousTimestamp.Hour ~= currentTimestamp.Hour then
			changed = true
			self.Signals.HourChanged:Fire(previousTimestamp.Hour, currentTimestamp.Hour)
		end

		if previousTimestamp.Minute ~= currentTimestamp.Minute then
			changed = true
			self.Signals.MinuteChanged:Fire(previousTimestamp.Minute, currentTimestamp.Minute)
		end

		if previousTimestamp.Second ~= currentTimestamp.Second then
			changed = true
			self.Signals.SecondChanged:Fire(previousTimestamp.Second, currentTimestamp.Second)
		end

		if changed then
			self.Signals.TimeChanged:Fire(previousTimestamp, currentTimestamp)
		end

		self._previousTimestamp = now
	end)

	return self
end

-- Creates and returns a TimeKeeper with a starting point defined by the timestamp.
function Module.fromTimestamp(startingTimestamp: UniversalTimestamp): TimeKeeper
	return Module.new(FunctionUtils.DateTime.fromTimestamp(startingTimestamp))
end

function Module:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")

	return getmetatable(object).__index == MT
end

-- Updates the start timestamp to dateTime.
-- This will reset the signals to calculate when seconds/minutes/etc changes from this new start time.
function MT.SetStartTime(self: TimeKeeper, dateTime: DateTime)
	self._startDateTime = dateTime
	self._previousTimestamp = dateTime
end

-- Updates the start timestamp to now.
-- Shorthand for <code>:SetStartTime(DateTime.now())</code>
function MT.AdvanceToNow(self: TimeKeeper)
	self:SetStartTime(dateTimeNow())
end

-- Checks if the amount of seconds that has elapsed since the start time is greater than the window duration.
function MT.HasWindowElapsed(self: TimeKeeper, windowDurationInSeconds: number): boolean
	return self:GetElapsedSeconds() >= windowDurationInSeconds
end

-- Get the amount of time that has passed since the last recorded start timestamp.
function MT.GetElapsedSeconds(self: TimeKeeper): number
	return dateTimeNow().UnixTimestamp - self._startDateTime.UnixTimestamp
end

-- Return the last recorded start DateTime for this object.
function MT.GetStartDateTime(self: TimeKeeper): DateTime
	return self._startDateTime
end

-- Get the math.floored amount of days elapsed since the start timestamp.
function MT.GetDaysSinceStart(self: TimeKeeper): number
	return math.floor(self:GetElapsedSeconds() / 86400)
end

-- Returns the current global timestamp.
function MT.GetCurrentTime(self: TimeKeeper): UniversalTimestamp
	return dateTimeNow():ToUniversalTime()
end

-- Gets the current global time offset by secondsOffset
function MT.GetTimeWithOffset(self: TimeKeeper, secondsOffset: number): UniversalTimestamp
	local currentTime = dateTimeNow().UnixTimestamp
	local correctedTime = currentTime + secondsOffset

	return DateTime.fromUnixTimestamp(correctedTime):ToUniversalTime()
end

function MT.Destroy(self: TimeKeeper)
	self._trove:Clean()
end

-----------------------------
-- MAIN --
-----------------------------
return Module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000042ff</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX3B5F21FA580B46FAB27F3E61E4B126DA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">75f753b1f00199f9078d9a670000d950</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_PredicateManager</string>
							<string name="ScriptGuid">{081C2889-79FB-4298-BB4F-B84DF319A0C8}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 11/20/24
--[[@description:
	A manager for collecting predicates and firing events when new predicates are added or removed.
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local Trove = require(script.Parent._Trove)
local Signal = require(script.Parent._Signal)
local Logger = require(script.Parent._Logger)

-----------------------------
-- TYPES --
-----------------------------
-- For all of the properties/fields of an object made from this class.
type Predicate = (...any) -> (boolean, string?)

type fields = {
	_trove: Trove.TroveType,
	Signals: {
		PredicateAdded: Signal.SignalType<() -> (), ()>,
		PredicateRemoved: Signal.SignalType<() -> (), ()>
	},
	_defaultEvaluation: boolean,
	_predicates: { [string]: Predicate }
}

-----------------------------
-- VARIABLES --
-----------------------------
local PredicateManager = {}
local MT = {}
MT.__index = MT
export type PredicateManager = typeof(setmetatable({} :: fields, MT))

local logger = Logger.new(script.Name)

-- CONSTANTS --

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- <strong>defaultEvaluation</strong>: What the manager should return from :Evaluate() by default if there are no predicates. Default is true.
function PredicateManager.new(defaultEvaluation: boolean?): PredicateManager
	local self = setmetatable({} :: fields, MT)
	
	self._trove = Trove.new()
	self.Signals = {
		PredicateAdded = self._trove:Construct(Signal),
		PredicateRemoved = self._trove:Construct(Signal)
	}
	self._defaultEvaluation = if defaultEvaluation ~= nil then defaultEvaluation else true
	self._predicates = {}

	return self
end

function PredicateManager:BelongsToClass(object: any)
	logger:assert(typeof(object) == "table", "Expected table for object!", true)

	return getmetatable(object).__index == MT
end

function MT.AddPredicate(self: PredicateManager, identifier: any, isAble: Predicate)
	if self._predicates[identifier] then
		logger:warn(`Overriding predicate with identifier: {identifier}`, true)
	end
	self._predicates[identifier] = isAble
	self.Signals.PredicateAdded:Fire()
end

function MT.RemovePredicate(self: PredicateManager, identifier: any)
	self._predicates[identifier] = nil
	self.Signals.PredicateRemoved:Fire()
end

-- Evaluates all predicates. If any predicates return false, this will return false.
-- If there are no predicates, this will return the default value supplied to the constructor (true).
-- If there are predicates and all passed, this will return true.
function MT.Evaluate(self: PredicateManager, ...: any?): (boolean, string?)
	local gotPredicate = false
	for _, predicate in pairs(self._predicates) do
		gotPredicate = true
		local success, msg = predicate(...)
		if not success then
			return false, msg
		end
	end
	return if gotPredicate then true else self._defaultEvaluation
end

function MT.Destroy(self: PredicateManager)
	self._trove:Clean()
	setmetatable(self :: any, nil)
	table.clear(self :: any)
end

-----------------------------
-- MAIN --
-----------------------------
return PredicateManager]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004300</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX60EFB8F390AC4AF0A74051C4134CB3A9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">339e857ed4bf1bf507724d6e0000f085</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_CallbackManager</string>
							<string name="ScriptGuid">{B688DE4F-6545-4359-B5A2-B27BD2E9B66C}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 11/20/24
--[[@description:
	A manager for collecting callbacks and firing events when new callbacks are added or removed.
	Similar to the PredicateManager except these callbacks are not required to return booleans and nothing is evaluated.
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local Trove = require(script.Parent._Trove)
local Signal = require(script.Parent._Signal)
local Logger = require(script.Parent._Logger)

-----------------------------
-- TYPES --
-----------------------------
type Callback = (...any) -> ()

type fields = {
	_trove: Trove.TroveType,
	Signals: {
		CallbackAdded: Signal.SignalType<() -> (), ()>,
		CallbackRemoved: Signal.SignalType<() -> (), ()>
	},
	_callbacks: { [string]: Callback }
}

-----------------------------
-- VARIABLES --
-----------------------------
local CallbackManager = {}
local MT = {}
MT.__index = MT
export type CallbackManager = typeof(setmetatable({} :: fields, MT))

local logger = Logger.new(script.Name)

-- CONSTANTS --

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Creates a new callback manager.
function CallbackManager.new(): CallbackManager
	local self = setmetatable({} :: fields, MT)
	
	self._trove = Trove.new()
	self.Signals = {
		CallbackAdded = self._trove:Construct(Signal),
		CallbackRemoved = self._trove:Construct(Signal)
	}
	self._callbacks = {}

	return self
end

function CallbackManager:BelongsToClass(object: any)
	logger:assert(typeof(object) == "table", "Expected table for object!", true)

	return getmetatable(object).__index == MT
end

function MT.AddCallback(self: CallbackManager, identifier: any, callback: Callback)
	if self._callbacks[identifier] then
		logger:warn(`Overriding callback with identifier: {identifier}`, true)
	end
	self._callbacks[identifier] = callback
	self.Signals.CallbackAdded:Fire()
end

function MT.RemoveCallback(self: CallbackManager, identifier: any)
	self._callbacks[identifier] = nil
	self.Signals.CallbackRemoved:Fire()
end

-- Calls all the callbacks with the given arguments.
function MT.Call(self: CallbackManager, ...: any?)
	for _, callback in pairs(self._callbacks) do
		task.spawn(callback, ...)
	end
end

function MT.Destroy(self: CallbackManager)
	self._trove:Clean()
end

-----------------------------
-- MAIN --
-----------------------------
return CallbackManager]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004301</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4168599BD7404F0398922817A3F893D0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">339e857ed4bf1bf507724d6e0000f087</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_AdjustmentPool</string>
							<string name="ScriptGuid">{81E53AE1-38A3-423C-9635-D4A1998F586B}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 11/1/24
--[[@description:
	Pools together different multipliers & offsets and can calculate the proper value after all offsets & multipliers are applied.
	This is VERY useful for multiple different scripts that attempt to modify the same property.
	
	For example, if there is a module that modifies walk speed for spriting & another that modifies walk speed for crouching,
	how can we pool their modifiers together and get a final result?
	
	Another example: a module that modifies camera FOV for guns & a module that modifies camera FOV when sprinting.
	We want to pool the modifiers together so we don't have either module interfering with each other!
]]
-----------------------------
-- SERVICES --
-----------------------------
--local ReplicatedStorage = game:GetService("ReplicatedStorage")

-----------------------------
-- DEPENDENCIES --
-----------------------------
--local lib = require(script.Parent.Parent.Parent)
local FunctionUtils = require(script.Parent.Parent.FunctionUtils)
local Trove = require(script.Parent._Trove)
local Signal = require(script.Parent._Signal)

-----------------------------
-- TYPES --
-----------------------------
type ModifierType = "O" | "M"
type ModifierEntry = { V: any, P: number, T: ModifierType }
type fields = {
	_trove: Trove.TroveType,
	Signals: {
		Changed: Signal.Signal<() -> (), ()>, -- Fired when a modifier is added/removed or the initial value is changed.
		Destroying: Signal.Signal<() -> (), ()>, -- Fired right before the pool is destroyed
	},
	_identifier: string,
	_initial: AcceptedValues,
	_modifiers: { [any]: ModifierEntry }, -- V is value, P is priority, T is type
	_cachedResultMixed: any?, -- Result of offsets & multipliers mixed based on priority
	_cachedResultOffsetsFirst: any?, -- Result of offsets first and then multipliers based on priority
	_cachedResultsMultipliersFirst: any?, -- Result of multiplier first and then offsets based on priority
}

-----------------------------
-- VARIABLES --
-----------------------------
local AdjustmentPool = {}
local MT = {}
MT.__index = MT
export type AdjustmentPool = typeof(setmetatable({} :: fields, MT))
export type AcceptedValues = number | Vector3 | Vector2

local objectCache: { AdjustmentPool } = {}

-- CONSTANTS --

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Creates and returns a new <code>AdjustmentPool</code>, or returns one if it already exists.
-- <strong>identifier</strong>: An optional ID for this pool. Further calls to <code>.new()</code> with the same ID will return the same pool.
-- <strong>starting</strong>: The initial value that all modifiers will be calculated upon. Serves as the basis for the pooled adjustments.
-- If not provided, the default initial value is 0.
function AdjustmentPool.new(identifier: string?, initial: AcceptedValues?): AdjustmentPool
	local whatType = typeof(initial)
	assert(
		whatType == "number" or whatType == "Vector3" or whatType == "Vector2" or whatType == "nil",
		"Invalid starting value."
	)
	if identifier then
		local self = AdjustmentPool:GetObject(identifier)
		if self then
			return self
		end
	end

	identifier = identifier :: string
	if not identifier then
		repeat
			identifier = FunctionUtils.Base64.random()
		until not AdjustmentPool:GetObject(identifier :: any)
	end

	local myTrove = Trove.new()
	local self: fields = {
		_trove = myTrove,
		Signals = {
			Changed = myTrove:Construct(Signal),
			Destroying = myTrove:Construct(Signal),
		},
		_identifier = identifier,
		_initial = initial or 0,
		_modifiers = {},
	} :: fields

	setmetatable(self, MT)
	table.insert(objectCache, self)
	return self
end

function AdjustmentPool:GetObject(identifier: string): AdjustmentPool?
	for _, obj in ipairs(objectCache) do
		if obj:Identifier() == identifier then
			return obj
		end
	end
	return
end

function AdjustmentPool:BelongsToClass(object: any): boolean
	assert(typeof(object) == "table", "Expected table for object!")

	local mt = getmetatable(object)
	return mt ~= nil and mt.__index == MT
end

function MT.Identifier(self: AdjustmentPool): string
	return self._identifier
end

--[[
	Observes whenever the pooled total changes/pool is destroyed.
	Total is calculated by the given <code>mode</code>, default is <code>Mixed</code>.
]]
function MT.Observe(
	self: AdjustmentPool,
	callback: (newValue: AcceptedValues) -> (() -> ())?,
	guard: ((AcceptedValues) -> boolean)?,
	mode: ("Mixed" | "OffsetsFirst" | "SummedMultipliers")?
)
	local valueGuard: any = guard or function(_v)
		return true
	end

	local cleanupFn: (() -> ())?
	local changeId = 0
	local changedConn: Signal.Connection
	local destroyConn: Signal.Connection

	local function evaluate(): AcceptedValues
		if mode == "OffsetsFirst" then
			return self:EvaluateTotalByOffsetsFirst()
		elseif mode == "SummedMultipliers" then
			return self:EvaluateTotalBySummedMultipliers()
		else
			return self:EvaluateTotalMixed()
		end
	end

	local function onChanged()
		if cleanupFn then
			task.spawn(cleanupFn)
			cleanupFn = nil
		end

		changeId += 1
		local thisId = changeId
		local newValue = evaluate()
		if not valueGuard(newValue) then
			return
		end

		task.spawn(function()
			local success, result = xpcall(function()
				return callback(newValue)
			end, function(err)
				return `{err}\n{debug.traceback()}`
			end)
			if success then
				if typeof(result) == "function" and changedConn.Connected and thisId == changeId then
					cleanupFn = result
				elseif typeof(result) == "function" then
					task.spawn(result)
				end
			else
				warn(result)
			end
		end)
	end

	local function doTeardown()
		if changedConn.Connected then
			changedConn:Disconnect()
		end
		if destroyConn.Connected then
			destroyConn:Disconnect()
		end
		if cleanupFn then
			task.spawn(cleanupFn)
			cleanupFn = nil
		end
	end

	changedConn = self.Signals.Changed:Connect(onChanged)
	destroyConn = self.Signals.Destroying:Connect(doTeardown)

	task.defer(onChanged)

	return doTeardown
end

-- Changes the initial value.
function MT.ChangeInitial(self: AdjustmentPool, new: AcceptedValues)
	self._initial = new
	self:_ClearCachedResults()
end

-- An all in one function of AddMultiplier or AddOffset
function MT.AddModifier(
	self: AdjustmentPool,
	identifier: any,
	value: any,
	modifierType: ModifierType,
	priority: number?
)
	self._modifiers[identifier] = { V = value, P = priority or 1, T = modifierType }
	self:_ClearCachedResults()
end

-- Gets the value of the modifier (if it exists)
function MT.GetModifierValue(self: AdjustmentPool, identifier: any): any
	return if self._modifiers[identifier] then self._modifiers[identifier].V else nil
end

-- Gets the type of the modifier (if it exists)
function MT.GetModifierType(self: AdjustmentPool, identifier: any): ModifierType?
	return if self._modifiers[identifier] then self._modifiers[identifier].T else nil
end

function MT.RemoveModifier(self: AdjustmentPool, identifier: any)
	self._modifiers[identifier] = nil
	self:_ClearCachedResults()
end

function MT.AddMultiplier(self: AdjustmentPool, identifier: any, value: any, priority: number?)
	self._modifiers[identifier] = { V = value, P = priority or 1, T = "M" }
	self:_ClearCachedResults()
end

---@deprecated
function MT.RemoveMultiplier(self: AdjustmentPool, identifier: any)
	warn("Deprecated. Use :RemoveModifier() instead\n", debug.traceback())
	self._modifiers[identifier] = nil
	self:_ClearCachedResults()
end

function MT.AddOffset(self: AdjustmentPool, identifier: any, value: any, priority: number?)
	self._modifiers[identifier] = { V = value, P = priority or 1, T = "O" }
	self:_ClearCachedResults()
end

---@deprecated
function MT.RemoveOffset(self: AdjustmentPool, identifier: any)
	warn("Deprecated. Use :RemoveModifier() instead\n", debug.traceback())
	self._modifiers[identifier] = nil
	self:_ClearCachedResults()
end

function MT.GetInitial(self: AdjustmentPool): AcceptedValues
	return self._initial
end

-- DEPRECATED!
-- Takes the inital value and applies all offsets & multipliers and returns the result. Results are cached to improve performance.
-- If any multipliers/offsets/initial value are changed, the result will be recalculated and recached.
-- <strong>offsetsFirst</strong>: If true, offsets are calculated first before multipliers (sorted by priority).
-- If false, multipliers are calculated first and then offsets are added (sorted by priority).
-- If nil, multipliers and offsets are mixed together (sorted by priority).
---@deprecated
function MT.EvaluateTotal(self: AdjustmentPool, offsetsFirst: boolean?): any
	local t = typeof(offsetsFirst)
	assert(t == "boolean" or t == "nil", "Invalid offsetsFirst value!")
	if offsetsFirst == true and self._cachedResultOffsetsFirst then
		return self._cachedResultOffsetsFirst
	elseif offsetsFirst == false and self._cachedResultsMultipliersFirst then
		return self._cachedResultsMultipliersFirst
	elseif offsetsFirst == nil and self._cachedResultMixed then
		return self._cachedResultMixed
	end

	local modifiers = FunctionUtils.Table.toArray(self._modifiers)
	local result
	-- OFFSETS FIRST
	if offsetsFirst == true then
		table.sort(modifiers, function(a: ModifierEntry, b: ModifierEntry)
			if a.T == b.T then
				return a.P > b.P
			end
			return a.T == "O"
		end)
		result = self._initial
		for _, entry in ipairs(modifiers) do
			result = if entry.T == "O" then result + entry.V else result * entry.V
		end
		self._cachedResultOffsetsFirst = result
	end

	-- MULTIPLIERS FIRST
	if offsetsFirst == false then
		table.sort(modifiers, function(a: ModifierEntry, b: ModifierEntry)
			if a.T == b.T then
				return a.P > b.P
			end
			return a.T == "M"
		end)
		result = self._initial
		for _, entry in ipairs(modifiers) do
			result = if entry.T == "M" then result * entry.V else result + entry.V
		end
		self._cachedResultsMultipliersFirst = result
	end

	-- PRIORITY SORT
	if offsetsFirst == nil then
		table.sort(modifiers, function(a: ModifierEntry, b: ModifierEntry)
			return a.P > b.P
		end)
		result = self._initial
		for _, entry in ipairs(modifiers) do
			result = if entry.T == "M" then result * entry.V else result + entry.V
		end
		self._cachedResultMixed = result
	end

	return result
end

--[[
	Evaluates the total by multiplying against the initial value and then adding offsets afterwards.
]]
function MT.EvaluateTotalByOffsetsFirst(self: AdjustmentPool): any
	if self._cachedResultOffsetsFirst then
		return self._cachedResultOffsetsFirst
	end

	local modifiers = FunctionUtils.Table.toArray(self._modifiers)
	table.sort(modifiers, function(a, b)
		if a.T == b.T then
			return a.P > b.P
		end
		return a.T == "O"
	end)

	local result = self._initial
	for _, entry in ipairs(modifiers) do
		result = if entry.T == "O" then result + entry.V else result * entry.V
	end

	self._cachedResultOffsetsFirst = result
	return result
end

--[[
	Evaluates the total by multiplying & adding based on priority.
]]
function MT.EvaluateTotalMixed(self: AdjustmentPool): any
	if self._cachedResultMixed then
		return self._cachedResultMixed
	end

	local modifiers = FunctionUtils.Table.toArray(self._modifiers)
	table.sort(modifiers, function(a, b)
		return a.P > b.P
	end)

	local result = self._initial
	for _, entry in ipairs(modifiers) do
		result = if entry.T == "M" then result * entry.V else result + entry.V
	end

	self._cachedResultMixed = result
	return result
end

--[[
	Evaluates the total by applying all offsets first, summing all multipliers, then multiplying once.
]]
function MT.EvaluateTotalBySummedMultipliers(self: AdjustmentPool): any
	local offsetSum: any = self._initial
	local multiplierSum = 0
	local hasMultipliers = false

	for _, entry in self._modifiers do
		if entry.T == "O" then
			offsetSum += entry.V
		elseif entry.T == "M" then
			multiplierSum += entry.V
			hasMultipliers = true
		end
	end

	if not hasMultipliers then
		multiplierSum = 1
	end

	return offsetSum * multiplierSum
end

-- Call when a modifier is changed or the initial value is changed.
function MT._ClearCachedResults(self: AdjustmentPool)
	self._cachedResultOffsetsFirst = nil
	self._cachedResultsMultipliersFirst = nil
	self._cachedResultMixed = nil
	self.Signals.Changed:Fire()
end

function MT.Destroy(self: AdjustmentPool)
	self.Signals.Destroying:Fire()
	table.remove(objectCache, table.find(objectCache, self))
end

-----------------------------
-- MAIN --
-----------------------------
return AdjustmentPool
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004302</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXE5A1F71FE63F4A918A2BEE08A3C3C9C1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc08218013000096d9</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_CollisionParticles</string>
							<string name="ScriptGuid">{7A976C18-FF46-4806-A00E-6212B88C2FB7}</string>
							<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native
--[[
This Module is Open Source. You can edit it however you like.
You don't need to credit me when you use it (But i would be happy if you would)
If you any ideas or you know how I can Optimize it, you can reply to my Post on Roblox DevForum.
If you don't know how this thing works, you can check my Post on DevForum. It is hard to use because i made it badly.

https://devforum.roblox.com/t/collideable-particles-fx-self-collisions-update-v32/2279402

!!!REMEMBER!!!
You shouldn't replace every Roblox Particles with this module because it can cause lag.
Even tho this module is optimized, making too many particles can affect performance on low end devices.
If you really need to simulate crazy amount of particles, you can try tweaking some setting to make it more performant at cost of accuracy.
]]
-- VERSION: 4.02
type BaseParticle = {Part:BasePart, Pos:vector, Velocity:vector, Delta:number, LifeTime:number, CamLastTime:boolean, Rand:number}
type Emitter = {
	EmmiterObject:BasePart?, --Object that will Emit Particles
	Folder:Folder?, --Folder where particles will be Parented to when created.
	Part:BasePart?, --Object that the emmiter will emmit.
	Enabled:boolean, --Determines whenever Emitter is Emitting Particles on it's own.

	Collisions:boolean, --Determines if Particles Collide with environment.
	ColliderSize:number, --Size of the collider.
	LifeOnCollision:number, --Lowers the particles lifetime after collision. Setting to 0 makes them disapear on collision, setting it to higher than max lifetime does nothing.
	CollisionChunkSize:number, --After update 4 collisions now use chunks to avoid using too many workspace calls for collisions. Basically set it to a value between 8-16.
	CollisionGroup:string, --Uses Roblox Collisions Groups. Change it to group particles will use for collisions.
	FixHumanoidCollisions:boolean, --As parts with CanCollide turned off no longer collide with particles, by enabling this, you can revert better collisions with players. Still in testing.

	Friction:number, --Changes how much sliding of Particles against surfaces slows them down.
	Bounce:number, --How strongly Particles Bounce. If 1, it bounces with the same velocity. If 0, it doesn't bounce at all. If 0.5, it decreases velocity by half when bouncing.
	Speed:NumberRange, --The starting speed of Particles when they are created.
	InheritSpeed:number, --Determines how much Emitter Velocity affects Particles Velocity
	Spread:Vector2, --The spread of Particles. If 0 they will all go in one direction.
	Rate:number, --How many Particles are created per second.
	LifeTime:NumberRange, --How long Particles will last.
	Drag:number, --How much air slows down the particles. 0.6 seems realistic.
	Acceleration:vector, --Force applied on Particles. Can be used to create Gravity.

	SelfCollisions:boolean, --Performance Hungry! (i think...). Basically makes it possible for collisions between particles.
	SelfCollType:"Default"|"Realistic"|"Fluid", --Type of Collision Algorithm to use when particles collide with eachother.
	Iterations:number, --Only used for Self Collisions. Collisions with environment are calculated at 60 fps. Makes Self Collisions more accurate at cost of performance.
	SelfSize:number, --Radius used for Collisions between particles, do not confuse with ColliderSize.
	Mass:number, --Used for Realistic Type Self Collisions.
	FluidForce:number, --Used for Fluid Type Self Collisions
	SimulateTurbulence:boolean, --Used for simulating. Well, wind turbulence. Objects affect wind, wind affects particles.

	MinimumCachce:number, --Makes it so that amount of cachced particles cannot be smaller than this number. Useful when creating explosions using Emit Function.
	FaceCamera:boolean, --Toggles whenever particles face the camera.
	CameraCulling:boolean, --Toggles whenever particles position update when they are not visible to camera. Should be mostly keep on unless facing issues. If particles use trails, use the TrailFix Property.
	CullingRadius:number?, --Defaults to ColliderSize if nil. Changes how big the sphere is that is used for CameraCulling. It is recommended to set it to the size of the Part that is being emitted in case ColliderSize property is smaller than part.
	RenderDistance:number, --Ingored when CameraCulling is Disabled. Changes how far particles can render. They are still simulated unless you disable the emitter.

	--Explanation on these in the DevForum Post.
	EveryFrame:nil | (Position:vector, Velocity:vector, LifeTime:number)->{[string]:any?},
	OnCollision:nil | (Position:vector, Velocity:vector, LifeTime:number, HitPart:BasePart)->{[string]:any?},
	OnSpawn:nil | (Position:vector, Velocity:vector, LifeTime:number)->{[string]:any?},
	OnDespawn:nil | ()->{[string]:any?},
	BeforePhysics:nil | ()->nil,

	Wind:boolean, --If true, Particles will be affected by wind.
	WindSpeed:number, --How fast wind flows.
	WindScale:number, --How frequent are the changes in the perlin noise of wind.
	WindDifference:NumberRange, --Controls the min and max force by wind. Setting it to (-1, 1) makes the particles sway in both ways.
	WindDirection:vector, --Direction of wind.
	--Wind Strenght is Deprecated. Similar result can be achieved with WindDifference property by setting it to (0, Strenght).

	DistanceFPS:number, --At which Distance Particles will update with lower FPS

	TrailFix:{{string}|string}|boolean|string, --Fix the annyoing Trails. Explanation on DevForum post.

	SyncToRenderToggle:(self: Emitter, boolean)->nil, --Should particles sync with Simulation or Rendering. If false, it will run at 60 fps (that's simulation fps). If true then it will sync with render which can make it look smoother when using more than 60 fps but can cause stuttering.
	AddForce:(self: Emitter)->nil,
	Emit:(self: Emitter, number)->nil,
	Destroy:(self: Emitter)->nil
}

local TheForcesTable = {
	["Repel"] = {["Type"] = "Repel", ["Position"] = vector.zero, ["Range"] = 12, ["Power"] = 15},
	["RepelConstant"] = {["Type"] = "RepelConstant", ["Position"] = vector.zero, ["Range"] = math.huge, ["Power"] = 15},
	["Turbulence"] = {["Type"] = "Turbulence", ["Position"] = vector.zero, ["Power"] = 15, ["Scale"] = 0.25}
}

type moduleType = {
	SelfCollType:{Default:"Default", Realistic:"Realistic", Fluid:"Fluid"}, --Enum
	TypeForce:{Repel:"Repel", RepelConstant:"RepelConstant", Turbulence:"Turbulence"}, --Enum
	NewForce:(string)->{}, --Returns a new force that can be used on emitter.
	new:()->Emitter
}

local module : moduleType = {}

module.SelfCollType = table.freeze {
	Default = "Default",
	Realistic = "Realistic",
	Fluid = "Fluid"
}

module.TypeForce = table.freeze {
	Repel = "Repel",
	RepelConstant = "RepelConstant",
	Turbulence = "Turbulence"
}
--Require a module used for Frustum Culling the particles.
local FRUSTUM = require(script._FrustumCulling)
--Require a module for collisions algorithms.
local CollisionAlgorithms = require(script._CollisionsAlgorithms)

local CollidersForShapes = {
	[Enum.PartType.Block] = CollisionAlgorithms.BoxSphereIntersectionOptimized,
	[Enum.PartType.Ball] = CollisionAlgorithms.BallSphereIntersectionOptimized,
	[Enum.PartType.Cylinder] = CollisionAlgorithms.CylinderSphereIntersectionOptimized,
}

local MeshCollFallback = CollisionAlgorithms.BoxSphereIntersectionOptimized

local Rand : Random = Random.new()
--Reflect vector off a surface normal.
local function Reflect(dir : vector, normal : vector)
	return (dir - (2 *  vector.dot(dir, normal) * normal))
end

local function GetGridPosition(Vec : vector, Size : number)
	return Vec // Size
end

local function ApplyProtertiesInstance(part : Instance, Properties : {})
	for name, val in pairs(Properties) do
		if typeof(val) == "table" then
			local Assign = part:FindFirstChild(name)
			ApplyProtertiesInstance(Assign, val)
		else
			part[name] = val
		end
	end
end
local function ApplyProperties(Properties:{})
	for part, pops in pairs(Properties) do
		for name, val in pairs(pops) do
			if typeof(val) == "table" then
				local Assign = part:FindFirstChild(name)
				ApplyProtertiesInstance(Assign, val)
			else
				part[name] = val
			end
		end
	end
end

--Pregenerate Vectors used to get Adjacent Cells in a Grid
local GridSearch : {vector} = {
	vector.create(1, 0, 0),
	-vector.create(1, 0, 0),
	vector.create(0, 1, 0),
	-vector.create(0, 1, 0),
	vector.create(0, 0, 1),
	-vector.create(0, 0, 1),
	vector.zero,
	vector.create(1, -1, -1),
	vector.create(1, -1, 0),
	vector.create(1, -1, 1),
	vector.create(0, -1, -1),
	vector.create(0, -1, 1),
	vector.create(-1, -1, -1),
	vector.create(-1, -1, 0),
	vector.create(-1, -1, 1),
	vector.create(1, 1, -1),
	vector.create(1, 1, 0),
	vector.create(1, 1, 1),
	vector.create(0, 1, -1),
	vector.create(0, 1, 1),
	vector.create(-1, 1, -1),
	vector.create(-1, 1, 0),
	vector.create(-1, 1, 1),
	vector.create(1, 0, 1),
	vector.create(-1, 0, 1),
	vector.create(1, 0, -1),
	vector.create(-1, 0, -1)

}

function module.NewForce(Type)
	return table.clone(TheForcesTable[Type])
end

--Lookup table that stores functions used when calculating forces on particles.
local AlghoritmForces = {
	["Repel"] = function(Forc, Pos, Vel) 
		if vector.magnitude(Pos - Forc.Position) < Forc.Range then
			return (Forc.Range - vector.magnitude(Pos - Forc.Position)) / Forc.Range * Forc.Power * vector.normalize(Pos - Forc.Position)
		else
			return vector.zero
		end
	end,
	["RepelConstant"] = function(Forc, Pos, Vel) 
		if vector.magnitude(Pos - Forc.Position) < Forc.Range then
			return Forc.Power * vector.normalize(Pos - Forc.Position)
		else
			return vector.zero
		end
	end,
	["Turbulence"] = function(Forc, Pos, Vel) 
		local ScaledForce = Forc.Position * Forc.Scale
		local ScaledPos = Pos* Forc.Scale
		return vector.create(math.noise( ScaledForce.X + ScaledPos.X, ScaledForce.Y, ScaledForce.Z), math.noise( ScaledForce.X, ScaledForce.Y + ScaledPos.Y, ScaledForce.Z), math.noise( ScaledForce.X, ScaledForce.Y, ScaledForce.Z + ScaledPos.Z)) * Forc.Power
	end
}

--Returns a new Emitter.
function module.new()
	debug.setmemorycategory("CollideableParticles") --Useful for debugging
	--You shouldn't change these Values in this script. You need to change them in your script, not in Module.
	local self : Emitter = {}
	self.EmmiterObject = nil --Object that will Emit Particles
	self.Folder = nil --Folder where particles will be Parented to when created.
	self.Enabled = false --Determines whenever Emitter is Emitting Particles on it's own.

	self.SelfCollType = "Realistic"
	self.SelfCollisions = false
	self.CollisionChunkSize = 8
	self.CollisionGroup = "Default"
	self.FixHumanoidCollisions = true
	self.Mass = 50
	self.Iterations = 1
	self.SelfSize = 1
	self.FluidForce = 1
	self.SimulateTurbulence = false
	self.Collisions = true
	self.LifeOnCollision = math.huge
	self.ColliderSize = 1
	self.Part = nil
	self.FaceCamera = false
	self.CameraCulling = true
	self.CullingRadius = nil
	self.RenderDistance = 512

	--You can find explanation of these functions on DevForum Post.
	self.EveryFrame = nil
	self.OnCollision = nil
	self.OnSpawn = nil
	self.OnDespawn = nil
	self.BeforePhysics = nil

	self.MinimumCachce = 20
	self.Friction = 0.6
	self.Bounce = 1
	self.Speed = NumberRange.new(1)
	self.InheritSpeed = 0
	self.Spread = Vector2.new(0, 0)
	self.Rate = 5
	self.LifeTime = NumberRange.new(1)
	self.Drag = 0
	self.Acceleration = vector.zero

	self.Wind = false
	self.WindSpeed = 0.8
	self.WindScale = 0.3
	self.WindDifference = NumberRange.new(0, 1)
	self.WindDirection = vector.create(50, 0, 0)

	self.DistanceFPS = 30
	self.TrailFix = false

	local Forces = {}
	local Particles : {BaseParticle} = {}
	local Cachce : {BasePart} = {}
	local Frame : number = 0
	local Index : number = 0

	function self:AddForce(Force)
		table.insert(Forces, Force)
	end

	--This is a function that you can use to emit particles by yourself. Useful for explosions.
	local function Emit(Rate)
		local Tabel = {}
		local SpreadX : number = self.Spread.X
		local SpreadY : number = self.Spread.Y
		local EmiCFrame : CFrame = self.EmmiterObject.CFrame
		local Size : vector = self.EmmiterObject.Size
		for i : number = 1, Rate do
			Index += 1
			local New = {}
			if #Cachce > 0 then
				New.Part = table.remove(Cachce, #Cachce)
			else
				New.Part = self.Part:Clone()
			end
			New.Part.CanCollide = false
			New.Part.CanTouch = false
			New.Part.CanQuery = false
			New.Part.Anchored = true
			New.Part.Locked = true
			New.Part.Parent = self.Folder

			New.LifeTime = Rand:NextNumber(self.LifeTime.Min, self.LifeTime.Max)
			New.Velocity = vector.zero
			New.Velocity = ((EmiCFrame * CFrame.Angles(math.rad(Rand:NextNumber(-SpreadX, SpreadX)), math.rad(Rand:NextNumber(-SpreadY, SpreadY)), 0)).LookVector * Rand:NextNumber(self.Speed.Min, self.Speed.Max)) + (self.EmmiterObject.AssemblyLinearVelocity * self.InheritSpeed)

			New.Pos = EmiCFrame.Position + EmiCFrame.RightVector *(Rand:NextNumber(-Size.X, Size.X) / 2) + EmiCFrame.UpVector * (Rand:NextNumber(-Size.Y, Size.Y) / 2) + EmiCFrame.LookVector * (Rand:NextNumber(-Size.Z, Size.Z) / 2)
			New.CamLastTime = false

			New.Delta = 0
			New.Rand = Rand:NextInteger(1, 1024)
			table.insert(Particles, 1, New)
			Index %= 12
			if self.OnSpawn then
				Tabel[New.Part] = self.OnSpawn(New.Pos, New.Velocity, 1)
			end
		end
		return Tabel	

	end

	function self:Emit(Ammount)
		local Properties = {}
		local Sav = Emit(Ammount)
		for i, v in pairs(Sav) do
			Properties[i] = v
		end
		for part, pops in pairs(Properties) do
			for name, val in pairs(pops) do
				part[name] = val
			end
		end
	end

	local Last :number = 0
	local Now :number = 0

	local function AdvanceTime(dt)
		Frame %= 36000
		Frame += 1
		local Properties = {}
		if self.Enabled and self.EmmiterObject then
			Now += dt
			local Rate :number = 1 / self.Rate
			local This :number = (Now - Last)
			if Now > Last + Rate then
				local Sav = Emit(This // Rate)
				for i, v in pairs(Sav) do
					Properties[i] = v
				end
				Last += (This // Rate) * Rate
			end
		else
			Last = Now
		end
		if Frame % 36 == 0 then
			if #Cachce > self.MinimumCachce then
				for i = 1, math.ceil((#Cachce - self.MinimumCachce) * 0.5) do
					Cachce[i]:Destroy()
					table.remove(Cachce, i)
				end
			end
		end
		local ColParams :OverlapParams = OverlapParams.new()
		ColParams.FilterType = Enum.RaycastFilterType.Exclude
		ColParams.FilterDescendantsInstances = {self.EmmiterObject, self.Folder}
		ColParams.CollisionGroup = self.CollisionGroup
		ColParams.RespectCanCollide = true
		local RayParams :RaycastParams = RaycastParams.new()
		RayParams.FilterType = Enum.RaycastFilterType.Exclude
		RayParams.FilterDescendantsInstances = {self.EmmiterObject, self.Folder}
		RayParams.CollisionGroup = self.CollisionGroup
		RayParams.RespectCanCollide = true
		if self.BeforePhysics then
			self.BeforePhysics()
		end
		task.desynchronize()
		local ColliderChunks : {[vector]:{BasePart}} = {}
		local Grid = {}
		local Parts : {BasePart} = {}
		local CFrames : {CFrame} = {}
		local TrailFixes : {[Part]:boolean} = {}
		local Cam : Camera = workspace.CurrentCamera
		local CamCFrame : CFrame = Cam.CFrame
		local CameraPlanes = FRUSTUM.getFrustum(Cam, self.RenderDistance)
		local GameTime : number = workspace.DistributedGameTime

		if Cam then
			local CamPos : vector? = nil
			if self.FaceCamera then
				CamPos = CamCFrame.Position
			end
			--debug.profilebegin("Particles") for some reason it's broken so don't use it
			for ind, this in pairs(Particles) do
				this.Delta += dt
				local thisPos : vector = this.Pos
				local thisVelocity : vector = this.Velocity
				local thisDelta : number = this.Delta
				for i, Forc in pairs(Forces) do
					thisVelocity += AlghoritmForces[Forc.Type](Forc, thisPos, thisVelocity) * dt
				end
				if (Frame + this.Rand) % math.ceil(vector.magnitude(CamCFrame.Position - thisPos) / self.DistanceFPS) == 0 then
					this.LifeTime -= thisDelta
					if this.LifeTime <= 0 then
						table.insert(Parts, this.Part)
						table.insert(CFrames, CFrame.new(0, -100, 0))
						if self.TrailFix then
							TrailFixes[this.Part] = false
						end
						table.insert(Cachce, this.Part)
						table.remove(Particles, ind)
						if self.OnDespawn then
							Properties[this.Part] = self.OnDespawn()
						end
						continue
					end
					local LastGrid : vector = GetGridPosition(thisPos, self.SelfSize)
					if self.SimulateTurbulence then
						--Fakes Objects Interacting with Wind which affects Particles
						local Colliders :{BasePart} = workspace:GetPartBoundsInRadius(thisPos, self.ColliderSize + 5, ColParams)
						local Moving : number = 0
						for i, v : BasePart in pairs(Colliders) do
							if vector.magnitude(v.AssemblyLinearVelocity) > 0.1 then
								Moving += 1
							end
						end
						for i, v : BasePart in pairs(Colliders) do
							if vector.magnitude(v.AssemblyLinearVelocity) > 0.1 then
								--this.Velocity += (v.Position - this.Pos).Unit:Cross(v.AssemblyLinearVelocity.Unit) * v.AssemblyLinearVelocity.Magnitude * this.Delta * 1
								local angle :number = math.acos(vector.dot(vector.normalize(v.AssemblyLinearVelocity), vector.normalize(thisPos-v.Position)))
								if angle < math.rad(80) then
									--This is Repel
									thisVelocity += (thisPos - ((CFrame.lookAt(v.Position, v.Position + v.AssemblyLinearVelocity) * CFrame.Angles(math.rad(25), 0, 0)).LookVector * vector.magnitude(thisPos - v.Position) + v.Position)) * thisDelta * vector.magnitude(v.AssemblyLinearVelocity) * 0.3 * (1 / Moving)

								else
									--This is Attract
									thisVelocity -= (thisPos - ((CFrame.lookAt(v.Position, v.Position + v.AssemblyLinearVelocity) * CFrame.Angles(math.rad(-5), 0, 0)).LookVector * vector.magnitude(thisPos - v.Position) + v.Position)) * thisDelta * vector.magnitude(v.AssemblyLinearVelocity) * 0.09 * (1 / Moving)

								end

							end
						end
					end

					local AlongSurfaceDir : vector?
					local Collided = false
					thisVelocity += self.Acceleration * thisDelta --Calculate Acceleration
					if self.Wind then
						thisVelocity += (self.WindDifference.Min + (self.WindDifference.Max - self.WindDifference.Min) * (math.noise(thisPos.X * self.WindScale, thisPos.Y * self.WindScale + GameTime * self.WindSpeed, thisPos.Z * self.WindScale) + 0.5)) * self.WindDirection * thisDelta
					end
					thisVelocity += (self.Drag*vector.magnitude(thisVelocity)*2*vector.normalize(-thisVelocity)) * thisDelta -- Simulate Air Drag
					thisVelocity = thisVelocity == thisVelocity and thisVelocity or vector.zero
					thisPos += thisVelocity * thisDelta --Move the Particle

					if self.Collisions then
						local Chunk : vector = thisPos // self.CollisionChunkSize
						local Col : {BasePart} = ColliderChunks[Chunk]
						if Col == nil then
							Col = workspace:GetPartBoundsInBox(CFrame.new((thisPos // self.CollisionChunkSize) * (vector.one * self.CollisionChunkSize) + vector.one * (self.CollisionChunkSize*0.5)), vector.one * (self.ColliderSize*2 + self.CollisionChunkSize), ColParams)
							if self.FixHumanoidCollisions then
								for colliderI, collider : BasePart in Col do
									if collider.Name == "HumanoidRootPart" then
										for connectedI, connected in collider:GetConnectedParts(true) do
											if not connected.CanCollide then
												if connected.Name ~= "Handle" and connected.Name ~= "HumanoidRootPart" then
													table.insert(Col, connected)
												end
											end
										end
									end
								end
							end
							ColliderChunks[Chunk] = Col
						end
						if #Col > 0 then
							for i, Coller in pairs(Col) do
								local Inside : boolean, Push : vector, Normal : vector
								if Coller:IsA("Part") then
									Inside, Push, Normal = (CollidersForShapes[Coller.Shape] or MeshCollFallback)(Coller.CFrame, Coller.Size, thisPos, self.ColliderSize)
								else
									Inside, Push, Normal = MeshCollFallback(Coller.CFrame, Coller.Size, thisPos, self.ColliderSize)
								end
								if Inside then
									Collided = Coller
									local CalculatedVel : vector = vector.zero
									--local Inside, Push, Normal = BoxPointIntersection(v.CFrame, v.Size, this.Pos)
									--CalculatedPos += (Push + (Normal * (ColliderSize / 2 + 0.01))) - this.Pos
									--CalculatedVel += v.AssemblyLinearVelocity + v.AssemblyAngularVelocity:Cross(this.Pos - v.Position)
									CalculatedVel += Coller:GetVelocityAtPosition(thisPos)


									--this.Velocity += CalculatedVel - this.Velocity + this.Velocity * Bounce
									local relativeVelocity : vector = CalculatedVel - thisVelocity 

									-- Calculate velocity components along normal and tangent directions
									local velocityAlongNormal : number = vector.dot(relativeVelocity, Normal)
									local tangentVelocity : vector = relativeVelocity - Normal * velocityAlongNormal
									AlongSurfaceDir = tangentVelocity
									-- Calculate friction force
									local frictionMagnitude : number = -self.Friction * vector.magnitude(tangentVelocity)
									local frictionForce : vector = vector.normalize(-tangentVelocity) * frictionMagnitude

									-- Calculate bounce vector
									local bounceVector : vector = Normal * (velocityAlongNormal * (self.Bounce + 1))

									-- Calculate final velocity
									local finalVelocity : vector = bounceVector + (frictionForce * thisDelta)

									-- Apply final velocity
									thisVelocity = thisVelocity + finalVelocity
									--this.Pos = CalculatedPos
									thisPos = Push
									-- + this.Velocity * this.Delta
								end
							end
							--CalculatedVel /= #Col

						end
					end

					if Collided then
						this.LifeTime = math.min(this.LifeTime, self.LifeOnCollision)
					end

					if self.CameraCulling then
						local Frusted = FRUSTUM.findInFrustumSphere(CameraPlanes, thisPos, self.CullingRadius or self.ColliderSize)
						--local ben, onScreen = Cam:WorldToScreenPoint(this.Part.Position)
						if Frusted then
							if not this.CamLastTime then
								if self.TrailFix then
									TrailFixes[this.Part] = true
								end
							end
							this.CamLastTime = true
							table.insert(Parts, this.Part)
							table.insert(CFrames, CFrame.lookAt(thisPos, CamPos or (thisPos + (AlongSurfaceDir or thisVelocity))))
							if self.EveryFrame and (not Properties[this.Part]) then
								Properties[this.Part] = self.EveryFrame(thisPos, thisVelocity, this.LifeTime / self.LifeTime.Max)
							end
						else
							if this.CamLastTime then
								table.insert(Parts, this.Part)
								table.insert(CFrames, CFrame.new(0, -100, 0))
								if self.TrailFix then
									TrailFixes[this.Part] = false
								end
								this.CamLastTime = false
							end
						end
						if Collided and self.OnCollision then
							Properties[this.Part] = self.OnCollision(thisPos, thisVelocity, this.LifeTime / self.LifeTime.Max, Collided)
						end
					else 
						table.insert(Parts, this.Part)
						table.insert(CFrames, CFrame.lookAt(thisPos, CamPos or (thisPos + (AlongSurfaceDir or thisVelocity))))
						if Collided and self.OnCollision then
							Properties[this.Part] = self.OnCollision(thisPos, thisVelocity, this.LifeTime / self.LifeTime.Max, Collided)
						elseif self.EveryFrame and (not Properties[this.Part]) then
							Properties[this.Part] = self.EveryFrame(thisPos, thisVelocity, this.LifeTime / self.LifeTime.Max)
						end
					end
					this.Pos = thisPos
					this.Velocity = thisVelocity
					this.Delta = 0
				end

			end
			--debug.profileend()

			if self.SelfCollisions then
				debug.profilebegin("SelfCollide")
				local gridPositions = {}

				for i, this in pairs(Particles) do
					local that : vector = GetGridPosition(this.Pos, self.SelfSize)
					if that == that then
						if Grid[that] then
							Grid[that][i] = true
						else
							Grid[that] = { [i] = true }
						end
					end
					gridPositions[i] = that
				end

				for iteration = 1, self.Iterations do
					for ind, this in ipairs(Particles) do

						local NowGrid = gridPositions[ind]
						local CollsionsTable = {}
						for i, Search in pairs(GridSearch) do
							if Grid[NowGrid + Search] then
								for ii, other in pairs(Grid[NowGrid + Search]) do
									if other then
										CollsionsTable[ii] = other
									end
								end
							end
						end

						local thisPos : vector = this.Pos

						if self.SelfCollType == "Realistic" then
							for i, otrhe in pairs(CollsionsTable) do
								if i ~= ind then
									local other = Particles[i]
									local Dist = vector.magnitude(other.Pos - this.Pos)
									local Look = vector.normalize(this.Pos - other.Pos)
									local Relative = (this.Velocity - other.Velocity)
									if Dist < self.SelfSize then
										if i < ind then
											this.Pos += ((self.SelfSize - Dist) * Look) / self.Iterations
											this.Velocity -= (((1 + self.Bounce) * vector.dot(Relative, Look) / self.Mass) * Look) / self.Iterations
											other.Velocity += (((1 + self.Bounce) * vector.dot(Relative, Look) / self.Mass) * Look) / self.Iterations
										else
											this.Pos += ((self.SelfSize - Dist) * Look) / self.Iterations
											this.Velocity -= (((1 + self.Bounce) * vector.dot(Relative, Look) / self.Mass) * Look) / self.Iterations
											other.Velocity += (((1 + self.Bounce) * vector.dot(Relative, Look) / self.Mass) * Look) / self.Iterations

										end

									end
								end
							end
						elseif self.SelfCollType == "Default" then
							for i, otrhe in pairs(CollsionsTable) do
								if i ~= ind then
									local other = Particles[i]
									local Dist = vector.magnitude(other.Pos - this.Pos)
									local Look = vector.normalize(this.Pos - other.Pos)
									if Dist < self.SelfSize then
										if i < ind then
											this.Pos += ((self.SelfSize - Dist) / self.Iterations) * Look
											this.Velocity += ((self.SelfSize - Dist)  / self.Iterations) * Look
											this.Velocity += other.Velocity * (dt / self.Iterations) 
										else
											this.Pos += ((self.SelfSize - Dist) / (self.Iterations*2)) * Look
											this.Velocity += ((self.SelfSize - Dist)  / (self.Iterations*2)) * Look
											this.Velocity += other.Velocity * (dt / self.Iterations) 
										end

									end
								end
							end
						elseif self.SelfCollType == "Fluid" then
							for i, otrhe in pairs(CollsionsTable) do
								if i ~= ind then
									local other = Particles[i]
									local Dist = vector.magnitude(other.Pos - this.Pos)
									local Look = vector.normalize(this.Pos - other.Pos)
									if Dist < self.SelfSize then
										if i < ind then
											local Pow : vector = (self.FluidForce * (self.SelfSize - Dist)) / self.Iterations * Look
											this.Velocity += Pow
											other.Velocity -= Pow
											--this.Pos +=Pow
										else
											local Pow : vector = (self.FluidForce * (self.SelfSize - Dist)) / (self.Iterations*2) * Look
											this.Velocity += Pow
											other.Velocity -= Pow
											--this.Pos += Pow
										end

									end
								end
							end
						end

						local LastGrid : vector = NowGrid
						local JustGrid : vector = GetGridPosition(this.Pos, self.SelfSize)
						if not (JustGrid ~= JustGrid) then
							if LastGrid ~= NowGrid then
								if Grid[LastGrid] then
									Grid[LastGrid][ind] = nil
								end
								if Grid[JustGrid] then
									Grid[JustGrid][ind] = this
								else
									Grid[JustGrid] = {[ind] = this}
								end
								gridPositions[ind] = JustGrid
							end
						end

					end
				end
				debug.profileend()
			end


		end
		Forces = {}
		task.synchronize()
		workspace:BulkMoveTo(Parts, CFrames, Enum.BulkMoveMode.FireCFrameChanged)
		ApplyProperties(Properties)
		for Part, Toggle in TrailFixes do
			if typeof(self.TrailFix) == "string" then

				Part:FindFirstChild(self.TrailFix).Enabled = Toggle

			elseif typeof(self.TrailFix) == "table" then

				for i, ChildTable in self.TrailFix do
					if typeof(ChildTable) == "string" then
						Part:FindFirstChild(ChildTable).Enabled = Toggle
					elseif typeof(ChildTable) == "table" then

						local foundPart = Part
						for ii, nextChild in ChildTable do
							foundPart = foundPart:FindFirstChild(nextChild)
						end
						foundPart.Enabled = Toggle

					end
				end

			end

		end

	end

	local Step = game:GetService("RunService").PostSimulation:Connect(AdvanceTime)

	function self:SyncToRenderToggle(bool)
		Step:Disconnect()
		if bool then
			Step = game:GetService("RunService").PreRender:Connect(AdvanceTime)
		else
			Step = game:GetService("RunService").PostSimulation:Connect(AdvanceTime)
		end
	end

	function self:Destroy()
		Step:Disconnect()
		for i, v in ipairs(Particles) do
			v.Part:Destroy()
		end
		for i, v in ipairs(Particles) do
			table.remove(Particles, i)
		end
		for i, v in ipairs(Cachce) do
			v:Destroy()
		end
		for i, v in pairs(self) do
			self[i] = nil
		end
		self = nil
	end

	return self
end

return table.freeze(module)]]></ProtectedString>
							<int64 name="SourceAssetId">12730735383</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004303</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXA3C71DAAAC7242E48A9DC0DE9F31D20F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc08218013000096da</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_FrustumCulling</string>
								<string name="ScriptGuid">{CF940743-3E67-4A5D-A77E-681637D4A7E8}</string>
								<ProtectedString name="Source"><![CDATA[--!native
type Plane = {P:Vector3, M:number}
local module = {}

local function distancePlaneFromOrigin(position, normal)
	return -position:Dot(normal)
end

function module.getFrustum(camera : Camera, renderDistance)
	local cameraCF = camera.CFrame

	local cameraHorizontalLimit = math.rad(camera.MaxAxisFieldOfView) / 2
	local cameraverticalLimit = math.rad(camera.FieldOfView) / 2

	-- Near Plane
	local nearPlaneCF = cameraCF * CFrame.new(0, 0, camera.NearPlaneZ)
	local nearNormal = -nearPlaneCF.LookVector
	local p1 = {P = nearNormal, M = (-nearNormal):Dot(nearPlaneCF.Position)}

	-- Far Plane
	local farPlaneCF = cameraCF * CFrame.new(0, 0, -renderDistance)
	local farNormal = farPlaneCF.LookVector
	local p2 = {P = farNormal, M = (-farNormal):Dot(farPlaneCF.Position)}

	-- Right Plane
	local rightPlaneCF = cameraCF * CFrame.Angles(0, cameraHorizontalLimit, 0)
	local rightNormal = -rightPlaneCF.RightVector
	local p3 = {P = rightNormal, M = (-rightNormal):Dot(cameraCF.Position)}

	-- Left Plane
	local leftPlaneCF = cameraCF * CFrame.Angles(0, -cameraHorizontalLimit, 0)
	local leftNormal = leftPlaneCF.RightVector
	local p4 = {P = leftNormal, M = (-leftNormal):Dot(cameraCF.Position)}

	-- Low Plane
	local lowPlaneCF = cameraCF * CFrame.Angles(-cameraverticalLimit, 0, 0)
	local lowNormal = -lowPlaneCF.UpVector
	local p5 = {P = lowNormal, M = (-lowNormal):Dot(cameraCF.Position)}

	-- Up Plane
	local upPlaneCF = cameraCF * CFrame.Angles(cameraverticalLimit, 0, 0)
	local upNormal = upPlaneCF.UpVector
	local p6 = {P = upNormal, M = (-upNormal):Dot(cameraCF.Position)}

	return {p1, p2, p3, p4, p5, p6} :: {Plane}
end


function module.findInFrustumPoint(planes : {Plane}, objectPos)
	for i, plane in planes do
		if (objectPos:Dot(plane["P"]) + plane["M"]) >= 0 then
			return false
		end
	end

	return true
end
type plane = {}
function module.findInFrustumSphere(planes : {Plane}, objectPos : Vector3, size : number)
	for i, plane in planes do
		if (objectPos:Dot(plane["P"]) + plane["M"]) >= size then
			return false
		end
	end

	return true
end

function module.findInFrustumAABB(planes : {Plane}, mins, maxs)
	local ret = "INSIDE"  -- Start assuming the box is inside unless proven otherwise.

	for i, plane in ipairs(planes) do
		local normal = plane["P"]
		local dist = plane["M"]

		local vmin = Vector3.new(
			(normal.X > 0) and mins.X or maxs.X,
			(normal.Y > 0) and mins.Y or maxs.Y,
			(normal.Z > 0) and mins.Z or maxs.Z
		)

		-- Determine the "most positive" vertex in relation to the plane normal
		local vmax = Vector3.new(
			(normal.X > 0) and maxs.X or mins.X,
			(normal.Y > 0) and maxs.Y or mins.Y,
			(normal.Z > 0) and maxs.Z or mins.Z
		)

		-- If the "most negative" vertex is outside the frustum, the entire box is outside
		if normal:Dot(Vector3.new(vmin.X, vmin.Y, vmin.Z)) + dist > 0 then
			return false
		end

		-- If the "most positive" vertex is inside, the box might intersect
		if normal:Dot(Vector3.new(vmax.X, vmax.Y, vmax.Z)) + dist >= 0 then
			ret = "Intersect"
		end
	end

	return ret  -- Could still be "INSIDE" if never updated to "Intersect"
end

function module.CalculateOBBVertices(cf : CFrame, size : Vector3)
	local vertices = {}
	for i = -1, 1, 2 do
		for j = -1, 1, 2 do
			for k = -1, 1, 2 do
				local corner = Vector3.new(i * size.X / 2, j * size.Y / 2, k * size.Z / 2)
				local vertex = cf:PointToWorldSpace(corner)
				table.insert(vertices, vertex)
			end
		end
	end
	return vertices
end

function module.findInFrustumBox(planes : {Plane}, Cf : CFrame, size : Vector3)
	local vertices = module.CalculateOBBVertices(Cf, size)
	for _, plane in ipairs(planes) do
		local allOut = true
		for _, vertex in ipairs(vertices) do
			if vertex:Dot(plane["P"]) + plane["M"] <= 0 then
				allOut = false
				break
			end
		end
		if allOut then
			return false -- All vertices are outside this plane
		end
	end
	return true -- No plane could exclude all vertices
end

return module
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004304</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF8C0C3CE21344A14AD14066F181B957D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc08218013000096db</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_CollisionsAlgorithms</string>
								<string name="ScriptGuid">{67B729BB-AFE8-46E8-B7A3-9A8D7EE575D9}</string>
								<ProtectedString name="Source"><![CDATA[
--Collision Detection between Ball and Particle.
local function BallSphereIntersection(cframe : CFrame, size : vector, point : vector, radius : number) : (boolean, vector, vector)
	local size : number = math.min(size.X, size.Y, size.Z) * 0.5
	local pos : vector = cframe.Position
	local rel : vector = point - pos
	local dist : number= vector.magnitude(rel)
	local normal : vector = vector.normalize(rel)
	local closestPoint : vector = normal * (size + radius) + pos
	if dist < size + radius then
		return true, closestPoint, normal
	else
		return false, closestPoint, normal
	end
end

--Collision Detection between Cylinder and Particle.
local function CylinderSphereIntersection(cframe : CFrame, size : vector, point : vector, radius : number) : (boolean, vector, vector)
	local rel : vector = cframe:PointToObjectSpace(point)
	local sx : number, sy : number, sz : number = size.X + radius, size.Y + radius, size.Z + radius
	local rx : number, ry : number, rz : number = rel.X, rel.Y, rel.Z

	local cx : number = math.clamp(rx, -sx*0.5, sx*0.5)
	local distSquared : number = (ry*ry + rz*rz)
	local SizeYZmin : number = math.min(sy, sz)*0.5

	if not (cx == rx and (distSquared <= SizeYZmin * SizeYZmin)) then
		local cy : number = sy * ry / SizeYZmin
		local cz : number = sz * rz / SizeYZmin
		local closestPoint : vector = cframe*vector.create(cx, cy, cz)
		local normal : vector = vector.normalize(point - closestPoint)
		return false, closestPoint, normal
	else
		local dist : number = math.sqrt(distSquared)
		local closestPoint: vector = vector.create(rx, ry / dist * SizeYZmin, rz / dist * SizeYZmin)
		local relToClosestPoint : vector = closestPoint - vector.create(rx, ry, rz)

		local posX : number = rx - sx*0.5
		local negX : number = -rx - sx*0.5 

		local max = math.max(posX, negX)
		if -max > vector.magnitude(relToClosestPoint) then
			local normal : vector = vector.normalize(relToClosestPoint)
			return true, cframe*closestPoint, normal
		elseif max == posX then
			local closestPoint : vector = cframe*vector.create(sx*0.5, ry, rz)
			return true, closestPoint, cframe.XVector
		elseif max == negX then
			local closestPoint : vector = cframe*vector.create(-sx*0.5, ry, rz)
			return true, closestPoint, -cframe.XVector
		end
	end
end

--Collision Detection between Box and Particle.
local function BoxSphereIntersection(cframe : CFrame, size : vector, point : vector, radius : number) : (boolean, vector, vector)
	local rel : vector = cframe:PointToObjectSpace(point)
	local sx : number, sy : number, sz : number = size.X + radius, size.Y + radius, size.Z + radius
	local rx : number, ry : number, rz : number = rel.X, rel.Y, rel.Z

	local cx : number = math.clamp(rx, -sx*0.5, sx*0.5)
	local cy : number = math.clamp(ry, -sy*0.5, sy*0.5)
	local cz : number = math.clamp(rz, -sz*0.5, sz*0.5)

	if not (cx == rx and cy == ry and cz == rz) then
		local closestPoint : vector = cframe*vector.create(cx, cy, cz)
		local normal : vector = vector.normalize(point - closestPoint)
		return false, closestPoint, normal
	end

	local posX : number = rx - sx*0.5 
	local posY : number = ry - sy*0.5 
	local posZ : number = rz - sz*0.5
	local negX : number = -rx - sx*0.5
	local negY : number = -ry - sy*0.5 
	local negZ : number = -rz - sz*0.5

	local max = math.max(posX, posY, posZ, negX, negY, negZ)
	if max == posX then
		local closestPoint : vector = cframe*vector.create(sx*0.5, ry, rz)
		return true, closestPoint, cframe.XVector
	elseif max == posY then
		local closestPoint : vector = cframe*vector.create(rx, sy*0.5, rz)
		return true, closestPoint, cframe.YVector
	elseif max == posZ then
		local closestPoint : vector = cframe*vector.create(rx, ry, sz*0.5)
		return true, closestPoint, cframe.ZVector
	elseif max == negX then
		local closestPoint : vector = cframe*vector.create(-sx*0.5, ry, rz)
		return true, closestPoint, -cframe.XVector
	elseif max == negY then
		local closestPoint : vector = cframe*vector.create(rx, -sy*0.5, rz)
		return true, closestPoint, -cframe.YVector
	elseif max == negZ then
		local closestPoint : vector = cframe*vector.create(rx, ry, -sz*0.5)
		return true, closestPoint, -cframe.ZVector
	end
end

--Old code for Collision between Box and Particle.
local function BoxPointIntersection(cframe, size, point) : (boolean, vector, vector)
	local rel = cframe:pointToObjectSpace(point)
	local sx :number, sy :number, sz :number = size.x, size.y, size.z
	local rx :number, ry :number, rz :number = rel.x, rel.y, rel.z

	-- constrain to within the box
	local cx = math.clamp(rx, -sx/2, sx/2)
	local cy = math.clamp(ry, -sy/2, sy/2)
	local cz = math.clamp(rz, -sz/2, sz/2)

	if not (cx == rx and cy == ry and cz == rz) then
		local closestPoint = cframe*vector.create(cx, cy, cz)
		local normal = vector.normalize(point - closestPoint)
		return false, closestPoint, normal
	end

	-- else, they are intersecting, find the surface the point is closest to

	local posX : number = rx - sx/2 
	local posY : number = ry - sy/2 
	local posZ : number = rz - sz/2 
	local negX : number = -rx - sx/2 
	local negY : number = -ry - sy/2 
	local negZ : number = -rz - sz/2

	local max = math.max(posX, posY, posZ, negX, negY, negZ)
	if max == posX then
		local closestPoint = cframe*vector.create(sx/2, ry, rz)
		return true, closestPoint, cframe.XVector
	elseif max == posY then
		local closestPoint = cframe*vector.create(rx, sy/2, rz)
		return true, closestPoint, cframe.YVector
	elseif max == posZ then
		local closestPoint = cframe*vector.create(rx, ry, sz/2)
		return true, closestPoint, cframe.ZVector
	elseif max == negX then
		local closestPoint = cframe*vector.create(-sx/2, ry, rz)
		return true, closestPoint, -cframe.XVector
	elseif max == negY then
		local closestPoint = cframe*vector.create(rx, -sy/2, rz)
		return true, closestPoint, -cframe.YVector
	elseif max == negZ then
		local closestPoint = cframe*vector.create(rx, ry, -sz/2)
		return true, closestPoint, -cframe.ZVector
	end
end


--[[
OLDER VERSIONS UP   ^^^
OPTIMIZED VERSIONS BELOW   vvv
]]

--Optimized version Collision Detection between Ball and Particle.
local function BallSphereIntersectionOptimized(cframe : CFrame, size : vector, point : vector, radius : number) : (boolean, vector, vector)
	local size : number = math.min(size.X, size.Y, size.Z) * 0.5
	local pos : vector = cframe.Position
	local rel : vector = point - pos
	local dist : number= vector.magnitude(rel)

	if dist < size + radius then
		local normal : vector = vector.normalize(rel)
		local closestPoint : vector = normal * (size + radius) + pos
		return true, closestPoint, normal
	else
		return nil
	end
end

--Optimized version Collision Detection between Cylinder and Particle.
local function CylinderSphereIntersectionOptimized(cframe : CFrame, size : vector, point : vector, radius : number) : (boolean, vector, vector)
	local rel : vector = cframe:PointToObjectSpace(point)
	local sx : number, sy : number, sz : number = size.X + radius, size.Y + radius, size.Z + radius
	local rx : number, ry : number, rz : number = rel.X, rel.Y, rel.Z

	local cx : number = math.clamp(rx, -sx*0.5, sx*0.5)
	local distSquared : number = (ry*ry + rz*rz)
	local SizeYZmin : number = math.min(sy, sz)*0.5

	if not (cx == rx and (distSquared <= SizeYZmin * SizeYZmin)) then
		return nil
	else
		local dist : number = math.sqrt(distSquared)
		local closestPoint: vector = vector.create(rx, ry / dist * SizeYZmin, rz / dist * SizeYZmin)
		local relToClosestPoint : vector = closestPoint - vector.create(rx, ry, rz)

		local posX : number = rx - sx*0.5
		local negX : number = -rx - sx*0.5 

		local max = math.max(posX, negX)
		if -max > vector.magnitude(relToClosestPoint) then
			local normal : vector = vector.normalize(relToClosestPoint)
			return true, cframe*closestPoint, normal
		elseif max == posX then
			local closestPoint : vector = cframe*vector.create(sx*0.5, ry, rz)
			return true, closestPoint, cframe.XVector
		elseif max == negX then
			local closestPoint : vector = cframe*vector.create(-sx*0.5, ry, rz)
			return true, closestPoint, -cframe.XVector
		end
	end
end

--Optimized version Collision Detection between Box and Particle.
local function BoxSphereIntersectionOptimized(cframe : CFrame, size : vector, point : vector, radius : number) : (boolean, vector, vector)
	local rel : vector = cframe:PointToObjectSpace(point)
	local sx : number, sy : number, sz : number = size.X + radius, size.Y + radius, size.Z + radius
	local rx : number, ry : number, rz : number = rel.X, rel.Y, rel.Z

	local cx : number = math.clamp(rx, -sx*0.5, sx*0.5)
	local cy : number = math.clamp(ry, -sy*0.5, sy*0.5)
	local cz : number = math.clamp(rz, -sz*0.5, sz*0.5)

	if not (cx == rx and cy == ry and cz == rz) then
		return nil
	end

	local posX : number = rx - sx*0.5 
	local posY : number = ry - sy*0.5 
	local posZ : number = rz - sz*0.5
	local negX : number = -rx - sx*0.5
	local negY : number = -ry - sy*0.5 
	local negZ : number = -rz - sz*0.5

	local max = math.max(posX, posY, posZ, negX, negY, negZ)
	if max == posX then
		local closestPoint : vector = cframe*vector.create(sx*0.5, ry, rz)
		return true, closestPoint, cframe.XVector
	elseif max == posY then
		local closestPoint : vector = cframe*vector.create(rx, sy*0.5, rz)
		return true, closestPoint, cframe.YVector
	elseif max == posZ then
		local closestPoint : vector = cframe*vector.create(rx, ry, sz*0.5)
		return true, closestPoint, cframe.ZVector
	elseif max == negX then
		local closestPoint : vector = cframe*vector.create(-sx*0.5, ry, rz)
		return true, closestPoint, -cframe.XVector
	elseif max == negY then
		local closestPoint : vector = cframe*vector.create(rx, -sy*0.5, rz)
		return true, closestPoint, -cframe.YVector
	elseif max == negZ then
		local closestPoint : vector = cframe*vector.create(rx, ry, -sz*0.5)
		return true, closestPoint, -cframe.ZVector
	end
end

local module = {
	["BallSphereIntersection"] = BallSphereIntersection,
	["CylinderSphereIntersection"] = CylinderSphereIntersection,
	["BoxSphereIntersection"] = BoxSphereIntersection,

	["BallSphereIntersectionOptimized"] = BallSphereIntersectionOptimized,
	["CylinderSphereIntersectionOptimized"] = CylinderSphereIntersectionOptimized,
	["BoxSphereIntersectionOptimized"] = BoxSphereIntersectionOptimized
}

return module
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004305</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXF4F07B25649F495BADE8E2A3829A0679">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc08218013000096dc</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Pathfinder</string>
							<string name="ScriptGuid">{7C3442A6-80F3-4440-B12A-8901D72C22E9}</string>
							<ProtectedString name="Source"><![CDATA[--!strict

local PathfindingService = game:GetService("PathfindingService")

local Types = require(script._Types)
local PathfinderMethods = require(script._PathfinderMethods)
local PathfinderHelper = require(script._PathfinderMethods._PathfinderHelper)

local Pathfinder = {}
Pathfinder.__index = setmetatable(Pathfinder, PathfinderMethods)

export type PathfinderInstance = typeof(setmetatable(
	{} :: Types.Pathfinder
, Pathfinder))

--[[
	Create a new Pathfinder instance.
]]
function Pathfinder.new(char: Model, config: Types.PathfinderConfiguration): PathfinderInstance
	assert(char, "A character is required for Pathfinder.")

	if config.MovingTarget then
		assert(typeof(config.Target) ~= "Vector3", "A BasePart or a Model needs to be provided if MovingTarget is enabled.")
	end

	if config.AbilitiesTable then
		for i, _ in config.AbilitiesTable do
			assert(typeof(i) == "number", "AbilitiesTable keys must be numeric.")
		end
	end

	local _, charBoundingBox = char:GetBoundingBox()

	local s = {} :: Types.Pathfinder
	s._character = char
	s._running = false
	s._target = config.Target
	s._pathfinderAbilities = config.AbilitiesTable :: Types.PathfinderAbilities
	s._movingTargetTrackingRange = config.MovingTargetTrackingRange or 100
	s._movingTargetRetargetingRange = config.MovingTargetRetargetingRange or
		math.max(charBoundingBox.X, charBoundingBox.Y, charBoundingBox.Z)
	s._activateAbilitiesInSequence = config.ActivateAbilitiesInSequence or false
	s._movingTarget = config.MovingTarget or false
	s._debugMode = config.DebugMode or false
	s._debugWaypoint = config.DebugWaypoint or false
	s._randomMove = config.RandomMove or false
	s._moveFunction = config.MoveFunction
	s._jumpFunction = config.JumpFunction
	s._randomMoveFunction = config.RandomMoveFunction
	s._noPathAction = config.NoPathAction
	s._abilityLastActivated = -1
	s._currentAbilityIndex = 0
	s._connections = {}
	s._memory = {}
	s._abilityCooldowns = {}

	s._path = PathfindingService:CreatePath(config.AgentParameters or 	
		{
			AgentRadius = 2, 
			AgentHeight = 5,
			AgentCanJump = true,
			AgentCanClimb =  true,
			PathSettings = 
				{
					SupportPartialPath = true
				}
		}
	)

	local rp = RaycastParams.new()
	rp.FilterDescendantsInstances = {char}
	rp.FilterType = Enum.RaycastFilterType.Exclude

	s._rp = rp

	setmetatable(s, Pathfinder)

	return s
end

--[[
	Change the target. Use this when you want to change the active target.
]]
function Pathfinder:ChangeTarget(newTarget: Vector3 | BasePart | Model)
	self._target = newTarget

	if self._movingTarget then
		self._pathDone = true
	end
end

--[[
	Run Pathfinder. Will continue to run unless stopped if movingTarget is true.
]]
function Pathfinder:Run()
	self:_DebugPrint("Pathfinding started.")
	self._running = true
	self:_InitPathfinding()
	
	local function checkAbilities(dist: number)
		if self._pathfinderAbilities and #self._pathfinderAbilities > 0 then
			if self._activateAbilitiesInSequence then
				local currentIndex = self._currentAbilityIndex :: number -- luau typing issue
				local newInd = currentIndex % #self._pathfinderAbilities + 1

				if self:_CheckAndRunAbility(dist, newInd) then
					self._currentAbilityIndex = newInd
				end
			else
				local randomTable = {}
				local total = 1
				local rollN
				local abilityToActivate

				for n, v in ipairs(self._pathfinderAbilities) do
					if self:_CheckIfAbilityCanBeActivated(dist, n) then
						table.insert(randomTable, {
							Weight = v.Weight or 1,
							n = n
						}) -- set up a table for roll

						total += v.Weight
					end
				end

				if #randomTable == 0 then return end -- no abilities to activate

				rollN = math.random(total, total*4)
				abilityToActivate = PathfinderHelper:Roll(rollN, randomTable)
				
				self:_CheckAndRunAbility(dist, abilityToActivate)
			end
		end
	end

	if self._movingTarget then
		task.spawn(function()
			while self._running do
				if self._target.Parent then
					local charPos = self:_GetCharacterPosition() :: Vector3
					local targetPos = self:_GetTargetPosition() :: Vector3
					
					local dist = (charPos - targetPos).Magnitude
					
					checkAbilities(dist)
					
					if dist <= self._movingTargetTrackingRange
						and dist > self._movingTargetRetargetingRange then
						self:_PathOperations(self._target)
					else
						self:_DebugPrint("Moving target not in range or distance is lower than "
							.. "retargeting range: " .. tostring(dist) ..
							" - " .. tostring(self._movingTargetTrackingRange)
						)

						if self._abilityLastActivated < os.clock() and self._randomMove then 
							self:_RandomMove() 
						end
					end
				elseif self._abilityLastActivated < os.clock() and self._randomMove then
					self:_RandomMove()
				end

				task.wait()
			end
		end)
	else
		local pos = self:_GetTargetPosition()

		self:_DebugPrint("Moving to " .. tostring(pos))

		self:_PathOperations(pos)
		
		task.spawn(function()
			while not self._pathDone do
				local charPos = self:_GetCharacterPosition() :: Vector3
				local targetPos = self:_GetTargetPosition() :: any 
				-- for some reasons, Luau thinks that this Vector3 return has a parent
	
				local dist = (charPos - targetPos).Magnitude
				
				checkAbilities(dist)
				task.wait()
			end
		end)
		
		self._running = false
	end
end

--[[
	Stops the Pathfinder instance.
]]
function Pathfinder:Stop()
	self._running = false
	self._pathDone = true
end

--[[
	Destroy the Pathfinder instance.
]]
function Pathfinder:Destroy()
	if self._running then
		self:Stop()
	end

	for _, c: RBXScriptConnection in self._connections do
		c:Disconnect()
	end

	setmetatable(self, nil)
end

return Pathfinder]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004306</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXCE5639B58D6845E989BCD931DD1B4311">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc08218013000096dd</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_PathfinderMethods</string>
								<string name="ScriptGuid">{99E242E9-C676-45B8-ACC4-450036DFC360}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

local PathfinderHelper = require(script._PathfinderHelper)

local PathfinderMethods = {}
PathfinderMethods.__index = setmetatable(PathfinderMethods, PathfinderHelper)

--[[
	MoveTo function which accounts for a custom MoveTo method.
]]
function PathfinderMethods:_MoveTo(p: Vector3)
	if self._moveFunction then
		self._moveFunction(p)
	else
		local Humanoid = self._character:FindFirstChildOfClass("Humanoid")

		if Humanoid then
			Humanoid:MoveTo(p)
		else
			self:_DebugPrint("Humanoid does not exist, MoveTo did not run.")
		end
	end
end

--[[
	Jump function which accounts for a custom jump method.
]]
function PathfinderMethods:_Jump(p: Vector3): boolean
	if self._jumpFunction then
		return self._jumpFunction(p)
	else
		local Humanoid = self._character:FindFirstChildOfClass("Humanoid")

		if Humanoid then
			Humanoid.Jump = true
		else
			self:_DebugPrint("Humanoid does not exist, Jump did not run.")
		end

		return true
	end
end

--[[
	RandomMove which is structurally like an ability. Basically randomly moves to a close position.
]]
function PathfinderMethods:_RandomMove()
	local pos: Vector3?
	self:_DebugPrint("Random moving")
	self._abilityLastActivated = os.clock() + 5

	if self._randomMoveFunction then
		pos = self._randomMoveFunction()

		assert(pos and typeof(pos) == "Vector3", "RandomMoveFunction did not return a Vector3.")
	else
		local Humanoid = self._character:FindFirstChildOfClass("Humanoid")

		if Humanoid then
			local RootPart = Humanoid.RootPart or self._character:FindFirstChild("HumanoidRootPart") :: Part

			if RootPart then
				pos = Vector3.new(
					RootPart.Position.X + math.random(0, 6), 
					RootPart.Position.Y + math.random(0, 2), 
					RootPart.Position.Z + math.random(0, 6)
				)
			end
		end
	end

	if pos then
		self:_InitPathfinding()
		self:_MoveInPath(pos)
	end
end

--[[
	Handles basic waypoint actions and increments _currentWaypoint.
]]
function PathfinderMethods:_OnWaypointReached()
	if self._waypoints and self._currentWaypoint and self._currentWaypoint < #self._waypoints then
		self._currentWaypoint += 1
		local currentWaypointInfo = self._waypoints[self._currentWaypoint]

		self._lastPathTick = os.clock()
		if currentWaypointInfo.Action == Enum.PathWaypointAction.Walk then
			self:_MoveTo(currentWaypointInfo.Position)
		elseif currentWaypointInfo.Action == Enum.PathWaypointAction.Jump then
			self:_DebugPrint("Waypoint " .. self._currentWaypoint .. " action is Jump.")
			local Humanoid = self._character:FindFirstChildOfClass("Humanoid")
			if not Humanoid then return end

			local willMoveTo = self:_Jump(currentWaypointInfo.Position)

			if willMoveTo then
				self:_MoveTo(currentWaypointInfo.Position)
			end
		else
			self:_DebugPrint("Waypoint action: " .. currentWaypointInfo.Action.Name)
			self:_MoveTo(currentWaypointInfo.Position)
		end

		self:_InsertDebugWaypoint(currentWaypointInfo.Position, self._currentWaypoint-1, nil, currentWaypointInfo.Action)

		self:_DebugPrint("Passed waypoint " .. self._currentWaypoint .. "/" .. #self._waypoints)
	elseif self._currentWaypoint and self._waypoints and self._currentWaypoint == #self._waypoints then
		self._pathDone = true
		self:_DebugPrint("Path is done, completed.")
	end
end

--[[
	The main function for pathfinding to a position.
]]
function PathfinderMethods:_MoveInPath(to: Vector3)
	self._pathDone = false
	self:_DebugPrint("Moving in path to " .. tostring(to))
	local Humanoid = self._character:FindFirstChildOfClass("Humanoid") :: Humanoid
	local RootPart = Humanoid.RootPart or self._character:FindFirstChild("HumanoidRootPart") :: Part

	self._path:ComputeAsync(RootPart.Position, to)
	self._waypoints = {}

	if self._path.Status == Enum.PathStatus.Success then
		self:_DebugPrint("Path creation was successful.")
		self._waypoints = self._path:GetWaypoints()
		self._currentWaypoint = 0

		task.spawn(function()
			local previousDirection
			local start = os.clock()

			while not self._pathDone do
				self:_OnWaypointReached()
				local currentWaypointInfo = self._waypoints[self._currentWaypoint]
				local previousPos = self._memory["PreviousPos"] :: Vector3
				
				if Humanoid and currentWaypointInfo then
					local currentWaypointPos = currentWaypointInfo.Position
					
					if previousPos then
						local charPos = self:_GetCharacterPosition() :: Vector3
						
						local direction1 = self:_GetXZDirection(charPos, previousPos)
						local direction2 = self:_GetXZDirection(charPos, currentWaypointPos)
						local directionNext
						local angleNext
						
						if self._currentWaypoint < #self._waypoints then
							directionNext = self:_GetXZDirection(charPos, self._waypoints[self._currentWaypoint+1].Position)
							angleNext = directionNext:Angle(direction2)
						end
						
						local angle = direction1:Angle(direction2)
						
						if directionNext and angleNext and math.round(angle) == 3 and 
							math.round(angleNext) == 3 then
							self:_DebugPrint("Skipped the waypoint behind the character " .. tostring(angle) .. " " .. tostring(angleNext))
							continue
						--else
							--self:_DebugPrint("Angle " .. " " .. tostring(self._currentWaypoint) .. " " .. tostring(angle) .. " " .. tostring(angleNext))
						end
					end

					local sAngle = self:_GetSurfaceAngle()
					local angle = 1-sAngle

					local groundDistance = (Vector3.new(currentWaypointPos.X,
						0,
						currentWaypointPos.Z
						) - Vector3.new(RootPart.Position.X,
							0,
							RootPart.Position.Z
						)).Magnitude

					local waitTime = if self._pathDone or not self._waypoints or not currentWaypointInfo or not RootPart then 
						0 else (if sAngle > 0 then angle else 1) * groundDistance/(Humanoid.WalkSpeed*2)

					task.wait(waitTime)

					if self._currentWaypoint > 2 then
						local prePrevWaypointP = self._waypoints[self._currentWaypoint-2].Position
						local prevWaypoint = self._waypoints[self._currentWaypoint-1]
						local prevWaypointP = prevWaypoint.Position

						local direction = self:_GetXZDirection(prePrevWaypointP, prevWaypointP)
						
						--self:_DebugPrint(tostring(self._currentWaypoint) .. " " .. tostring(direction) .. " " .. tostring(previousDirection))

						if previousDirection and not previousDirection:FuzzyEq(direction, 0.01) and
							(prePrevWaypointP.Y == prevWaypointP.Y 
								or prevWaypoint.Action == Enum.PathWaypointAction.Jump 
								or (prevWaypoint.Action == Enum.PathWaypointAction.Walk and 
									math.round(prePrevWaypointP.Y) ~= math.round(prevWaypointP.Y)
								)) then
							
							self:_InsertDebugWaypoint(prevWaypointP, self._currentWaypoint-2, Color3.fromRGB(255, 0, 0))

							if not RootPart.AssemblyLinearVelocity:FuzzyEq(Vector3.new(0, 0, 0), 0.01) then
								self:_DebugPrint("Waiting for MoveToFinished")
								--Humanoid.MoveToFinished:Wait()
								--MoveToFinished doesn't do the job in most cases and is not the effect we want

								repeat
									task.wait()
								until RootPart.AssemblyLinearVelocity:FuzzyEq(Vector3.new(0, 0, 0), .1)
							end
						end

						previousDirection = direction
					end
				else
					break -- TODO
				end
			end

			self:_DebugPrint("Path took " .. os.clock() - start .. " seconds.")
		end)
	elseif self._path.Status == Enum.PathStatus.NoPath or 
		self._path.Status == Enum.PathStatus.ClosestNoPath  then
		-- 04/12/2024, even if it is marked as deprecated, pathfinding service still returns ClosestNoPath
		self:_DebugPrint("No path.")

		local targetPos = self:_GetTargetPosition() :: Vector3
		local charPos = self:_GetCharacterPosition() :: Vector3
		local dist = (targetPos-charPos).Magnitude

		if self._noPathAction then
			self._noPathAction(self:_DefaultT())
		else
			if dist < (self._movingTargetTrackingRange or math.huge) then
				self:_DebugPrint("Moving target is in range, moving to moving target.")
				self:_MoveTo(targetPos)
			else
				self:_DebugPrint("Random moving.")
				self:_RandomMove()
			end

			task.wait(0.5)

			self._pathDone = true
		end
	else
		self:_MoveTo(RootPart.Position)
		self:_DebugPrint("Unknown path status: " .. self._path.Status.Name)
		self:_RandomMove()

		self._pathDone = true
	end
end

--[[
	Currently only sets the path as done and recalculates from current position.
]]
function PathfinderMethods:_OnPathBlocked(blockedWaypointIndex: number)
	if blockedWaypointIndex > self._currentWaypoint then
		local Humanoid = self._character:FindFirstChildOfClass("Humanoid")

		if Humanoid then
			self:_DebugPrint("Current waypoint is blocked.")
			self._pathDone = true

			self:_PathOperations(self:_GetTargetPosition())
		end
	end
end

--[[
	Cleanup past waypoints and reset some variables
]]
function PathfinderMethods:_InitPathfinding()
	self:_DebugPrint("Pathfinding init")
	self._waypoints = {}
	self._currentWaypoint = 1
	self._lastPathTick = nil

	self._pathDone = true

	self._connections[#self._connections+1] = self._path.Blocked:Once(function(blockedWaypointIndex)
		self:_OnPathBlocked(blockedWaypointIndex)
	end)
end

--[[
	The main function to get paths started and manage moving target retargeting.
]]
function PathfinderMethods:_PathOperations()
	if self._movingTarget then
		self._memory["CurrentPos"] = self:_GetTargetPosition()

		if self._memory["PreviousPos"] and not
			self._memory["PreviousPos"]:FuzzyEq(self._memory["CurrentPos"]) then
			self:_OnPositionChanged()
		end
		
		self._memory["PreviousPos"] = self._memory["CurrentPos"]
	end

	self:_DebugPrint("Path done status: " .. tostring(self._pathDone) or "nil")
	if self._pathDone then
		self:_DebugPrint("Path was done, initializing")
		self:_InitPathfinding()

		self:_MoveInPath(self:_GetTargetPosition())
	else
		if self._lastPathTick then
			if os.clock() - self._lastPathTick  > 5 then
				self._pathDone = true
			end
		end
	end
end

return PathfinderMethods
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004307</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX6FEEDC22A0A94F6D91CB1383A3B9D603">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">09edd42ec210d5cc08218013000096de</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">_PathfinderHelper</string>
									<string name="ScriptGuid">{FE47B624-8261-4CA1-870F-BC67F929CFCE}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
local Debris = game:GetService("Debris")

local PathfinderHelper = {}
PathfinderHelper.__index = PathfinderHelper

local Types = require("../_Types")

function PathfinderHelper:_InsertDebugWaypoint(pos: Vector3, num: number, color: Color3?, action: Enum.PathWaypointAction?)
	if not self._debugWaypoint then return end

	local b = Instance.new("Part")
	b.Shape = Enum.PartType.Ball
	b.Size = color and Vector3.new(1.1, 1.1, 1.1) or Vector3.new(1,1,1)
	b.Anchored = true
	b.CanCollide = false
	b.Material = Enum.Material.Neon
	b.Color = color or ((action and action == Enum.PathWaypointAction.Jump) and Color3.fromRGB(255, 186, 12) or Color3.fromRGB(255, 255, 255))
	b.Position = pos
	b.Parent = workspace

	local bg = Instance.new("BillboardGui")
	bg.Size = UDim2.new(1, 0, 1, 0)
	bg.StudsOffset = Vector3.new(0, 1, 0)
	bg.LightInfluence = 0

	local tl = Instance.new("TextLabel")
	tl.TextScaled = true
	tl.TextWrapped = true
	tl.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	tl.TextColor3 = Color3.fromRGB(255, 255, 255)
	tl.Size = UDim2.new(.9, 0, .9, 0)
	tl.Text = tostring(num)
	tl.Parent = bg

	local uc = Instance.new("UICorner")
	uc.CornerRadius = UDim.new(0.5, 0)
	uc.Parent = tl

	bg.Parent = b

	Debris:AddItem(b, 5)
end

function PathfinderHelper:_GetXZDirection(pos1: Vector3, pos2: Vector3): Vector3
	return Vector3.new(
		pos1.X-pos2.X,
		0,
		pos1.Z-pos2.Z
	)
end

function PathfinderHelper:_GetSurfaceAngle(): number
	local Humanoid = self._character:FindFirstChildOfClass("Humanoid")

	if Humanoid then
		local RootPart = Humanoid.RootPart or self._character:FindFirstChild("HumanoidRootPart") :: Part

		if RootPart then
			local raycast = workspace:Raycast(RootPart.Position, Vector3.new(0, -1, 0) * 5, self._rp) -- TODO

			if raycast then
				return math.acos(raycast.Normal:Dot(Vector3.new(0, 1, 0)))
			end
		end
	end

	return -1
end

function PathfinderHelper:_GetTargetPosition(): Vector3
	local pos

	if typeof(self._target) == "Vector3" then
		pos = self._target
	elseif self._target:IsA("Part") then
		pos = self._target.Position
	else
		pos = self._target:GetPivot().Position
	end

	return pos
end

function PathfinderHelper:_GetCharacterPosition(): Vector3
	local charPart = self._character:FindFirstChild("HumanoidRootPart") :: BasePart
	local Humanoid = self._character:FindFirstChildOfClass("Humanoid")

	if Humanoid then
		charPart = Humanoid.RootPart
	else
		charPart = self._character:FindFirstChildWhichIsA("BasePart")
	end
	
	return charPart.Position
end

function PathfinderHelper:_OnPositionChanged()
	local newPos = self._memory["CurrentPos"] :: Vector3

	local direction = newPos - self._memory["PreviousPos"]

	if self._memory["PreviousDirection"] and 
		self._memory["PreviousDirection"]:FuzzyEq(direction, .75) then
		self:_DebugPrint("direction same " .. tostring(self._memory["PreviousDirection"]) .. " " .. tostring(direction))
	else
		self._pathDone = true
		self:_DebugPrint("direction different " .. tostring(self._memory["PreviousDirection"]) .. " " .. tostring(direction))
	end

	self._memory["PreviousDirection"] = direction
end

function PathfinderHelper:_CheckIfAbilityCanBeActivated(dist: number, n: number): boolean
	local ability = self._pathfinderAbilities[n]
	assert(ability, "An ability with " .. n  .. " key does not exist.")

	if dist <= ability.ActivationRange 
		and self._abilityLastActivated < os.clock()
		and (if self._abilityCooldowns[n] then 
			os.clock() - self._abilityCooldowns[n] >= ability.CooldownTime else true)
		and (if ability.CustomConditions then ability.CustomConditions({
			self:_DefaultT()
		})
	else true) then
		return true
	else
		return false
	end
end

function PathfinderHelper:_CheckAndRunAbility(dist: number, n: number): boolean
	local ability = self._pathfinderAbilities[n]
	assert(ability, "An ability with " .. n  .. " key does not exist.")

	local canBeActivated = self:_CheckIfAbilityCanBeActivated(dist, n)

	if canBeActivated then
		self:_DebugPrint("Activating ability " .. tostring(n))

		self._abilityCooldowns[n] = os.clock()
		self._abilityLastActivated = os.clock() + (ability.ActiveTime or 0)
		
		ability.Callback(self:_DefaultT())

		return true
	end

	return false
end

function PathfinderHelper:_DebugPrint(...: any)
	if self._debugMode then
		local charName: string = self._character.Name
		
		print("[" .. charName .. "]", ...)
	end
end

function PathfinderHelper:Roll(n: number, randomTable: {[number]: {[string]: number}}): number
	while true do
		for _, v in ipairs(randomTable) do
			n -= v.Weight

			if n < 0 then
				return v.n
			end
		end
	end
end

function PathfinderHelper:_DefaultT(): Types.t
	local targetPos = self:_GetTargetPosition() :: Vector3
	local charPos = self:_GetCharacterPosition() :: Vector3
	local dist = (targetPos-charPos).Magnitude

	return {
		Character = self._character,
		Target = self._target,
		Distance = dist,
		Move = function(p: Vector3)
			self:_InitPathfinding()
			self:_MoveInPath(p)
		end,
		RandomMove = function()	
			self:_RandomMove()
		end
	}
end

return PathfinderHelper
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004308</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX08086B52906343A5B4BF6DC5AF2DD217">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc08218013000096df</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_Types</string>
								<string name="ScriptGuid">{3C79D210-1D41-40F4-A033-7E53E73155BA}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
export type Pathfinder = {
	["_character"]: Model,
	["_target"]: Vector3 | BasePart | Model,
	["_movingTarget"]: boolean,
	["_abilityLastActivated"]: number,
	["_movingTargetTrackingRange"]: number?,
	["_movingTargetRetargetingRange"]: number?,
	["_pathfinderAbilities"]: PathfinderAbilities?,
	["_running"]: boolean,
	["_path"]: Path,
	["_pathDone"]: boolean,
	["_waypoints"]: {[number]: PathWaypoint},
	["_currentWaypoint"]: number,
	["_currentAbilityIndex"]: number,
	["_rp"]: RaycastParams,
	["_lastPathTick"]: number?,
	["_debugMode"]: boolean?,
	["_debugWaypoint"]: boolean?,
	["_randomMove"]: boolean?,
	["_activateAbilitiesInSequence"]: boolean?,
	["_connections"]: {[number]: RBXScriptConnection},
	["_memory"]: {any: any},
	["_abilityCooldowns"]: {[string | number]: number},
	["_noPathAction"]: ((t) -> ())?,
	["_moveFunction"]: ((Vector3) -> ())?,
	["_jumpFunction"]: ((Vector3) -> (boolean))?,
	["_randomMoveFunction"]: (() -> (Vector3))?
}

export type PathfinderAbilities = {
	[number]: {
		["ActivationRange"]: number,
		["ActiveTime"]: number,
		["CooldownTime"]: number,
		["Weight"]: number?,
		["CustomConditions"]: ((t) -> (boolean))?,
		["Callback"]: (t) -> (),
	}
}

export type PathfinderConfiguration = {
	["Target"]: Vector3 | BasePart | Model,
	["MovingTargetTrackingRange"]: number?,
	["MovingTargetRetargetingRange"]: number?,
	["DebugMode"]: boolean?,
	["DebugWaypoint"]: boolean?,
	["MovingTarget"]: boolean?,
	["RandomMove"]: boolean?,
	["ActivateAbilitiesInSequence"]: boolean?,
	["MoveFunction"]: ((Vector3) -> ())?,
	["JumpFunction"]: ((Vector3) -> (boolean))?,
	["RandomMoveFunction"]: (() -> (Vector3))?,
	["NoPathAction"]: ((t) -> ())?,
	["AgentParameters"]: {[string]: any}?,
	["AbilitiesTable"]: PathfinderAbilities?,
}

export type t = {
	["Character"]: Model,
	["Target"]: Model | Part | Vector3,
	["Distance"]: number,
	["Move"]: (Vector3) -> (),
	["RandomMove"]: () -> ()
}

return {}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004309</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXC1847847D1EF4B91A093BA8F23135717">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c68</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_DynamicOctree</string>
							<string name="ScriptGuid">{74B3C622-6871-4EAD-AA6C-9E1CE50C1B46}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
-- Dynamic Octree System (DOS), by plasma_node, using Octree by Quenty
-- Creates Octrees that are able to remember objects, useful for
-- grids where objects will need to move or disappear.
-- Slightly modified by @crusherfire for type support

local Octree = require(script._Octree)
local R = Random.new(os.clock() * os.time());

--- This
local DOS = {};

--- Const
local OCTREE_DEFAULTS = {
    Depth = 4;
    Size = 512;
};

--- Grid Class
local Grid = {};
Grid.__index = Grid;
type fields = {
	Name: string,
	Tree: any,
	Update: any,
	Entries: any,
	Tracked: any,
	_trash: any,
}
export type DynamicOctree = typeof(setmetatable({} :: fields, Grid))

-- Used to add items which will not
-- be destroyed or moved within the lifespan
-- of the DOS grid
function Grid:AddStatic (Item: any, Position: Vector3?)
    table.insert(self._trash, self.Tree:CreateNode(Position or Vector3.zero, Item));
end

function Grid:Add (Item: any, Position: Vector3?)
    self.Entries[Item] = self.Tree:CreateNode(Position or Vector3.zero, Item);
end

function Grid:RadiusSearch(pos: Vector3, radius: number)
	return self.Tree:RadiusSearch(pos, radius)
end

--[=[
    Track object:

    This function will automatically update the objects position, and
    automatically remove stale nodes.

    ! WARNING ! Not intended for large scale use, as it will cause perf issues
	
    Usage:
    ```lua
    local cleanup = Grid:Track(Model, 0.1);
    task.wait(2);
    cleanup();
    ```
]=]
function Grid:Track (Item: Instance, Interval: number): () -> ()
    assert(typeof(Item) == "Instance", "Object must be an instance");

    local operate = true;
    Interval = math.clamp(Interval or 0.1, 0, 10);

	if (Item:IsA("PVInstance")) then
        task.defer(function ()
            while self.Update and operate do
                pcall(function ()
                    self.Tracked[Item]:Destroy();
                end);
                self.Tracked[Item] = self.Tree:CreateNode(Item:GetPivot().Position, Item);
                task.wait(Interval);
            end
        end);
	else
		error(`don't know how to handle instance: '{Item}'`, 2)
	end

	return function ()
		operate = false;
		task.wait(Interval);
		pcall(function () self.Tracked[Item]:Destroy(); end);
		self.Tracked[Item] = nil
	end
end

function Grid:Remove (Item: any)
    if (self.Entries[Item]) then
        self.Entries[Item]:Destroy();
    end
    self.Entries[Item] = nil;
end

function Grid:UpdateFor (Item: any, Position: Vector3)
    if (self.Entries[Item]) then
        self.Entries[Item]:Destroy();
    end
    self:Add(Item, Position);
end

-- Destroy the grid
function Grid:Destroy ()
    self.Update = false;

    for _, g in self._trash do
        g:Destroy();
    end
    
    for _, entry in self.Entries do
        entry:Destroy();
    end

    self.Tree = nil;
end

function Grid:_init ()
    self.Update = true;
end


---- DOS ----

function DOS.New (Name: string?, Depth: number?, Size: number?): DynamicOctree
    local grid = {
        Name = Name or ("Unnamed DOS Grid ~~"..R:NextInteger(1000,9999)); -- Not a unique ID, just helps to distinguish things in the log if something goes wrong
        Tree = Octree.new(Depth or OCTREE_DEFAULTS.Depth, Size or OCTREE_DEFAULTS.Size);
        Update = false;

        Entries = {}; -- List of all objects/items stored
        Tracked = {}; -- List of all objects being tracked

        _trash = {};
    }

    grid = setmetatable(grid, Grid);
    grid:_init();
    
    return grid;
end

return DOS;]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000430a</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXBD662CAA2D244714A21D3D1E4AEFD6B9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c69</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_Octree</string>
								<string name="ScriptGuid">{5A5054E6-951D-4351-A36C-583D4AD6ED29}</string>
								<ProtectedString name="Source"><![CDATA[--[=[
	# MODIFIED BY PLASMA_NODE FOR OMEGASPACE, 2023 #

	Octree implementation. An octree is a data structure that allows for quick spatial
	data queries of static objects. For example, trees can be stored in an octree, and
	nearby trees could be found near the player.
	Octrees exists as a grid of nodes, which are subdivided in half in each axis, which
	results in 8 different regions. This recursively happens to a set depth.
	This allows for O(n) data storage and log(n) retrieval of nearby objects. With a large
	quantity of items in the octree, this can make data retrieval significantly faster.
	See also: https://en.wikipedia.org/wiki/Octree
	```lua
	local octree = Octree.new()
	octree:CreateNode(Vector3.new(0, 0, 0), "A")
	octree:CreateNode(Vector3.new(0, 0, 0), "B")
	octree:CreateNode(Vector3.new(0, 0, 0), workspace)
	octree:CreateNode(Vector3.new(0, 0, 1000), "C")
	print(octree:RadiusSearch(Vector3.new(0, 0, 0), 100)) --> { "A", "B", workspace }
	```
	:::tip
	Octrees are best for static objects in the world, and not objects moving around, since then
	data can be statically cached.
	Sometimes using Roblox's spatial hash using the region API is faster than using an octree. However,
	for data that is centralized, or static, an octree can be a very efficient spatial query mechanism.
	That said, it is totally fine to track the objects that DO move around using octree, as long as you 
	apply proper optimizations. The main performance cost of doing this comes down to tracking and 
	upating the position of the objects, which is fine if: 
		1) You have a way to detect the movement without having to loop through all the moving 
		objects to update the position
		2) You can tolerate some inaccuracy with positions and smear this update
		3) You have less than 1000 objects to track, in this case looping through everything 
		shouldn't be too costly. 
	:::
	@class Octree
]=]

local OctreeRegionUtils = require(script._OctreeRegionUtils)
local OctreeNode = require(script._OctreeNode)

local EPSILON = 1e-9

local Octree = {}
Octree.ClassName = "Octree"
Octree.__index = Octree

Octree.Node = script._OctreeNode;
Octree.RegionUtils = script._OctreeRegionUtils;

--[=[
	Constructs a new Octree.
	@return Octree<T>
]=]
function Octree.new(Depth, MaxSize)
	local self = setmetatable({}, Octree)

	self._maxRegionSize = if MaxSize then { MaxSize, MaxSize, MaxSize} else { 512, 512, 512 } -- these should all be the same number
	self._maxDepth = Depth or 4
	self._regionHashMap = {} -- [hash] = region

	return self
end

--[=[
	Returns all octree nodes stored in the octree!
	```lua
	local octree = Octree.new()
	octree:CreateNode(Vector3.new(0, 0, 0), "Hi")
	octree:CreateNode(Vector3.new(0, 0, 0), "Bob")
	print(octree:GetAllNodes()) --> { "Hi", "Bob" }
	```
	Order is not guaranteed.
	:::warning
	If you have 100,000 nodes in your octree, this is going to be very slow.
	:::
	@return { OctreeNode<T> }
]=]
function Octree:GetAllNodes()
	local options = {}

	for _, regionList in pairs(self._regionHashMap) do
		for _, region in pairs(regionList) do
			for node, _ in pairs(region.nodes) do
				options[#options+1] = node
			end
		end
	end

	return options
end

--[=[
	Creates a new OctreeNode at the given position which can be retrieved
	:::tip
	Be sure to call :Destroy() on a node if the data becomes stale. Note that
	this is not necessary if the whole octree is removed from memory.
	:::
	```lua
	local octree = Octree.new()
	octree:CreateNode(Vector3.new(0, 0, 0), "A")
	octree:CreateNode(Vector3.new(0, 0, 0), "B")
	```
	@param position Vector3
	@param object T
	@return OctreeNode<T>
]=]
function Octree:CreateNode(position, object)
	assert(typeof(position) == "Vector3", "Bad position value")
	assert(object, "Bad object value")

	local node = OctreeNode.new(self, object)

	node:SetPosition(position)

	return node
end

--[=[
	Searches at the position and radius for any objects that may be within
	this radius.
	```lua
	local octree = Octree.new()
	octree:CreateNode(Vector3.new(0, 0, 0), "A")
	octree:CreateNode(Vector3.new(0, 0, 0), "B")
	octree:CreateNode(Vector3.new(0, 0, 1000), "C")
	print(octree:RadiusSearch(Vector3.new(0, 0, 0), 100)) --> { "A", "B" }
	```
	@param position Vector3
	@param radius number
	@return { T } -- Objects found
	@return { number } -- Distances squared
]=]
function Octree:RadiusSearch(position, radius)
	assert(typeof(position) == "Vector3", "Bad position")
	assert(type(radius) == "number", "Bad radius")

	local px, py, pz = position.x, position.y, position.z
	return self:_radiusSearch(px, py, pz, radius)
end

--[=[
	Searches at the position and radius for any objects that may be within
	this radius. Returns the knearest entries.
	The closest entities will be first in the list.
	@param position Vector3
	@param k number -- Number of objects to find
	@param radius number
	@return { any } -- Objects found
	@return { number } -- Distances squared
]=]
function Octree:KNearestNeighborsSearch(position, k, radius)
	assert(typeof(position) == "Vector3", "Bad position")
	assert(type(radius) == "number", "Bad radius")

	local px, py, pz = position.x, position.y, position.z
	local objects, nodeDistances2 = self:_radiusSearch(px, py, pz, radius)

	local sortable = {}
	for index, dist2 in pairs(nodeDistances2) do
		table.insert(sortable, {
			dist2 = dist2;
			index = index;
		})
	end

	table.sort(sortable, function(a, b)
		return a.dist2 < b.dist2
	end)

	local knearest = {}
	local knearestDist2 = {}
	for i = 1, math.min(#sortable, k) do
		local sorted = sortable[i]
		knearestDist2[#knearestDist2 + 1] = sorted.dist2
		knearest[#knearest + 1] = objects[sorted.index]
	end

	return knearest, knearestDist2
end

--[=[
	Internal API to create lowest subregion
	@private
	@param px number
	@param py number
	@param pz number
	@return OctreeSubregion
]=]
function Octree:GetOrCreateLowestSubRegion(px, py, pz)
	local region = self:_getOrCreateRegion(px, py, pz)
	return OctreeRegionUtils.getOrCreateSubRegionAtDepth(region, px, py, pz, self._maxDepth)
end

function Octree:_radiusSearch(px, py, pz, radius)
	local objectsFound = {}
	local nodeDistances2 = {}

	local diameter = self._maxRegionSize[1]
	local searchRadiusSquared = OctreeRegionUtils.getSearchRadiusSquared(radius, diameter, EPSILON)

	for _, regionList in pairs(self._regionHashMap) do
		for _, region in pairs(regionList) do
			local rpos = region.position
			local rpx, rpy, rpz = rpos[1], rpos[2], rpos[3]
			local ox, oy, oz = px - rpx, py - rpy, pz - rpz
			local dist2 = ox*ox + oy*oy + oz*oz

			if dist2 <= searchRadiusSquared then
				OctreeRegionUtils.getNeighborsWithinRadius(
					region, radius, px, py, pz, objectsFound, nodeDistances2, self._maxDepth)
			end
		end
	end

	return objectsFound, nodeDistances2
end

function Octree:_getRegion(px, py, pz)
	return OctreeRegionUtils.findRegion(self._regionHashMap, self._maxRegionSize, px, py, pz)
end

function Octree:_getOrCreateRegion(px, py, pz)
	return OctreeRegionUtils.getOrCreateRegion(self._regionHashMap, self._maxRegionSize, px, py, pz)
end

return Octree]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000430b</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX1BDC631B596A4EEBB9812F83ED22D205">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c6a</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">_OctreeRegionUtils</string>
									<string name="ScriptGuid">{3817337B-7C45-4E14-B95E-0697A2931831}</string>
									<ProtectedString name="Source"><![CDATA[--!native
--[=[
	Octree implementation utilities. Primarily this utility code
	should not be used directly and should be considered private to
	the library.

	Use [Octree](/api/Octree) instead of this library directly.

	@class OctreeRegionUtils
]=]

local EPSILON = 1e-6
local SQRT_3_OVER_2 = math.sqrt(3)/2
local SUB_REGION_POSITION_OFFSET = {
	{ 0.25, 0.25, -0.25 };
	{ -0.25, 0.25, -0.25 };
	{ 0.25, 0.25, 0.25 };
	{ -0.25, 0.25, 0.25 };
	{ 0.25, -0.25, -0.25 };
	{ -0.25, -0.25, -0.25 };
	{ 0.25, -0.25, 0.25 };
	{ -0.25, -0.25, 0.25 };
}

local OctreeRegionUtils = {}

local FunctionUtils = require("../../../FunctionUtils")

--[=[
	Visualizes the octree region.

	@param region OctreeRegion<T>
	@return MaidTask
]=]
function OctreeRegionUtils.visualize(region, transparency, color)
	local size = region.size
	local position = region.position
	local sx, sy, sz = size[1], size[2], size[3]
	local px, py, pz = position[1], position[2], position[3]
	
	local box = FunctionUtils.DebugDraw.box(CFrame.new(Vector3.new(px, py, pz)), Vector3.new(sx, sy, sz), color)

	return box
end

--[=[
	A Vector3 equivalent for octrees. This type is primarily internal and
	used for faster access than a Vector3.

	@type OctreeVector3 { [1]: number, [2]: number, [3]: number }
	@within OctreeRegionUtils
]=]

--[=[
	An internal region which stores the data.

	@interface OctreeRegion<T>
	.subRegions { OctreeRegion<T> }
	.lowerBounds OctreeVector3
	.upperBounds OctreeVector3
	.position OctreeVector3
	.size OctreeVector3
	.parent OctreeRegion<T>?
	.parentIndex number
	.depth number
	.nodes { OctreeNode<T> }
	.node_count number
	@within OctreeRegionUtils
]=]

--[=[
	Creates a new OctreeRegion<T>

	@param px number
	@param py number
	@param pz number
	@param sx number
	@param sy number
	@param sz number
	@param parent OctreeRegion<T>?
	@param parentIndex number?
	@return OctreeRegion<T>
]=]
local boxes = {};
function OctreeRegionUtils.create(px, py, pz, sx, sy, sz, parent, parentIndex)
	local hsx, hsy, hsz = sx/2, sy/2, sz/2

	local region = {
		subRegions = {
			--topNorthEast
			--topNorthWest
			--topSouthEast
			--topSouthWest
			--bottomNorthEast
			--bottomNorthWest
			--bottomSouthEast
			--bottomSouthWest
		};
		lowerBounds = { px - hsx, py - hsy, pz - hsz };
		upperBounds = { px + hsx, py + hsy, pz + hsz };
		position = { px, py, pz };
		size = { sx, sy, sz }; -- { sx, sy, sz }
		parent = parent;
		depth = parent and (parent.depth + 1) or 1;
		parentIndex = parentIndex;
		nodes = {}; -- [node] = true (contains subchild nodes too)
		node_count = 0;
	}

	--[[
	local map = {Color3.new(1, 0, 0),Color3.new(0, 0, 1), Color3.new(0, 1, 0), Color3.new(0.7, 0, 0.8)}
	if (region.depth >= 1) then

		local trans = 0.92;
		if (region.depth >= 3) then
			trans = 0.98;
		end

		OctreeRegionUtils.visualize(region, trans, map[#map-region.depth], false)

	end
	--]]
	-- if region.depth >= 5 then
	-- 	OctreeRegionUtils.visualize(region)
	-- end

	return region
end


--[=[
	Adds a node to the lowest subregion
	@param lowestSubregion OctreeRegion<T>
	@param node OctreeNode
]=]
function OctreeRegionUtils.addNode(lowestSubregion, node)
	assert(node, "Bad node")

	local current = lowestSubregion
	while current do
		if not current.nodes[node] then
			current.nodes[node] = node
			current.node_count = current.node_count + 1
		end
		current = current.parent
	end
end

--[=[
	Moves a node from one region to another

	@param fromLowest OctreeRegion<T>
	@param toLowest OctreeRegion<T>
	@param node OctreeNode
]=]
function OctreeRegionUtils.moveNode(fromLowest, toLowest, node)
	assert(fromLowest.depth == toLowest.depth, "fromLowest.depth ~= toLowest.depth")
	assert(fromLowest ~= toLowest, "fromLowest == toLowest")

	local currentFrom = fromLowest
	local currentTo = toLowest
	while currentFrom ~= currentTo do
		-- remove from current
		do
			assert(currentFrom.nodes[node], "Not in currentFrom")
			assert(currentFrom.node_count > 0, "No nodes in currentFrom")

			currentFrom.nodes[node] = nil
			currentFrom.node_count = currentFrom.node_count - 1

			-- remove subregion!
			if currentFrom.node_count <= 0 and currentFrom.parentIndex then
				assert(currentFrom.parent, "Bad currentFrom.parent")
				assert(currentFrom.parent.subRegions[currentFrom.parentIndex] == currentFrom, "Not in subregion")
				currentFrom.parent.subRegions[currentFrom.parentIndex] = nil
			end
		end

		-- add to new
		do
			assert(not currentTo.nodes[node], "Failed to add")
			currentTo.nodes[node] = node
			currentTo.node_count = currentTo.node_count + 1
		end

		currentFrom = currentFrom.parent
		currentTo = currentTo.parent
	end
end

--[=[
	Removes a node from the given region

	@param lowestSubregion OctreeRegion<T>
	@param node OctreeNode
]=]
function OctreeRegionUtils.removeNode(lowestSubregion, node)
	assert(node, "Bad node")

	local current = lowestSubregion
	while current do
		assert(current.nodes[node], "Not in current")
		assert(current.node_count > 0, "Current has bad node count")

		current.nodes[node] = nil
		current.node_count = current.node_count - 1

		-- remove subregion!
		if current.node_count <= 0 and current.parentIndex then
			assert(current.parent, "No parent")
			assert(current.parent.subRegions[current.parentIndex] == current, "Not in subregion")
			current.parent.subRegions[current.parentIndex] = nil
		end

		current = current.parent
	end
end


--[=[
	Retrieves the search radius for a given radius given the region
	diameter

	@param radius number
	@param diameter number
	@param epsilon number
	@return number
]=]
function OctreeRegionUtils.getSearchRadiusSquared(radius, diameter, epsilon)
	local diagonal = SQRT_3_OVER_2*diameter
	local searchRadius = radius + diagonal
	return searchRadius*searchRadius + epsilon
end

-- luacheck: push ignore
--[=[
	Adds all octree nod values to objectsFound

	See basic algorithm:
	https://github.com/PointCloudLibrary/pcl/blob/29f192af57a3e7bdde6ff490669b211d8148378f/octree/include/pcl/octree/impl/octree_search.hpp#L309

	@param region OctreeRegion<T>
	@param radius number
	@param px number
	@param py number
	@param pz number
	@param objectsFound { T }
	@param nodeDistances2 { number }
	@param maxDepth number
]=]
function OctreeRegionUtils.getNeighborsWithinRadius(region, radius, px, py, pz, objectsFound, nodeDistances2, maxDepth)
-- luacheck: pop
	assert(maxDepth, "Bad maxDepth")

	local childDiameter = region.size[1]/2
	local searchRadiusSquared = OctreeRegionUtils.getSearchRadiusSquared(radius, childDiameter, EPSILON)

	local radiusSquared = radius*radius

	-- for each child
	for _, childRegion in pairs(region.subRegions) do
		local cposition = childRegion.position
		local cpx, cpy, cpz = cposition[1], cposition[2], cposition[3]

		local ox, oy, oz = px - cpx, py - cpy, pz - cpz
		local dist2 = ox*ox + oy*oy + oz*oz

		-- within search radius
		if dist2 <= searchRadiusSquared then
			if childRegion.depth == maxDepth then
				for node, _ in pairs(childRegion.nodes) do
					local npx, npy, npz = node:GetRawPosition()
					local nox, noy, noz = px - npx, py - npy, pz - npz
					local ndist2 = nox*nox + noy*noy + noz*noz
					if ndist2 <= radiusSquared then
						objectsFound[#objectsFound + 1] = node:GetObject()
						nodeDistances2[#nodeDistances2 + 1] = ndist2
					end
				end
			else
				OctreeRegionUtils.getNeighborsWithinRadius(
					childRegion, radius, px, py, pz, objectsFound, nodeDistances2, maxDepth)
			end
		end
	end
end

--[=[
	Recursively ensures that a subregion exists at a given depth, and returns
	that region for usage.

	@param region OctreeRegion<T> -- Top level region
	@param px number
	@param py number
	@param pz number
	@param maxDepth number
	@return OctreeRegion<T>
]=]
function OctreeRegionUtils.getOrCreateSubRegionAtDepth(region, px, py, pz, maxDepth)
	local current = region
	for _ = region.depth, maxDepth do
		local index = OctreeRegionUtils.getSubRegionIndex(current, px, py, pz)
		local _next = current.subRegions[index]

		-- construct
		if not _next then
			_next = OctreeRegionUtils.createSubRegion(current, index)
			current.subRegions[index] = _next
		end

		-- iterate
		current = _next
	end
	return current
end

--[=[
	Creates a subregion for an octree.
	@param parentRegion OctreeRegion<T>
	@param parentIndex number
	@return OctreeRegion<T>
]=]
function OctreeRegionUtils.createSubRegion(parentRegion, parentIndex)
	local size = parentRegion.size
	local position = parentRegion.position
	local multiplier = SUB_REGION_POSITION_OFFSET[parentIndex]

	local px = position[1] + multiplier[1]*size[1]
	local py = position[2] + multiplier[2]*size[2]
	local pz = position[3] + multiplier[3]*size[3]
	local sx, sy, sz = size[1]/2, size[2]/2, size[3]/2

	return OctreeRegionUtils.create(px, py, pz, sx, sy, sz, parentRegion, parentIndex)
end

--[=[
	Computes whether a region is in bounds.

	Consider regions to be range [px, y).

	@param region OctreeRegion<T>
	@param px number
	@param py number
	@param pz number
	@return boolean
]=]
function OctreeRegionUtils.inRegionBounds(region, px, py, pz)
	local lowerBounds = region.lowerBounds
	local upperBounds = region.upperBounds
	return (
		px >= lowerBounds[1] and px <= upperBounds[1] and
		py >= lowerBounds[2] and py <= upperBounds[2] and
		pz >= lowerBounds[3] and pz <= upperBounds[3]
	)
end

--[=[
	Gets a subregion's internal index.

	@param region OctreeRegion<T>
	@param px number
	@param py number
	@param pz number
	@return number
]=]
function OctreeRegionUtils.getSubRegionIndex(region, px, py, pz)
	local index = px > region.position[1] and 1 or 2
	if py <= region.position[2] then
		index = index + 4
	end

	if pz >= region.position[3] then
		index = index + 2
	end
	return index
end

--[=[
	This definitely collides fairly consistently

	See: https://stackoverflow.com/questions/5928725/hashing-2d-3d-and-nd-vectors

	@param cx number
	@param cy number
	@param cz number
	@return number
]=]
function OctreeRegionUtils.getTopLevelRegionHash(cx, cy, cz)
	-- Normally you would modulus this to hash table size, but we want as flat of a structure as possible
	return cx * 73856093 + cy*19351301 + cz*83492791
end

--[=[
	Computes the index for a top level cell given a position

	@param maxRegionSize OctreeVector3
	@param px number
	@param py number
	@param pz number
	@return number -- rpx
	@return number -- rpy
	@return number -- rpz
]=]
function OctreeRegionUtils.getTopLevelRegionCellIndex(maxRegionSize, px, py, pz)
	return math.floor(px / maxRegionSize[1] + 0.5),
		math.floor(py / maxRegionSize[2] + 0.5),
		math.floor(pz / maxRegionSize[3] + 0.5)
end

--[=[
	Computes a top-level region's position

	@param maxRegionSize OctreeVector3
	@param cx number
	@param cy number
	@param cz number
	@return number
	@return number
	@return number
]=]
function OctreeRegionUtils.getTopLevelRegionPosition(maxRegionSize, cx, cy, cz)
	return maxRegionSize[1] * cx,
		maxRegionSize[2] * cy,
		maxRegionSize[3] * cz
end

--[=[
	Given a top-level region, returns if the region position are equal
	to this region

	@param region OctreeRegion<T>
	@param rpx number
	@param rpy number
	@param rpz number
	@return boolean
]=]
function OctreeRegionUtils.areEqualTopRegions(region, rpx, rpy, rpz)
	local position = region.position
	return position[1] == rpx
		and position[2] == rpy
		and position[3] == rpz
end

--[=[
	Given a world space position, finds the current region in the hashmap

	@param regionHashMap { [number]: { OctreeRegion<T> } }
	@param maxRegionSize OctreeVector3
	@param px number
	@param py number
	@param pz number
	@return OctreeRegion3?
]=]
function OctreeRegionUtils.findRegion(regionHashMap, maxRegionSize, px, py, pz)
	local cx, cy, cz = OctreeRegionUtils.getTopLevelRegionCellIndex(maxRegionSize, px, py, pz)
	local hash = OctreeRegionUtils.getTopLevelRegionHash(cx, cy, cz)

	local regionList = regionHashMap[hash]
	if not regionList then
		return nil
	end

	local rpx, rpy, rpz = OctreeRegionUtils.getTopLevelRegionPosition(maxRegionSize, cx, cy, cz)
	for _, region in pairs(regionList) do
		if OctreeRegionUtils.areEqualTopRegions(region, rpx, rpy, rpz) then
			return region
		end
	end

	return nil
end

--[=[
	Gets the current region for a position, or creates a new one.

	@param regionHashMap { [number]: { OctreeRegion<T> } }
	@param maxRegionSize OctreeVector3
	@param px number
	@param py number
	@param pz number
	@return OctreeRegion<T>
]=]
function OctreeRegionUtils.getOrCreateRegion(regionHashMap, maxRegionSize, px, py, pz)
	local cx, cy, cz = OctreeRegionUtils.getTopLevelRegionCellIndex(maxRegionSize, px, py, pz)
	local hash = OctreeRegionUtils.getTopLevelRegionHash(cx, cy, cz)

	local regionList = regionHashMap[hash]
	if not regionList then
		regionList = {}
		regionHashMap[hash] = regionList
	end

	local rpx, rpy, rpz = OctreeRegionUtils.getTopLevelRegionPosition(maxRegionSize, cx, cy, cz)
	for _, region in pairs(regionList) do
		if OctreeRegionUtils.areEqualTopRegions(region, rpx, rpy, rpz) then
			return region
		end
	end

	local region = OctreeRegionUtils.create(
		rpx, rpy, rpz,
		maxRegionSize[1], maxRegionSize[2], maxRegionSize[3])
	table.insert(regionList, region)

	return region
end

return OctreeRegionUtils]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000430c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBE059D5B85D04003B95E1847E338646C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c6b</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">_OctreeNode</string>
									<string name="ScriptGuid">{3661DD10-D65A-4CC7-B30A-43C56103DDE1}</string>
									<ProtectedString name="Source"><![CDATA[--[=[
	Basic node interacting with the octree. See [Octree](/api/Octree) for usage.

	```lua
	local octree = Octree.new()
	local node = octree:CreateNode(Vector3.new(0, 0, 0), "A")
	print(octree:RadiusSearch(Vector3.new(0, 0, 0), 100)) --> { "A" }

	node:Destroy() -- Remove node from octree

	print(octree:RadiusSearch(Vector3.new(0, 0, 0), 100)) --> { }
	```
	@class OctreeNode
]=]

local OctreeRegionUtils = require("./_OctreeRegionUtils")

local OctreeNode = {}
OctreeNode.ClassName = "OctreeNode"
OctreeNode.__index = OctreeNode

--[=[
	Creates a new for the given Octree with the object.

	:::warning
	Use Octree:CreateNode() for more consistent results. To use this object directly
	you need to set the position before it's registered which may be unclean.
	:::

	@private
	@param octree Octree
	@param object T
	@return OctreeNode<T>
]=]
function OctreeNode.new(octree, object)
	local self = setmetatable({}, OctreeNode)

	self._octree = octree or error("No octree")
	self._object = object or error("No object")

	self._currentLowestRegion = nil
	self._position = nil

	return self
end

--[=[
	Finds the nearest neighbors to this node within the radius

	```lua
	local octree = Octree.new()
	local node = octree:CreateNode(Vector3.new(0, 0, 0), "A")
	octree:CreateNode(Vector3.new(0, 0, 5), "B")
	print(octree:KNearestNeighborsSearch(10, 100)) --> { "A", "B" } { 0, 25 }
	```

	@param k number -- The number to retrieve
	@param radius number -- The radius to search in
	@return { T } -- Objects found, including self
	@return { number } -- Distances squared
]=]
function OctreeNode:KNearestNeighborsSearch(k, radius)
	return self._octree:KNearestNeighborsSearch(self._position, k, radius)
end

--[=[
	Returns the object stored in the octree

	```lua
	local octree = Octree.new()
	local node = octree:CreateNode(Vector3.new(0, 0, 0), "A")
	print(octree:GetObject()) --> "A"
	```

	@return T
]=]
function OctreeNode:GetObject()
	return self._object
end

--[=[
	Finds the nearest neighbors to the octree node

	@param radius number -- The radius to search in
	@return { any } -- Objects found
	@return { number } -- Distances squared
]=]
function OctreeNode:RadiusSearch(radius)
	return self._octree:RadiusSearch(self._position, radius)
end

--[=[
	Retrieves the position

	@return Vector3
]=]
function OctreeNode:GetPosition()
	return self._position
end

--[=[
	Retrieves the as px, py, pz

	@return number -- px
	@return number -- py
	@return number -- pz
]=]
function OctreeNode:GetRawPosition()
	return self._px, self._py, self._pz
end

--[=[
	Sets the position of the octree nodes and updates the octree accordingly

	```lua
	local octree = Octree.new()
	local node = octree:CreateNode(Vector3.new(0, 0, 0), "A")
	print(octree:RadiusSearch(Vector3.new(0, 0, 0), 100)) --> { "A" }

	node:SetPosition(Vector3.new(1000, 0, 0))
	print(octree:RadiusSearch(Vector3.new(0, 0, 0), 100)) --> {}
	```

	@param position Vector3
]=]
function OctreeNode:SetPosition(position)
	if self._position == position then
		return
	end

	local px, py, pz = position.x, position.y, position.z

	self._px = px
	self._py = py
	self._pz = pz
	self._position = position

	if self._currentLowestRegion then
		if OctreeRegionUtils.inRegionBounds(self._currentLowestRegion, px, py, pz) then
			return
		end
	end

	local newLowestRegion = self._octree:GetOrCreateLowestSubRegion(px, py, pz)

	-- Sanity check for debugging
	-- if not OctreeRegionUtils.inRegionBounds(newLowestRegion, px, py, pz) then
	-- 	error("[OctreeNode.SetPosition] newLowestRegion is not in region bounds!")
	-- end

	if self._currentLowestRegion then
		OctreeRegionUtils.moveNode(self._currentLowestRegion, newLowestRegion, self)
	else
		OctreeRegionUtils.addNode(newLowestRegion, self)
	end

	self._currentLowestRegion = newLowestRegion
end

--[=[
	Removes the OctreeNode from the octree
]=]
function OctreeNode:Destroy()
	if self._currentLowestRegion then
		OctreeRegionUtils.removeNode(self._currentLowestRegion, self)
	end
end

return OctreeNode]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000430d</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX1FEF743C7D734C0EA8487447634ECC75">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">2a732b3377d053d0089136b60000c746</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_StateMachine</string>
							<string name="ScriptGuid">{B234FC55-04AE-41FB-A321-A500C8675A15}</string>
							<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local State = require(script.State)
local Transition = require(script.Transition)
local Signal = require(script.Parent._Signal)
local Trove = require(script.Parent._Trove)
local Copy = require(script.Parent.Parent.FunctionUtils._table).copy

type Trove = Trove.Trove

local DUPLICATE_ERROR: string = "There cannot be more than 1 state by the same name"
local DATA_WARNING: string = "[Warning]: The data of this state machine is not a table. It will be converted to a table. Please do not set data to a non table object"
local STATE_NOT_FOUND: string = "Attempt to %s, but there is no state by the name of %s"
local WRONG_TRANSITION: string = "Attempt to add a transition that is not a transition"

-- Used for quicker access to the directories
local cacheDirectories = {} :: {[Instance]: {any}}

--[=[
    @class StateMachine

    State Machines consist of state managers that dictate at which state does an object currently meet at.
    It allows us to easily manage what should an object do at each given state and when/how it should change
    between them
]=]
local StateMachine = {}
StateMachine.__index = StateMachine
--[=[
    @prop Data {[string]: any}
    @within StateMachine

    Contains the data that is shared accross all states and transitions of this state machine. Should be accessed with :GetData

    E.g
    ```lua
    local stateMachine = RobloxStateMachine.new("state", states, {health = 0})
    stateMachine:GetData().health = 50
    ```

    The data is shared accross all states and transitions. It can be access in 2 different ways

    ```lua
    --transition.lua
    local GoToBlue = Transition.new("Blue")

    function GoToBlue:OnDataChanged(data)
        print(self.Data, data) -- 2 ways to access the data
        return false
    end

    --state.lua
    local Default: State = State.new("Blue")

    function Default:OnInit(data)
        print(self.Data, data)
    end
    ```
]=]
StateMachine.Data = {} :: {[string]: any}
--[=[
    @prop StateChanged�?� Signal<(string, string)>?
    @within StateMachine

    Called whenever the state of this state machinse changes. The first argument
    is the new state and the second one is the previous state. If there was no previous state
    then it will be an empty string

    e.g
    ```lua
    exampleStateMachine.StateChanged:Connect(function(newState: string, previousState: string)
        print("Our previous state was: " .. previousState .. " now our state is: " .. newState)
    end)
    ```
]=]
StateMachine.StateChanged = nil :: Signal.Signal<(string, string)>?
--[=[
    @prop DataChanged�?� Signal<({[string]: any}, any, any, any)>?
    @within StateMachine

    Called whenever the data from the state machine gets changed. 

    :::warning
    **DataChanged** only gets called when the data is changed by a **ChangeData** call
    :::

    e.g
    ```lua
    exampleStateMachine.StateChanged:Connect(function(newState: string, previousState: string)
        print("Our previous state was: " .. previousState .. " now our state is: " .. newState)
    end)
    ```
]=]
StateMachine.DataChanged = nil :: Signal.Signal<({[string]: any}, any, any, any)>?
--[=[
    @prop State State
    @within StateMachine

    A reference to the State class
]=]
StateMachine.State = State
--[=[
    @prop Transition Transition
    @within StateMachine

    A reference to the Transition class
]=]
StateMachine.Transition = Transition
--[=[
    @prop _States {[string]: State}
    @within StateMachine
    @private

    Caches the states of this state machine. It's used to change states and check transitions
]=]
StateMachine._States = {} :: {[string]: State}
--[=[
    @prop _trove Trove
    @within StateMachine
    @private

    A trove object to store and clear up connections
]=]
StateMachine._trove = newproxy() :: Trove
--[=[
    @prop _stateTrove Trove
    @within StateMachine
    @private

    A trove object to clear state threads and connections
]=]
StateMachine._stateTrove = newproxy() :: Trove
--[=[
    @prop _CurrentState string
    @within StateMachine
    @private

    Caches the current state in a string format. It's used to fire the StateChanged signal
]=]
StateMachine._CurrentState = "" :: string
--[=[
    @prop _PreviousState string
    @within StateMachine
    @private

    Caches the previous state in a string format. It's used to fire the StateChanged signal
]=]
StateMachine._PreviousState = "" :: string
--[=[
    @prop _Destroyed boolean
    @within StateMachine
    @private

    Checks if the object has already been destroyed or not
]=]
StateMachine._Destroyed = false :: boolean
--[=[
    Used to create a new State Machine. It expects 3 arguments being the third one an optional one

    ```lua
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local RobloxStateMachine = require(ReplicatedStorage.RobloxStateMachine)

    local exampleStateMachine: RobloxStateMachine.RobloxStateMachine = RobloxStateMachine.new(
        "Default",
        RobloxStateMachine:LoadDirectory(script.Example.States), 
        {
            part = workspace.Example,
            time = tick(),
        }
    )
    ```

    @param initialState string -- The name of the state at which it should start
    @param states {State.State} -- An array of the states this state machine should have
    @param initialData {[string]: any}? -- The starting data to be used by the states

    @return RobloxStateMachine
]=]
function StateMachine.new(initialState: string, states: {State}, initialData: {[string]: any}?): RobloxStateMachine
    local self = setmetatable({}, StateMachine)

    self._States = {} :: {[string]: State}
    self._trove = Trove.new()
    self._stateTrove = Trove.new()

    self._Destroyed = false
    
    self.Data = initialData or {} :: {[string]: any}
    self.StateChanged = Signal.new() :: Signal.Signal<(string, string)>
    self.DataChanged = Signal.new() :: Signal.Signal<({[string]: any}, any, any, any)>?

    for _, state: State.State in states do -- Load the states
        if self._States[state.Name] then
            error(DUPLICATE_ERROR.." \""..state.Name.."\"", 2)
        end

        local stateClone: State.State = Copy(state)
        stateClone.Data = self.Data
        stateClone._changeState = function(newState: string)
            self:ChangeState(newState)
        end
        stateClone._changeData = function(index: string, newValue: any)
            self:ChangeData(index, newValue)
        end
        stateClone._getState = function()
            return self:GetCurrentState()
        end
        stateClone._getPreviousState = function()
            return self:GetPreviousState()
        end

        stateClone._transitions = {}

        for _, transition: Transition in stateClone.Transitions do
            if #transition.Name == 0 then
                transition.Name = HttpService:GenerateGUID(false)
            end

            local transitionClone: Transition = Copy(transition)
            transitionClone._changeData = function(index: string, newValue: any)
                self:ChangeData(index, newValue)
            end
            transitionClone._getState = function()
                return self:GetCurrentState()
            end
            transitionClone._getPreviousState = function()
                return self:GetPreviousState()
            end

            if transitionClone.Type ~= Transition.Type then
                error(WRONG_TRANSITION, 2)
            end
 
            transitionClone.Data = stateClone.Data
            transitionClone._changeState = function(newState: string)
                self:ChangeState(newState)
            end

            stateClone._transitions[transitionClone.Name] = transitionClone
            task.spawn(transitionClone.OnInit, transitionClone, self.Data)
            self._trove:Add(transitionClone, "OnDestroy")
        end

        self._States[state.Name] = stateClone
        task.spawn(stateClone.OnInit, stateClone, self.Data)
        self._trove:Add(stateClone, "OnDestroy")
    end

    if not self._States[initialState] then
        error(STATE_NOT_FOUND:format("create a state machine", initialState), 2)
    end

    local previousState: State = nil
    self._trove:Add(RunService.Heartbeat:Connect(function(deltaTime: number)
        if self._Destroyed then
            return
        end

        self:_CheckTransitions()
        
        local state = self:_GetCurrentStateObject()
        local firstFrame: boolean = state ~= previousState
        previousState = state
        if firstFrame then
            return
        end

        if not state or getmetatable(state).OnHeartbeat == state.OnHeartbeat then
            return
        end

        task.spawn(state.OnHeartbeat, state, self:GetData(), deltaTime)
    end))

    self._trove:Add(self.StateChanged)
    self._trove:Add(self.DataChanged)

    self:_ChangeState(initialState)

    return self
end

--[=[
    Returns the current state of the State Machine

    ```lua
    local exampleStateMachine = RobloxStateMachine.new("Default", {}, {})
    print(exampleStateMachine:GetCurrentState()) -- Default
    ```

    @return string
]=]
function StateMachine:GetCurrentState(): string
    return self._CurrentState
end

--[=[
    Returns the previous state of the State Machine

    ```lua
    local exampleStateMachine = RobloxStateMachine.new("Default", {...BlueStateHere}, {})
    exampleStateMachine:ChangeState("Blue")
    print(exampleStateMachine:GetPreviousState()) -- "Default"
    ```

    @return string
]=]
function StateMachine:GetPreviousState(): string
    return self._PreviousState
end

--[=[
    Changing data request. You can also just Get the data and change the data at run time.

    ```lua
    local stateMachine = RobloxStateMachine.new("state", states, {health = 0})

    stateMachine:GetData().health = 50 -- This is the same as
    stateMachine:ChangeData("Health", 50) -- this
    ```

    @param index string
    @param newValue any

    @return ()
]=]
function StateMachine:ChangeData(index: string, newValue: any): ()
    if self._Destroyed or self.Data[index] == newValue then
        return
    end
    
    local oldValue: any = self.Data[index]
    self.Data[index] = newValue

    local state: State = self._States[self:GetCurrentState()]
    task.spawn(state.OnDataChanged, state, self.Data, index, newValue, oldValue)
    self.DataChanged:Fire(self.Data, index, newValue, oldValue)
end

--[=[
    Gets the custom data of this state machine object.

    ```lua
    local stateMachine = RobloxStateMachine.new("Start", {state1, state2}, {health = 20})

    print(stateMachine:GetData().health) -- 20
    ```

    @return {[string]: any}
]=]
function StateMachine:GetData(): {[string]: any}
    if typeof(self.Data) ~= "table" then
        warn(DATA_WARNING)
        self.Data = {}
    end

    return self.Data
end

--[=[
    Used to load thru a directory. It's specially useful to load states and or transitions!

    ```lua
    local exampleStateMachine: RobloxStateMachine.RobloxStateMachine = RobloxStateMachine.new(
        "Default",
        RobloxStateMachine:LoadDirectory(script.Example.States), 
        {
            part = workspace.Example,
            time = tick(),
        }
    )
    ```

    You can also use it to load specific files by feeding the names you wish to load


    @param directory Instance
    @param names {string}? -- If you wish to only load specific states you can pass an array of names

    @return {any}
]=]
function StateMachine:LoadDirectory(directory: Instance, names: {string}?): {any}
    if not cacheDirectories[directory] then
        cacheDirectories[directory] = {}

        for _, child: Instance in directory:GetDescendants() do
            if not child:IsA("ModuleScript") then
                continue
            end
            
            local success: boolean, result: any = pcall(function()
                return require(child)
            end)

            if 
                not success or
                typeof(result) ~= "table"
            then
                continue
            end

            if result.Type ~= State.Type and result.Type ~= Transition.Type then
                continue
            end

            if not result.Name or result.Name == "" then
                result.Name = child.Name
            end
            
            table.insert(cacheDirectories[directory], result)
        end
    end

    if not names then
        return cacheDirectories[directory]
    end

    local filteredFiles = {}

    for _, file in cacheDirectories[directory] do
        if table.find(names, file.Name) then
            table.insert(filteredFiles, file)
        end
    end

    return filteredFiles
end

--[=[
    If you wish to stop using the state machine at any point you should then clear
    it from the memory. Call Destroy whenever you are done with the state machine.

    ```lua
    local stateMachine = RobloxStateMachine.new(...)

    task.wait(5)

    stateMachine:Destroy()
    ```

    @return ()
]=]
function StateMachine:Destroy(): ()
    if self._Destroyed then
        return
    end
    
    self._Destroyed = true
    
    local state: State? = self:_GetCurrentStateObject()

    if state then
        task.spawn(state.OnLeave, state, self:GetData())
    end

    self._trove:Destroy()
    self._stateTrove:Destroy()
end

--[=[
    Forcelly changes the current state of our state machine to a new one

    @param newState string -- The name of the new state

    @return ()
]=]
function StateMachine:ChangeState(newState: string): ()
    local currentState: State? = self:_GetCurrentStateObject()

    if currentState and not currentState:CanChangeState(newState) then
        return
    end

    self:_ChangeState(newState)
end

--[=[
    Checks if the state exists

    @private

    @param stateName string

    @return boolean
]=]
function StateMachine:_StateExists(stateName: string): boolean
    return self._States[stateName] ~= nil
end

--[=[
    Called to change the current state of the state machine

    @private

    @param newState string

    @return ()
]=]
function StateMachine:_ChangeState(newState: string): ()
    if self._Destroyed then
        return
    end
    
    assert(self:_StateExists(newState), STATE_NOT_FOUND:format(`change to {newState}`, newState))

    if self._CurrentState == newState then
        return
    end

    local previousState: State? = self:_GetCurrentStateObject()
    local state: State? = self._States[newState]

    if not state then
        return
    end

    self._stateTrove:Clean()
    if previousState then
        task.spawn(previousState.OnLeave, previousState, self:GetData())
        self:_CallTransitions(previousState, "OnLeave", self:GetData())
    end

    task.defer(function()
        self:_CallTransitions(state, "OnEnter", self:GetData())
    end)
    self._stateTrove:Add(task.defer(state.OnEnter, state, self:GetData()))
    
    self._CurrentState = newState

    if previousState then
        self._PreviousState = previousState.Name
        self.StateChanged:Fire(newState, previousState.Name or "")
    end
end

--[=[
    Gets the current state object of the state machine

    @private

    @return State
]=]
function StateMachine:_GetCurrentStateObject(): State?
    return self._States[self:GetCurrentState()]
end

--[=[
    Checks if we meet any condition to change the current state.
    If any of the transitions returns true then we should change the current state

    @private

    @return ()
]=]
function StateMachine:_CheckTransitions(): ()
    for _, transition: Transition in self:_GetCurrentStateObject()._transitions do
        if transition:CanChangeState(self:GetData()) and transition:OnDataChanged(self:GetData()) then
            self:ChangeState(transition.TargetState)
            break
        end
    end
end

--[=[
    Calls the transition method of the given state

    @param state State
    @param methodName string
    @param ... any

    @private

    @return ()
]=]
function StateMachine:_CallTransitions(state: State, methodName: string, ...: any): ()
    for _, transition: Transition in state._transitions do
        task.spawn(transition[methodName], transition, ...)
    end
end

export type RobloxStateMachine = typeof(StateMachine)
export type State = State.State
export type Transition = Transition.Transition

return setmetatable(StateMachine, {
    __call = function(_, initialState: string, states: {State}, initialData: {[string]: any}?): RobloxStateMachine
        return StateMachine.new(initialState, states, initialData)
    end
})]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000430e</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXD2F8B1CC1B5B4025A95F37EB9A185D34">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">2a732b3377d053d0089136b60000c744</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">State</string>
								<string name="ScriptGuid">{18FDDD3A-7B88-4217-9172-B796E8305BC9}</string>
								<ProtectedString name="Source"><![CDATA[local Transition = require(script.Parent.Transition)
local mergeTables = require(script.Parent.Parent.Parent.FunctionUtils._table).mergeTables

--[=[
    @class State

    Describes one of the many states an object can have. It also declares
    how it should behave when it enters, is and leaves the given state
]=]
local State = {}
State.__index = State
State.Type = "State"
--[=[
    @prop Name string
    @within State

    The name of the state. This is used to identify the state. Usually set while creating the state

    ```lua
    local Blue: State = State.new("Blue")
    ```
]=]
State.Name = "" :: string
--[=[
    @prop Transitions string
    @within State

    A reference for the transitions of this state. This is usually set while creating the state

    ```lua
    local GoToBlue = require(script.Parent.Parent.Transitions.GoToBlue)

    local State = StateMachine.State

    local Default = State.new("Default")
    Default.Transitions = {GoToBlue}
    ```
]=]
State.Transitions = {} :: {Transition.Transition}
--[=[
    @prop Data {[string]: any}
    @within State

    Contains the state machine data, it can be accessed from within the class
]=]
State.Data = {} :: {[string]: any}
--[=[
    @prop _transitions {[string]: Transition.Transition}
    @within State
    @private

    Used to cache the transitions objects
]=]
State._transitions = {} :: {[string]: Transition.Transition}
--[=[
    @prop _changeState (newState: string)->()?
    @within State
    @private

    This is used to change the state of the state machine. This is set by the state machine itself
]=]
State._changeState = nil :: (newState: string)->()?
--[=[
    @prop _changeData (index: string, newValue: any)->()?
    @within State
    @private

    This is used to change the data of the state machine. This is set by the state machine itself
]=]
State._changeData = nil :: (index: string, newValue: any)-> ()?
--[=[
    @prop _getState (index: string, newValue: any)-> string
    @within State
    @private

    Gets the current state of our state machine
]=]
State._getState = nil :: (index: string, newValue: any)-> string
--[=[
    @prop _getPreviousState ()-> string?
    @within State
    @private

    Gets the previous state of our state machine
]=]
State._getPreviousState = nil :: ()-> string?
--[=[
    Used to create a new State. The state should manage how the object should behave during
    that given state. I personally recommend having your states in their own files for organizational
    purposes

    ```lua
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local StateMachine = require(ReplicatedStorage.RobloxStateMachine)
    local State = StateMachine.State

    local Default = State.new("Blue") -- The name of this state is "Blue"
    Default.Transitions = { -- The transitions that will be listened to while in the blue state
        transition1,
        transition2
    }
    function Default:OnEnter(data)
        data.part.Color = Color3.fromRGB(0, 166, 255) --This will turn the part Blue when it enters the state blue
    end

    return Default
    ```

    @param stateName string?

    @return State
]=]
function State.new(stateName: string?): State
    local self = setmetatable({}, State)
    
    self.Name = stateName or ""
    self.Transitions = {}

    return self
end

--[=[
    Extends a state inheriting the behavior from the parent state

    ```lua
    local state = State.new("Blue")
    
    function state:Print()
        print("Hello World!")
    end

    local extendedState = state:Extend("Red")

    function extendedState:OnInit()
        self:Print() -- Will print "Hello World!"
    end
    ```

    @param stateName string

    @return State
]=]
function State:Extend(stateName: string): State
    return mergeTables(State.new(stateName), self)
end

--[=[
    Forcelly changes the current state of our state machine to a new one

    @param newState string -- The name of the new state

    @return ()
]=]
function State:ChangeState(newState: string): ()
    if not self._changeState then
        return
    end

    self._changeState(newState)
end

--[=[
    Gets the current state of our state machine

    @return string
]=]
function State:GetState(): string
    if not self._getState then
        return ""
    end

    return self._getState()
end

--[=[
    Gets the previous state of our state machine

    @return string
]=]
function State:GetPreviousState(): string
    if not self._getPreviousState then
        return ""
    end

    return self._getPreviousState()
end

--[=[
    Changing data request. You can also just Get the data and change the data at run time.

    ```lua
    local example: State = State.new("Blue")

    function example:OnEnter(data)
        self:ChangeData("color", Color3.fromRGB(255, 0, 0)) -- Change to red :D

        data.part.Color = data.color
    end
    ```

    @param index string
    @param newValue any

    @return ()
]=]
function State:ChangeData(index: string, newValue: any): ()
    if not self._changeData then
        return
    end

    self._changeData(index, newValue)
end

--[=[
    :::info
    This is a **Virtual Method**. Virtual Methods are meant to be overwritten
    :::

    Called whenever a state machine is created with this state.

    ```lua
    function State:OnInit(data)
        print("I was init!")
        self.SomeStartingData = tick()
    end
    ```

    @param _data {[string]: any} -- This is the data from the StateMachine itself!

    @return ()
]=]
function State:OnInit(_data: {[string]: any}): ()

end

--[=[
    :::info
    This is a **Virtual Method**. Virtual Methods are meant to be overwritten
    :::

    ```lua
    function State:CanChangeState(targetState: string)
        return targetState == "Blue" -- If the target state is blue, we can change to it
    end
    ```

    @param _targetState string -- The state we are trying to change to

    @return boolean -- Whether or not we can change to the given state
]=]
function State:CanChangeState(_targetState: string): boolean
    return true
end

--[=[
    :::info
    This is a **Virtual Method**. Virtual Methods are meant to be overwritten
    :::

    :::warning
    **OnDataChanged** only gets called when the data is changed by a **ChangeData** call
    :::

    Called whenever the data of the state machine changes.

    ```lua
    function State:OnDataChanged(data, index, newValue, oldValue)
        if index == "SomeStartingData" then
            self.SomeStartingData = value
        end
    end
    ```

    @param _data {[string]: any} -- This is the data from the StateMachine itself!
    @param _index any -- The index of the data that changed
    @param _value any -- The new value of the data
    @param _oldValue any -- The old value of the data

    @return ()
]=]
function State:OnDataChanged(_data: {[string]: any}, _index: any, _value: any, _oldValue: any): ()

end

--[=[
    :::info
    This is a **Virtual Method**. Virtual Methods are meant to be overwritten
    :::

    Called whenever you enter this state

    ```lua
    function State:OnEnter(data)
        data.part.Color = Color3.fromRGB(0, 166, 255)
    end
    ```

    @param _data {[string]: any} -- This is the data from the StateMachine itself!

    @return ()
]=]
function State:OnEnter(_data: {[string]: any}): ()

end

--[=[
    :::info
    This is a **Virtual Method**. Virtual Methods are meant to be overwritten
    :::

    Called every frame after the physics simulation while in this state

    ```lua
    function Default:OnHeartbeat(data, deltaTime: number)
        self.timePassed += deltaTime
    end
    ```

    @param _data {[string]: any} -- This is the data from the StateMachine itself!
    @param _deltaTime number

    @return ()
]=]
function State:OnHeartbeat(_data: {[string]: any}, _deltaTime: number): ()

end

--[=[
    :::info
    This is a **Virtual Method**. Virtual Methods are meant to be overwritten
    :::

    Called whenever you leave this state

    ```lua
    function State:OnLeave(data)
        data.stuff:Clean()
    end
    ```

    @param _data {[string]: any} -- This is the data from the StateMachine itself!

    @return ()
]=]
function State:OnLeave(_data: {[string]: any}): ()

end

--[=[
    :::info
    This is a **Virtual Method**. Virtual Methods are meant to be overwritten
    :::

    Called whenever the state machine is destroyed

    ```lua
    function State:OnDestroy()
        print("I was destroyed!")
    end
    ```

    @return ()
]=]
function State:OnDestroy(): ()
    
end

export type State = typeof(State)

return setmetatable(State, {
    __call = function(_, properties): State
        return State.new(properties)
    end
})]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000430f</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXBCF6D9E068AE4D16923C28F7250D2F58">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">2a732b3377d053d0089136b60000c742</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Transition</string>
								<string name="ScriptGuid">{A3762CDD-A601-4BCB-AB59-FAD1FFD4BA45}</string>
								<ProtectedString name="Source"><![CDATA[local mergeTables = require(script.Parent.Parent.Parent.FunctionUtils._table).mergeTables

--[=[
    @class Transition

    Dictates how and when should you move between different states
]=]
local Transition = {}
Transition.__index = Transition
Transition.Type = "Transition"
--[=[
    @prop Name string
    @within Transition

    The name of the state. This is used to identify the state. Usually set while creating the state

    ```lua
    local Transition = StateMachine.Transition

    local GoToBlue = Transition.new("Blue")
    GoToBlue.Name = "GoToBlue"
    ```
]=]
Transition.Name = "" :: string
--[=[
    @prop TargetState string
    @within Transition

    The name of the state. This is used to identify the state. Usually set while creating the state

    ```lua
    local Transition = StateMachine.Transition

    local GoToBlue = Transition.new("Blue") -- The target state is now "Blue"
    print(GoToBlue.TargetState) -- "Blue"
    ```
]=]
Transition.TargetState = "" :: string
--[=[
    @prop Data {[string]: any}
    @within Transition

    Contains the state machine data, it can be accessed from within the class

    ```lua
    local Default: State = State.new("Blue")

    function Default:OnInit(data)
        print(self.Data)
    end
    ```
]=]
Transition.Data = {} :: {[string]: any}
--[=[
    @prop _changeState (newState: string)->()?
    @within Transition
    @private

    This is used to change the state of the state machine. This is set by the state machine itself
]=]
Transition._changeState = nil :: (newState: string)->()?
--[=[
    @prop _changeData (index: string, newValue: any)->()?
    @within Transition
    @private

    This is used to change the data of the state machine. This is set by the state machine itself
]=]
Transition._changeData = nil :: (index: string, newValue: any)-> ()?
--[=[
    @prop _getState (index: string, newValue: any)-> string
    @within Transition
    @private

    Gets the current state of our state machine
]=]
Transition._getState = nil :: (index: string, newValue: any)-> string
--[=[
    @prop _getPreviousState ()-> string?
    @within Transition
    @private

    Gets the previous state of our state machine
]=]
Transition._getPreviousState = nil :: ()-> string?

--[=[
    Creates a new transition. Transitions are used to tell our state
    when and how should it move from the current state to a different one.
    They are meant to be reusable and allow us to easily add and reuse transitions
    between states and objects

    ```lua
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local StateMachine = require(ReplicatedStorage.RobloxStateMachine)
    local Transition = StateMachine.Transition

    local GoToBlue = Transition.new("Blue")
    GoToBlue.OnHearbeat = false

    function GoToBlue:OnDataChanged(data)
        return tick() - data.time > 10 -- Will change to blue after 10 seconds 
    end

    return GoToBlue
    ```

    @param targetState string? -- The state the transition will change to when it meets the requirements

    @return Transition
]=]
function Transition.new(targetState: string?): Transition
    local self = setmetatable({}, Transition)
    self.TargetState = targetState or ""

    return self
end

--[=[
    Extends a state inheriting the behavior from the parent state

    ```lua
    local transition = Transition.new("Blue")
    
    function transition:Print()
        print("Hello World!")
    end

    local extendedTransition = transition:Extend("Red")

    function extendedTransition:OnInit()
        self:Print() -- Will print "Hello World!"
    end
    ```

    @param targetState string

    @return Transition
]=]
function Transition:Extend(targetState: string): Transition
    return mergeTables(Transition.new(targetState), self)
end

--[=[
    :::info
    This is a **Virtual Method**. Virtual Methods are meant to be overwritten
    :::

    Called whenever the state machine is created

    ```lua
    function Transition:OnInit()
        print("Hello World")
    end
    ```

    @param _data {[string]: any} -- This is the data from the StateMachine itself!

    @return ()
]=]
function Transition:OnInit(_data: {[string]: any}): ()
    
end

--[=[
    :::info
    This is a **Virtual Method**. Virtual Methods are meant to be overwritten
    :::

    Called whenever you enter this transition object

    ```lua
    function State:OnEnter(data)
        data.part.Color = Color3.fromRGB(0, 166, 255)
    end
    ```

    @param _data {[string]: any} -- This is the data from the StateMachine itself!

    @return ()
]=]
function Transition:OnEnter(_data: {[string]: any}): ()

end

--[=[
    :::info
    This is a **Virtual Method**. Virtual Methods are meant to be overwritten
    :::

    Called whenever you leave this transition object

    ```lua
    function State:OnLeave(data)
        data.stuff:Clean()
    end
    ```

    @param _data {[string]: any} -- This is the data from the StateMachine itself!

    @return ()
]=]
function Transition:OnLeave(_data: {[string]: any}): ()

end


--[=[
    :::info
    This is a **Virtual Method**. Virtual Methods are meant to be overwritten
    :::

    @deprecated v1.1.7 -- This function is redundant since it essencially just works as a blocker for OnDataChanged

    Whether it can change to this state or not. It's a good way to lock the current state

    @param data {[string]: any}

    @return boolean -- By default it returns true
]=]
function Transition:CanChangeState(data: {[string]: any}): boolean
    assert(data, "")
    return true
end

--[=[
    Forcelly changes the current state of our state machine to a new one

    @param newState string -- The name of the new state

    @return ()
]=]
function Transition:ChangeState(newState: string): ()
    if not self._changeState then
        return
    end

    self._changeState(newState)
end

--[=[
    :::info
    This is a **Virtual Method**. Virtual Methods are meant to be overwritten
    :::
    
    Should return true if it should change to the target state
    and false if it shouldn't

    @param data {[string]: any}

    @return boolean -- By default it returns false
]=]
function Transition:OnDataChanged(data: {[string]: any}): boolean
    assert(data, "")
    return false
end

--[=[
    Gets the current state of our state machine

    @return string
]=]
function Transition:GetState(): string
    if not self._getState then
        return ""
    end

    return self._getState()
end

--[=[
    Gets the previous state of our state machine

    @return string
]=]
function Transition:GetPreviousState(): string
    if not self._getPreviousState then
        return ""
    end

    return self._getPreviousState()
end

--[=[
    Changing data request. You can also just Get the data and change the data at run time.

    ```lua
    local example: State = State.new("Blue")

    function example:OnEnter(data)
        self:ChangeData("color", Color3.fromRGB(255, 0, 0)) -- Change to red :D

        data.part.Color = data.color
    end
    ```

    @param index string
    @param newValue any

    @return ()
]=]
function Transition:ChangeData(index: string, newValue: any): ()
    if not self._changeData then
        return
    end

    self._changeData(index, newValue)
end

--[=[
    :::info
    This is a **Virtual Method**. Virtual Methods are meant to be overwritten
    :::

    Called whenever the state machine is destroyed

    ```lua
    function Transition:OnDestroy()
        print("I was destroyed!")
    end
    ```

    @return ()
]=]
function Transition:OnDestroy(): ()
    
end

export type Transition = typeof(Transition)

return setmetatable(Transition, {
    __call = function(_, properties): Transition
        return Transition.new(properties)
    end
})]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004310</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXDC824EFE22CA4A1BBE770DDB16C0F86F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">6447dab81528837808994f0900001042</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_ZonePlus</string>
							<string name="ScriptGuid">{1734C697-4243-46EC-9B67-C94DC76212C7}</string>
							<ProtectedString name="Source"><![CDATA[-- LOCAL
local players = game:GetService("Players")
local runService = game:GetService("RunService")
local heartbeat = runService.Heartbeat
local localPlayer = runService:IsClient() and players.LocalPlayer
local replicatedStorage = game:GetService("ReplicatedStorage")
local httpService = game:GetService("HttpService")
local Enum_ = require(script.Enum)
local enum = Enum_.enums
local Janitor = require(script.Janitor)
local Signal = require(script.Parent._Signal)
local ZonePlusReference = require(script.ZonePlusReference)
local referenceObject = ZonePlusReference.getObject()
local zoneControllerModule = script.ZoneController
local trackerModule = zoneControllerModule.Tracker
local collectiveWorldModelModule = zoneControllerModule.CollectiveWorldModel
local zoneController = require(zoneControllerModule)
local referenceLocation = (game:GetService("RunService"):IsClient() and "Client") or "Server"
local referencePresent = referenceObject and referenceObject:FindFirstChild(referenceLocation)
if referencePresent then
	return require(referenceObject.Value)
end

local Zone = {}
Zone.__index = Zone
if not referencePresent then
	ZonePlusReference.addToReplicatedStorage()
end
Zone.enum = enum



-- CONSTRUCTORS
function Zone.new(container)
	local self = {}
	setmetatable(self, Zone)
	
	-- Validate container
	local INVALID_TYPE_WARNING = "The zone container must be a model, folder, basepart or table!"
	local containerType = typeof(container)
	if not(containerType == "table" or containerType == "Instance") then
		error(INVALID_TYPE_WARNING)
	end

	-- Configurable
	self.accuracy = enum.Accuracy.High
	self.autoUpdate = true
	self.respectUpdateQueue = true
	--self.maxPartsAddition = 20
	--self.ignoreRecommendedMaxParts = false

	-- Variable
	local janitor = Janitor.new()
	self.janitor = janitor
	self._updateConnections = janitor:add(Janitor.new(), "destroy")
	self.container = container
	self.zoneParts = {}
	self.overlapParams = {}
	self.region = nil
	self.volume = nil
	self.boundMin = nil
	self.boundMax = nil
	self.recommendedMaxParts = nil
	self.zoneId = httpService:GenerateGUID()
	self.activeTriggers = {}
	self.occupants = {}
	self.trackingTouchedTriggers = {}
	self.enterDetection = enum.Detection.Centre
	self.exitDetection = enum.Detection.Centre
	self._currentEnterDetection = nil -- This will update automatically internally
	self._currentExitDetection = nil -- This will also update automatically internally
	self.totalPartVolume = 0
	self.allZonePartsAreBlocks = true
	self.trackedItems = {}
	self.settingsGroupName = nil
	self.worldModel = workspace
	self.onItemDetails = {}
	self.itemsToUntrack = {}

	-- This updates _currentEnterDetection and _currentExitDetection right away to prevent nil comparisons
	zoneController.updateDetection(self)

	-- Signals
	self.updated = janitor:add(Signal.new(), "Destroy")
	local triggerTypes = {
		"player",
		"part",
		"localPlayer",
		"item"
	}
	local triggerEvents = {
		"entered",
		"exited",
	}
	for _, triggerType in pairs(triggerTypes) do
		local activeConnections = 0
		local previousActiveConnections = 0
		for i, triggerEvent in pairs(triggerEvents) do
			-- this enables us to determine when a developer connects to an event
			-- so that we can act accoridngly (i.e. begin or end a checker loop)
			local signal = janitor:add(Signal.new(true), "Destroy")
			local triggerEventUpper = triggerEvent:sub(1,1):upper()..triggerEvent:sub(2)
			local signalName = triggerType..triggerEventUpper
			self[signalName] = signal
			signal.connectionsChanged:Connect(function(increment)
				if triggerType == "localPlayer" and not localPlayer and increment == 1 then
					error(("Can only connect to 'localPlayer%s' on the client!"):format(triggerEventUpper))
				end
				previousActiveConnections = activeConnections
				activeConnections += increment
				if previousActiveConnections == 0 and activeConnections > 0 then
					-- At least 1 connection active, begin loop
					zoneController._registerConnection(self, triggerType, triggerEventUpper)
				elseif previousActiveConnections > 0 and activeConnections == 0 then
					-- All connections have disconnected, end loop
					zoneController._deregisterConnection(self, triggerType)
				end
			end)
		end
	end

	-- Setup touched receiver functions where applicable
	Zone.touchedConnectionActions = {}
	for _, triggerType in pairs(triggerTypes) do
		local methodName = ("_%sTouchedZone"):format(triggerType)
		local correspondingMethod = self[methodName]
		if correspondingMethod then
			self.trackingTouchedTriggers[triggerType] = {}
			Zone.touchedConnectionActions[triggerType] = function(touchedItem)
				correspondingMethod(self, touchedItem)
			end
		end
	end

	-- This constructs the zones boundaries, region, etc
	self:_update()

	-- Register/deregister zone
	zoneController._registerZone(self)
	janitor:add(function()
		zoneController._deregisterZone(self)
	end, true)
	
	return self
end

function Zone.fromRegion(cframe, size)
	local MAX_PART_SIZE = 2024
	local container = Instance.new("Model")
	local function createCube(cubeCFrame, cubeSize)
		if cubeSize.X > MAX_PART_SIZE or cubeSize.Y > MAX_PART_SIZE or cubeSize.Z > MAX_PART_SIZE then
			local quarterSize = cubeSize * 0.25
			local halfSize = cubeSize * 0.5
			createCube(cubeCFrame * CFrame.new(-quarterSize.X, -quarterSize.Y, -quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(-quarterSize.X, -quarterSize.Y, quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(-quarterSize.X, quarterSize.Y, -quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(-quarterSize.X, quarterSize.Y, quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(quarterSize.X, -quarterSize.Y, -quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(quarterSize.X, -quarterSize.Y, quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(quarterSize.X, quarterSize.Y, -quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(quarterSize.X, quarterSize.Y, quarterSize.Z), halfSize)
		else
			local part = Instance.new("Part")
			part.CFrame = cubeCFrame
			part.Size = cubeSize
			part.Anchored = true
			part.Parent = container
		end
	end
	createCube(cframe, size)
	local zone = Zone.new(container)
	zone:relocate()
	return zone
end



-- PRIVATE METHODS
function Zone:_calculateRegion(tableOfParts, dontRound)
	local bounds = {["Min"] = {}, ["Max"] = {}}
	for boundType, details in pairs(bounds) do
		details.Values = {}
		function details.parseCheck(v, currentValue)
			if boundType == "Min" then
				return (v <= currentValue)
			elseif boundType == "Max" then
				return (v >= currentValue)
			end
		end
		function details:parse(valuesToParse)
			for i,v in pairs(valuesToParse) do
				local currentValue = self.Values[i] or v
				if self.parseCheck(v, currentValue) then
					self.Values[i] = v
				end
			end
		end
	end
	for _, part in pairs(tableOfParts) do
		local sizeHalf = part.Size * 0.5
		local corners = {
			part.CFrame * CFrame.new(-sizeHalf.X, -sizeHalf.Y, -sizeHalf.Z),
			part.CFrame * CFrame.new(-sizeHalf.X, -sizeHalf.Y, sizeHalf.Z),
			part.CFrame * CFrame.new(-sizeHalf.X, sizeHalf.Y, -sizeHalf.Z),
			part.CFrame * CFrame.new(-sizeHalf.X, sizeHalf.Y, sizeHalf.Z),
			part.CFrame * CFrame.new(sizeHalf.X, -sizeHalf.Y, -sizeHalf.Z),
			part.CFrame * CFrame.new(sizeHalf.X, -sizeHalf.Y, sizeHalf.Z),
			part.CFrame * CFrame.new(sizeHalf.X, sizeHalf.Y, -sizeHalf.Z),
			part.CFrame * CFrame.new(sizeHalf.X, sizeHalf.Y, sizeHalf.Z),
		}
		for _, cornerCFrame in pairs(corners) do
			local x, y, z = cornerCFrame:GetComponents()
			local values = {x, y, z}
			bounds.Min:parse(values)
			bounds.Max:parse(values)
		end
	end
	local minBound = {}
	local maxBound = {}
	-- Rounding a regions coordinates to multiples of 4 ensures the region optimises the region
	-- by ensuring it aligns on the voxel grid
	local function roundToFour(to_round)
		local ROUND_TO = 4
		local divided = (to_round+ROUND_TO/2) / ROUND_TO
		local rounded = ROUND_TO * math.floor(divided)
		return rounded
	end
	for boundName, boundDetail in pairs(bounds) do
		for _, v in pairs(boundDetail.Values) do
			local newTable = (boundName == "Min" and minBound) or maxBound
			local newV = v
			if not dontRound then
				local roundOffset = (boundName == "Min" and -2) or 2
				newV = roundToFour(v+roundOffset) -- +-2 to ensures the zones region is not rounded down/up
			end
			table.insert(newTable, newV)
		end
	end
	local boundMin = Vector3.new(unpack(minBound))
	local boundMax = Vector3.new(unpack(maxBound))
	local region = Region3.new(boundMin, boundMax)
	return region, boundMin, boundMax
end

function Zone:_displayBounds()
	if not self.displayBoundParts then
		self.displayBoundParts = true
		local boundParts = {BoundMin = self.boundMin, BoundMax = self.boundMax}
		for boundName, boundCFrame in pairs(boundParts) do
			local part = Instance.new("Part")
			part.Anchored = true
			part.CanCollide = false
			part.Transparency = 0.5
			part.Size = Vector3.new(1,1,1)
			part.Color = Color3.fromRGB(255,0,0)
			part.CFrame = CFrame.new(boundCFrame)
			part.Name = boundName
			part.Parent = workspace
			self.janitor:add(part, "Destroy")
		end
	end
end

function Zone:_update()
	local container = self.container
	local zoneParts = {}
	local updateQueue = 0
	self._updateConnections:clean()

	local containerType = typeof(container)
	local holders = {}
	local INVALID_TYPE_WARNING = "The zone container must be a model, folder, basepart or table!"
	if containerType == "table" then
		for _, part in pairs(container) do
			if part:IsA("BasePart") then
				table.insert(zoneParts, part)
			end
		end
	elseif containerType == "Instance" then
		if container:IsA("BasePart") then
			table.insert(zoneParts, container)
		else
			table.insert(holders, container)
			for _, part in pairs(container:GetDescendants()) do
				if part:IsA("BasePart") then
					table.insert(zoneParts, part)
				else
					table.insert(holders, part)
				end
			end
		end
	end
	self.zoneParts = zoneParts
	self.overlapParams = {}
	
	local allZonePartsAreBlocksNew = true
	for _, zonePart in pairs(zoneParts) do
		local success, shapeName = pcall(function() return zonePart.Shape.Name end)
		if shapeName ~= "Block" then
			allZonePartsAreBlocksNew = false
		end
	end
	self.allZonePartsAreBlocks = allZonePartsAreBlocksNew
	
	local zonePartsWhitelist = OverlapParams.new()
	zonePartsWhitelist.FilterType = Enum.RaycastFilterType.Whitelist
	zonePartsWhitelist.MaxParts = #zoneParts
	zonePartsWhitelist.FilterDescendantsInstances = zoneParts
	self.overlapParams.zonePartsWhitelist = zonePartsWhitelist

	local zonePartsIgnorelist = OverlapParams.new()
	zonePartsIgnorelist.FilterType = Enum.RaycastFilterType.Blacklist
	zonePartsIgnorelist.FilterDescendantsInstances = zoneParts
	self.overlapParams.zonePartsIgnorelist = zonePartsIgnorelist
	
	-- this will call update on the zone when the container parts size or position changes, and when a
	-- child is removed or added from a holder (anything which isn't a basepart)
	local function update()
		if self.autoUpdate then
			local executeTime = os.clock()
			if self.respectUpdateQueue then
				updateQueue += 1
				executeTime += 0.1
			end
			local updateConnection
			updateConnection = runService.Heartbeat:Connect(function()
				if os.clock() >= executeTime then
					updateConnection:Disconnect()
					if self.respectUpdateQueue then
						updateQueue -= 1
					end
					if updateQueue == 0 and self.zoneId then
						self:_update()
					end
				end
			end)
		end
	end
	local partProperties = {"Size", "Position"}
	local function verifyDefaultCollision(instance)
		if instance.CollisionGroupId ~= 0 then
			error("Zone parts must belong to the 'Default' (0) CollisionGroup! Consider using zone:relocate() if you wish to move zones outside of workspace to prevent them interacting with other parts.")
		end
	end
	for _, part in pairs(zoneParts) do
		for _, prop in pairs(partProperties) do
			self._updateConnections:add(part:GetPropertyChangedSignal(prop):Connect(update), "Disconnect")
		end
		verifyDefaultCollision(part)
		self._updateConnections:add(part:GetPropertyChangedSignal("CollisionGroupId"):Connect(function()
			verifyDefaultCollision(part)
		end), "Disconnect")
	end
	local containerEvents = {"ChildAdded", "ChildRemoved"}
	for _, holder in pairs(holders) do
		for _, event in pairs(containerEvents) do
			self._updateConnections:add(self.container[event]:Connect(function(child)
				if child:IsA("BasePart") then
					update()
				end
			end), "Disconnect")
		end
	end
	
	local region, boundMin, boundMax = self:_calculateRegion(zoneParts)
	local exactRegion, _, _ = self:_calculateRegion(zoneParts, true)
	self.region = region
	self.exactRegion = exactRegion
	self.boundMin = boundMin
	self.boundMax = boundMax
	local rSize = region.Size
	self.volume = rSize.X*rSize.Y*rSize.Z
	
	-- Update: I was going to use this for the old part detection until the CanTouch property was released
	-- everything below is now irrelevant however I'll keep just in case I use again for future
	-------------------------------------------------------------------------------------------------
	-- When a zones region is determined, we also check for parts already existing within the zone
	-- these parts are likely never to move or interact with the zone, so we set the number of these
	-- to the baseline MaxParts value. 'recommendMaxParts' is then determined through the sum of this
	-- and maxPartsAddition. This ultimately optimises region checks as they can be generated with
	-- minimal MaxParts (i.e. recommendedMaxParts can be used instead of math.huge every time)
	--[[
	local result = self.worldModel:FindPartsInRegion3(region, nil, math.huge)
	local maxPartsBaseline = #result
	self.recommendedMaxParts = maxPartsBaseline + self.maxPartsAddition
	--]]
	
	self:_updateTouchedConnections()
	
	self.updated:Fire()
end

function Zone:_updateOccupants(trackerName, newOccupants)
	local previousOccupants = self.occupants[trackerName]
	if not previousOccupants then
		previousOccupants = {}
		self.occupants[trackerName] = previousOccupants
	end
	local signalsToFire = {}
	for occupant, prevItem in pairs(previousOccupants) do
		local newItem = newOccupants[occupant]
		if newItem == nil or newItem ~= prevItem then
			previousOccupants[occupant] = nil
			if not signalsToFire.exited then
				signalsToFire.exited = {}
			end
			table.insert(signalsToFire.exited, occupant)
		end
	end
	for occupant, _ in pairs(newOccupants) do
		if previousOccupants[occupant] == nil then
			local isAPlayer = occupant:IsA("Player")
			previousOccupants[occupant] = (isAPlayer and occupant.Character) or true
			if not signalsToFire.entered then
				signalsToFire.entered = {}
			end
			table.insert(signalsToFire.entered, occupant)
		end
	end 
	return signalsToFire
end

function Zone:_formTouchedConnection(triggerType)
	local touchedJanitorName = "_touchedJanitor"..triggerType
	local touchedJanitor = self[touchedJanitorName]
	if touchedJanitor then
		touchedJanitor:clean()
	else
		touchedJanitor = self.janitor:add(Janitor.new(), "destroy")
		self[touchedJanitorName] = touchedJanitor
	end
	self:_updateTouchedConnection(triggerType)
end

function Zone:_updateTouchedConnection(triggerType)
	local touchedJanitorName = "_touchedJanitor"..triggerType
	local touchedJanitor = self[touchedJanitorName]
	if not touchedJanitor then return end
	for _, basePart in pairs(self.zoneParts) do
		touchedJanitor:add(basePart.Touched:Connect(self.touchedConnectionActions[triggerType], self), "Disconnect")
	end
end

function Zone:_updateTouchedConnections()
	for triggerType, _ in pairs(self.touchedConnectionActions) do
		local touchedJanitorName = "_touchedJanitor"..triggerType
		local touchedJanitor = self[touchedJanitorName]
		if touchedJanitor then
			touchedJanitor:cleanup()
			self:_updateTouchedConnection(triggerType)
		end
	end
end

function Zone:_disconnectTouchedConnection(triggerType)
	local touchedJanitorName = "_touchedJanitor"..triggerType
	local touchedJanitor = self[touchedJanitorName]
	if touchedJanitor then
		touchedJanitor:cleanup()
		self[touchedJanitorName] = nil
	end
end

local function round(number, decimalPlaces)
	return math.round(number * 10^decimalPlaces) * 10^-decimalPlaces
end
function Zone:_partTouchedZone(part)
	local trackingDict = self.trackingTouchedTriggers["part"]
	if trackingDict[part] then return end
	local nextCheck = 0
	local verifiedEntrance = false
	local enterPosition = part.Position
	local enterTime = os.clock()
	local partJanitor = self.janitor:add(Janitor.new(), "destroy")
	trackingDict[part] = partJanitor
	local instanceClassesToIgnore = {Seat = true, VehicleSeat = true}
	local instanceNamesToIgnore = {HumanoidRootPart = true}
	if not (instanceClassesToIgnore[part.ClassName] or not instanceNamesToIgnore[part.Name])  then
		part.CanTouch = false
	end
	--
	local partVolume = round((part.Size.X * part.Size.Y * part.Size.Z), 5)
	self.totalPartVolume += partVolume
	--
	partJanitor:add(heartbeat:Connect(function()
		local clockTime = os.clock()
		if clockTime >= nextCheck then
			----
			local cooldown = enum.Accuracy.getProperty(self.accuracy)
			nextCheck = clockTime + cooldown
			----

			-- We initially perform a singular point check as this is vastly more lightweight than a large part check
			-- If the former returns false, perform a whole part check in case the part is on the outer bounds.
			local withinZone = self:findPoint(part.CFrame)
			if not withinZone then
				withinZone = self:findPart(part)
			end
			if not verifiedEntrance then
				if withinZone then
					verifiedEntrance = true
					self.partEntered:Fire(part)
				elseif (part.Position - enterPosition).Magnitude > 1.5 and clockTime - enterTime >= cooldown then
					-- Even after the part has exited the zone, we track it for a brief period of time based upon the criteria
					-- in the line above to ensure the .touched behaviours are not abused
					partJanitor:cleanup()
				end
			elseif not withinZone then
				verifiedEntrance = false
				enterPosition = part.Position
				enterTime = os.clock()
				self.partExited:Fire(part)
			end
		end
	end), "Disconnect")
	partJanitor:add(function()
		trackingDict[part] = nil
		part.CanTouch = true
		self.totalPartVolume = round((self.totalPartVolume - partVolume), 5)
	end, true)
end

local partShapeActions = {
	["Ball"] = function(part)
		return "GetPartBoundsInRadius", {part.Position, part.Size.X}
	end,
	["Block"] = function(part)
		return "GetPartBoundsInBox", {part.CFrame, part.Size}
	end,
	["Other"] = function(part)
		return "GetPartsInPart", {part}
	end,
}
function Zone:_getRegionConstructor(part, overlapParams)
	local success, shapeName = pcall(function() return part.Shape.Name end)
	local methodName, args
	if success and self.allZonePartsAreBlocks then
		local action = partShapeActions[shapeName]
		if action then
			methodName, args = action(part)
		end
	end
	if not methodName then
		methodName, args = partShapeActions.Other(part)
	end
	if overlapParams then
		table.insert(args, overlapParams)
	end
	return methodName, args
end



-- PUBLIC METHODS
function Zone:findLocalPlayer()
	if not localPlayer then
		error("Can only call 'findLocalPlayer' on the client!")
	end
	return self:findPlayer(localPlayer)
end

function Zone:_find(trackerName, item)
	zoneController.updateDetection(self)
	local tracker = zoneController.trackers[trackerName]
	local touchingZones = zoneController.getTouchingZones(item, false, self._currentEnterDetection, tracker)
	for _, zone in pairs(touchingZones) do
		if zone == self then
			return true
		end
	end
	return false
end

function Zone:findPlayer(player)
	local character = player.Character
	local humanoid = character and character:FindFirstChildOfClass("Humanoid")
	if not humanoid then
		return false
	end
	return self:_find("player", player.Character)
end

function Zone:findItem(item)
	return self:_find("item", item)
end

function Zone:findPart(part)
	local methodName, args = self:_getRegionConstructor(part, self.overlapParams.zonePartsWhitelist)
	local touchingZoneParts = self.worldModel[methodName](self.worldModel, unpack(args))
	--local touchingZoneParts = self.worldModel:GetPartsInPart(part, self.overlapParams.zonePartsWhitelist)
	if #touchingZoneParts > 0 then
		return true, touchingZoneParts
	end
	return false
end

function Zone:getCheckerPart()
	local checkerPart = self.checkerPart
	if not checkerPart then
		checkerPart = self.janitor:add(Instance.new("Part"), "Destroy")
		checkerPart.Size = Vector3.new(0.1, 0.1, 0.1)
		checkerPart.Name = "ZonePlusCheckerPart"
		checkerPart.Anchored = true
		checkerPart.Transparency = 1
		checkerPart.CanCollide = false
		self.checkerPart = checkerPart
	end
	local checkerParent = self.worldModel
	if checkerParent == workspace then
		checkerParent = zoneController.getWorkspaceContainer()
	end
	if checkerPart.Parent ~= checkerParent then
		checkerPart.Parent = checkerParent
	end
	return checkerPart
end

function Zone:findPoint(positionOrCFrame)
	local cframe = positionOrCFrame
	if typeof(positionOrCFrame) == "Vector3" then
		cframe = CFrame.new(positionOrCFrame)
	end
	local checkerPart = self:getCheckerPart()
	checkerPart.CFrame = cframe
	--checkerPart.Parent = self.worldModel
	local methodName, args = self:_getRegionConstructor(checkerPart, self.overlapParams.zonePartsWhitelist)
	local touchingZoneParts = self.worldModel[methodName](self.worldModel, unpack(args))
	--local touchingZoneParts = self.worldModel:GetPartsInPart(self.checkerPart, self.overlapParams.zonePartsWhitelist)
	if #touchingZoneParts > 0 then
		return true, touchingZoneParts
	end
	return false
end

function Zone:_getAll(trackerName)
	zoneController.updateDetection(self)
	local itemsArray = {}
	local zonesAndOccupants = zoneController._getZonesAndItems(trackerName, {self = true}, self.volume, false, self._currentEnterDetection)
	local occupantsDict = zonesAndOccupants[self]
	if occupantsDict then
		for item, _ in pairs(occupantsDict) do
			table.insert(itemsArray, item)
		end
	end
	return itemsArray
end

function Zone:getPlayers()
	return self:_getAll("player")
end

function Zone:getItems()
	return self:_getAll("item")
end

function Zone:getParts()
	-- This is designed for infrequent 'one off' use
	-- If you plan on checking for parts within a zone frequently, it's recommended you
	-- use the .partEntered and .partExited events instead.
	local partsArray = {}
	if self.activeTriggers["part"] then
		local trackingDict = self.trackingTouchedTriggers["part"]
		for part, _ in pairs(trackingDict) do
			table.insert(partsArray, part)
		end
		return partsArray
	end
	local partsInRegion = self.worldModel:GetPartBoundsInBox(self.region.CFrame, self.region.Size, self.overlapParams.zonePartsIgnorelist)
	for _, part in pairs(partsInRegion) do
		if self:findPart(part) then
			table.insert(partsArray, part)
		end
	end
	return partsArray
end

function Zone:getRandomPoint()
	local region = self.exactRegion
	local size = region.Size
	local cframe = region.CFrame
	local random = Random.new()
	local randomCFrame
	local success, touchingZoneParts
	local pointIsWithinZone
	repeat
		randomCFrame = cframe * CFrame.new(random:NextNumber(-size.X/2,size.X/2), random:NextNumber(-size.Y/2,size.Y/2), random:NextNumber(-size.Z/2,size.Z/2))
		success, touchingZoneParts = self:findPoint(randomCFrame)
		if success then
			pointIsWithinZone = true
		end
	until pointIsWithinZone
	local randomVector = randomCFrame.Position
	return randomVector, touchingZoneParts
end

function Zone:setAccuracy(enumIdOrName)
	local enumId = tonumber(enumIdOrName)
	if not enumId then
		enumId = enum.Accuracy[enumIdOrName]
		if not enumId then
			error(("'%s' is an invalid enumName!"):format(enumIdOrName))
		end
	else
		local enumName = enum.Accuracy.getName(enumId)
		if not enumName then
			error(("%s is an invalid enumId!"):format(enumId))
		end
	end
	self.accuracy = enumId
end

function Zone:setDetection(enumIdOrName)
	local enumId = tonumber(enumIdOrName)
	if not enumId then
		enumId = enum.Detection[enumIdOrName]
		if not enumId then
			error(("'%s' is an invalid enumName!"):format(enumIdOrName))
		end
	else
		local enumName = enum.Detection.getName(enumId)
		if not enumName then
			error(("%s is an invalid enumId!"):format(enumId))
		end
	end
	self.enterDetection = enumId
	self.exitDetection = enumId
end

function Zone:trackItem(instance)
	local isBasePart = instance:IsA("BasePart")
	local isCharacter = false
	if not isBasePart then
		isCharacter = instance:FindFirstChildOfClass("Humanoid") and instance:FindFirstChild("HumanoidRootPart")
	end

	assert(isBasePart or isCharacter, "Only BaseParts or Characters/NPCs can be tracked!")

	if self.trackedItems[instance] then
		return
	end
	if self.itemsToUntrack[instance] then
		self.itemsToUntrack[instance] = nil
	end

	local itemJanitor = self.janitor:add(Janitor.new(), "destroy")
	local itemDetail = {
		janitor = itemJanitor,
		item = instance,
		isBasePart = isBasePart,
		isCharacter = isCharacter,
	}
	self.trackedItems[instance] = itemDetail

	itemJanitor:add(instance.AncestryChanged:Connect(function()
		if not instance:IsDescendantOf(game) then
			self:untrackItem(instance)
		end
	end), "Disconnect")

	local Tracker = require(trackerModule)
	Tracker.itemAdded:Fire(itemDetail)
end

function Zone:untrackItem(instance)
	local itemDetail = self.trackedItems[instance]
	if itemDetail then
		itemDetail.janitor:destroy()
	end
	self.trackedItems[instance] = nil

	local Tracker = require(trackerModule)
	Tracker.itemRemoved:Fire(itemDetail)
end

function Zone:bindToGroup(settingsGroupName)
	self:unbindFromGroup()
	local group = zoneController.getGroup(settingsGroupName) or zoneController.setGroup(settingsGroupName)
	group._memberZones[self.zoneId] = self
	self.settingsGroupName = settingsGroupName
end

function Zone:unbindFromGroup()
	if self.settingsGroupName then
		local group = zoneController.getGroup(self.settingsGroupName)
		if group then
			group._memberZones[self.zoneId] = nil
		end
		self.settingsGroupName = nil
	end
end

function Zone:relocate()
	if self.hasRelocated then
		return
	end

	local CollectiveWorldModel = require(collectiveWorldModelModule)
	local worldModel = CollectiveWorldModel.setupWorldModel(self)
	self.worldModel = worldModel
	self.hasRelocated = true
	
	local relocationContainer = self.container
	if typeof(relocationContainer) == "table" then
		relocationContainer = Instance.new("Folder")
		for _, zonePart in pairs(self.zoneParts) do
			zonePart.Parent = relocationContainer
		end
	end
	self.relocationContainer = self.janitor:add(relocationContainer, "Destroy", "RelocationContainer")
	relocationContainer.Parent = worldModel
end

function Zone:_onItemCallback(eventName, desiredValue, instance, callbackFunction)
	local detail = self.onItemDetails[instance]
	if not detail then
		detail = {}
		self.onItemDetails[instance] = detail
	end
	if #detail == 0 then
		self.itemsToUntrack[instance] = true
	end
	table.insert(detail, instance)
	self:trackItem(instance)

	local function triggerCallback()
		callbackFunction()
		if self.itemsToUntrack[instance] then
			self.itemsToUntrack[instance] = nil
			self:untrackItem(instance)
		end
	end

	local inZoneAlready = self:findItem(instance)
	if inZoneAlready == desiredValue then
		triggerCallback()
	else
		local connection
		connection = self[eventName]:Connect(function(item)
			if connection and item == instance then
				connection:Disconnect()
				connection = nil
				triggerCallback()
			end
		end)
		--[[
		if typeof(expireAfterSeconds) == "number" then
			task.delay(expireAfterSeconds, function()
				if connection ~= nil then
					print("EXPIRE!")
					connection:Disconnect()
					connection = nil
					triggerCallback()
				end
			end)
		end
		--]]
	end
end

function Zone:onItemEnter(...)
	self:_onItemCallback("itemEntered", true, ...)
end

function Zone:onItemExit(...)
	self:_onItemCallback("itemExited", false, ...)
end

function Zone:destroy()
	self:unbindFromGroup()
	self.janitor:destroy()
end
Zone.Destroy = Zone.destroy



return Zone]]></ProtectedString>
							<int64 name="SourceAssetId">6245329519</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004311</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX1EB62FC572994CD29337D985ACFC26D4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">6447dab81528837808994f0900001043</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Enum</string>
								<string name="ScriptGuid">{294DFE2C-3C4D-4550-B984-A169228ADB5C}</string>
								<ProtectedString name="Source"><![CDATA[-- Custom enum implementation that provides an effective way to compare, send
-- and store values. Instead of returning a userdata value, enum items return
-- their corresponding itemValue (an integer) when indexed. Enum items can
-- also associate a 'property', specified as the third element, which can be
-- retrieved by doing ``enum.getProperty(ITEM_NAME_OR_VALUE)``
-- This ultimately means groups of data can be easily categorised, efficiently
-- transmitted over networks and saved without throwing errors.
-- Ben Horton (ForeverHD)



-- LOCAL
local Enum = {}
local enums = {}
Enum.enums = enums



-- METHODS
function Enum.createEnum(enumName, details)
	assert(typeof(enumName) == "string", "bad argument #1 - enums must be created using a string name!")
	assert(typeof(details) == "table", "bad argument #2 - enums must be created using a table!")
	assert(not enums[enumName], ("enum '%s' already exists!"):format(enumName))
	
	local enum = {}
	local usedNames = {}
	local usedValues = {}
	local usedProperties = {}
	local enumMetaFunctions = {
		getName = function(valueOrProperty)
			valueOrProperty = tostring(valueOrProperty)
			local index = usedValues[valueOrProperty]
			if not index then
				index = usedProperties[valueOrProperty]
			end
			if index then
				return details[index][1]
			end
		end,
		getValue = function(nameOrProperty)
			nameOrProperty = tostring(nameOrProperty)
			local index = usedNames[nameOrProperty]
			if not index then
				index = usedProperties[nameOrProperty]
			end
			if index then
				return details[index][2]
			end
		end,
		getProperty = function(nameOrValue)
			nameOrValue = tostring(nameOrValue)
			local index = usedNames[nameOrValue]
			if not index then
				index = usedValues[nameOrValue]
			end
			if index then
				return details[index][3]
			end
		end
	}
	for i, detail in pairs(details) do
		assert(typeof(detail) == "table", ("bad argument #2.%s - details must only be comprised of tables!"):format(i))
		local name = detail[1]
		assert(typeof(name) == "string", ("bad argument #2.%s.1 - detail name must be a string!"):format(i))
		assert(typeof(not usedNames[name]), ("bad argument #2.%s.1 - the detail name '%s' already exists!"):format(i, name))
		assert(typeof(not enumMetaFunctions[name]), ("bad argument #2.%s.1 - that name is reserved."):format(i, name))
		usedNames[tostring(name)] = i
		local value = detail[2]
		local valueString = tostring(value)
		--assert(typeof(value) == "number" and math.ceil(value)/value == 1, ("bad argument #2.%s.2 - detail value must be an integer!"):format(i))
		assert(typeof(not usedValues[valueString]), ("bad argument #2.%s.2 - the detail value '%s' already exists!"):format(i, valueString))
		usedValues[valueString] = i
		local property = detail[3]
		if property then
			assert(typeof(not usedProperties[property]), ("bad argument #2.%s.3 - the detail property '%s' already exists!"):format(i, tostring(property)))
			usedProperties[tostring(property)] = i
		end
		enum[name] = value
		setmetatable(enum, {
			__index = function(_, index)
				return(enumMetaFunctions[index])
			end
		})
	end
	
	enums[enumName] = enum
	return enum
end

function Enum.getEnums()
	return enums
end



-- SETUP ENUMS
local createEnum = Enum.createEnum
for _, childModule in pairs(script:GetChildren()) do
	if childModule:IsA("ModuleScript") then
		local enumDetail = require(childModule)
		createEnum(childModule.Name, enumDetail)
	end
end

--[[
-- Example enum
createEnum("Color", {
	{"White", 1, Color3.fromRGB(255, 255, 255)},
	{"Black", 2, Color3.fromRGB(0, 0, 0)},
})
--]]



return Enum
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004312</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX04AC780C56D94789B7915F20AD3F1160">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">6447dab81528837808994f0900001044</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Accuracy</string>
									<string name="ScriptGuid">{89FB3888-8AAA-4481-A4C8-B4E91D5436E6}</string>
									<ProtectedString name="Source"><![CDATA[-- enumName, enumValue, additionalProperty
-- in this case, additionalProperty is the delay between each check
return {
	{"Low", 	1,	1.0},
	{"Medium",	2,	0.5},
	{"High",	3,	0.1},
	{"Precise",	4,	0.0},
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004313</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC8D513FC70164BA582C612578148F454">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">6447dab81528837808994f0900001045</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Detection</string>
									<string name="ScriptGuid">{F745C8CE-ACDC-4B9B-9813-E2E7AD23C657}</string>
									<ProtectedString name="Source"><![CDATA[-- Important note: Precision checks currently only for 'players' and the 'localplayer', not 'parts'.

-- enumName, enumValue, additionalProperty
return {
	{"WholeBody", 1}, -- Multiple checks will be casted over an entire players character
	{"Centre", 2}, -- A singular check will be performed on the players HumanoidRootPart
	--{"Automatic", 3}, -- REMOVED DUE TO UNECESSARY COMPLEXITY. ZonePlus will dynamically switch between 'WholeBody' and 'Centre' depending upon the number of players in a server (this typically only occurs for servers with 100+ players when volume checks begin to exceed 0.5% in script performance).
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004314</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX4D70621ED7354808B62B64814C89362A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">6447dab81528837808994f0900001046</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Janitor</string>
								<string name="ScriptGuid">{B425A3CC-BA10-4198-9131-C4351C79A6EA}</string>
								<ProtectedString name="Source"><![CDATA[-- Janitor
-- Original by Validark
-- Modifications by pobammer
-- roblox-ts support by OverHash and Validark
-- LinkToInstance fixed by Elttob.

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat

local IndicesReference = newproxy(true)
getmetatable(IndicesReference).__tostring = function()
	return "IndicesReference"
end

local LinkToInstanceIndex = newproxy(true)
getmetatable(LinkToInstanceIndex).__tostring = function()
	return "LinkToInstanceIndex"
end

local METHOD_NOT_FOUND_ERROR = "Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s"
--local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))"

local Janitor = {
	ClassName = "Janitor";
	__index = {
		CurrentlyCleaning = true;
		[IndicesReference] = nil;
	};
}

local TypeDefaults = {
	["function"] = true;
	RBXScriptConnection = "Disconnect";
}

--[[**
	Instantiates a new Janitor object.
	@returns [t:Janitor]
**--]]
function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false;
		[IndicesReference] = nil;
	}, Janitor)
end

--[[**
	Determines if the passed object is a Janitor.
	@param [t:any] Object The object you are checking.
	@returns [t:boolean] Whether or not the object is a Janitor.
**--]]
function Janitor.Is(Object)
	return type(Object) == "table" and getmetatable(Object) == Janitor
end

Janitor.is = Janitor.Is

--[[**
	Adds an `Object` to Janitor for later cleanup, where `MethodName` is the key of the method within `Object` which should be called at cleanup time. If the `MethodName` is `true` the `Object` itself will be called instead. If passed an index it will occupy a namespace which can be `Remove()`d or overwritten. Returns the `Object`.
	@param [t:any] Object The object you want to clean up.
	@param [t:string|true?] MethodName The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes `Destroy`.
	@param [t:any?] Index The index that can be used to clean up the object manually.
	@returns [t:any] The object that was passed.
**--]]
function Janitor.__index:Add(Object, MethodName, Index)
	if Index == nil then
		Index = newproxy(false)
	end

	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]
		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end
	--[[
	if Promise.is(Object) then
		local Id = newproxy(false)
		if Object:getStatus() == Promise.Status.Started then
			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise, Id
		else
			return Object
		end
	end--]]

	MethodName = MethodName or TypeDefaults[typeof(Object)] or "Destroy"
	if type(Object) ~= "function" and not Object[MethodName] then
		warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil, 2)))
	end

	self[Object] = MethodName
	return Object, Index
end

Janitor.__index.Give = Janitor.__index.Add

-- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.

--[[**
	Adds a promise to the janitor. If the janitor is cleaned up and the promise is not completed, the promise will be cancelled.
	@param [t:Promise] PromiseObject The promise you want to add to the janitor.
	@returns [t:Promise]
**--]]
--[[
function Janitor.__index:AddPromise(PromiseObject)
	if not Promise.is(PromiseObject) then
		error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
	end

	if PromiseObject:getStatus() == Promise.Status.Started then
		local Id = newproxy(false)
		local NewPromise = self:Add(Promise.resolve(PromiseObject), "cancel", Id)
		NewPromise:finallyCall(self.Remove, self, Id)
		return NewPromise, Id
	else
		return PromiseObject
	end
end
--]]

--Janitor.__index.GivePromise = Janitor.__index.AddPromise

-- This will assume whether or not the object is a Promise or a regular object.
function Janitor.__index:AddObject(Object)
	local Id = newproxy(false)
	--[[
	if Promise.is(Object) then
		if Object:getStatus() == Promise.Status.Started then
			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise, Id
		else
			return Object
		end
	else
		return self:Add(Object, false, Id), Id
	end---]]
	return self:Add(Object, false, Id), Id
end

Janitor.__index.GiveObject = Janitor.__index.AddObject

--[[**
	Cleans up whatever `Object` was set to this namespace by the 3rd parameter of `:Add()`.
	@param [t:any] Index The index you want to remove.
	@returns [t:Janitor] The same janitor, for chaining reasons.
**--]]
function Janitor.__index:Remove(Index)
	local This = self[IndicesReference]

	if This then
		local Object = This[Index]

		if Object then
			local MethodName = self[Object]

			if MethodName then
				if MethodName == true then
					Object()
				else
					local ObjectMethod = Object[MethodName]
					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end

--[[**
	Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the job using `__index`.
	@param [t:any] Index The index that the object is stored under.
	@returns [t:any?] This will return the object if it is found, but it won't return anything if it doesn't exist.
**--]]
function Janitor.__index:Get(Index)
	local This = self[IndicesReference]
	if This then
		return This[Index]
	end
end

--[[**
	Calls each Object's `MethodName` (or calls the Object if `MethodName == true`) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor Object (so it can be used as a destructor callback).
	@returns [t:void]
**--]]
function Janitor.__index:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil
		for Object, MethodName in next, self do
			if Object == IndicesReference then
				continue
			end

			-- Weird decision to rawset directly to the janitor in Agent. This should protect against it though.
			local TypeOf = type(Object)
			if TypeOf == "string" or TypeOf == "number" then
				self[Object] = nil
				continue
			end

			if MethodName == true then
				Object()
			else
				local ObjectMethod = Object[MethodName]
				if ObjectMethod then
					ObjectMethod(Object)
				end
			end

			self[Object] = nil
		end

		local This = self[IndicesReference]
		if This then
			for Index in next, This do
				This[Index] = nil
			end

			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end

Janitor.__index.Clean = Janitor.__index.Cleanup

--[[**
	Calls `:Cleanup()` and renders the Janitor unusable.
	@returns [t:void]
**--]]
function Janitor.__index:Destroy()
	self:Cleanup()
	--table.clear(self)
	--setmetatable(self, nil)
end

Janitor.__call = Janitor.__index.Cleanup

--- Makes the Janitor clean up when the instance is destroyed
-- @param Instance Instance The Instance the Janitor will wait for to be Destroyed
-- @returns Disconnectable table to stop Janitor from being cleaned up upon Instance Destroy (automatically cleaned up by Janitor, btw)
-- @author Corecii
local Disconnect = {Connected = true}
Disconnect.__index = Disconnect
function Disconnect:Disconnect()
	if self.Connected then
		self.Connected = false
		self.Connection:Disconnect()
	end
end

function Disconnect:__tostring()
	return "Disconnect<" .. tostring(self.Connected) .. ">"
end

--[[**
	"Links" this Janitor to an Instance, such that the Janitor will `Cleanup` when the Instance is `Destroyed()` and garbage collected. A Janitor may only be linked to one instance at a time, unless `AllowMultiple` is true. When called with a truthy `AllowMultiple` parameter, the Janitor will "link" the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy `AllowMultiple` parameter, the Janitor will overwrite the previous link which was also called with a falsy `AllowMultiple` parameter, if applicable.
	@param [t:Instance] Object The instance you want to link the Janitor to.
	@param [t:boolean?] AllowMultiple Whether or not to allow multiple links on the same Janitor.
	@returns [t:RbxScriptConnection] A pseudo RBXScriptConnection that can be disconnected.
**--]]
function Janitor.__index:LinkToInstance(Object, AllowMultiple)
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, Disconnect)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				coroutine.wrap(function()
					Heartbeat:Wait()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							Heartbeat:Wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)()
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil
	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end

--[[**
	Links several instances to a janitor, which is then returned.
	@param [t:...Instance] ... All the instances you want linked.
	@returns [t:Janitor] A janitor that can be used to manually disconnect all LinkToInstances.
**--]]
function Janitor.__index:LinkToInstances(...)
	local ManualCleanup = Janitor.new()
	for _, Object in ipairs({...}) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end

for FunctionName, Function in next, Janitor.__index do
	local NewFunctionName = string.sub(string.lower(FunctionName), 1, 1) .. string.sub(FunctionName, 2)
	Janitor.__index[NewFunctionName] = Function
end

return Janitor]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004315</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF10D1BF9AADC40EE99F75EB8582D0F93">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">6447dab81528837808994f0900001047</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">OldSignal</string>
								<string name="ScriptGuid">{E64E81E3-FDDE-4771-AC65-45C5C0986567}</string>
								<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local heartbeat = RunService.Heartbeat
local Signal = {}
Signal.__index = Signal
Signal.ClassName = "Signal"
Signal.totalConnections = 0



-- CONSTRUCTOR
function Signal.new(createConnectionsChangedSignal)
	local self = setmetatable({}, Signal)
	
	if createConnectionsChangedSignal then
		self.connectionsChanged = Signal.new()
	end

	self.connections = {}
	self.totalConnections = 0
	self.waiting = {}
	self.totalWaiting = 0

	return self
end



-- METHODS
function Signal:Fire(...)
	for _, connection in pairs(self.connections) do
		--connection.Handler(...)
		task.spawn(connection.Handler, ...)
	end
	if self.totalWaiting > 0 then
		local packedArgs = table.pack(...)
		for waitingId, _ in pairs(self.waiting) do
			self.waiting[waitingId] = packedArgs
		end
	end
end
Signal.fire = Signal.Fire

function Signal:Connect(handler)
	if not (type(handler) == "function") then
		error(("connect(%s)"):format(typeof(handler)), 2)
	end
	
	local signal = self
	local connectionId = HttpService:GenerateGUID(false)
	local connection = {}
	connection.Connected = true
	connection.ConnectionId = connectionId
	connection.Handler = handler
	self.connections[connectionId] = connection

	function connection:Disconnect()
		signal.connections[connectionId] = nil
		connection.Connected = false
		signal.totalConnections -= 1
		if signal.connectionsChanged then
			signal.connectionsChanged:Fire(-1)
		end
	end
	connection.Destroy = connection.Disconnect
	connection.destroy = connection.Disconnect
	connection.disconnect = connection.Disconnect
	self.totalConnections += 1
	if self.connectionsChanged then
		self.connectionsChanged:Fire(1)
	end

	return connection
end
Signal.connect = Signal.Connect

function Signal:Wait()
	local waitingId = HttpService:GenerateGUID(false)
	self.waiting[waitingId] = true
	self.totalWaiting += 1
	repeat heartbeat:Wait() until self.waiting[waitingId] ~= true
	self.totalWaiting -= 1
	local args = self.waiting[waitingId]
	self.waiting[waitingId] = nil
	return unpack(args)
end
Signal.wait = Signal.Wait

function Signal:Destroy()
	if self.bindableEvent then
		self.bindableEvent:Destroy()
		self.bindableEvent = nil
	end
	if self.connectionsChanged then
		self.connectionsChanged:Fire(-self.totalConnections)
		self.connectionsChanged:Destroy()
		self.connectionsChanged = nil
	end
	self.totalConnections = 0
	for connectionId, connection in pairs(self.connections) do
		self.connections[connectionId] = nil
	end
end
Signal.destroy = Signal.Destroy
Signal.Disconnect = Signal.Destroy
Signal.disconnect = Signal.Destroy



return Signal]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004316</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC0FAD1010C1645A8AADA24E02C59954D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">6447dab81528837808994f0900001049</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">VERSION</string>
								<string name="ScriptGuid">{438BFA44-04FD-498E-B7FB-980A34499E0F}</string>
								<ProtectedString name="Source">-- v3.2.0</ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004317</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX46C5DCF63B7F48ACA4E823BD056A2260">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">6447dab81528837808994f090000104a</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ZoneController</string>
								<string name="ScriptGuid">{A2AB204C-0FB0-464E-A15D-4D80F2F0E19F}</string>
								<ProtectedString name="Source"><![CDATA[-- CONFIG
local WHOLE_BODY_DETECTION_LIMIT = 729000 -- This is roughly the volume where Region3 checks begin to exceed 0.5% in Script Performance



-- LOCAL
local Janitor = require(script.Parent.Janitor)
local Enum_ = require(script.Parent.Enum)
local Signal = require(script.Parent.Parent._Signal)
local Tracker = require(script.Tracker)
local CollectiveWorldModel = require(script.CollectiveWorldModel)
local enum = Enum_.enums
local players = game:GetService("Players")
local activeZones = {}
local activeZonesTotalVolume = 0
local activeTriggers = {}
local registeredZones = {}
local activeParts = {}
local activePartToZone = {}
local allParts = {}
local allPartToZone = {}
local activeConnections = 0
local runService = game:GetService("RunService")
local heartbeat = runService.Heartbeat
local heartbeatConnections = {}
local localPlayer = runService:IsClient() and players.LocalPlayer



-- PUBLIC
local ZoneReplica = {}
local trackers = {}
trackers.player = Tracker.new("player")
trackers.item = Tracker.new("item")
ZoneReplica.trackers = trackers



-- LOCAL FUNCTIONS
local function dictLength(dictionary)
	local count = 0
	for _, _ in pairs(dictionary) do
		count += 1
	end
	return count
end

local function fillOccupants(zonesAndOccupantsTable, zone, occupant)
	local occupantsDict = zonesAndOccupantsTable[zone]
	if not occupantsDict then
		occupantsDict = {}
		zonesAndOccupantsTable[zone] = occupantsDict
	end
	local prevCharacter = occupant:IsA("Player") and occupant.Character
	occupantsDict[occupant] = (prevCharacter or true)
end

local heartbeatActions = {
	["player"] = function(recommendedDetection)
		return ZoneReplica._getZonesAndItems("player", activeZones, activeZonesTotalVolume, true, recommendedDetection)
	end,
	["localPlayer"] = function(recommendedDetection)
		local zonesAndOccupants = {}
		local character = localPlayer.Character
		if not character then
			return zonesAndOccupants
		end
		local touchingZones = ZoneReplica.getTouchingZones(character, true, recommendedDetection, trackers.player)
		for _, zone in pairs(touchingZones) do
			if zone.activeTriggers["localPlayer"] then
				fillOccupants(zonesAndOccupants, zone, localPlayer)
			end
		end
		return zonesAndOccupants
	end,
	["item"] = function(recommendedDetection)
		return ZoneReplica._getZonesAndItems("item", activeZones, activeZonesTotalVolume, true, recommendedDetection)
	end,
}



-- PRIVATE FUNCTIONS
function ZoneReplica._registerZone(zone)
   	registeredZones[zone] = true
	local registeredJanitor = zone.janitor:add(Janitor.new(), "destroy")
	zone._registeredJanitor = registeredJanitor
	registeredJanitor:add(zone.updated:Connect(function()
		ZoneReplica._updateZoneDetails()
	end), "Disconnect")
   ZoneReplica._updateZoneDetails()
end

function ZoneReplica._deregisterZone(zone)
	registeredZones[zone] = nil
	zone._registeredJanitor:destroy()
	zone._registeredJanitor = nil
	ZoneReplica._updateZoneDetails()
end

function ZoneReplica._registerConnection(registeredZone, registeredTriggerType)
	local originalItems = dictLength(registeredZone.activeTriggers)
	activeConnections += 1
	if originalItems == 0 then
		activeZones[registeredZone] = true
		ZoneReplica._updateZoneDetails()
	end
	local currentTriggerCount = activeTriggers[registeredTriggerType]
	activeTriggers[registeredTriggerType] = (currentTriggerCount and currentTriggerCount+1) or 1
	registeredZone.activeTriggers[registeredTriggerType] = true
	if registeredZone.touchedConnectionActions[registeredTriggerType] then
		registeredZone:_formTouchedConnection(registeredTriggerType)
	end
	if heartbeatActions[registeredTriggerType] then
		ZoneReplica._formHeartbeat(registeredTriggerType)
	end
end

-- This decides what to do if detection is 'Automatic'
-- This is placed in ZoneReplica instead of the Zone object due to the ZoneReplicas all-knowing group-minded logic
function ZoneReplica.updateDetection(zone)
	local detectionTypes = {
		["enterDetection"] = "_currentEnterDetection",
		["exitDetection"] = "_currentExitDetection",
	}
	for detectionType, currentDetectionName in pairs(detectionTypes) do
		local detection = zone[detectionType]
		local combinedTotalVolume = Tracker.getCombinedTotalVolumes()
		if detection == enum.Detection.Automatic then
			if combinedTotalVolume > WHOLE_BODY_DETECTION_LIMIT then
				detection = enum.Detection.Centre
			else
				detection = enum.Detection.WholeBody
			end
		end
		zone[currentDetectionName] = detection
	end
end

function ZoneReplica._formHeartbeat(registeredTriggerType)
	local heartbeatConnection = heartbeatConnections[registeredTriggerType]
	if heartbeatConnection then return end
	-- This will only ever connect once per triggerType per server
	-- This means instead of initiating a loop per-zone we can handle everything within
	-- a singular connection. This is particularly beneficial for player/item-orinetated
	-- checking, where a check only needs to be cast once per interval, as apposed
	-- to every zone per interval
	-- I utilise heartbeat with os.clock() to provide precision (where needed) and flexibility
	local nextCheck = 0
	heartbeatConnection = heartbeat:Connect(function()
		local clockTime = os.clock()
		if clockTime >= nextCheck then
			local lowestAccuracy
			local lowestDetection
			for zone, _ in pairs(activeZones) do
				if zone.activeTriggers[registeredTriggerType] then
					local zAccuracy = zone.accuracy
					if lowestAccuracy == nil or zAccuracy < lowestAccuracy then
						lowestAccuracy = zAccuracy
					end
					ZoneReplica.updateDetection(zone)
					local zDetection = zone._currentEnterDetection
					if lowestDetection == nil or zDetection < lowestDetection then
						lowestDetection = zDetection
					end
				end
			end
			local highestAccuracy = lowestAccuracy
			local zonesAndOccupants = heartbeatActions[registeredTriggerType](lowestDetection)

			-- If a zone belongs to a settingsGroup with 'onlyEnterOnceExitedAll = true' , and the occupant already exists in a member group, then
			-- ignore all incoming occupants for the other zones (preventing the enteredSignal from being fired until the occupant has left
			-- all other zones within the same settingGroup)
			local occupantsToBlock = {}
			local zonesToPotentiallyIgnore = {}
			for zone, newOccupants in pairs(zonesAndOccupants) do
				local settingsGroup = (zone.settingsGroupName and ZoneReplica.getGroup(zone.settingsGroupName))
				if settingsGroup and settingsGroup.onlyEnterOnceExitedAll == true then
					--local currentOccupants = zone.occupants[registeredTriggerType]
					--if currentOccupants then
						for newOccupant, _ in pairs(newOccupants) do
							--if currentOccupants[newOccupant] then
								local groupDetail = occupantsToBlock[zone.settingsGroupName]
								if not groupDetail then
									groupDetail = {}
									occupantsToBlock[zone.settingsGroupName] = groupDetail
								end
								groupDetail[newOccupant] = zone
							--end
						end
						zonesToPotentiallyIgnore[zone] = newOccupants
					--end
				end
			end
			for zone, newOccupants in pairs(zonesToPotentiallyIgnore) do
				local groupDetail = occupantsToBlock[zone.settingsGroupName]
				if groupDetail then
					for newOccupant, _ in pairs(newOccupants) do
						local occupantToKeepZone = groupDetail[newOccupant]
						if occupantToKeepZone and occupantToKeepZone ~= zone then
							newOccupants[newOccupant] = nil
						end
					end
				end
			end

			-- This deduces what signals should be fired
			local collectiveSignalsToFire = {{}, {}}
			for zone, _ in pairs(activeZones) do
				if zone.activeTriggers[registeredTriggerType] then
					local zAccuracy = zone.accuracy
					local occupantsDict = zonesAndOccupants[zone] or {}
					local occupantsPresent = false
					for k,v in pairs(occupantsDict) do
						occupantsPresent = true
						break
					end
					if occupantsPresent and zAccuracy > highestAccuracy then
						highestAccuracy = zAccuracy
					end
					local signalsToFire = zone:_updateOccupants(registeredTriggerType, occupantsDict)
					collectiveSignalsToFire[1][zone] = signalsToFire.exited
					collectiveSignalsToFire[2][zone] = signalsToFire.entered
				end
			end

			-- This ensures all exited signals and called before entered signals
			local indexToSignalType = {"Exited", "Entered"}
			for index, zoneAndOccupants in pairs(collectiveSignalsToFire) do
				local signalType = indexToSignalType[index]
				local signalName = registeredTriggerType..signalType
				for zone, occupants in pairs(zoneAndOccupants) do
					local signal = zone[signalName]
					if signal then
						for _, occupant in pairs(occupants) do
							signal:Fire(occupant)
						end
					end
				end
			end

			local cooldown = enum.Accuracy.getProperty(highestAccuracy)
			nextCheck = clockTime + cooldown
		end
	end)
	heartbeatConnections[registeredTriggerType] = heartbeatConnection
end

function ZoneReplica._deregisterConnection(registeredZone, registeredTriggerType)
	activeConnections -= 1
	if activeTriggers[registeredTriggerType] == 1 then
		activeTriggers[registeredTriggerType] = nil
		local heartbeatConnection = heartbeatConnections[registeredTriggerType]
		if heartbeatConnection then
			heartbeatConnections[registeredTriggerType] = nil
			heartbeatConnection:Disconnect()
		end
	else
		activeTriggers[registeredTriggerType] -= 1
	end
	registeredZone.activeTriggers[registeredTriggerType] = nil
	if dictLength(registeredZone.activeTriggers) == 0 then
		activeZones[registeredZone] = nil
		ZoneReplica._updateZoneDetails()
	end
	if registeredZone.touchedConnectionActions[registeredTriggerType] then
		registeredZone:_disconnectTouchedConnection(registeredTriggerType)
	end
end

function ZoneReplica._updateZoneDetails()
	activeParts = {}
	activePartToZone = {}
	allParts = {}
	allPartToZone = {}
	activeZonesTotalVolume = 0
	for zone, _ in pairs(registeredZones) do
		local isActive = activeZones[zone]
		if isActive then
			activeZonesTotalVolume += zone.volume
		end
		for _, zonePart in pairs(zone.zoneParts) do
			if isActive then
				table.insert(activeParts, zonePart)
				activePartToZone[zonePart] = zone
			end
			table.insert(allParts, zonePart)
			allPartToZone[zonePart] = zone
		end
	end
end

function ZoneReplica._getZonesAndItems(trackerName, zonesDictToCheck, zoneCustomVolume, onlyActiveZones, recommendedDetection)
	local totalZoneVolume = zoneCustomVolume
	if not totalZoneVolume then
		for zone, _ in pairs(zonesDictToCheck) do
			totalZoneVolume += zone.volume
		end
	end
	local zonesAndOccupants = {}
	local tracker = trackers[trackerName]
	if tracker.totalVolume < totalZoneVolume then
		-- If the volume of all *characters/items* within the server is *less than* the total
		-- volume of all active zones (i.e. zones which listen for .playerEntered)
		-- then it's more efficient cast checks within each character and
		-- then determine the zones they belong to
		for _, item in pairs(tracker.items) do
			local touchingZones = ZoneReplica.getTouchingZones(item, onlyActiveZones, recommendedDetection, tracker)
			for _, zone in pairs(touchingZones) do
				if not onlyActiveZones or zone.activeTriggers[trackerName] then
					local finalItem = item
					if trackerName == "player" then
						finalItem = players:GetPlayerFromCharacter(item)
					end
					if finalItem then
						fillOccupants(zonesAndOccupants, zone, finalItem)
					end
				end
			end
		end
	else
		-- If the volume of all *active zones* within the server is *less than* the total
		-- volume of all characters/items, then it's more efficient to perform the
		-- checks directly within each zone to determine players inside
		for zone, _ in pairs(zonesDictToCheck) do
			if not onlyActiveZones or zone.activeTriggers[trackerName] then
				local result = CollectiveWorldModel:GetPartBoundsInBox(zone.region.CFrame, zone.region.Size, tracker.whitelistParams)
				local finalItemsDict = {}
				for _, itemOrChild in pairs(result) do
					local correspondingItem = tracker.partToItem[itemOrChild]
					if not finalItemsDict[correspondingItem] then
						finalItemsDict[correspondingItem] = true
					end
				end
				for item, _ in pairs(finalItemsDict) do
					if trackerName == "player" then
						local player = players:GetPlayerFromCharacter(item)
						if zone:findPlayer(player) then
							fillOccupants(zonesAndOccupants, zone, player)
						end
					elseif zone:findItem(item) then
						fillOccupants(zonesAndOccupants, zone, item)
					end
				end
			end
		end
	end
	return zonesAndOccupants
end



-- PUBLIC FUNCTIONS
function ZoneReplica.getZones()
	local registeredZonesArray = {}
	for zone, _ in pairs(registeredZones) do
		table.insert(registeredZonesArray, zone)
	end
	return registeredZonesArray
end

--[[
-- the player touched events which utilise active zones at the moment may change to the new CanTouch method for parts in the future
-- hence im disabling this as it may be depreciated quite soon
function ZoneReplica.getActiveZones()
	local zonesArray = {}
	for zone, _ in pairs(activeZones) do
		table.insert(zonesArray, zone)
	end
	return zonesArray
end
--]]

function ZoneReplica.getTouchingZones(item, onlyActiveZones, recommendedDetection, tracker)
	local exitDetection, finalDetection
	if tracker then
		exitDetection = tracker.exitDetections[item]
		tracker.exitDetections[item] = nil
	end
	finalDetection = exitDetection or recommendedDetection

	local itemSize, itemCFrame
	local itemIsBasePart = item:IsA("BasePart")
	local itemIsCharacter = not itemIsBasePart
	local bodyPartsToCheck = {}
	if itemIsBasePart then
		itemSize, itemCFrame = item.Size, item.CFrame
		table.insert(bodyPartsToCheck, item)
	elseif finalDetection == enum.Detection.WholeBody then
		itemSize, itemCFrame = Tracker.getCharacterSize(item)
		bodyPartsToCheck = item:GetChildren()
	else
		local hrp = item:FindFirstChild("HumanoidRootPart")
		if hrp then
			itemSize, itemCFrame = hrp.Size, hrp.CFrame
			table.insert(bodyPartsToCheck, hrp)
		end
	end
	if not itemSize or not itemCFrame then return {} end

	--[[
	local part = Instance.new("Part")
	part.Size = itemSize
	part.CFrame = itemCFrame
	part.Anchored = true
	part.CanCollide = false
	part.Color = Color3.fromRGB(255, 0, 0)
	part.Transparency = 0.4
	part.Parent = workspace
	game:GetService("Debris"):AddItem(part, 2)
	--]]
	local partsTable = (onlyActiveZones and activeParts) or allParts
	local partToZoneDict = (onlyActiveZones and activePartToZone) or allPartToZone

	local boundParams = OverlapParams.new()
	boundParams.FilterType = Enum.RaycastFilterType.Whitelist
	boundParams.MaxParts = #partsTable
	boundParams.FilterDescendantsInstances = partsTable

	-- This retrieves the bounds (the rough shape) of all parts touching the item/character
	-- If the corresponding zone is made up of *entirely* blocks then the bound will
	-- be the actual shape of the part.
	local touchingPartsDictionary = {}
	local zonesDict = {}
	local boundParts = CollectiveWorldModel:GetPartBoundsInBox(itemCFrame, itemSize, boundParams)
	local boundPartsThatRequirePreciseChecks = {}
	for _, boundPart in pairs(boundParts) do
		local correspondingZone = partToZoneDict[boundPart]
		if correspondingZone and correspondingZone.allZonePartsAreBlocks then
			zonesDict[correspondingZone] = true
			touchingPartsDictionary[boundPart] = correspondingZone
		else
			table.insert(boundPartsThatRequirePreciseChecks, boundPart)
		end
	end

	-- If the bound parts belong to a zone that isn't entirely made up of blocks, then
	-- we peform additional checks using GetPartsInPart which enables shape
	-- geometries to be precisely determined for non-block baseparts.
	local totalRemainingBoundParts = #boundPartsThatRequirePreciseChecks
	local precisePartsCount = 0
	if totalRemainingBoundParts > 0 then
		
		local preciseParams = OverlapParams.new()
		preciseParams.FilterType = Enum.RaycastFilterType.Whitelist
		preciseParams.MaxParts = totalRemainingBoundParts
		preciseParams.FilterDescendantsInstances = boundPartsThatRequirePreciseChecks

		local character = item
		for _, bodyPart in pairs(bodyPartsToCheck) do
			local endCheck = false
			if not bodyPart:IsA("BasePart") or (itemIsCharacter and Tracker.bodyPartsToIgnore[bodyPart.Name]) then
				continue
			end
			local preciseParts = CollectiveWorldModel:GetPartsInPart(bodyPart, preciseParams)
			for _, precisePart in pairs(preciseParts) do
				if not touchingPartsDictionary[precisePart] then
					local correspondingZone = partToZoneDict[precisePart]
					if correspondingZone then
						zonesDict[correspondingZone] = true
						touchingPartsDictionary[precisePart] = correspondingZone
						precisePartsCount += 1
					end
					if precisePartsCount == totalRemainingBoundParts then
						endCheck = true
						break
					end
				end
			end
			if endCheck then
				break
			end
		end
	end
	
	local touchingZonesArray = {}
	local newExitDetection
	for zone, _ in pairs(zonesDict) do
		if newExitDetection == nil or zone._currentExitDetection < newExitDetection then
			newExitDetection = zone._currentExitDetection
		end
		table.insert(touchingZonesArray, zone)
	end
	if newExitDetection and tracker then
		tracker.exitDetections[item] = newExitDetection
	end
	return touchingZonesArray, touchingPartsDictionary
end

local settingsGroups = {}
function ZoneReplica.setGroup(settingsGroupName, properties)
	local group = settingsGroups[settingsGroupName]
	if not group then
		group = {}
		settingsGroups[settingsGroupName] = group
	end
	

	-- PUBLIC PROPERTIES --
	group.onlyEnterOnceExitedAll = true
	
	-- PRIVATE PROPERTIES --
	group._name = settingsGroupName
	group._memberZones = {}


	if typeof(properties) == "table" then
		for k, v in pairs(properties) do
			group[k] = v
		end
	end
	return group
end

function ZoneReplica.getGroup(settingsGroupName)
	return settingsGroups[settingsGroupName]
end

local workspaceContainer
local workspaceContainerName = string.format("ZonePlus%sContainer", (runService:IsClient() and "Client") or "Server")
function ZoneReplica.getWorkspaceContainer()
	local container = workspaceContainer or workspace:FindFirstChild(workspaceContainerName)
	if not container then
		container = Instance.new("Folder")
		container.Name = workspaceContainerName
		container.Parent = workspace
		workspaceContainer = container
	end
	return container
end



return ZoneReplica]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004318</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX48C1286C409C461F9E8CB66AC56A8AD3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">6447dab81528837808994f090000104b</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">CollectiveWorldModel</string>
									<string name="ScriptGuid">{D5E0C61B-2887-4067-A8DD-25AE7E909980}</string>
									<ProtectedString name="Source"><![CDATA[local CollectiveWorldModel = {}
local worldModel
local runService = game:GetService("RunService")



-- FUNCTIONS
function CollectiveWorldModel.setupWorldModel(zone)
	if worldModel then
		return worldModel
	end
	local location = (runService:IsClient() and "ReplicatedStorage") or "ServerStorage"
	worldModel = Instance.new("WorldModel")
	worldModel.Name = "ZonePlusWorldModel"
	worldModel.Parent = game:GetService(location)
	return worldModel
end



-- METHODS
function CollectiveWorldModel:_getCombinedResults(methodName, ...)
	local results = workspace[methodName](workspace, ...)
	if worldModel then
		local additionalResults = worldModel[methodName](worldModel, ...)
		for _, result in pairs(additionalResults) do
			table.insert(results, result)
		end
	end
	return results
end

function CollectiveWorldModel:GetPartBoundsInBox(cframe, size, overlapParams)
	return self:_getCombinedResults("GetPartBoundsInBox", cframe, size, overlapParams)
end

function CollectiveWorldModel:GetPartBoundsInRadius(position, radius, overlapParams)
	return self:_getCombinedResults("GetPartBoundsInRadius", position, radius, overlapParams)
end

function CollectiveWorldModel:GetPartsInPart(part, overlapParams)
	return self:_getCombinedResults("GetPartsInPart", part, overlapParams)
end



return CollectiveWorldModel]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004319</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX88A6227ADEFC44F7B1D3AC69A33AB9B8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">6447dab81528837808994f090000104c</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Tracker</string>
									<string name="ScriptGuid">{CE8B404B-4AD0-4A27-8525-9180E73B1476}</string>
									<ProtectedString name="Source"><![CDATA[-- This enables data on volumes, HumanoidRootParts, etc to be handled on an event-basis, instead of being retrieved every interval

-- LOCAL
local players = game:GetService("Players")
local runService = game:GetService("RunService")
local heartbeat = runService.Heartbeat
local Signal = require(script.Parent.Parent.Parent._Signal)
local Janitor = require(script.Parent.Parent.Janitor)



-- PUBLIC
local Tracker = {}
Tracker.__index = Tracker
local trackers = {}
Tracker.trackers = trackers
Tracker.itemAdded = Signal.new()
Tracker.itemRemoved = Signal.new()
Tracker.bodyPartsToIgnore = {
	-- We ignore these due to their insignificance (e.g. we ignore the lower and
	-- upper torso because the HumanoidRootPart also covers these areas)
	-- This ultimately reduces the burden on the player region checks
	UpperTorso = true,
	LowerTorso = true,
	Torso = true,
	LeftHand = true,
	RightHand = true,
	LeftFoot = true,
	RightFoot = true,
}



-- FUNCTIONS
function Tracker.getCombinedTotalVolumes()
	local combinedVolume = 0
	for tracker, _ in pairs(trackers) do
		combinedVolume += tracker.totalVolume
	end
	return combinedVolume
end

function Tracker.getCharacterSize(character)
	local head = character and character:FindFirstChild("Head")
	local hrp = character and character:FindFirstChild("HumanoidRootPart")
	if not(hrp and head) then return nil end
	if not head:IsA("BasePart") then
		head = hrp
	end
	local headY = head.Size.Y
	local hrpSize = hrp.Size
	local charSize = (hrpSize * Vector3.new(2, 2, 1)) + Vector3.new(0, headY, 0)
	local charCFrame = hrp.CFrame * CFrame.new(0, headY/2 - hrpSize.Y/2, 0)
	return charSize, charCFrame
end



-- CONSTRUCTOR
function Tracker.new(name)
	local self = {}
	setmetatable(self, Tracker)
	
	self.name = name
	self.totalVolume = 0
	self.parts = {}
	self.partToItem = {}
	self.items = {}
	self.whitelistParams = nil
	self.characters = {}
	self.baseParts = {}
	self.exitDetections = {}
	self.janitor = Janitor.new()

	if name == "player" then
		local function updatePlayerCharacters()
			local characters = {}
			for _, player in pairs(players:GetPlayers()) do
				local character = player.Character
				if character then
					characters[character] = true
				end
			end
			self.characters = characters
		end
		
		local function playerAdded(player)
			local function charAdded(character)
				local humanoid = character:WaitForChild("Humanoid", 3)
				if humanoid then
					updatePlayerCharacters()
					self:update()
					for _, valueInstance in pairs(humanoid:GetChildren()) do
						if valueInstance:IsA("NumberValue") then
							valueInstance.Changed:Connect(function()
								self:update()
							end)
						end
					end
				end
			end
			if player.Character then
				charAdded(player.Character)
			end
			player.CharacterAdded:Connect(charAdded)
			player.CharacterRemoving:Connect(function(removingCharacter)
				self.exitDetections[removingCharacter] = nil
			end)
		end
		
		players.PlayerAdded:Connect(playerAdded)
		for _, player in pairs(players:GetPlayers()) do
			playerAdded(player)
		end
		
		players.PlayerRemoving:Connect(function(player)
			updatePlayerCharacters()
			self:update()
		end)


	elseif name == "item" then
		local function updateItem(itemDetail, newValue)
			if itemDetail.isCharacter then
				self.characters[itemDetail.item] = newValue
			elseif itemDetail.isBasePart then
				self.baseParts[itemDetail.item] = newValue
			end
			self:update()
		end
		Tracker.itemAdded:Connect(function(itemDetail)
			updateItem(itemDetail, true)
		end)
		Tracker.itemRemoved:Connect(function(itemDetail)
			self.exitDetections[itemDetail.item] = nil
			updateItem(itemDetail, nil)
		end)
	end

	trackers[self] = true
	task.defer(self.update, self)
	return self
end



-- METHODS
function Tracker:_preventMultiFrameUpdates(methodName, ...)
	-- This prevents the funtion being called twice within a single frame
	-- If called more than once, the function will initally be delayed again until the next frame, then all others cancelled
	self._preventMultiDetails = self._preventMultiDetails or {}
	local detail = self._preventMultiDetails[methodName]
	if not detail then
		detail = {
			calling = false,
			callsThisFrame = 0,
			updatedThisFrame = false,
		}
		self._preventMultiDetails[methodName] = detail
	end

	detail.callsThisFrame += 1
	if detail.callsThisFrame == 1 then
		local args = table.pack(...)
		task.defer(function()
			local newCallsThisFrame = detail.callsThisFrame
			detail.callsThisFrame = 0
			if newCallsThisFrame > 1 then
				self[methodName](self, unpack(args))
			end
		end)
		return false
	end
	return true
end

function Tracker:update()
	if self:_preventMultiFrameUpdates("update") then
		return
	end
	
	self.totalVolume = 0
	self.parts = {}
	self.partToItem = {}
	self.items = {}
	
	-- This tracks the bodyparts of a character
	for character, _ in pairs(self.characters) do
		local charSize = Tracker.getCharacterSize(character)
		if not charSize then
			continue
		end
		local rSize = charSize
		local charVolume = rSize.X*rSize.Y*rSize.Z
		self.totalVolume += charVolume
		
		local characterJanitor = self.janitor:add(Janitor.new(), "destroy", "trackCharacterParts-"..self.name)
		local function updateTrackerOnParentChanged(instance)
			characterJanitor:add(instance.AncestryChanged:Connect(function()
				if not instance:IsDescendantOf(game) then
					if instance.Parent == nil and characterJanitor ~= nil then
						characterJanitor:destroy()
						characterJanitor = nil
						self:update()
					end
				end
			end), "Disconnect")
		end

		for _, part in pairs(character:GetChildren()) do
			if part:IsA("BasePart") and not Tracker.bodyPartsToIgnore[part.Name] then
				self.partToItem[part] = character
				table.insert(self.parts, part)
				updateTrackerOnParentChanged(part)
			end
		end
		updateTrackerOnParentChanged(character)
		table.insert(self.items, character)
	end

	-- This tracks any additional baseParts
	for additionalPart, _ in pairs(self.baseParts) do
		local rSize = additionalPart.Size
		local partVolume = rSize.X*rSize.Y*rSize.Z
		self.totalVolume += partVolume
		self.partToItem[additionalPart] = additionalPart
		table.insert(self.parts, additionalPart)
		table.insert(self.items, additionalPart)
	end
	
	-- This creates the whitelist so that
	self.whitelistParams = OverlapParams.new()
	self.whitelistParams.FilterType = Enum.RaycastFilterType.Whitelist
	self.whitelistParams.MaxParts = #self.parts
	self.whitelistParams.FilterDescendantsInstances = self.parts
end



return Tracker]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000431a</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX733E61DC81DB4A65A07577A52BE71FC5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">6447dab81528837808994f090000104d</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ZonePlusReference</string>
								<string name="ScriptGuid">{9B13BE5C-0FF9-42A1-831F-BD33C44D00C2}</string>
								<ProtectedString name="Source"><![CDATA[-- This module enables you to place Zone wherever you like within the data model while
-- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it
-- This is necessary to prevent two ZonePlus applications initiating at runtime which would
-- diminish it's overall efficiency

local replicatedStorage = game:GetService("ReplicatedStorage")
local ZonePlusReference = {}

function ZonePlusReference.addToReplicatedStorage()
    local existingItem = replicatedStorage:FindFirstChild(script.Name)
    if existingItem then
        return false
    end
    local objectValue = Instance.new("ObjectValue")
    objectValue.Name = script.Name
    objectValue.Value = script.Parent
    objectValue.Parent = replicatedStorage
    local locationValue = Instance.new("BoolValue")
    locationValue.Name = (game:GetService("RunService"):IsClient() and "Client") or "Server"
    locationValue.Value = true
    locationValue.Parent = objectValue
    return objectValue
end

function ZonePlusReference.getObject()
    local objectValue = replicatedStorage:FindFirstChild(script.Name)
    if objectValue then
        return objectValue
    end
    return false
end

return ZonePlusReference]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000431b</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXEB82E55EE05A4EC6914710A17651B2E8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">6ceed69402a652aa08a577a200001014</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Signal</string>
							<string name="ScriptGuid">{2AD2E9F7-3587-4B83-97F1-4D78F09C9B40}</string>
							<ProtectedString name="Source"><![CDATA[--[[--!optimize 2
--!strict
--!native

local freeThreads: { thread } = {}

local function runCallback(callback, thread, ...)
	callback(...)
	table.insert(freeThreads, thread)
end

local function yielder()
	while true do
		runCallback(coroutine.yield())
	end
end

local Connection = {}
Connection.__index = Connection
type self = {
	Connected: boolean,
	_signal: any,
	_next: any,
	_prev: any,
}
export type SignalConnection = typeof(setmetatable({} :: self, Connection))

local function disconnect(self: SignalConnection)
	if not self.Connected then
		return
	end
	self.Connected = false

	local next = self._next
	local prev = self._prev

	if next then
		next._prev = prev
	end
	if prev then
		prev._next = next
	end

	local signal = self._signal
	if signal._head == self then
		signal._head = next
	end
end

local function reconnect(self: SignalConnection)
	if self.Connected then
		return
	end
	self.Connected = true

	local signal = self._signal
	local head = signal._head
	if head then
		head._prev = self
	end
	signal._head = self

	self._next = head
	self._prev = false
end

Connection.Disconnect = disconnect
Connection.Reconnect = reconnect

--\\ Signal //--
local Signal = {} --:: SignalTable
Signal.__index = Signal

export type Signal<T...> = {
	RBXScriptConnection: RBXScriptConnection?,

	Connect: (self: Signal<T...>, fn: (T...) -> ()) -> SignalConnection,
	Once: (self: Signal<T...>, fn: (T...) -> ()) -> SignalConnection,
	Wait: (self: Signal<T...>) -> T...,
	Fire: (self: Signal<T...>, T...) -> (),
	FireDefer: (self: Signal<T...>, T...) -> (),
	DisconnectAll: (self: Signal<T...>) -> (),
	Destroy: (self: Signal<T...>) -> (),
}

export type SignalType<Func, T...> = {
	RBXScriptConnection: RBXScriptConnection?,

	Fire: (self: SignalType<Func, T...>, T...) -> (),
	FireDefer: (self: SignalType<Func, T...>, T...) -> (),
	Connect: (self: SignalType<Func, T...>, fn: Func) -> SignalConnection,
	Once: (self: SignalType<Func, T...>, fn: Func) -> SignalConnection,
	Wait: (self: SignalType<Func, T...>) -> T...,
	DisconnectAll: (self: SignalType<Func, T...>) -> (),
	Destroy: (self: SignalType<Func, T...>) -> ()
}

export type GenericSignal = Signal<>

-- stylua: ignore
local rbxConnect, rbxDisconnect do
	if task then
		local bindable = Instance.new("BindableEvent")
		rbxConnect = bindable.Event.Connect
		rbxDisconnect = bindable.Event:Connect(function() end).Disconnect
		bindable:Destroy()
	end
end

local function connect(self: any, fn: any, ...: any)
	local head = self._head
	local cn = setmetatable({
		Connected = true,
		_signal = self,
		_fn = fn,
		_varargs = if not ... then false else { ... },
		_next = head,
		_prev = false,
	}, Connection)

	if head then
		head._prev = cn
	end
	self._head = cn

	return cn
end

local function once(self, fn, ...)
	local cn
	cn = connect(self :: any, function(...)
		disconnect(cn)
		fn(...)
	end, ...)
	return cn
end

local function wait(self)
	local thread = coroutine.running()
	local cn
	cn = connect(self :: any, function(...)
		disconnect(cn)
		self._waiting[thread] = nil
		if coroutine.status(thread) == "suspended" then
			task.spawn(thread, ...)
		end
	end)
	self._waiting[thread] = true
	return coroutine.yield()
end

-- Fires the signal and resumes connections immediately via <code>task.spawn()</code>.
-- Please transition to <code>:FireDefer()</code> instead to continue adopting the new deferred signaling model.
local function fire<Func, T...>(self: any, ...: any)
	local cn = self._head
	while cn do
		local thread
		if #freeThreads > 0 then
			thread = freeThreads[#freeThreads]
			freeThreads[#freeThreads] = nil
		else
			thread = coroutine.create(yielder)
			coroutine.resume(thread)
		end

		if not cn._varargs then
			task.spawn(thread, cn._fn, thread, ...)
		else
			local args = cn._varargs
			local len = #args
			local count = len
			local newArgs = table.pack(...) -- Use table.pack to pack the variadic arguments (resolves type error)
			for i = 1, newArgs.n do
				count += 1
				args[count] = newArgs[i]
			end

			task.spawn(thread, cn._fn, thread, table.unpack(args))

			for i = count, len + 1, -1 do
				args[i] = nil
			end
		end

		cn = cn._next
	end
end

-- Fires the signal and resumes connections via <code>task.defer()</code>.
local function fireDefer<Func, T...>(self: any, ...: any)
	local newArgs = table.pack(...) -- Use table.pack to pack the variadic arguments (resolves type error)
	-- cannot task.defer the threads themselves due to the thread recycling
	task.defer(function()
		local cn = self._head
		while cn do
			local thread
			if #freeThreads > 0 then
				thread = freeThreads[#freeThreads]
				freeThreads[#freeThreads] = nil
			else
				thread = coroutine.create(yielder)
				coroutine.resume(thread)
			end

			if not cn._varargs then
				task.spawn(thread, cn._fn, thread, table.unpack(newArgs))
			else
				local args = cn._varargs
				local len = #args
				local count = len
				for i = 1, newArgs.n do
					count += 1
					args[count] = newArgs[i]
				end

				task.spawn(thread, cn._fn, thread, table.unpack(args))

				for i = count, len + 1, -1 do
					args[i] = nil
				end
			end

			cn = cn._next
		end
	end)
end

local function disconnectAll(self: any)
	local cn = self._head
	while cn do
		disconnect(cn)
		cn = cn._next
	end
end

local function destroy(self: any)
	disconnectAll(self :: any)
	for thread, _ in pairs(self._waiting) do
		if coroutine.status(thread) == "suspended" then
			task.cancel(thread)
		end
		self._waiting[thread] = nil
	end
	local cn = self.RBXScriptConnection
	if cn then
		rbxDisconnect(cn)
		self.RBXScriptConnection = nil
	end
end

--\\ Constructors
function Signal.new(): any
	local self = { _head = false, _waiting = {} }
	setmetatable(self, Signal)

	return self :: any
end

function Signal.wrap(signal: RBXScriptSignal): any
	local wrapper = setmetatable({ _head = false, _waiting = {} }, Signal)

	wrapper.RBXScriptConnection = rbxConnect(signal :: any, function(...)
		fire(wrapper :: any, ...)
	end)

	return wrapper :: any
end

--\\ Methods
Signal.Connect = connect
Signal.Once = once
Signal.Wait = wait
Signal.Fire = fire
Signal.FireDefer = fireDefer
Signal.DisconnectAll = disconnectAll
Signal.Destroy = destroy

return { new = Signal.new, wrap = Signal.wrap }]]

-- -----------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- License:                                                                   --
--   Licensed under the MIT license.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--   sleitnick - August 3rd, 2021 - Modified for Knit.                        --
-- -----------------------------------------------------------------------------

-- Signal types
export type Connection = {
	Disconnect: (self: Connection) -> (),
	Destroy: (self: Connection) -> (),
	Connected: boolean,
}

export type Signal<Func = () -> (), T... = ...any> = {
	Fire: (self: Signal<Func, T...>, T...) -> (),
	FireDeferred: (self: Signal<Func, T...>, T...) -> (),
	Connect: (self: Signal<Func, T...>, fn: Func) -> Connection,
	Once: (self: Signal<Func, T...>, fn: Func) -> Connection,
	DisconnectAll: (self: Signal<Func, T...>) -> (),
	GetConnections: (self: Signal<Func, T...>) -> { Connection },
	Destroy: (self: Signal<Func, T...>) -> (),
	Wait: (self: Signal<Func, T...>) -> T...,
}

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread(...)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

--[[
	@within Signal
	@interface SignalConnection
	.Connected boolean
	.Disconnect (SignalConnection) -> ()
	Represents a connection to a signal.
	```lua
	local connection = signal:Connect(function() end)
	print(connection.Connected) --> true
	connection:Disconnect()
	print(connection.Connected) --> false
	```
]]

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		Connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	if not self.Connected then
		return
	end
	self.Connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end

	if self._signal.connectionsChanged then
		self._signal.totalConnections -= 1
		self._signal.connectionsChanged:Fire(-1)
	end
end

Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(_tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

--[[
	@within Signal
	@type ConnectionFn (...any) -> ()
	A function connected to a signal.
]]

--[[
	@class Signal
	Signals allow events to be dispatched and handled.
	For example:
	```lua
	local signal = Signal.new()
	signal:Connect(function(msg)
		print("Got message:", msg)
	end)
	signal:Fire("Hello world!")
	```
]]
local Signal = {}
Signal.__index = Signal

--[[
	Constructs a new Signal
	@return Signal
]]
function Signal.new<Func, T...>(createConnectionsChangedSignal: boolean?): Signal<Func, T...>
	local self = setmetatable({
		_handlerListHead = false,
		_proxyHandler = nil,
	}, Signal)
	if createConnectionsChangedSignal then
		self.totalConnections = 0
		self.connectionsChanged = Signal.new()
	end
	return self
end

--[[
	Constructs a new Signal that wraps around an RBXScriptSignal.
	@param rbxScriptSignal RBXScriptSignal -- Existing RBXScriptSignal to wrap
	@return Signal
	For example:
	```lua
	local signal = Signal.Wrap(workspace.ChildAdded)
	signal:Connect(function(part) print(part.Name .. " added") end)
	Instance.new("Part").Parent = workspace
	```
]]
function Signal.Wrap<func, T...>(rbxScriptSignal: RBXScriptSignal): Signal<func, T...>
	assert(
		typeof(rbxScriptSignal) == "RBXScriptSignal",
		"Argument #1 to Signal.Wrap must be a RBXScriptSignal; got " .. typeof(rbxScriptSignal)
	)
	local signal = Signal.new()
	signal._proxyHandler = rbxScriptSignal:Connect(function(...)
		signal:Fire(...)
	end)
	return signal
end

--[[
	Checks if the given object is a Signal.
	@param obj any -- Object to check
	@return boolean -- `true` if the object is a Signal.
]]
function Signal.Is(obj: any): boolean
	return type(obj) == "table" and getmetatable(obj) == Signal
end

--[[
	@param fn ConnectionFn
	@return SignalConnection
	Connects a function to the signal, which will be called anytime the signal is fired.
	```lua
	signal:Connect(function(msg, num)
		print(msg, num)
	end)
	signal:Fire("Hello", 25)
	```
]]
function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end

	if self.connectionsChanged then
		self.totalConnections += 1
		self.connectionsChanged:Fire(1)
	end
	return connection
end

--[[
	@deprecated v1.3.0 -- Use `Signal:Once` instead.
	@param fn ConnectionFn
	@return SignalConnection
]]
function Signal:ConnectOnce(fn)
	return self:Once(fn)
end

--[[
	@param fn ConnectionFn
	@return SignalConnection
	Connects a function to the signal, which will be called the next time the signal fires. Once
	the connection is triggered, it will disconnect itself.
	```lua
	signal:Once(function(msg, num)
		print(msg, num)
	end)
	signal:Fire("Hello", 25)
	signal:Fire("This message will not go through", 10)
	```
]]
function Signal:Once(fn)
	local connection
	local done = false
	connection = self:Connect(function(...)
		if done then
			return
		end
		done = true
		connection:Disconnect()
		fn(...)
	end)
	return connection
end

function Signal:GetConnections()
	local items = {}
	local item = self._handlerListHead
	while item do
		table.insert(items, item)
		item = item._next
	end
	return items
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
--[[
	Disconnects all connections from the signal.
	```lua
	signal:DisconnectAll()
	```
]]
function Signal:DisconnectAll()
	local item = self._handlerListHead
	while item do
		item.Connected = false
		item = item._next
	end
	self._handlerListHead = false

	if self.connectionsChanged then
		self.connectionsChanged:Fire(-self.totalConnections)
		self.connectionsChanged:Destroy()
		self.connectionsChanged = nil
		self.totalConnections = 0
	end
end

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
--[[
	@param ... any
	Fire the signal, which will call all of the connected functions with the given arguments.
	```lua
	signal:Fire("Hello")
	-- Any number of arguments can be fired:
	signal:Fire("Hello", 32, {Test = "Test"}, true)
	```
]]
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item.Connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

--[[
	@param ... any
	Same as `Fire`, but uses `task.defer` internally & doesn't take advantage of thread reuse.
	```lua
	signal:FireDeferred("Hello")
	```
]]
function Signal:FireDeferred(...)
	local item = self._handlerListHead
	while item do
		task.defer(item._fn, ...)
		item = item._next
	end
end

--[[
	@return ... any
	@yields
	Yields the current thread until the signal is fired, and returns the arguments fired from the signal.
	Yielding the current thread is not always desirable. If the desire is to only capture the next event
	fired, using `Once` might be a better solution.
	```lua
	task.spawn(function()
		local msg, num = signal:Wait()
		print(msg, num) --> "Hello", 32
	end)
	signal:Fire("Hello", 32)
	```
]]
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local connection
	local done = false
	connection = self:Connect(function(...)
		if done then
			return
		end
		done = true
		connection:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end

--[[
	Cleans up the signal.
	Technically, this is only necessary if the signal is created using
	`Signal.Wrap`. Connections should be properly GC'd once the signal
	is no longer referenced anywhere. However, it is still good practice
	to include ways to strictly clean up resources. Calling `Destroy`
	on a signal will also disconnect all connections immediately.
	```lua
	signal:Destroy()
	```
]]
function Signal:Destroy()
	self:DisconnectAll()
	local proxyHandler = rawget(self, "_proxyHandler")
	if proxyHandler then
		proxyHandler:Disconnect()
	end
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(_tb, key)
		return rawget(_tb, key)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

return {
	new = Signal.new,
	Wrap = Signal.Wrap,
	Is = Signal.Is,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">16440367657</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000431c</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX055EFD25E154429BAD3C9FB9E044A4AC">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">01a96444d5e0b85d061879580000555a</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">FunctionUtils</string>
						<string name="ScriptGuid">{745A5AD8-1320-4177-A4F8-B875EB304C26}</string>
						<ProtectedString name="Source"><![CDATA[--!strict
--@title: Util
--@author: crusherfire
--@date: 3/30/24
-----------------------------
-- SERVICES --
-----------------------------

-----------------------------
-- DEPENDENCIES --
-----------------------------
local _vector = require(script._vector)
local _interface = require(script._interface)
local _table = require(script._table)
local _format = require(script._format)
local _game = require(script._game)
local _character = require(script._character)
local _object = require(script._object)
local _random = require(script._random)
local _math = require(script._math)
local _observers = require(script._observers)
local _debugDraw = require(script._debugDraw)
local _player = require(script._player)
local _t = require(script._t)
local _buffer = require(script._buffer)
local _camera = require(script._camera)
local _vfx = require(script._vfx)
local _cframe = require(script._cframe)
local _base64 = require(script._base64)
local _remotes = require(script._remotes)
local _region3 = require(script._region3)
local _Sera = require(script._Sera)
local _proxy = require(script._proxy)
local _input = require(script._input)
local _color = require(script._color)
local _dateTime = require(script._dateTime)

-----------------------------
-- TYPES --
-----------------------------

export type Schema = _Sera.Schema

-----------------------------
-- VARIABLES --
-----------------------------
local Util = {
	Vector = _vector,
	Interface = _interface,
	Table = _table,
	Format = _format,
	Game = _game,
	Character = _character,
	Player = _player,
	Object = _object,
	Random = _random,
	Math = _math,
	Observers = _observers,
	DebugDraw = _debugDraw,
	t = _t,
	Buffer = _buffer,
	Camera = _camera,
	VFX = _vfx,
	CFrame = _cframe,
	Base64 = _base64,
	Remotes = _remotes,
	Region3 = _region3,
	Sera = _Sera,
	Proxy = _proxy,
	Input = _input,
	Color = _color,
	DateTime = _dateTime
}

-----------------------------
-- MAIN --
-----------------------------
return Util]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000431d</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX3B84188A12934E289E88A0E8E259EEFA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009630</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_vector</string>
							<string name="ScriptGuid">{5879AD2A-5E17-4AAB-B13F-5963C6C12039}</string>
							<ProtectedString name="Source"><![CDATA[local PathfindingService = game:GetService("PathfindingService")
local Vector = {}

function Vector.distance(position0: Vector3, position1: Vector3)
	assert(position0 and typeof(position0) == "Vector3", "Position0 is invalid or nil")
	assert(position1 and typeof(position1) == "Vector3", "Position1 is invalid or nil")

	local p = position0 - position1
	local magnitude = p.Magnitude

	return magnitude
end

function Vector.pathDistance(position0: Vector3, position1: Vector3, agentOptions: {})
	assert(position0 and typeof(position0) == "Vector3", "Position0 is invalid or nil")
	assert(position1 and typeof(position1) == "Vector3", "Position1 is invalid or nil")

	local path = PathfindingService:CreatePath(agentOptions)
	path:ComputeAsync(position0, position1)

	local totalDistance = 0

	local waypoints = path:GetWaypoints()
	for i, waypoint in pairs(waypoints) do
		if not waypoints[i + 1] then return end
		totalDistance += Vector.distance(waypoint.Position, waypoints[i + 1].Position)
	end

	return totalDistance
end

function Vector.direction(position0: Vector3, position1: Vector3)
	assert(position0 and typeof(position0) == "Vector3", "Position0 is invalid or nil")
	assert(position1 and typeof(position1) == "Vector3", "Position1 is invalid or nil")

	local p = position0 - position1
	return p
end

function Vector.limit(xPosition: Vector3, minPosition: Vector3, maxPosition: Vector3)
	assert(xPosition and typeof(xPosition) == "Vector3", "xPosition is invalid or nil")
	assert(minPosition and typeof(minPosition) == "Vector3", "minPosition is invalid or nil")
	assert(maxPosition and typeof(maxPosition) == "Vector3", "maxPosition is invalid or nil")

	local X, Y, Z = xPosition.X, xPosition.Y, xPosition.Z

	local minX, minY, minZ = minPosition.X, minPosition.Y, minPosition.Z
	local maxX, maxY, maxZ = maxPosition.X, maxPosition.Y, maxPosition.Z

	local newVector = Vector3.new(
		math.clamp(X, minX, maxX),
		math.clamp(Y, minY, maxY),
		math.clamp(Z, minZ, maxZ)
	)

	return newVector
end

function Vector.getPositionInFrontOf(object: BasePart, offsetStuds: number): Vector3
	assert(object and object:IsA("BasePart"), "object is invalid or nil")
	assert(offsetStuds and typeof(offsetStuds) == "number", "object is invalid or nil")
	
	return object.Position + object.CFrame.LookVector * offsetStuds
end

return Vector]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000431e</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX01C727FA399C486DBCEF873E07C121A7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009631</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_random</string>
							<string name="ScriptGuid">{4B38B660-C43A-4E44-8623-3D0DB36C7D43}</string>
							<ProtectedString name="Source"><![CDATA[local _Random = {}

local rng = Random.new(tick())

-- <strong>percentChance</strong>: Should be a value between 0-100.
-- <strong>luck</strong>: Represents how many rerolls.
function _Random.rollChance(percentChance: number, luck: number?): boolean
	if percentChance <= 0 then
		return false
	end
	luck = luck or 0
	local rolls = math.ceil(math.abs(luck :: number))
	local num2 = rng:NextNumber(0, 100)

	for i = 1, rolls do
		local b = rng:NextNumber(0, 100)
		num2 = if luck > 0 then math.min(num2, b) else math.max(num2, b)
	end
	if num2 <= percentChance then
		return true
	end
	return false
end

function _Random.range(minF: number, maxF: number, seed: number)
	assert(minF and typeof(minF) == "number", "minF is invalid or nil")
	assert(maxF and typeof(maxF) == "number", "maxF is invalid or nil")

	local RBLX_Random = Random.new(seed or math.random() * 1000000)
	local randomValue = RBLX_Random:NextInteger(minF, maxF)

	return randomValue
end

function _Random.object(objectsList: {} | Instance, recursive: boolean)
	assert(objectsList and typeof(objectsList) == "table" or typeof(objectsList) == "Instance", "objectsList is invalid or nil")

	local list = typeof(objectsList) == "Instance" and (recursive and objectsList:GetDescendants() or objectsList:GetChildren()) or objectsList
	local randomObject = list[_Random.range(1, #list)]

	return randomObject
end

function _Random.randomString(length: number, includeCapitals: boolean)
	local random = Random.new()
	local letters = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}

	local function getRandomLetter()
		return letters[random:NextInteger(1,#letters)]
	end


	local length = length or 10
	local str = ''
	for i = 1, length do
		local randomLetter = getRandomLetter()
		if includeCapitals and random:NextNumber() > .5 then
			randomLetter = string.upper(randomLetter)
		end
		str = str .. randomLetter
	end
	return str
end

return _Random
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000431f</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8460CA6DF76C4C41B7A68E04B6E07091">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009632</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_object</string>
							<string name="ScriptGuid">{1B90A2A3-AE03-4265-9F40-4B7DA3A068B7}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local PhysicsService = game:GetService("PhysicsService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local Future = require("../ModuleUtils/_Future")
local _game = require("./_game")
local _table = require("./_table")

local Table = require("./_table")

local Logger = require("../ModuleUtils/_Logger")

local Module = {}

--[[
	Grabs all instances with <code>tag</code>.
	<strong>validAncestors</strong>: Optionally filter for instances within the ancestor list.
]]
function Module.getTagged(tag: string, validAncestors: { any }?): { any }
	debug.profilebegin("FunctionUtils::getTagged")
	local tagged: { Instance } = CollectionService:GetTagged(tag)
	if validAncestors then
		tagged = _table.filter(tagged, function(instance)
			local found = false
			for _, ancestor in validAncestors do
				if instance:IsDescendantOf(ancestor) then
					found = true
					break
				end
			end
			return found
		end)
	end
	debug.profileend()
	return tagged
end

-- Returns a future that resolves once the animation track is loaded (Length becomes greater than 0)
function Module.getAnimationTrackLoadedFuture(track: AnimationTrack)
	return Future.new(function(track: AnimationTrack)
		if track.Length == 0 then
			-- GetPropertyChangedSignal does NOT work with the Length property!
			repeat
				task.wait()
			until track.Length > 0
		end
	end, track)
end

-- Creates a new OverlapParams
function Module.overlapParams(
	properties: {
		FilterDescendantsInstances: { any }?,
		FilterType: Enum.RaycastFilterType?,
		CollisionGroup: string?,
		RespectCanCollide: boolean?,
		BruteForceAllSlow: boolean?,
		Tolerance: number?,
		MaxParts: number?
	}?
): OverlapParams
	local params: any = OverlapParams.new()
	if properties then
		for name, value in pairs(properties) do
			params[name] = value
		end
	end
	return params
end

-- Creates a new RaycastParams
function Module.raycastParams(
	properties: {
		FilterDescendantsInstances: { any }?,
		FilterType: Enum.RaycastFilterType?,
		CollisionGroup: string?,
		RespectCanCollide: boolean?,
		BruteForceAllSlow: boolean?,
		IgnoreWater: boolean?,
	}?
): RaycastParams
	local params: any = RaycastParams.new()
	if properties then
		for name, value in pairs(properties) do
			params[name] = value
		end
	end
	return params
end

-- Determines if the two parts can collide with each other based on their CanCollide and CollisionGroup properties.
function Module.areCollideable(part1: BasePart, part2: BasePart): boolean
	local part1Group = part1.CollisionGroup
	local part2Group = part2.CollisionGroup
	return part2.CanCollide and part1.CanCollide and PhysicsService:CollisionGroupsAreCollidable(part1Group, part2Group)
end

@deprecated
-- DEPRECATED (use math library)
-- Given a ground position and model, this returns what the model should be :PivotTo() for a flush ground position.
function Module.getPivotFlushWithGround(groundPoint: CFrame, model: Model): CFrame
	local pivot = model:GetPivot()
	local center, size = model:GetBoundingBox()

	local bottomWorld = Vector3.new(
		center.X,
		center.Y - size.Y / 2,
		center.Z
	)

	local offset = pivot:PointToObjectSpace(bottomWorld)

	return groundPoint * CFrame.new(-offset)
end

@deprecated
-- DEPRECATED (use math library)
-- Resizes the model via <code>:ScaleTo()</code> to ensure it fits within a spherical volume.
function Module.resizeModelToFitRadius(model: Model, radius: number)
	local pivotCFrame, size = model:GetBoundingBox()
	local currentRadius = size.Magnitude * 0.5
	assert(currentRadius > 0, "Model has zero size")

	model:PivotTo(pivotCFrame)

	local scaleFactor = radius / currentRadius
	model:ScaleTo(scaleFactor)
end

@deprecated
-- DEPRECATED (use math library)
-- Returns the central bottom point of the model's bounding box (includes orientation)
function Module.getBottomPositionOfModel(model: Model): Vector3
	local boundingBox, size = model:GetBoundingBox()
	return (boundingBox * CFrame.new(0, -size.Y / 2, 0)).Position
end

-- Returns the 'depth' of <code>descendant</code> in the child hierarchy of <code>root</code>.
-- If the descendant is not found in <code>root</code>, then this function will return 0.
function Module.getDepthInHierarchy(descendant: Instance, root: Instance): number
	local depth = 0
	local current: Instance? = descendant
	while current and current ~= root do
		current = current.Parent
		depth += 1
	end
	if not current then
		depth = 0
	end
	return depth
end

-- Default searchDepth is removal of tags for all descendents, 1 is for just the passed object.
function Module.removeAllTags(obj: Instance, searchDepth: number?)
	if searchDepth ~= nil then
		assert(typeof(searchDepth) == "number" and searchDepth >= 1, "findWithPredicate: searchDepth must be positive number")
	end

	local function removeTags(instance: any, tags: {string})
		for _, tag in ipairs(tags) do
			instance:RemoveTag(tag)
		end
	end

	local tags = obj:GetTags()
	removeTags(obj, tags)

	if not searchDepth then
		for _, desc in ipairs(obj:GetDescendants()) do
			local tags = desc:GetTags()
			removeTags(desc, tags)
		end
	elseif searchDepth == 1 then
		return
	else
		local function recurse(node: Instance, depth: number)
			for _, child in ipairs(node:GetChildren()) do
				local tags = child:GetTags()
				removeTags(child, tags)
				if depth < searchDepth then
					recurse(child, depth + 1)
				end
			end
		end
		recurse(obj, 1)
	end
end

-- Given an unknown number of arrays containing instances, returns all descendants of all instances in the arrays.
function Module.getDescendants(...: { any }): { any }
	local arrays = {...}
	local result = {}

	local function collect(instance: Instance)
		local descendants = instance:GetDescendants()
		result = Table.mergeArrays(result, descendants)
	end

	-- Iterate over every array in the arguments
	for _, array in ipairs(arrays) do
		for _, instance in ipairs(array) do
			table.insert(result, instance)
			collect(instance)
		end
	end

	return result
end

-- DESCENDANT FIND FUNCTIONS --
do
	--<strong>isValid</strong>: Validates instances to be returned in the result of the function.
	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements of <code>class</code>.
	function Module.findAllWithPredicate(
		searchIn: any,
		isValid: (instance: any) -> boolean,
		searchDepth: number?
	): { any }
		assert(typeof(searchIn)  == "Instance", "findAllWithPredicate: searchIn must be an Instance")
		assert(typeof(isValid)   == "function", "findAllWithPredicate: isValid must be a function")
		if searchDepth ~= nil then
			assert(
				typeof(searchDepth) == "number" and searchDepth >= 1,
				"findAllWithPredicate: searchDepth must be a positive number"
			)
		end
		debug.profilebegin("FunctionUtils::findAllWithPredicate")
		local results = {}

		if not searchDepth then
			-- no limit -> use the built-in, highly‑optimized path
			for _, obj in ipairs(searchIn:GetDescendants()) do
				if isValid(obj) then
					table.insert(results, obj)
				end
			end
		elseif searchDepth == 1 then
			-- only direct children
			for _, child in ipairs(searchIn:GetChildren()) do
				if isValid(child) then
					table.insert(results, child)
				end
			end
		else
			-- recursive depth-first, tracking current depth
			local function recurse(node: Instance, depth: number)
				for _, child in ipairs(node:GetChildren()) do
					if isValid(child) then
						table.insert(results, child)
					end
					if depth < searchDepth then
						recurse(child, depth + 1)
					end
				end
			end
			recurse(searchIn, 1)
		end

		debug.profileend()
		return results
	end

	-- Finds all instances that have the given name.
	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements of <code>className</code>.
	-- Default is no limit.
	function Module.findAll(name: string, searchIn: any, searchDepth: number?)
		assert(typeof(name) == "string", "name is invalid or nil")
		assert(typeof(searchIn) == "Instance", "searchIn is invalid or nil")

		return Module.findAllWithPredicate(
			searchIn,
			function(obj)
				return obj.Name == name
			end,
			searchDepth
		)
	end

	-- DEPRECATED. Use findAllWhichAreA or findAllOfClass
	-- NOTE: This function uses :IsA() which is incorrect behavior based on its name.
	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements of <code>className</code>.
	-- Default is no limit.
	@deprecated
	function Module.findAllFromClass(
		className: string,
		searchIn: any,
		searchDepth: number?
	): { any }
		assert(typeof(className) == "string", "findAllFromClass: className must be a string")
		return Module.findAllWithPredicate(
			searchIn,
			function(obj: Instance)
				return obj:IsA(className)
			end,
			searchDepth
		)
	end

	--[[
		Searches for objects via <strong>:IsA()</strong>.
		<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements of <code>className</code>.
		Default is no limit.
	]]
	function Module.findAllWhichAreA(
		className: string,
		searchIn: any,
		searchDepth: number?
	): { any }
		assert(typeof(className) == "string", "findAllWhichAreA: className must be a string")
		return Module.findAllWithPredicate(
			searchIn,
			function(obj: Instance)
				return obj:IsA(className)
			end,
			searchDepth
		)
	end

	--[[
		Searches for objects via the <strong>ClassName</strong> property of the object.
		<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements of <code>className</code>.
		Default is no limit.
	]]
	function Module.findAllOfClass(
		className: string,
		searchIn: any,
		searchDepth: number?
	): { any }
		assert(typeof(className) == "string", "findAllOfClass: className must be a string")
		return Module.findAllWithPredicate(
			searchIn,
			function(obj: Instance)
				return obj.ClassName == className
			end,
			searchDepth
		)
	end

	--[[
		This function is more optimal as it grabs all with <code>tagName</code> via CollectionService,
		rather than looking through all descendants of <code>searchIn</code> (if you don't use <code>searchDepth</code>).
		<strong>searchDepth</strong>: Optional argument that defines how far to include elements of <code>className</code>.
		Default is no limit.
	]]
	function Module.findAllWithTag(
		tagName: string,
		searchIn: any,
		searchDepth: number?
	): { any }
		assert(typeof(tagName) == "string", "findAllWithTag: tagName must be a string")
		assert(typeof(searchIn) == "Instance", "findAllWithTag: searchIn must be an Instance")
		debug.profilebegin("FunctionUtils::findAllWithTag")

		if searchDepth then
			-- Recursive search
			local result = Module.findAllWithPredicate(
				searchIn,
				function(obj)
					return obj:HasTag(tagName)
				end,
				searchDepth
			)
			debug.profileend()
			return result
		end

		local tagged = CollectionService:GetTagged(tagName)
		local results = {}

		for _, instance in ipairs(tagged) do
			if instance:IsDescendantOf(searchIn) then
				table.insert(results, instance)
			end
		end

		debug.profileend()
		return results
	end

	--<strong>attributeValue</strong>: Optionally find only those with the matching attribute value.
	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements with <code>attribute</code>.
	-- Default is no limit.
	function Module.findAllWithAttribute(
		attribute: string,
		searchIn: any,
		attributeValue: any?,
		searchDepth: number?
	): { any }
		assert(typeof(attribute) == "string", "findAllWithAttribute: attribute must be a string")
		return Module.findAllWithPredicate(
			searchIn,
			function(obj)
				local attr = obj:GetAttribute(attribute)
				if attributeValue ~= nil then
					return attr == attributeValue
				else
					return attr ~= nil
				end
			end,
			searchDepth
		)
	end

	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements with <code>isValid</code>.
	-- Default is no limit.
	function Module.findWithPredicate(
		searchIn: any,
		isValid: (any) -> boolean,
		searchDepth: number?
	): any
		assert(typeof(searchIn) == "Instance", "findWithPredicate: searchIn must be Instance")
		assert(typeof(isValid) == "function", "findWithPredicate: isValid must be function")
		if searchDepth ~= nil then
			assert(typeof(searchDepth) == "number" and searchDepth >= 1, "findWithPredicate: searchDepth must be positive number")
		end
		debug.profilebegin("FunctionUtils::findWithPredicate")
		if not searchDepth then
			for _, obj in ipairs(searchIn:GetDescendants()) do
				if isValid(obj) then
					return obj
				end
			end
			return nil
		end

		if searchDepth == 1 then
			for _, child in ipairs(searchIn:GetChildren()) do
				if isValid(child) then
					return child
				end
			end
			return nil
		end

		-- recursive up to searchDepth
		local function recurse(node: Instance, depth: number): Instance?
			for _, child in ipairs(node:GetChildren()) do
				if isValid(child) then
					return child
				end
				if depth < searchDepth then
					local found = recurse(child, depth + 1)
					if found then
						return found
					end
				end
			end
			return nil
		end

		local result = recurse(searchIn, 1)

		debug.profileend()
		return result
	end

	--[[
		Alias for <code>findWithPredicate()</code>.
	]]
	function Module.findFirstWithPredicate(
		searchIn: any,
		isValid: (any) -> boolean,
		searchDepth: number?
	): any
		return Module.findWithPredicate(searchIn, isValid, searchDepth)
	end

	-- Shorthand for :FindFirstChild
	function Module.find(name: string, searchIn: any, recursive: boolean): any
		assert(typeof(name) == "string", "find: name must be string")
		assert(typeof(searchIn) == "Instance", "find: searchIn must be Instance")
		return searchIn:FindFirstChild(name, recursive)
	end

	--[[
		Alias for <code>find()</code>.
	]]
	function Module.findFirst(name: string, searchIn: any, recursive: boolean): any
		return Module.find(name, searchIn, recursive)
	end

	-- Find first descendant of given a given class via :IsA()
	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements with <code>className</code>.
	-- Default is no limit.
	function Module.findFromClass(
		className: string,
		searchIn: any,
		searchDepth: number?
	): any
		assert(typeof(className) == "string", "findFromClass: className must be string")
		assert(typeof(searchIn) == "Instance", "findFromClass: searchIn must be Instance")
		return Module.findWithPredicate(
			searchIn,
			function(obj)
				return obj:IsA(className)
			end,
			searchDepth
		)
	end

	--[[
		Alias for <code>findFromClass()</code>.
	]]
	function Module.findFirstFromClass(
		className: string,
		searchIn: any,
		searchDepth: number?
	): any
		return Module.findFromClass(className, searchIn, searchDepth)
	end

	--[[
		If <code>searchDepth</code> is shallow (1) or unlimited, then the search is optimized by using <code>CollectionService:GetTagged()</code>.
		<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements with <code>tagName</code>.
		Default is no limit.
	]]
	function Module.findWithTag(
		tagName: string,
		searchIn: any,
		searchDepth: number?
	): any
		assert(typeof(tagName) == "string", "findWithTag: tagName must be string")
		assert(typeof(searchIn) == "Instance", "findWithTag: searchIn must be Instance")

		local isUnlimited = searchDepth == nil or searchDepth < 0
		local isShallow = searchDepth == 1

		if
			not isUnlimited
			and not isShallow
		then
			return Module.findWithPredicate(
				searchIn,
				function(obj)
					return CollectionService:HasTag(obj, tagName)
				end,
				searchDepth
			)
		end

		debug.profilebegin("FunctionUtils::findWithTag")
		for _, instance in CollectionService:GetTagged(tagName) do
			if not instance:IsDescendantOf(searchIn) then
				continue
			end
			if isShallow and instance.Parent ~= searchIn then
				continue
			end
			debug.profileend()
			return instance
		end
		debug.profileend()
		return nil
	end

	--[[
		Alias for <code>findWithTag()</code>.
	]]
	function Module.findFirstWithTag(
		tagName: string,
		searchIn: any,
		searchDepth: number?
	): any
		return Module.findWithTag(tagName, searchIn, searchDepth)
	end

	--<strong>attributeValue</strong>: Optional match for the attribute value.
	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements with <code>attribute</code>.
	-- Default is no limit.
	function Module.findWithAttribute(
		attribute: string,
		searchIn: any,
		attributeValue: any?,
		searchDepth: number?
	): any
		assert(typeof(attribute) == "string", "findWithAttribute: attribute must be string")
		assert(typeof(searchIn) == "Instance", "findWithAttribute: searchIn must be Instance")

		return Module.findWithPredicate(
			searchIn,
			function(obj)
				local val = obj:GetAttribute(attribute)
				if attributeValue ~= nil then
					return val == attributeValue
				else
					return val ~= nil
				end
			end,
			searchDepth
		)
	end

	--[[
		Alias for <code>findWithAttribute()</code>.
	]]
	function Module.findFirstWithAttribute(
		attribute: string,
		searchIn: any,
		attributeValue: any?,
		searchDepth: number?
	): any
		return Module.findWithAttribute(attribute, searchIn, attributeValue, searchDepth)
	end
end

-- WAIT FUNCTIONS --
do
	@deprecated
	-- DEPRECATED
	function Module.waitForChild(parent: Instance, childMatchesCriteria: (child: Instance) -> (boolean), timeOut: number?): Instance?
		for _, child in parent:GetChildren() do
			if childMatchesCriteria(child) then
				return child
			end
		end

		local thread = coroutine.running()
		local connection = nil :: RBXScriptConnection?

		connection = parent.ChildAdded:Connect(function(child)
			if not connection then
				return
			end

			if childMatchesCriteria(child) then
				connection:Disconnect()
				connection = nil

				task.spawn(thread, child)
			end
		end)

		if timeOut then
			task.delay(timeOut, function()
				if not connection then
					return
				end

				connection:Disconnect()
				connection = nil

				task.spawn(thread, nil)
			end)
		end

		return coroutine.yield()
	end

	-- Yields until a valid child is found.
	function Module.waitForChildWithPredicate(
		parent: Instance,
		isValid: (any) -> boolean,
		timeout: number?
	): any
		for _, child in parent:GetChildren() do
			if isValid(child) then
				return child
			end
		end

		local thread = coroutine.running()
		local connection: RBXScriptConnection?

		connection = parent.ChildAdded:Connect(function(child)
			if not connection then
				return
			end
			if not isValid(child) then
				return
			end

			connection:Disconnect()
			connection = nil
			if coroutine.status(thread) == "suspended" then
				task.spawn(thread, child)
			end
		end)

		if timeout then
			task.delay(timeout, function()
				if not connection then
					return
				end

				connection:Disconnect()
				connection = nil

				if coroutine.status(thread) == "suspended" then
					task.spawn(thread)
				end
			end)
		end

		return coroutine.yield()
	end

	function Module.waitForChildWhichIsA(
		parent: Instance,
		className: string,
		timeout: number?
	): any
		assert(typeof(className) == "string", "waitForChildWhichIsA: className must be a string")

		return Module.waitForChildWithPredicate(parent, function(child)
			return child:IsA(className)
		end, timeout)
	end

	function Module.waitForChildWithTag(
		parent: Instance,
		tagName: string,
		timeout: number?
	): any
		assert(typeof(tagName) == "string", "waitForChildWithTag: tagName must be a string")

		return Module.waitForChildWithPredicate(parent, function(child)
			return child:HasTag(tagName)
		end, timeout)
	end

	function Module.waitForChildWithAttribute(
		parent: Instance,
		attributeName: string,
		attributeValue: any?,
		timeout: number?
	): any
		assert(typeof(attributeName) == "string", "waitForChildWithAttribute: attributeName must be a string")

		return Module.waitForChildWithPredicate(parent, function(child)
			local value = child:GetAttribute(attributeName)
			if attributeValue ~= nil then
				return value == attributeValue
			else
				return value ~= nil
			end
		end, timeout)
	end
end

-- WAITFORDESCENDANT FUNCTIONS --
do
	-- Yields until a valid descendant is found.
	function Module.waitForDescendantWithPredicate(
		parent: Instance,
		isValid: (any) -> boolean,
		timeout: number?
	): any
		assert(typeof(parent) == "Instance", "waitForDescendantWithPredicate: parent must be an Instance")
		assert(typeof(isValid) == "function", "waitForDescendantWithPredicate: isValid must be a function")

		for _, descendant in ipairs(parent:GetDescendants()) do
			if isValid(descendant) then
				return descendant
			end
		end

		local thread = coroutine.running()
		local connection: RBXScriptConnection?

		connection = parent.DescendantAdded:Connect(function(descendant)
			if not connection then
				return
			end
			if not isValid(descendant) then
				return
			end

			connection:Disconnect()
			connection = nil

			if coroutine.status(thread) == "suspended" then
				task.spawn(thread, descendant)
			end
		end)

		if timeout then
			task.delay(timeout, function()
				if not connection then
					return
				end

				connection:Disconnect()
				connection = nil

				if coroutine.status(thread) == "suspended" then
					task.spawn(thread)
				end
			end)
		end

		return coroutine.yield()
	end

	function Module.waitForDescendantWhichIsA(
		parent: Instance,
		className: string,
		timeout: number?
	): any
		assert(typeof(className) == "string", "waitForDescendantWhichIsA: className must be a string")

		return Module.waitForDescendantWithPredicate(parent, function(obj)
			return obj:IsA(className)
		end, timeout)
	end

	function Module.waitForDescendantWithTag(
		parent: Instance,
		tagName: string,
		timeout: number?
	): any
		assert(typeof(tagName) == "string", "waitForDescendantWithTag: tagName must be a string")

		return Module.waitForDescendantWithPredicate(parent, function(obj)
			return obj:HasTag(tagName)
		end, timeout)
	end

	function Module.waitForDescendantWithAttribute(
		parent: Instance,
		attributeName: string,
		attributeValue: any?,
		timeout: number?
	): any
		assert(typeof(attributeName) == "string", "waitForDescendantWithAttribute: attributeName must be a string")

		return Module.waitForDescendantWithPredicate(parent, function(obj)
			local value = obj:GetAttribute(attributeName)
			if attributeValue ~= nil then
				return value == attributeValue
			else
				return value ~= nil
			end
		end, timeout)
	end

	function Module.waitForDescendant(
		parent: Instance,
		name: string,
		timeout: number?
	): any
		return Module.waitForDescendantWithPredicate(parent, function(instance)
			return instance.Name == name
		end, timeout)
	end

	--[[
		Yields until the <code>PrimaryPart</code> is available for <code>model</code>.
	]]
	function Module.waitForPrimaryPart(
		model: Model,
		timeout: number?
	): BasePart?
		assert(model:IsA("Model"), "Expected model")
		if model.PrimaryPart then
			return model.PrimaryPart
		end
		local signal = model:GetPropertyChangedSignal("PrimaryPart")
		if timeout then
			_game.waitWithTimeout(signal, timeout)
		else
			signal:Wait()
		end
		return model.PrimaryPart
	end
end

@deprecated
-- Deprecated. Use scheduleDestruction instead
function Module.destroy(object: Instance, destroyAfter: number?)
	assert(object and typeof(object) == "Instance", "object is invalid or nil")

	Debris:AddItem(object, destroyAfter or 0)
end

@deprecated
-- Deprecated.
-- Destroys all objects that match the class via :IsA()
-- You can include a predicate to filter instances to be destroyed and include descendants.
function Module.destroyAllOfClass(searchIn: any, class: string, canDestroy: ((instance: any) -> (boolean))?, descendants: boolean?, destroyAfter: number?)
	assert(class and typeof(class) == "string", "class is invalid or nil")
	assert(searchIn and typeof(searchIn) == "Instance", "object is invalid or nil")
	local destroyAfter = destroyAfter or 0

	local children = if descendants then searchIn:GetDescendants() else searchIn:GetChildren()
	for _, object in ipairs(children) do
		if object:IsA(class) then
			if canDestroy and not canDestroy(object) then
				continue
			end

			if destroyAfter == 0 then
				object:Destroy()
			else
				Debris:AddItem(object, destroyAfter)
			end
		end
	end
end

-- LOAD FUNCTIONS --
do
	--[[
		Collects every Model or Folder in pre-order (parent before children).
	]]
	local function collectContainersPreOrder(
		root: Instance,
		out: { any }?
	): { any }
		local out = out or {}
		if root:IsA("Model") or root:IsA("Folder") then
			table.insert(out, root)
			for _, child in ipairs(root:GetChildren()) do
				collectContainersPreOrder(child, out)
			end
		end
		return out
	end

	--[[
		Gradually instantiates your templateRoot and all descendant Models/Folders
		under destinationParent, in top-down order.
	
		<strong>root</strong>: The instance to be gradually loaded.
		<strong>destination</strong>: The desired parent for <strong>root</strong>.
		<strong>instancesPerFrame</strong>: How many models/folders to load per frame for performance control.
	]]
	function Module.loadModelHierarchyGradually(
		rootModel: Instance,
		destinationParent: Instance,
		instancesPerFrame: number
	): Future.Future<>
		assert(
			typeof(instancesPerFrame) == "number"
				and instancesPerFrame > 0,
			"instancesPerFrame must be > 0"
		)
		assert(
			rootModel:IsA("Model") or rootModel:IsA("Folder"),
			"rootModel must be a Model or Folder"
		)

		-- Gather every container (root + descendants) in pre-order
		local containers = collectContainersPreOrder(rootModel)

		-- Remember where each one originally lived
		local originalParentMap: { [Instance]: Instance } = {}
		for _, c in ipairs(containers) do
			originalParentMap[c] = c.Parent
		end

		-- Detach all containers except the root back to their old parent
		-- (this is a ServerStorage or similar, so no network spike here)
		local ghostParent = originalParentMap[rootModel]
		for i = 2, #containers do
			containers[i].Parent = ghostParent
		end

		-- Return a Future that, on Heartbeat, reparents one batch at a time
		return Future.new(function(
			orderedContainers: { Instance },
			parentMap: { [Instance]: Instance },
			rate: number,
			destination: Instance
		)
			-- move the root itself first (now empty) into the new parent
			local root = orderedContainers[1]
			root.Parent = destination

			local index = 2
			while index <= #orderedContainers do
				for _ = 1, rate do
					local container = orderedContainers[index]
					-- put it back under its original parent (which has already moved)
					container.Parent = parentMap[container]
					index += 1
					if index > #orderedContainers then
						break
					end
				end
				RunService.Heartbeat:Wait()
			end
		end, containers, originalParentMap, instancesPerFrame, destinationParent)
	end
end

-- DESTROY FUNCTIONS --
do
	local function collectInstancesPostOrder(instance: Instance): { Instance }
		local result = {}

		local function visit(inst: Instance)
			for _, child in inst:GetChildren() do
				visit(child)
			end
			table.insert(result, inst)
		end

		visit(instance)
		return result
	end

	local function collectContainersPostOrder(root: Instance): { Instance }
		local result: { Instance } = {}

		local function visit(instance: Instance)
			for _, child in instance:GetChildren() do
				visit(child)
			end

			if instance ~= root and (instance:IsA("Model") or instance:IsA("Folder")) then
				table.insert(result, instance)
			end
		end

		visit(root)
		return result
	end

	--[[
		Destroys the root and its descendants starting from the 'leaves' back to the 'root'.
		<strong>instancesPerFrame</strong>: How many instances to destroy per frame for performance control.
	]]
	function Module.destroyHierarchyGradually(root: Instance, instancesPerFrame: number): Future.Future<>
		assert(typeof(instancesPerFrame) == "number" and instancesPerFrame > 0, "instancesPerFrame must be a number greater than 0")
		local instances = collectInstancesPostOrder(root)
		return Future.new(function(instances, instancesPerFrame)
			local index = 1
			while index <= #instances do
				for i = 1, instancesPerFrame do
					local instance = instances[index]
					if instance then
						instance:Destroy()
					end
					index += 1
					if index > #instances then
						break
					end
				end
				RunService.Heartbeat:Wait()
			end
		end, instances, instancesPerFrame)
	end

	--[[
		Destroys all descendants of the root (but not the root itself), starting from the 'leaves' back to the 'root'.
		<strong>instancesPerFrame</strong>: How many instances to destroy per frame for performance control.
	]]
	function Module.destroyDescendantsGradually(root: Instance, instancesPerFrame: number): Future.Future<>
		assert(typeof(instancesPerFrame) == "number" and instancesPerFrame > 0, "instancesPerFrame must be a number greater than 0")
		local instances = collectInstancesPostOrder(root)

		-- Exclude the root itself (last in post-order)
		table.remove(instances, #instances)

		return Future.new(function(instances, instancesPerFrame)
			local index = 1
			while index <= #instances do
				for i = 1, instancesPerFrame do
					local instance = instances[index]
					if instance then
						instance:Destroy()
					end
					index += 1
					if index > #instances then
						break
					end
				end
				RunService.Heartbeat:Wait()
			end
		end, instances, instancesPerFrame)
	end

	--[[
		Destroys all descendant models and folders (excluding the root), starting from the leaves upward.
		Skips destroying individual parts/scripts/etc.
		<strong>instancesPerFrame</strong>: How many models/folders to destroy per frame.
		<strong>shouldDestroy</strong>: Optional predicate to evaluate if the given container (model or folder) should be destroyed.
	]]
	function Module.destroyDescendantModelsGradually(root: Instance, instancesPerFrame: number, shouldDestroy: ( (container: any) -> (boolean) )?): Future.Future<>
		assert(typeof(instancesPerFrame) == "number" and instancesPerFrame > 0, "instancesPerFrame must be a number greater than 0")

		local containers = collectContainersPostOrder(root)
		local shouldDestroy: (any) -> (boolean) = shouldDestroy or function() return true end

		return Future.new(function(instances, instancesPerFrame)
			local index = 1
			while index <= #instances do
				for _ = 1, instancesPerFrame do
					local instance = instances[index]
					if instance and shouldDestroy(instance) then
						instance:Destroy()
					end
					index += 1
					if index > #instances then
						break
					end
				end
				RunService.Heartbeat:Wait()
			end
		end, containers, instancesPerFrame)
	end

	-- Destroys the instance via Debris.
	-- Default delay is 0.
	function Module.scheduleDestruction(
		instance: any,
		destroyAfter: number?
	)
		assert(typeof(instance) == "Instance", "scheduleDestruction: instance must be an Instance")
		local destroyAfter = destroyAfter or 0
		Debris:AddItem(instance, destroyAfter)
	end

	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements with <code>isValid</code>
	-- Default is no limit.
	function Module.destroyAllWithPredicate(
		searchIn: any,
		isValid: (any) -> boolean,
		searchDepth: number?
	)
		assert(typeof(searchIn) == "Instance", "destroyAllWithPredicate: searchIn must be an Instance")
		assert(typeof(isValid) == "function", "destroyAllWithPredicate: isValid must be a function")
		if searchDepth ~= nil then
			assert(
				typeof(searchDepth) == "number" and searchDepth >= 1,
				"destroyAllWithPredicate: searchDepth must be a positive number"
			)
		end

		if not searchDepth then
			for _, obj in ipairs(searchIn:GetDescendants()) do
				if isValid(obj) then
					obj:Destroy()
				end
			end
		elseif searchDepth == 1 then
			for _, child in ipairs(searchIn:GetChildren()) do
				if isValid(child) then
					child:Destroy()
				end
			end
		else
			local function recurse(node: Instance, depth: number)
				for _, child in ipairs(node:GetChildren()) do
					if isValid(child) then
						child:Destroy()
					end
					if depth < searchDepth then
						recurse(child, depth + 1)
					end
				end
			end
			recurse(searchIn, 1)
		end
	end

	-- Uses :IsA()!
	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements of <code>className</code>
	-- Default is no limit.
	function Module.destroyAllFromClass(
		className: string,
		searchIn: Instance,
		searchDepth: number?
	)
		assert(typeof(className) == "string", "destroyAllFromClass: className must be a string")
		Module.destroyAllWithPredicate(
			searchIn,
			function(obj) return obj:IsA(className) end,
			searchDepth
		)
	end

	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements with <code>tagName</code>
	-- Default is no limit.
	function Module.destroyAllWithTag(
		tagName: string,
		searchIn: Instance,
		searchDepth: number?
	)
		assert(typeof(tagName) == "string", "destroyAllWithTag: tagName must be a string")
		Module.destroyAllWithPredicate(
			searchIn,
			function(obj) return obj:HasTag(tagName) end,
			searchDepth
		)
	end

	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements with <code>attribute</code>
	-- Default is no limit.
	-- <strong>attributeValue</strong>: Optionally match a value.
	function Module.destroyAllWithAttribute(
		attribute: string,
		searchIn: Instance,
		attributeValue: any?,
		searchDepth: number?
	)
		assert(typeof(attribute) == "string", "destroyAllWithAttribute: attribute must be a string")
		Module.destroyAllWithPredicate(
			searchIn,
			function(obj)
				local val = obj:GetAttribute(attribute)
				if attributeValue ~= nil then
					return val == attributeValue
				else
					return val ~= nil
				end
			end,
			searchDepth
		)
	end
end

-- ANCESTRY FIND FUNCTIONS --
do
	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements.
	-- Default is no limit.
	function Module.getAncestors(
		instance: any,
		searchDepth: number?
	): { any }
		assert(typeof(instance) == "Instance", "getAncestors: instance must be an Instance")
		if searchDepth ~= nil then
			assert(
				typeof(searchDepth) == "number" and searchDepth >= 1,
				"getAncestors: searchDepth must be a positive number"
			)
		end

		local ancestors = {}
		local depth = 0
		local current = instance.Parent

		while current and (not searchDepth or depth < searchDepth) do
			table.insert(ancestors, current)
			current = current.Parent
			depth += 1
		end

		return ancestors
	end

	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements with <code>isValid()</code>
	-- Default is no limit.
	function Module.findAllAncestorsWithPredicate(
		instance: any,
		isValid: (any) -> boolean,
		searchDepth: number?
	): { any }
		assert(typeof(isValid) == "function", "findAllAncestorsWithPredicate: isValid must be a function")
		local results   = {}
		for _, anc in ipairs(Module.getAncestors(instance, searchDepth)) do
			if isValid(anc) then
				table.insert(results, anc)
			end
		end
		return results
	end

	---<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for an element with <code>isValid()</code>
	-- Default is no limit.
	function Module.findFirstAncestorWithPredicate(
		instance: any,
		isValid: (any) -> boolean,
		searchDepth: number?
	): any
		assert(typeof(isValid) == "function", "findFirstAncestorWithPredicate: isValid must be a function")
		for _, anc in ipairs(Module.getAncestors(instance, searchDepth)) do
			if isValid(anc) then
				return anc
			end
		end
		return nil
	end

	-- Uses :IsA(), not .ClassName!
	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements with <code>className</code>
	-- Default is no limit.
	function Module.findAllAncestorsWhichAre(
		instance: any,
		className: string,
		searchDepth: number?
	): { any }
		assert(typeof(className) == "string", "findAllAncestorsWhichAre: className must be a string")
		return Module.findAllAncestorsWithPredicate(
			instance,
			function(obj)
				return obj:IsA(className)
			end,
			searchDepth
		)
	end

	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements with <code>tagName</code>
	-- Default is no limit.
	function Module.findAllAncestorsWithTag(
		instance: any,
		tagName: string,
		searchDepth: number?
	): { any }
		assert(typeof(tagName) == "string", "findAllAncestorsWithTag: tagName must be a string")
		return Module.findAllAncestorsWithPredicate(
			instance,
			function(obj)
				return obj:HasTag(tagName)
			end,
			searchDepth
		)
	end

	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for element with <code>tagName</code>
	-- Default is no limit.
	function Module.findFirstAncestorWithTag(
		instance: any,
		tagName: string,
		searchDepth: number?
	): any
		assert(typeof(tagName) == "string", "findFirstAncestorWithTag: tagName must be a string")
		return Module.findFirstAncestorWithPredicate(
			instance,
			function(obj) return obj:HasTag(tagName) end,
			searchDepth
		)
	end

	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for elements with <code>attribute</code>
	-- Default is no limit.
	-- <strong>attributeValue</strong>: Optionally match a value.
	function Module.findAllAncestorsWithAttribute(
		instance: any,
		attribute: string,
		attributeValue: any?,
		searchDepth: number?
	): { any }
		assert(typeof(attribute) == "string", "findAllAncestorsWithAttribute: attribute must be a string")
		return Module.findAllAncestorsWithPredicate(
			instance,
			function(obj)
				local val = obj:GetAttribute(attribute)
				if attributeValue ~= nil then
					return val == attributeValue
				else
					return val ~= nil
				end
			end,
			searchDepth
		)
	end

	--<strong>searchDepth</strong>: Optional argument that defines how far to recursively search for an element with <code>attribute</code>
	-- Default is no limit.
	-- <strong>attributeValue</strong>: Optionally match a value.
	function Module.findFirstAncestorWithAttribute(
		instance: any,
		attribute: string,
		attributeValue: any?,
		searchDepth: number?
	): any?
		assert(typeof(attribute) == "string", "findFirstAncestorWithAttribute: attribute must be a string")
		return Module.findFirstAncestorWithPredicate(
			instance,
			function(obj)
				local val = obj:GetAttribute(attribute)
				if attributeValue ~= nil then
					return val == attributeValue
				else
					return val ~= nil
				end
			end,
			searchDepth
		)
	end
end

function Module.getNearestPartFromArray(parts: { BasePart }, comparePosition: Vector3): BasePart
	local lastDist = math.huge
	local closestPart = nil
	for _, part in ipairs(parts) do
		local distance = (part.Position - comparePosition).Magnitude
		if distance < lastDist then
			lastDist = distance
			closestPart = part
		end
	end
	return closestPart
end

function Module.snapToRelative(modelToSnap: Model, snapAnchor: BasePart, targetPosition: Vector3)
	assert(modelToSnap and typeof(modelToSnap) == "Instance" and modelToSnap.PrimaryPart, "Model is nil or doesn't have PrimaryPart")

	local offset = snapAnchor.Position - modelToSnap.PrimaryPart.Position
	coroutine.wrap(function()
		repeat task.wait()
			modelToSnap:PivotTo(CFrame.new(targetPosition - offset))
		until (snapAnchor.Position - targetPosition).Magnitude < 1
	end)()

	return targetPosition - offset
end

local activeTweens = {}
function Module.tweenModelScale(model: Model, duration: number, targetScale: number, easingStyle: Enum.EasingStyle?, easingDirection: Enum.EasingDirection?)
	local initialScale = model:GetScale() -- Get the model's original scale
	local timeElapsed = 0

	if activeTweens[model] then
		activeTweens[model]:Disconnect()
	end

	activeTweens[model] = RunService.RenderStepped:Connect(function(dt)
		timeElapsed += dt
		local alpha = TweenService:GetValue(timeElapsed / duration, easingStyle or Enum.EasingStyle.Linear, easingDirection or Enum.EasingDirection.In)
		local currentScale = initialScale + (targetScale - initialScale) * alpha

		-- Ensure the scale is a positive non-zero value
		if currentScale <= 0 then
			currentScale = 0.001
		end

		model:ScaleTo(currentScale)

		if alpha >= 1 then
			activeTweens[model]:Disconnect()
			activeTweens[model] = nil
		end
	end)
end

function Module.setModelCollisionGroup<T>(model: T, collisionGroup: string): T
	assert(typeof(model) == "Instance" and model:IsA("Model"), "Expected model.")
	if not PhysicsService:IsCollisionGroupRegistered(collisionGroup) then
		error(`CollisionGroup: {collisionGroup} is not registered!`)
	end

	for _, desc in model:GetDescendants() do
		if desc:IsA("BasePart") then
			desc.CollisionGroup = collisionGroup
		end
	end

	return model
end

function Module.createCollisionGroup(name: string, nonCollidableGroups: {string})
	if PhysicsService:IsCollisionGroupRegistered(name) then
		warn(`Collision group with name {name} already exists.`)
		return
	end

	local newCollisionGroup = PhysicsService:RegisterCollisionGroup(name)
	for i, otherGroupName in ipairs(nonCollidableGroups) do
		if not PhysicsService:IsCollisionGroupRegistered(otherGroupName) then
			error(`CollisionGroup: {otherGroupName} is not registered!`)
		end

		if not PhysicsService:CollisionGroupsAreCollidable(name, otherGroupName) then
			PhysicsService:CollisionGroupSetCollidable(name, otherGroupName, false)
		end
	end
end

-- <strong>YIELDS</strong>
-- This yields until there is an attribute
function Module.waitForAttributes(logger: Logger.LoggerType, attributes: {string}, parent: Instance)
	for _, attrName: string in ipairs(attributes) do
		if parent:GetAttribute(attrName) == nil then
			logger:print(`{script.Name} is waiting for attribute {attrName} to initialize on {parent.ClassName} {parent.Name}`)
			parent:GetAttributeChangedSignal(attrName):Wait()
			logger:print(`{attrName} has been initialized on {parent.ClassName} {parent.Name}`)
		end
	end
end

function Module.weldToPrimaryPart(part1: BasePart, model: Model): WeldConstraint
	local weld = Instance.new("WeldConstraint")
	weld.Parent = model.PrimaryPart
	weld.Part0 = model.PrimaryPart
	weld.Part1 = part1
	return weld
end

-- If no parent, automatically parents to part0
function Module.weld(part0: BasePart, part1: BasePart, parent: Instance?): WeldConstraint
	local weld = Instance.new("WeldConstraint")
	weld.Part0 = part0
	weld.Part1 = part1
	weld.Parent = parent or part0
	return weld
end

-- Copies attributes from one instance to another with options on the copying behavior.
-- Default mode is reconcile.
-- SYNC: Copies all attributes and pastes them on <code>to</code>. Overrides values and removes any attributes not found on <code>from</code>.
-- RECONCILE: Copies all attributes and pastes them on <code>to</code>. Skips same-name attributes and does not delete attributes.
-- OVERRIDE: Copies all attributes and pastes them on <code>to</code>. Can override values but does not delete attributes.
-- REPLACE: Copies only same name attributes on <code>to</code> and overrides them. Does not add or delete attributes.
function Module.copyAttributes(from: Instance, to: Instance, mode: ("SYNC" | "RECONCILE" | "OVERRIDE" | "REPLACE")?)
	local mode = mode or "RECONCILE"

	local attributesToCopy = from:GetAttributes()
	if mode == "SYNC" then
		for name, _ in to:GetAttributes() do
			to:SetAttribute(name, attributesToCopy[name] or nil)
		end
		for name, value in attributesToCopy do
			to:SetAttribute(name, value)
		end
	elseif mode == "RECONCILE" then
		for name, value in attributesToCopy do
			if to:GetAttribute(name) then
				continue
			end
			to:SetAttribute(name, value)
		end
	elseif mode == "OVERRIDE" then
		for name, value in attributesToCopy do
			to:SetAttribute(name, value)
		end
	elseif mode == "REPLACE" then
		for name, value in attributesToCopy do
			if not to:GetAttribute(name) then
				continue
			end
			to:SetAttribute(name, value)
		end
	end
end

return Module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004320</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX7866851F7A694FB7A5FBD56EBFA0266A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009633</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_interface</string>
							<string name="ScriptGuid">{2093D5B6-9086-4F19-B412-896C1CA153B6}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Module = {}

local _input = require("./_input")
local DebugDraw = require(script.Parent._debugDraw)
local Trove = require("../ModuleUtils/_Trove")
local Future = require("../ModuleUtils/_Future")
local observeProperty = require("./_observers/_observeProperty")

local camera = workspace.CurrentCamera

local function removeTags(str: string): string
	-- replace line break tags (otherwise grapheme loop will miss those linebreak characters)
	str = str:gsub("<br%s*/>", "\n")
	return (str:gsub("<[^<>]->", ""))
end

--[[
	Grabs the left-hand canvas position of <code>object</code>.
	The parent must be a scrolling frame.
]]
function Module.getCanvasPosition(object: GuiObject): Vector2
	local scrollingFrame = object.Parent
	assert(typeof(scrollingFrame) == "Instance" and scrollingFrame:IsA("ScrollingFrame"), "invalid parent")
	return scrollingFrame.CanvasPosition + object.AbsolutePosition - scrollingFrame.AbsolutePosition
end

--[[
	Same as <code>getCanvasPosition()</code> but places the position at the center of the scrolling frame.
]]
function Module.getCentralCanvasPosition(object: GuiObject): Vector2
	local scrollingFrame = object.Parent
	assert(typeof(scrollingFrame) == "Instance" and scrollingFrame:IsA("ScrollingFrame"), "invalid parent")
	local objectCanvasPosition = scrollingFrame.CanvasPosition + object.AbsolutePosition - scrollingFrame.AbsolutePosition

	local scrollingFrameHalfSize = scrollingFrame.AbsoluteSize / 2
	local objectHalfSize = object.AbsoluteSize / 2

	return objectCanvasPosition - scrollingFrameHalfSize + objectHalfSize
end

-- Returns a boolean if the given <code>object</code> and all of its ancestors have <code>Visible</code> or <code>Enabled</code> set to true.
function Module.trulyVisible(object: GuiObject): boolean
	debug.profilebegin("Interface.trulyVisible")
	local parentGui = object:FindFirstAncestorWhichIsA("LayerCollector")

	if parentGui and parentGui.Enabled == false then
		return false
	end
	
	local currentCheck: Instance? = object.Parent
	while currentCheck ~= parentGui and currentCheck ~= nil do
		if currentCheck:IsA("GuiObject") and not currentCheck.Visible then
			return false
		end

		currentCheck = currentCheck.Parent
	end

	debug.profileend()
	return true
end

-- Client-side only!
-- <strong>includeInteractable</strong>: Should GuiObjects that have Interactable set to true be included?
-- WARNING: Setting <strong>includeInteractable</strong> to true will increase the time it takes to execute this function!
function Module.getGuiObjectsAtPosition(position: Vector2, includeInteractable: boolean?): { GuiObject }
	assert(RunService:IsClient(), "This function can only be called from the client!")
	debug.profilebegin("Interface.getGuiObjectsAtPosition()")
	local UserInputService = game:GetService("UserInputService")
	local player = game:GetService("Players").LocalPlayer

	local toggled = {}
	if includeInteractable then
		debug.profilebegin("set Interactable = false")
		for _, element in player.PlayerGui:GetDescendants() do
			if not element:IsA("GuiObject") then
				continue
			end
			if element.Interactable then
				element.Interactable = false
				table.insert(toggled, element)
			end
		end
		debug.profileend()
	end

	local result = player.PlayerGui:GetGuiObjectsAtPosition(position.X, position.Y)

	for _, element in toggled do
		element.Interactable = true
	end
	debug.profileend()
	return result
end

-- Client-side only!
function Module.isGuiObjectAtMousePosition(guiObject: GuiObject): boolean
	assert(RunService:IsClient(), "Only client can call this function!")
	debug.profilebegin("Interface.isGuiObjectAtMousePosition()")
	local UserInputService = game:GetService("UserInputService")
	local GuiService = game:GetService("GuiService")
	local player = game:GetService("Players").LocalPlayer
	local mouseLocation = UserInputService:GetMouseLocation()

	local updatedInteractable = false
	if guiObject.Interactable then
		guiObject.Interactable = false
		updatedInteractable = true
	end

	local offset: Vector2 = GuiService:GetGuiInset()
	local result = player.PlayerGui:GetGuiObjectsAtPosition(mouseLocation.X - offset.X, mouseLocation.Y - offset.Y)
	local found = false
	for _, obj in result do
		if obj == guiObject then
			found = true
			break
		end
	end

	if updatedInteractable then
		guiObject.Interactable = true
	end

	debug.profileend()
	return found
end

--[[
	Generates a <code>UDim2</code> position that is perpendicular to <code>pointA</code> and <code>pointB</code>.
	This assumes all positions are based from the entire screen size.
	<strong>alpha</strong>: Lerped position between pointA and pointB where offsetScale will be applied.
	<strong>offsetScale</strong>: Perpendicular offset multiplied against the pixel distance between pointA and pointB. (Negative values flip offset direction)
]]
function Module.getPerpendicularOffsetPosition(pointA: UDim2, pointB: UDim2, alpha: number, offsetScale: number, screenSize: Vector2): UDim2
	-- Due to pixel distances on scale being disproportionate, we must convert scale into pixels!
	local pointA = Vector2.new(
		pointA.X.Scale * screenSize.X + pointA.X.Offset,
		pointA.Y.Scale * screenSize.Y + pointA.Y.Offset
	)
	local pointB = Vector2.new(
		pointB.X.Scale * screenSize.X + pointB.X.Offset,
		pointB.Y.Scale * screenSize.Y + pointB.Y.Offset
	)

	local offsetOrigin = pointA:Lerp(pointB, alpha)

	local direction = pointB - pointA
	local perpendicular = Vector2.new(-direction.Y, direction.X).Unit

	local offsetPixels = perpendicular * (direction.Magnitude * offsetScale)

	local resultPixels = offsetOrigin + offsetPixels

	return UDim2.new(0, resultPixels.X, 0, resultPixels.Y), direction.Magnitude
end

--[[
	Returns the pixel unit direction between pointA and pointB and the original magnitude.
]]
function Module.getDirection(pointA: UDim2, pointB: UDim2, screenSize: Vector2): (Vector2, number)
	-- Due to pixel distances on scale being disproportionate, we must convert scale into pixels!
	local pointAPixels = Vector2.new(
		pointA.X.Scale * screenSize.X + pointA.X.Offset,
		pointA.Y.Scale * screenSize.Y + pointA.Y.Offset
	)
	local pointBPixels = Vector2.new(
		pointB.X.Scale * screenSize.X + pointB.X.Offset,
		pointB.Y.Scale * screenSize.Y + pointB.Y.Offset
	)
	local direction = (pointBPixels - pointAPixels)
	return direction.Unit, direction.Magnitude
end

--[[
	Generates a bezier curve Path2D that can be used for UI tweens.
	<strong>alpha</strong>: Lerped position between pointA and pointB where offsetScale will be applied.
	<strong>offsetScale</strong>: Perpendicular offset multiplied against the pixel distance between pointA and pointB. (Negative values flip offset direction)
	<strong>tangentScale</strong>: Tangent size multiplied against the pixel distance between pointA and pointB. 0.5 would be a tangent half the total distance.
]]
function Module.createCurvedPath2D(startPoint: UDim2, endPoint: UDim2, alpha: number, offsetScale: number, tangentScale: number): Path2D
	local screenSize = camera.ViewportSize
	local path = Instance.new("Path2D")
	local points: { Path2DControlPoint } = {}
	points[1] = Path2DControlPoint.new(startPoint)
	points[3] = Path2DControlPoint.new(endPoint)
	local midPointPosition = Module.getPerpendicularOffsetPosition(points[1].Position, points[3].Position, alpha, offsetScale, screenSize)
	points[2] = Path2DControlPoint.new(midPointPosition)
	
	local tangent, magnitude = Module.getDirection(startPoint, endPoint, screenSize)
	local tangentScale = (magnitude / 2) * tangentScale
	points[2].LeftTangent = UDim2.fromOffset(-tangent.X * tangentScale, -tangent.Y * tangentScale)
	points[2].RightTangent = UDim2.fromOffset(tangent.X * tangentScale, tangent.Y * tangentScale)
	path:SetControlPoints(points)
	path.Visible = false
	return path
end

-- Returns a corrected <code>UDim2</code> position for <code>uiElement</code> that matches the <code>screenPosition</code>.
-- This function accounts for the <code>AbsolutePosition</code> of uiElement's parent, enforces screen boundaries, and includes GUI inset if <code>IgnoreGuiInset</code> is disabled on the <code>gui</code>.
-- <strong>offset</strong>: Offset should be the difference between the <code>AbsolutePosition</code> of <code>uiElement</code> and <code>screenPosition</code> to stop snapping to the element's <code>AnchorPoint</code>.
function Module.getRelativePositionFromScreenPosition(screenPosition: Vector2, uiElement: GuiObject, gui: ScreenGui, offset: Vector2?): UDim2
	-- Retrieve screen size and GUI inset
	local offset = offset or Vector2.zero
	do
		-- Provided offset helps stop snapping to anchor point
		local absoluteSize = uiElement.AbsoluteSize
		local anchorPoint = uiElement.AnchorPoint
		local offsetX = absoluteSize.X * anchorPoint.X
		local offsetY = absoluteSize.Y * anchorPoint.Y
		local realOffset = offset + Vector2.new(offsetX, offsetY)
		screenPosition += realOffset
	end
	
	local parentFrame = uiElement.Parent :: GuiObject
	local viewportSize = camera.ViewportSize
	local guiInsetY = 0
	if not gui.IgnoreGuiInset then
		guiInsetY = game:GetService("GuiService"):GetGuiInset().Y
	end

	-- Calculate base position from the screen position
	local posX, posY = screenPosition.X, screenPosition.Y
	local parentAbsPos = parentFrame.AbsolutePosition
	local uiElementSize = uiElement.AbsoluteSize

	-- Offset to ensure position relative to parent frame
	local relativeX = posX - parentAbsPos.X
	local relativeY = posY - parentAbsPos.Y

	-- Calculate width and height offsets based on anchor point
	local widthOffset = uiElementSize.X * uiElement.AnchorPoint.X
	local heightOffset = uiElementSize.Y * uiElement.AnchorPoint.Y

	-- Adjust relative position to match the intended anchor point
	local adjustedX = relativeX
	local adjustedY = relativeY

	-- Boundaries check to keep UI within screen limits, accounting for anchor point
	local minX = 0 - parentAbsPos.X + widthOffset
	local minY = 0 - parentAbsPos.Y + heightOffset
	local maxX = viewportSize.X - parentAbsPos.X - (uiElementSize.X - widthOffset)
	local maxY = viewportSize.Y - parentAbsPos.Y - (uiElementSize.Y - heightOffset) - guiInsetY

	-- Clamp adjusted position to be within screen boundaries
	local finalX = math.clamp(adjustedX, minX, maxX)
	local finalY = math.clamp(adjustedY, minY, maxY)

	-- Return the calculated position as a UDim2 offset
	return UDim2.fromOffset(finalX, finalY)
end

function Module.getScreenSize()
	assert(camera, "Camera does not exist")

	return Vector2.new(camera.ViewportSize.X, camera.ViewportSize.Y)
end

function Module.offsetToScale(offset: Vector2, proportions: Vector2)
	assert(typeof(offset) == "Vector2", "offset is invalid or nil")
	assert(typeof(proportions) == "Vector2", "proportions is invalid or nil")

	local X, Y = offset.X, offset.Y
	X, Y = (X / proportions.X), (Y / proportions.Y)

	return Vector2.new(X, Y)
end

function Module.scaleToOffset(scale: Vector2, proportions: Vector2)
	assert(typeof(scale) == "Vector2", "scale is invalid or nil")
	assert(typeof(proportions) == "Vector2", "proportions is invalid or nil")

	local X, Y = scale.X, scale.Y
	X, Y = (X * proportions.X), (Y * proportions.Y)

	return Vector2.new(X, Y)
end

function Module.center(object: GuiObject)
	object.AnchorPoint = Vector2.new(0.5, 0.5)
	object.Position = UDim2.new(0.5, 0, 0.5, 0)
end

function Module.vec2UDim(vector2: Vector2, inScale: boolean)
	assert(typeof(vector2) == "Vector2", "vector2 is invalid or nil")

	return inScale and UDim2.fromScale(vector2.X, vector2.Y) or UDim2.fromOffset(vector2.X, vector2.Y)
end

-- Converts the UDim2 to scale based on the screen size.
-- <strong>screenSize</strong>: Overrides the screenSize
function Module.scaleUDim(udim: UDim2, screenSize: Vector2?)
	assert(typeof(udim) == "UDim2", "UDIm is invalid or nil")

	local offsetVector = Vector2.new(udim.X.Offset, udim.Y.Offset)
	local screenSize = screenSize or Module.getScreenSize()

	local resultVector = Module.offsetToScale(offsetVector, screenSize)

	return Module.vec2UDim(resultVector, true)
end

-- Converts the UDim2 to offset based on the screen size.
-- <strong>screenSize</strong>: Overrides the screenSize
function Module.offsetUDim(udim: UDim2, screenSize: Vector2?)
	assert(typeof(udim) == "UDim2", "UDIm is invalid or nil")

	local scaleVector = Vector2.new(udim.X.Scale, udim.Y.Scale)
	local screenSize = screenSize or Module.getScreenSize()

	local resultVector = Module.scaleToOffset(scaleVector, screenSize)

	return Module.vec2UDim(resultVector, false)
end

-- Client-side only!
-- Uses CoreGui to send a notification.
function Module.notify(title: string, text: string, duration: number, icon: string)
	assert(RunService:IsClient(), "notify() is client-only!")
	game:GetService("StarterGui"):SetCore("SendNotification",{
		Title = title or "No title specified",
		Text = text or "No text specified",
		Icon = icon,
		Duration = duration or 5,
	})
end

--[[
	Client-only!
	Fades in a black frame that hides the viewport.
	Returns a function that can be called to fade the frame back out & cleanup.
	If the cleanup is not given a TweenInfo, it instantly destroys the frame.
	<strong>displayOrder</strong>: Optionally define the rendering order for the Gui. Default is -1.
]]
function Module.fadeInBlack(tweenInfo: TweenInfo, displayOrder: number?): (Tween, (tweenInfo: TweenInfo?) -> (Tween?)) 
	assert(RunService:IsClient(), "fadeInBlack() is client-only!")
	local gui = Instance.new("ScreenGui")
	gui.Name = "__FADE_GUI__"
	gui.DisplayOrder = displayOrder or -1
	gui.ResetOnSpawn = false
	gui.IgnoreGuiInset = true

	local blackFrame = Instance.new("Frame")
	blackFrame.Size = UDim2.fromScale(1, 1)
	blackFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	blackFrame.Transparency = 1
	blackFrame.Parent = gui

	gui.Parent = Players.LocalPlayer.PlayerGui
	gui = gui
	
	local tween = TweenService:Create(blackFrame, tweenInfo, { Transparency = 0 })
	tween:Play()
	
	return tween, function(tweenInfo: TweenInfo?)
		local tween
		if tweenInfo then
			tween = TweenService:Create(blackFrame, tweenInfo, { Transparency = 1 })
			tween.Completed:Once(function()
				gui:Destroy()
			end)
			tween:Play()
		else
			gui:Destroy()
		end
		return tween
	end
end

-- Applies a black, semi-transparent frame to the obj to make it look disabled.
function Module.applyDisabledOverlay(obj: GuiObject): Frame
	local frame = Instance.new("Frame")
	frame.BackgroundColor3 = Color3.new()
	frame.BackgroundTransparency = 0.5
	frame.Size = UDim2.fromScale(1, 1)
	frame.Name = "_disabledOverlay"
	frame.Parent = obj
	return frame
end

-- Looks for the frame created by applyDisabledOverlay() and destroys it.
function Module.clearDisabledOverlay(obj: GuiObject)
	local frame = obj:FindFirstChild("_disabledOverlay")
	if frame then
		frame:Destroy()
	end
end

local defaultTime = 0.25
@deprecated
function Module.typeAnimation(textLabel: TextLabel, text: string?, timeBtwLetters: number?, yield: boolean?)
	assert(typeof(textLabel) == "Instance" and textLabel:IsA("TextLabel"), "Missing TextLabel")
	
	if not timeBtwLetters then
		timeBtwLetters = defaultTime
	end
	
	yield = if yield == nil then true else yield
	textLabel.MaxVisibleGraphemes = 0
	textLabel.Text = text or textLabel.Text
	
	if yield then
		for i = 0, string.len(textLabel.Text), 1 do
			textLabel.MaxVisibleGraphemes = i
			task.wait(timeBtwLetters)
		end
	else
		task.spawn(function()
			for i = 0, string.len(textLabel.Text), 1 do
				textLabel.MaxVisibleGraphemes = i
				task.wait(timeBtwLetters)
			end
		end)
	end
end

function Module.animateText(textLabel: TextLabel, onNewGrapheme: ( (TextLabel) -> () )?, text: string?, interval: number?): Future.Future<>
	text = text or textLabel.Text
	interval = interval or 0.025
	
	textLabel.RichText = true
	textLabel.Text = text :: string
	textLabel.MaxVisibleGraphemes = 0

	-- count graphemes (approximated by utf8 codepoints)
	local total = 0
	for _ in utf8.graphemes(removeTags(text :: string)) do
		total += 1
	end
	
	return Future.new(function()
		for i = 1, total do
			textLabel.MaxVisibleGraphemes = i
			if onNewGrapheme then
				task.spawn(onNewGrapheme, textLabel)
			end
			task.wait(interval)
		end
	end)
end

--[[
	Creates a outline
]]
function Module.outlineGuiObject(guiObject: GuiObject, highlightTweenInfo: TweenInfo?, strokeProperties: {[string]: any}?): Frame
	local highLightFrame = Instance.new("Frame")
	highLightFrame.Parent = guiObject
	highLightFrame.Size = UDim2.fromScale(1,1)
	highLightFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	highLightFrame.Position = UDim2.fromScale(0.5, 0.5)
	highLightFrame.BackgroundTransparency = 1
	local uiStroke = Instance.new("UIStroke") :: any
	uiStroke.Parent = highLightFrame
	uiStroke.Thickness = 5
	uiStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	uiStroke.LineJoinMode = Enum.LineJoinMode.Round
	uiStroke.Color = Color3.new(0.0666667, 1, 0.486275)
	
	if strokeProperties then
		for property, value in pairs(strokeProperties) do
			if not uiStroke[property] then
				continue
			end
			uiStroke[property] = value
		end
	end
	
	highlightTweenInfo = highlightTweenInfo or TweenInfo.new(.3, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, -1, true)
	
	local tween = TweenService:Create(highLightFrame, highlightTweenInfo, {Size = UDim2.new(1, 10, 1, 10)})
	tween:Play()

	highLightFrame.ZIndex = guiObject.ZIndex + 1
	return highLightFrame
end

--[[
	Focuses the <code>guiObject</code> by using a <code>UIStroke</code> and obscuring other UI elements.
	This can only be performed on UI elements within a <code>ScreenGui</code>.
	Returns a cleanup function that can optionally fade out the focus and a tween (if <code>tweenInfo</code> is provided).
	<strong>tweenInfo</strong>: Provide a TweenInfo to fade in the focus.
	<strong>displayOrder</strong>: Optionally set for the gui containing the stroke. Default is 100.
	<strong>color</strong>: Default color is black.
	<strong>transparency</strong>: Default is 0.25.
]]
function Module.focusGuiObject(guiObject: GuiObject, tweenInfo: TweenInfo?, displayOrder: number?, color: Color3?, transparency: number?): ( (tweenInfo: TweenInfo?) -> ( Tween? ), Tween? )
	assert(guiObject:FindFirstAncestorWhichIsA("ScreenGui"), "guiObject must be a descendant of a ScreenGui")
	local trove = Trove.new()
	local stroke = Instance.new("UIStroke")
	stroke.Name = "FocusStroke"
	stroke.Transparency = 1
	stroke.Color = color or Color3.new(0, 0, 0)
	stroke.Thickness = 20_000
	trove:Add(stroke)
	
	local gui = Instance.new("ScreenGui")
	gui.Name = "_FocusStrokeGui"
	gui.DisplayOrder = displayOrder or 100
	gui.ScreenInsets = Enum.ScreenInsets.CoreUISafeInsets
	trove:Add(gui)
	
	local guiObjectZone = Instance.new("Frame")
	guiObjectZone.Transparency = 1
	trove:Add(observeProperty(guiObject, "AbsolutePosition", function(absolutePosition: Vector2)
		guiObjectZone.Position = UDim2.fromOffset(absolutePosition.X, absolutePosition.Y)
		return
	end))
	trove:Add(observeProperty(guiObject, "AbsoluteSize", function(absoluteSize: Vector2)
		guiObjectZone.Size = UDim2.fromOffset(absoluteSize.X, absoluteSize.Y)
		return
	end))
	trove:Add(guiObjectZone)
	
	local tween
	if tweenInfo then
		tween = TweenService:Create(stroke, tweenInfo, { Transparency = transparency or 0.25 })
		tween:Play()
	else
		stroke.Transparency = transparency or 0.25
	end

	stroke.Parent = guiObjectZone
	guiObjectZone.Parent = gui
	gui.Parent = Players.LocalPlayer.PlayerGui

	return function(tweenInfo: TweenInfo?)
		local tween
		if tweenInfo then
			tween = TweenService:Create(stroke, tweenInfo, { Transparency = 1 })
			tween:Play()
			tween.Completed:Once(function()
				trove:Clean()
			end)
		else
			trove:Clean()
		end
		return tween
	end, tween
end

@deprecated
-- Grabs a string that represents the keycode with some shortened strings for specific strings.
-- This is an artistic preference.
function Module.getStringForKeyCode(keycode: Enum.KeyCode): string
	return _input.getStringForKeyCode(keycode)
end

@deprecated
-- Returns a string image id for the keycode.
function Module.getImageForKeyCode(keycode: Enum.KeyCode): string?
	return _input.getImageForKeyCode(keycode)
end

return Module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004321</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFC7597E4AC2D464F82C1661931225EB4">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009634</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_character</string>
							<string name="ScriptGuid">{E08DF94F-F62B-4F2B-A8C6-31FA3EF0925C}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
local Vector = require(script.Parent._vector)
local Module = {}
local Players = game:GetService("Players")

-- Relative move direction tells you if the humanoid is moving left/right/forward/backward no matter
-- what direction they're moving in global space
function Module.getRelativeHumanoidMoveDirection(humanoid: Humanoid)
	local rootPart = humanoid.RootPart :: BasePart
	if not rootPart then
		warn("Humanoid has no root part")
		return Vector3.new()
	end
	return rootPart.CFrame:VectorToObjectSpace(humanoid.MoveDirection)
end

-- Returns a boolean if the humanoid can jump by normal means.
-- The humanoid must be within the valid humanoid states and the <code>Jumping</code> state must be enabled.
function Module.canJump(humanoid: Humanoid): boolean
	local myState = humanoid:GetState()
	if
		(myState == Enum.HumanoidStateType.Running
		or myState == Enum.HumanoidStateType.Swimming
		or myState == Enum.HumanoidStateType.Seated
		or myState == Enum.HumanoidStateType.Climbing)
		and humanoid:GetStateEnabled(Enum.HumanoidStateType.Jumping)
	then
		return true
	end
	return false
end

function Module.isHumanoidMoving(humanoid: Humanoid): (boolean, Vector3)
	local isMoving = humanoid.MoveDirection.Magnitude > 0
	return isMoving, humanoid.MoveDirection
end

function Module.isHumanoidDead(humanoid: Humanoid): boolean
	if humanoid:GetState() == Enum.HumanoidStateType.Dead or humanoid.Health <= 0 then
		return true
	end
	return false
end

function Module.onGround(humanoid: Humanoid): (boolean, Enum.Material)
	local onGround = humanoid.FloorMaterial ~= Enum.Material.Air
	return onGround, humanoid.FloorMaterial
end

function Module.getCharacterFromDescendant(descendant: Instance): Model?
	local currentInstance = descendant.Parent

	while currentInstance do
		if currentInstance:IsA("Model") and currentInstance:FindFirstChildWhichIsA("Humanoid") then
			return currentInstance
		end

		currentInstance = currentInstance.Parent
	end

	return nil
end

function Module.getRigAnimator(rig: Instance): Animator?
	assert(rig, "Specified rig does not exist")

	local animationReplica = rig:FindFirstChildWhichIsA("Humanoid") or rig:FindFirstChildWhichIsA("AnimationReplica")
	if animationReplica then
		local animator = animationReplica:FindFirstChildWhichIsA("Animator")
		if animator then
			return animator
		end
	end
	return nil
end

function Module.createRigAnimator(rig: Instance): Animator
	assert(rig, "Specified rig does not exist")

	local animationReplica = rig:FindFirstChildWhichIsA("Humanoid") or rig:FindFirstChildWhichIsA("AnimationReplica")
	if not animationReplica then
		animationReplica = Instance.new("AnimationReplica")
		animationReplica.Parent = rig
	end

	local animator = animationReplica:FindFirstChildWhichIsA("Animator")
	if not animator then
		animator = Instance.new("Animator")
		animator.Parent = animationReplica
	end

	return animator
end

function Module.loadPlay(animator: Animator, animation: number | string | Animation, ...: any): AnimationTrack
	assert(animator and typeof(animator) == "Instance", "animator is invalid or nil")
	assert(animation, "animation is invalid or nil")

	local animationResult
	if typeof(animation) == "number" then
		animationResult = Instance.new("Animation")
		animationResult.AnimationId = "rbxassetid://" ..animation
	elseif typeof(animation) == "string" then
		animationResult = Instance.new("Animation")
		animationResult.AnimationId =  animation
	elseif typeof(animation) == "Instance" then
		animationResult = animation
	end

	local loadedAnimation = animator:LoadAnimation(animationResult)
	loadedAnimation:Play(...)

	return loadedAnimation
end

function Module.load(animator: Animator, animation: number | string | Animation)
	assert(animator and typeof(animator) == "Instance", "animator is invalid or nil")
	assert(animation, "animation is invalid or nil")

	local animationResult
	if typeof(animation) == "number" then
		animationResult = Instance.new("Animation")
		animationResult.AnimationId = "rbxassetid://" ..animation
	elseif typeof(animation) == "string" then
		animationResult = Instance.new("Animation")
		animationResult.AnimationId =  animation
	elseif typeof(animation) == "Instance" then
		animationResult = animation
	end

	local loadedAnimation = animator:LoadAnimation(animationResult)
	return loadedAnimation
end

function Module.waitForAnimTrackToLoad(animTrack: AnimationTrack, timeOut: number?): boolean
	-- There is no built-in way to see if an animation track loads and
	-- property signals don't fire for .Length!
	-- Roblox Moment! :/
	if animTrack.Length > 0 then
		return false
	end
	local currentThread = coroutine.running()
	task.defer(function()
		local start = os.clock()
		while true do
			if animTrack.Length > 0 then
				if coroutine.status(currentThread) == "suspended" then
					task.spawn(currentThread, false)
				end
				return
			elseif timeOut and os.clock() - start >= timeOut then
				if coroutine.status(currentThread) == "suspended" then
					task.spawn(currentThread, false)
				end
				return
			end
			task.wait()
		end
	end)
	return coroutine.yield()
end

function Module.getRootPart(descendant: Instance): BasePart?
	local humanoid = Module.getHumanoid(descendant)
	return humanoid.RootPart
end

function Module.getHumanoid(descendant: Instance): Humanoid?
	local character = Module.getCharacterFromDescendant(descendant)
	if not character then
		return nil
	end
	return character:FindFirstChildOfClass("Humanoid")
end

function Module.getAliveHumanoid(descendant: Instance): Humanoid?
	local humanoid = Module.getHumanoid(descendant)
	return if humanoid and humanoid.Health > 0 then humanoid else nil
end

function Module.getPlayerHumanoid(player: Player): Humanoid?
	local character = player.Character
	if not character then
		return nil
	end

	return character:FindFirstChildOfClass("Humanoid")
end

--[=[
	Gets a player's humanoid, and ensures it is alive, otherwise returns nil
	@param player Player
	@return Humanoid? -- Nil if not found
]=]
function Module.getAlivePlayerHumanoid(player: Player): Humanoid?
	local humanoid = Module.getPlayerHumanoid(player)
	if not humanoid or humanoid.Health <= 0 then
		return nil
	end

	return humanoid
end

--[=[
	Gets a player's humanoid's rootPart, and ensures the humanoid is alive, otherwise
	returns nil
	@param player Player
	@return BasePart? -- Nil if not found
]=]
function Module.getAlivePlayerRootPart(player: Player): BasePart?
	local humanoid = Module.getPlayerHumanoid(player)
	if not humanoid or humanoid.Health <= 0 then
		return nil
	end

	return humanoid.RootPart
end

-- Client-only!
-- Gets a local player from a descendant otherwise returns nil
function Module.getLocalPlayerFromCharacter(descendant: Instance): Player?
	local player = Module.getPlayerFromCharacter(descendant)
	if player == Players.LocalPlayer then
		return player
	end
	return
end

--[=[
	Gets a player's humanoid's rootPart otherwise returns nil
	@param player Player
	@return BasePart? -- Nil if not found
]=]
function Module.getPlayerRootPart(player: Player): BasePart?
	local humanoid = Module.getPlayerHumanoid(player)
	if not humanoid then
		return nil
	end

	return humanoid.RootPart
end

--[=[
	Unequips all tools for a give player's humanomid, if the humanoid
	exists

	```lua
	local Players = game:GetService("Players")

	for _, player in pairs(Players:GetPlayers()) do
		Character.unequipTools(player)
	end
	```

	@param player Player
]=]
function Module.unequipTools(player: Player)
	local humanoid = Module.getPlayerHumanoid(player)
	if humanoid then
		humanoid:UnequipTools()
	end
end

--[=[
	Returns the player that a descendent is part of, if it is part of one.

	```lua
	script.Parent.Touched:Connect(function(inst)
		local player = Character.getPlayerFromCharacter(inst)
		if player then
			-- activate button!
		end
	end)
	```

	:::tip
	This method is useful in a ton of different situations. For example, you can
	use it on classes bound to a humanoid, to determine the player. You can also
	use it to determine, upon touched events, if a part is part of a character.
	:::

	@param descendant Instance -- A child of the potential character.
	@return Player? -- Nil if not found
]=]
function Module.getPlayerFromCharacter(descendant: Instance): Player?
	if typeof(descendant) ~= "Instance" then
		error("invalid descendant", 2)
	end
	local character = descendant
	local player = Players:GetPlayerFromCharacter(character)

	while not player do
		if character.Parent then
			character = character.Parent
			player = Players:GetPlayerFromCharacter(character)
		else
			return nil
		end
	end

	return player
end

function Module.applyDescriptionFromUserId(userId: number, humanoid: Humanoid)
	local success, result = pcall(function()
		return Players:GetHumanoidDescriptionFromUserId(userId)
	end)

	assert(success, "Failed to get humanoid description")

	humanoid:ApplyDescriptionReset(result)
end

return Module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004322</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC15272E1968549B18F380F94BE3C3062">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009635</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_game</string>
							<string name="ScriptGuid">{8C205B37-BC06-4E07-9AFD-0D628FE1C427}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local SoundService = game:GetService("SoundService")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local _Signal = require("../ModuleUtils/_Signal")
local Players = game:GetService("Players")
local _table = require("./_table")

local sfxSoundGroup: SoundGroup? do
	local master = SoundService:FindFirstChild("Master")
	if master then
		sfxSoundGroup = master:FindFirstChild("SFX")
	end
end

local Module = {}
local rng = Random.new(tick())

-----------------------------
-- UTIL FUNCTIONS --
-----------------------------

-- Allows you to call a lambda function to avoid creating closures.
function Module.call<T1..., T2...>(fn: (T1...) -> (T2...), ...: T1...): T2...
	return fn(...)
end

-- Reduces memory usage for RBXScriptSignal handlers by only capturing a single upvalue.
-- Upvalue memory usage is <code>32 + 28n</code> bytes where <code>n</code> is the number of upvalues.
function Module.connect(signal: RBXScriptSignal, fn, ...)
	assert(typeof(signal) == "RBXScriptSignal", "invalid signal given to connect")
	local args = table.pack(fn, ...)

	return signal:Connect(function(...)
		-- Fast path: no bound args
		local fn = args[1]
		if args.n == 1 then
			return fn(...)
		end
		local signalArgCount = select("#", ...)
		-- Fast path: no signal args
		if signalArgCount == 0 then
			return fn(table.unpack(args, 2, args.n))
		end

		-- General case: combine signal args + bound args
		local totalCount = signalArgCount + args.n
		local totalArgs = table.create(totalCount)

		for i = 1, signalArgCount do
			totalArgs[i] = select(i, ...)
		end

		for i = 2, args.n do
			local boundIndex = i - 1
			totalArgs[signalArgCount + boundIndex] = args[i]
		end

		return fn(table.unpack(totalArgs, 1, totalCount))
	end)
end

do
	local throttleState: { [any]: { [any]: boolean } } = _table.weakCache("k")
	-- Runs <strong>func</strong> immediately and blocks further calls until the deferred delay is over.
	-- <strong>identifier</strong> is stored per function and is not global.
	function Module.throttleDefer<T, A...>(
		identifier: T,
		func: (T, A...) -> (),
		...: A...
	): boolean
		throttleState[func] = throttleState[func] or {}

		if throttleState[func][identifier] then
			return false
		end

		throttleState[func][identifier] = true
		task.defer(function()
			throttleState[func][identifier] = nil
		end)

		task.spawn(func, identifier, ...)
		return true
	end

	local timeThrottle: { [any]: number } = {}
	-- Runs <strong>func</strong> immediately and blocks further calls until the time delay is over.
	-- <strong>identifier</strong> is stored per function and is not global.
	function Module.throttle<T, A...>(
		identifier: T,
		delay: number,
		func: (T, A...) -> (),
		...: A...
	): boolean
		local now = os.clock()
		local last = timeThrottle[identifier]
		if last and now - last < delay then
			return false
		end

		timeThrottle[identifier] = now
		task.spawn(func, identifier, ...)

		task.delay(delay, function()
			-- to avoid memory leaks
			if timeThrottle[identifier] == now then
				timeThrottle[identifier] = nil
			end
		end)

		return true
	end
end

function Module.cloneTweenInfo(tweenInfo: TweenInfo, overrides: { [any]: any }?): TweenInfo
	local time = if overrides then overrides.Time or tweenInfo.Time else tweenInfo.Time
	local easingStyle = if overrides then overrides.EasingStyle or tweenInfo.EasingStyle else tweenInfo.EasingStyle
	local easingDirection = if overrides then overrides.EasingDirection or tweenInfo.EasingDirection else tweenInfo.EasingDirection
	local repeatCount = if overrides then overrides.RepeatCount or tweenInfo.RepeatCount else tweenInfo.RepeatCount
	local reverses = if overrides then overrides.Reverses or tweenInfo.Reverses else tweenInfo.Reverses
	local delayTime = if overrides then overrides.DelayTime or tweenInfo.DelayTime else tweenInfo.DelayTime

	return TweenInfo.new(time, easingStyle, easingDirection, repeatCount, reverses, delayTime)
end

function Module.inFirstPerson(distanceDelta: number?): boolean
	assert(RunService:IsClient(), "inFirstPerson() can only be called by client.")
	local dist = (workspace.CurrentCamera.CFrame.Position - workspace.CurrentCamera.Focus.Position).Magnitude

	local distanceDelta = distanceDelta or 0
	local threshold = math.max(0, 0.501 + distanceDelta)

	return dist <= threshold
end

-- DEPRECATED --
do
	local SPEED_OF_SOUND = 343 -- meters per second
	local METERS_PER_STUD = 0.28 -- 1 stud is approx 0.28 meter

	-- <strong><code>!DEPRECATED!</code></strong>
	-- <strong><code>!YIELDS!</code></strong>
	-- Use <code>Math.getSoundTravelDuration()</code> instead
	-- This will yield for the exact duration it takes for sound to travel the given distance.
	function Module.yieldForSoundTravel(distanceInStuds: number)
		warn("yieldForSoundTravel() is deprecated")
		local distanceInMeters = distanceInStuds * METERS_PER_STUD
		local timeToYield = distanceInMeters / SPEED_OF_SOUND

		task.wait(timeToYield)
	end
end
-- --

-- <strong><code>!YIELDS!</code></strong>
-- Pauses the current thread until the end of the current resumption cycle.
function Module.defer()
	local current = coroutine.running()
	task.defer(function()
		if coroutine.status(current) == "suspended" then
			task.spawn(current)
		end
	end)
	return coroutine.yield()
end

-- This function will yield until all supplied signals fire once with a timeout.
-- -1 for no timeout
-- <strong><code>!YIELDS!</code></strong>
function Module.waitForAll<Func, T...>(timeoutInSeconds: number, ...: RBXScriptSignal | _Signal.SignalType<Func, T...>): (boolean, T...)
	local events = table.pack(...)
	local connections = {} :: { any }
	local totalCount = #events
	local count = 0
	local thread = coroutine.running()

	local function onEvent()
		if not connections then
			return
		end

		count += 1
		if count >= totalCount then
			connections = nil
			if coroutine.status(thread) == "suspended" then
				task.spawn(thread, true)
			end
		end
	end

	for i, event: RBXScriptSignal in ipairs(events) do
		connections[i] = event:Once(onEvent)
	end

	if timeoutInSeconds >= 0 then
		task.delay(timeoutInSeconds, function()
			if not connections then
				return
			end

			for _, connection in connections do
				connection:Disconnect()
			end
			connections = nil
			if coroutine.status(thread) == "suspended" then
				task.spawn(thread, true)
			end
		end)
	end

	return coroutine.yield()
end

-- <strong><code>!YIELDS!</code></strong>
function Module.waitForEither<Func, T...>(eventYes: RBXScriptSignal | _Signal.SignalType<Func, T...>, eventNo: RBXScriptSignal | _Signal.SignalType<Func, T...>): boolean
	local eventYes = eventYes -- fixes type annotation issue
	local eventNo = eventNo -- fixes type annotation issue
	local thread = coroutine.running()

	local connection1 = nil
	local connection2 = nil
	
	connection1 = eventYes:Once(function(...)
		if connection1 == nil then
			return
		end

		connection1:Disconnect()
		connection2:Disconnect()
		connection1 = nil
		connection2 = nil

		if coroutine.status(thread) == "suspended" then
			task.spawn(thread, true, ...)
		end
	end)

	connection2 = eventNo:Once(function(...)
		if connection2 == nil then
			return
		end

		connection1:Disconnect()
		connection2:Disconnect()
		connection1 = nil
		connection2 = nil
		
		if coroutine.status(thread) == "suspended" then
			task.spawn(thread, false, ...)
		end
	end)

	return coroutine.yield()
end

-- -1 for no timeout
-- <strong><code>!YIELDS!</code></strong>
function Module.waitForAny(timeoutInSeconds: number, ...: RBXScriptSignal | _Signal.SignalType<any, ...any>): (boolean, ...any)
	local thread = coroutine.running()
	local connections = {} :: { any }

	local function disconnectAll()
		for _, connection in connections do
			connection:Disconnect()
		end

		connections = nil
	end

	local function onEvent(...)
		if not connections then
			return
		end

		disconnectAll()
		
		if coroutine.status(thread) == "suspended" then
			task.spawn(thread, false, ...)
		end
	end

	for _, event in {...} do
		table.insert(connections, event:Once(onEvent))
	end

	if timeoutInSeconds >= 0 then
		task.delay(timeoutInSeconds, function()
			if not connections then
				return
			end

			disconnectAll()
			
			if coroutine.status(thread) == "suspended" then
				task.spawn(thread, true)
			end
		end)
	end

	return coroutine.yield()
end

-- <strong><code>!YIELDS!</code></strong>
function Module.waitWithTimeout<Func, T...>(event: RBXScriptSignal | _Signal.SignalType<Func, T...>, timeoutInSeconds: number): (boolean, T...)
	local event = event
	local thread = coroutine.running()
	local connection

	local function onOnce(...)
		if not connection then
			return
		end

		connection:Disconnect()
		connection = nil
		
		if coroutine.status(thread) == "suspended" then
			task.spawn(thread, false, ...)
		end
	end

	connection = event:Once(onOnce)

	task.delay(timeoutInSeconds, function()
		if not connection then
			return
		end

		connection:Disconnect()
		connection = nil

		if coroutine.status(thread) == "suspended" then
			task.spawn(thread, true)
		end
	end)

	return coroutine.yield()
end

do
	local MAX_POOL_SIZE = 50
	local freeThreads: { thread } = {}

	local function runCallback(callback, thread, ...)
		local success, err = pcall(callback, ...)
		if not success then
			warn(err)
		end
		if #freeThreads < MAX_POOL_SIZE then
			table.insert(freeThreads, thread)
		end
	end

	local function yielder()
		while true do
			runCallback(coroutine.yield())
		end
	end
	
	-- Similar to task.spawn, but doesn't return any threads.
	-- This is a 'fast spawn' that recycles thread for improved performance.
	function Module.spawn<T...>(callback: (T...) -> (), ...: T...)
		local thread
		if #freeThreads > 0 then
			thread = freeThreads[#freeThreads]
			freeThreads[#freeThreads] = nil
		else
			thread = coroutine.create(yielder)
			coroutine.resume(thread)
		end

		task.spawn(thread, callback, thread, ...)
	end
end

do
	type RaycastResultData = {
		Instance: Instance,
		Position: Vector3,
		Normal: Vector3,
		Material: Enum.Material,
		Distance: number
	}

	function Module.createRemoteCompatibleRaycastResult(result: RaycastResult): RaycastResultData
		return {
			Instance = result.Instance,
			Position = result.Position,
			Normal = result.Normal,
			Material = result.Material,
			Distance = result.Distance
		} :: RaycastResultData
	end

	-- Client-only!
	function Module.getMouseRay(params: RaycastParams, maxDistance: number?): Ray
		assert(RunService:IsClient(), "getMouseRay can only be used from client-side!")
		local mousePos = UserInputService:GetMouseLocation()
		maxDistance = maxDistance or 5000
		return workspace.CurrentCamera:ViewportPointToRay(mousePos.X, mousePos.Y)
	end
	
	-- Client-only!
	function Module.raycastFromMouse(params: RaycastParams, maxDistance: number?): (RaycastResult?, Ray)
		assert(RunService:IsClient(), "raycastFromMouse can only be used from client-side!")
		local mousePos = UserInputService:GetMouseLocation()
		maxDistance = maxDistance or 5000
		local mouseRay = workspace.CurrentCamera:ViewportPointToRay(mousePos.X, mousePos.Y)

		local direction = mouseRay.Direction * maxDistance
		local result = workspace:Raycast(mouseRay.Origin, direction, params)

		return result, Ray.new(mouseRay.Origin, direction)
	end
	
	-- Client-only!
	function Module.raycastFromScreenCenter(params: RaycastParams, maxDistance: number?): (RaycastResult?, Ray)
		assert(RunService:IsClient(), "raycastFromScreenCenter can only be used from client-side!")
		maxDistance = maxDistance or 5000
		local mouseRay = workspace.CurrentCamera:ViewportPointToRay(
			workspace.CurrentCamera.ViewportSize.X/2,
			workspace.CurrentCamera.ViewportSize.Y/2
		)

		local direction = mouseRay.Direction * maxDistance
		local result = workspace:Raycast(mouseRay.Origin, direction, params)

		return result, Ray.new(mouseRay.Origin, direction)
	end
	
	-- Client-only!
	-- Shorthand for <code>UserSettings():GetService("UserGameSettings") :: UserGameSettings</code>
	-- Returns the class that stores all client-side settings, such as graphics quality level.
	function Module.getUserSettings(): UserGameSettings
		return UserSettings():GetService("UserGameSettings")
	end
end

function Module.getPlayerList(exclude: { Player }?): {Player}
	if not exclude then
		return Players:GetPlayers()
	end
	local result = {}
	for _, player in ipairs(Players:GetPlayers()) do
		if exclude and table.find(exclude, player) then
			continue
		end
		table.insert(result, player)
	end
	return result
end

-- Currently, :GetPlayerFromCharacter is not safe to call in parallel (which makes no sense).
function Module.getPlayerFromCharacterWriteSafe(character: Model): Player?
	for _, player in Players:GetPlayers() do
		if player.Character == character then
			return player
		end
	end
	return
end

-- DEPRECATED!
-- Use <code>Remotes.fireToAllClientsExcept()</code>
function Module.fireToAllClientsExcept(exception: { Player }, remote: RemoteEvent, ...: any)
	warn("Game.fireToAllClientsExcept() is deprecated")
	local players = Module.getPlayerList(exception)
	for _, player in players do
		remote:FireClient(player, ...)
	end
end

function Module.hasEnumKey(key: string, enumTable: { [any]: any }): boolean
	for _, thing in enumTable do
		if typeof(thing) == "table" then
			local found = Module.hasEnumKey(key, thing)
			if found then
				return found
			end
		elseif thing == key then
			return true
		end
	end

	return false
end

function Module.repeatUntil(repeatCallback: () -> boolean, condition: () -> boolean, yield: boolean)
	assert(repeatCallback ~= nil, "repeatCallback is invalid or nil")

	if yield then
		task.spawn(function()
			repeat repeatCallback() until (condition() == true)
		end)
	else
		repeat repeatCallback() until (condition() == true)
	end
end

-- Caches results from a pure function in a weak table so the same input
-- doesn't need to be calculated again for the same output.
function Module.memoize<T, U>(fn: (T) -> (U)): (T) -> (U)
	local cache = {}
	setmetatable(cache, {__mode = "kv"})
	return function(input: T)
		local result = cache[input]
		if not result[input] then
			result = fn(input)
			cache[input] = result
			return result
		end
		return result
	end
end

-- Returns the game's PlaceVersion
function Module.getBuild(): "STUDIO" | string
	if RunService:IsStudio() then
		return "STUDIO"
	else
		return ("%d"):format(game.PlaceVersion)
	end
end

--[=[
	Gets the game build with a server type specified for debugging
	@return string
]=]
function Module.getBuildWithServerType(): string
	return Module.getBuild() .. "-" .. Module.getServerType()
end

--[=[
	Gets a string label for the current server type
]=]
function Module.getServerType(): "PRIVATE" | "RESERVED" | "STANDARD"
	if game.PrivateServerId ~= "" then
		if game.PrivateServerOwnerId ~= 0 then
			return "PRIVATE"
		else
			return "RESERVED"
		end
	else
		return "STANDARD"
	end
end

-- Indicates if this is a server that was purchased by a player.
function Module.isPrivateServer(): boolean
	return game.PrivateServerId ~= "" and game.PrivateServerOwnerId ~= 0
end

-- Indicates if this is a reserved server created through the TeleportService.
function Module.isReservedServer(): boolean
	return game.PrivateServerId ~= "" and game.PrivateServerOwnerId == 0
end

--[=[
	DEPRECATED
	Use: <code>isPrivateServer()</code>
]=]
function Module.isVIPServer(): boolean
	warn("isVIPServer() is deprecated")
	return game.PrivateServerId ~= "" and game.PrivateServerOwnerId ~= 0
end

-- Alternative to <code>Instance.new()</code> that allows you to apply properties at the same time.
-- If the <code>Parent</code> property is included, it will be applied last.
-- Any properties that are supposed to be numbers but are provided as NumberRange will be randomized via :NextNumber()
-- Any values that are tables are presumed to be new instances that will be made children of the primary instance.
function Module.create(className, properties: { [any]: any }?)
	local instance = Instance.new(className)

	if properties then
		local parent
		for name, value in pairs(properties) do
			if name == "Parent" then
				parent = value
				continue
			elseif typeof(value) == "table" then
				local newInstance = Module.create(name, value)
				newInstance.Parent = instance
				continue
			elseif
				typeof(value) == "NumberRange"
				and typeof(instance[name]) == "number"
			then
				value = rng:NextNumber(value.Min, value.Max)
			end
			local success, err = pcall(function()
				instance[name] = value
			end)
			if not success then
				warn(err)
			end
		end
		instance.Parent = parent
	end

	return instance
end

-- Creates the sound. Automatically parents to SoundService if no parent is provided.
-- Sound has parent set last. Default SoundGroup is SFX (if present)
function Module.createSound(properties: { [string]: any }): Sound
	local sound = Instance.new("Sound")
	local parent, soundGroup = SoundService, sfxSoundGroup
	for property, value in pairs(properties) do
		if property == "Parent" then
			parent = value
			continue
		end
		if property == "SoundGroup" then
			soundGroup = value
			continue
		end
		sound[property] = value
	end
	sound.Parent = parent
	sound.SoundGroup = soundGroup
	return sound
end

-- Automatically cleans up the sound once it ends.
-- Default parent is SoundService.
function Module.playSoundClone(sound: Sound, parent: Instance?): Sound
	local clone = sound:Clone()
	clone.Parent = parent or SoundService
	clone.Ended:Once(function()
		clone:Destroy()
	end)
	clone:Play()
	return clone
end

-- Automatically cleans up the sound once it ends. Parent property will be ignored.
-- Default SoundGroup is SFX (if present)
function Module.playSoundFollow(soundProperties: { [string]: any }, follow: BasePart | Attachment): Sound
	local sound = Instance.new("Sound")
	local soundGroup = sfxSoundGroup
	for name, value in pairs(soundProperties) do
		if name == "SoundGroup" then
			soundGroup = value
			continue
		end
		sound[name] = value
	end
	sound.SoundGroup = soundGroup
	
	local myFollowPart = Instance.new("Part")
	myFollowPart.Transparency = 1
	myFollowPart.Anchored = true
	myFollowPart.CanCollide = false
	myFollowPart.CanQuery = false
	myFollowPart.CanCollide = false
	myFollowPart.Size = if follow:IsA("BasePart") then follow.Size else Vector3.new(1, 1, 1)
	
	sound.Parent = myFollowPart
	myFollowPart.Parent = workspace
	local connection = RunService.RenderStepped:Connect(function()
		myFollowPart.Position = if follow:IsA("Attachment") then follow.WorldPosition else follow.Position
	end)
	sound:Play()
	sound.Ended:Once(function()
		connection:Disconnect()
		myFollowPart:Destroy()
	end)
	
	return sound
end

-- Automatically cleans up the sound once it ends.
-- Default SoundGroup is SFX (if present)
function Module.playSoundInWorld(soundProperties: { [string]: any }, position: Vector3): Sound
	local attachment = Instance.new("Attachment")
	attachment.WorldPosition = position
	local sound = Instance.new("Sound")
	local soundGroup = sfxSoundGroup
	for name, value in pairs(soundProperties) do
		if name == "SoundGroup" then
			soundGroup = value
			continue
		end
		sound[name] = value
	end
	sound.SoundGroup = soundGroup
	sound.Parent = attachment
	attachment.Parent = workspace.Terrain
	sound:Play()
	sound.Ended:Once(function()
		attachment:Destroy()
	end)
	return sound
end

-- Plays the song for you and automatically cleans it up.
function Module.playSoundOnce(sound: Sound)
	sound:Play()
	sound.Ended:Once(function()
		sound:Destroy()
	end)
end

-- Automatically cleans up the sound once it ends.
-- Default parent is the SoundService, Default SoundGroup is SFX (if present)
function Module.playSound(soundProperties: { [string]: any }, parent: Instance?): Sound
	local sound = Instance.new("Sound")
	local parent, soundGroup = parent or SoundService, sfxSoundGroup
	for name, value in pairs(soundProperties) do
		if name == "Parent" then
			parent = value
			continue
		end
		if name == "SoundGroup" then
			soundGroup = value
			continue
		end
		sound[name] = value
	end
	sound.SoundGroup = soundGroup
	sound.Parent = parent
	if sound.PlayOnRemove then
		sound:Destroy()
	else
		sound:Play()
		sound.Ended:Once(function()
			sound:Destroy()
		end)
	end
	return sound
end

-- Automatically cleans up the sound once it ends.
-- Default SoundGroup is SFX (if present)
function Module.playRandomSound(soundIds: {string}, soundProperties: { [string]: any }, parent: Instance): Sound
	local soundId = soundIds[rng:NextInteger(1, #soundIds)]

	local sound = Instance.new("Sound")
	local soundGroup = sfxSoundGroup
	for name, value in pairs(soundProperties) do
		if name == "SoundGroup" then
			soundGroup = value
			continue
		end
		sound[name] = value
	end
	sound.SoundGroup = soundGroup
	sound.SoundId = soundId
	sound.Parent = parent
	if sound.PlayOnRemove then
		sound:Destroy()
	else
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end
	return sound
end

-- Automatically cleans up the sound once it ends.
function Module.playRandomSoundClone(sounds: { Sound }, source: Instance, destroyFirst: boolean?, volume: number?): Sound
	local soundTemplate = sounds[rng:NextInteger(1, #sounds)]

	local sound = soundTemplate:Clone()
	sound.Volume *= (volume or 1)
	sound:Play()
	
	sound.Parent = source
	if destroyFirst or sound.PlayOnRemove then
		sound.PlayOnRemove = true
		sound:Destroy()
	else
		sound.Ended:Once(function()
			sound:Destroy()
		end)
	end
	
	return sound
end

return Module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004323</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB5B8C29FA60048AC9128E352A24F396F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009636</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_math</string>
							<string name="ScriptGuid">{54169757-6286-4EC5-A2DE-E86AA263E449}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--!native
local _easingDirection = require(script._easingDirection)
local _easingStyle = require(script._easingStyle)
local t = require("./_t")

local Module = {}
Module.EasingDirection = _easingDirection
Module.EasingStyle = _easingStyle

local PI = math.pi
local TAU = 2 * PI
local HUGE = math.huge
local rng = Random.new(tick())

local abs, clamp, min, max, rad, deg, pow, log = math.abs, math.clamp, math.min, math.max, math.rad, math.deg, math.pow, math.log
local sin, cos, tan, asin, acos, atan2 = math.sin, math.cos, math.tan, math.asin, math.acos,  math.atan2

local vect3New, vect2New, cfNew = Vector3.new, Vector2.new, CFrame.new

local vector = vector
local createVector = vector.create
local magnitude, normalize = vector.magnitude, vector.normalize

-- in radians
function Module.angleAbs(angle: number): number
	while angle < 0 do
		angle = angle + TAU
	end
	while angle > TAU do
		angle = angle - TAU
	end
	return angle
end

-- in radians
function Module.angleShortest(a0: number, a1: number): number
	local d1 = Module.angleAbs(a1 - a0)
	local d2 = -Module.angleAbs(a0 - a1)
	return abs(d1) > abs(d2) and d2 or d1
end

-- in radians
function Module.lerpAngle(a0: number, a1: number, frac: number): number
	return a0 + Module.angleShortest(a0, a1) * frac
end

function Module.playerVecToAngle(vec: Vector3): number
	return atan2(-vec.Z, vec.X) - rad(90)
end

-- in radians
function Module.playerAngleToVec(angle: number): Vector3
	return vect3New(sin(angle), 0, cos(angle))
end

--dt variable decay function
function Module.friction(val: number, fric: number, deltaTime: number): number
	return (1 / (1 + (deltaTime / fric))) * val
end

function Module.velocityFriction(vel: Vector3, fric: number, deltaTime: number): Vector3
	local speed = vel.Magnitude
	speed = Module.friction(speed, fric, deltaTime)

	if speed < 0.001 then
		return vect3New(0, 0, 0)
	end
	vel = vel.Unit * speed

	return vel
end

-- Removes the Y component of the vector
function Module.flatVec(vec: Vector3): Vector3
	return vect3New(vec.X, 0, vec.Z)
end

--Redirects velocity
function Module.groundAccelerate(wishDir: Vector3, wishSpeed: number, accel: number, velocity: Vector3, dt: number): Vector3
	--Cap velocity
	local speed = velocity.Magnitude
	if speed > wishSpeed then
		velocity = velocity.Unit * wishSpeed
	end

	local wishVel = wishDir * wishSpeed
	local pushDir = wishVel - velocity

	local pushLen = pushDir.Magnitude

	local canPush = accel * dt * wishSpeed

	if canPush > pushLen then
		canPush = pushLen
	end
	if canPush < 0.00001 then
		return velocity
	end
	return velocity + (canPush * pushDir.Unit)
end

function Module.accelerate(wishDir: Vector3, wishSpeed: number, accel: number, velocity: Vector3, dt: number): Vector3
	local speed = velocity.Magnitude

	local currentSpeed = velocity:Dot(wishDir)
	local addSpeed = wishSpeed - currentSpeed

	if addSpeed <= 0 then
		return velocity
	end

	local accelSpeed = accel * dt * wishSpeed
	if accelSpeed > addSpeed then
		accelSpeed = addSpeed
	end

	velocity = velocity + (accelSpeed * wishDir)

	--if we're already going over max speed, don't go any faster than that
	--Or you'll get strafe jumping!
	if speed > wishSpeed and velocity.Magnitude > speed then
		velocity = velocity.Unit * speed
	end
	return velocity
end

function Module.capVelocity(velocity: Vector3, maxSpeed: number): Vector3
	local mag = velocity.Magnitude
	mag = min(mag, maxSpeed)
	if mag > 0.01 then
		return velocity.Unit * mag
	end
	return Vector3.zero
end

function Module.clipVelocity(input: Vector3, normal: Vector3, overbounce: number): Vector3
	local backoff = input:Dot(normal)

	if backoff < 0 then
		backoff = backoff * overbounce
	else
		backoff = backoff / overbounce
	end

	local changex = normal.X * backoff
	local changey = normal.Y * backoff
	local changez = normal.Z * backoff

	return vect3New(input.X - changex, input.Y - changey, input.Z - changez)
end

--Smoothlerp for lua. "Zeno would be proud!"
--Use it in a feedback loop over multiple frames to converge A towards B, in a deltaTime safe way
--eg:  cameraPos = SmoothLerp(cameraPos, target, 0.5, deltaTime)
--Handles numbers and types that implement Lerp like Vector3 and CFrame
function Module.smoothLerp(variableA: any, variableB: any, fraction: number, deltaTime: number): any

	local f = 1.0 - pow(1.0 - fraction, deltaTime)

	if (type(variableA) == "number") then
		return ((1-f) * variableA) + (variableB * f)
	end

	return variableA:Lerp(variableB, f)
end

do
	local SPEED_OF_SOUND = 343 -- meters per second
	local METERS_PER_STUD = 0.28 -- 1 stud is approx 0.28 meter

	function Module.getSoundTravelDuration(distanceInStuds: number): number
		local distanceInMeters = distanceInStuds * METERS_PER_STUD
		local duration = distanceInMeters / SPEED_OF_SOUND
		return duration
	end
end

-- Perform a hitbox check. The hitbox will be positioned <code>size.Z / 2</code> in front of <code>origin</code>.
-- <strong>heightCoverage</strong>: Add additional size in the positive Y-direction for height coverage. This will also reposition the hitbox accordingly.
-- <strong>lookAt</strong>: Tilt the hitbox around the X-axis to lookAt
function Module.hitboxCheck(origin: CFrame, size: Vector3, heightCoverage: number?, lookAt: Vector3?, params: OverlapParams?): { BasePart }
	local size = if heightCoverage then size + vect3New(0, heightCoverage, 0) else size
	local finalCFrame = origin * cfNew(0, if heightCoverage then heightCoverage / 2 else 0, -(size.Z / 2))
	if lookAt then
		local direction = (lookAt - origin.Position).Unit
		local angle = asin(direction.Y)
		local tilt = CFrame.Angles(angle, 0, 0)
		finalCFrame *= tilt
	end

	return workspace:GetPartBoundsInBox(finalCFrame, size, params)
end

-- DEPRECATED! Use getClosestSurfacePositionOn()
-- Returns a vector that represents the closest part's surface point to position.
-- <strong>highFidelity</strong>: Determines if the calculation should take the <code>Shape</code> property into account for parts. Default is false.
-- Fidelity doesn't support Wedges or CornerWedges
@deprecated
@native
function Module.getClosestSurfacePoint(part: BasePart, position: Vector3, highFidelity: boolean?): Vector3
	local shape = if part:IsA("Part") then part.Shape else nil
	local className = part.ClassName

	if highFidelity then
		-- BALL: Use the smallest axis as the ball’s diameter.
		if shape == Enum.PartType.Ball then
			local center = part.Position
			local diameter = min(part.Size.X, part.Size.Y, part.Size.Z)
			local radius = diameter * 0.5
			local dir = position - center
			if dir.Magnitude == 0 then
				return center + part.CFrame.LookVector * radius
			else
				return center + dir.Unit * radius
			end
		elseif shape == Enum.PartType.Cylinder then
			-- CYLINDER: Dominant (flat) axis is the local X-axis.
			local localPos = part.CFrame:PointToObjectSpace(position)
			local halfLength = part.Size.X * 0.5
			local radius = min(part.Size.Y, part.Size.Z) * 0.5
			local candidate

			-- Case 1: Outside the X-range (caps)
			if abs(localPos.X) > halfLength then
				local clampedX = clamp(localPos.X, -halfLength, halfLength)
				local radial = vect2New(localPos.Y, localPos.Z)
				local clampedRadial = (radial.Magnitude > radius and radial.Unit * radius or radial)
				candidate = vect3New(clampedX, clampedRadial.X, clampedRadial.Y)

				-- Case 2: Within X-range
			else
				local radial = vect2New(localPos.Y, localPos.Z)
				local radialMagnitude = radial.Magnitude
				local radialUnit = radial.Unit

				if radialMagnitude > radius then
					candidate = vect3New(localPos.X, radialUnit.X * radius, radialUnit.Y * radius)
				else
					-- Inside cylinder: choose the minimal push out: to the cap or the side.
					local dCap = halfLength - abs(localPos.X)
					local dSide = radius - radialMagnitude
					if dCap < dSide then
						candidate = vect3New(localPos.X >= 0 and halfLength or -halfLength, localPos.Y, localPos.Z)
					else
						if radialMagnitude == 0 then
							candidate = vect3New(localPos.X, radius, 0)
						else
							candidate = vect3New(localPos.X, radialUnit.X * radius, radialUnit.Y * radius)
						end
					end
				end
			end

			return part.CFrame:PointToWorldSpace(candidate)
		end
	end

	-- DEFAULT (Block): Simple axis clamping.
	local localPos = part.CFrame:PointToObjectSpace(position)
	local halfSize = part.Size * 0.5
	local clamped = vect3New(
		clamp(localPos.X, -halfSize.X, halfSize.X),
		clamp(localPos.Y, -halfSize.Y, halfSize.Y),
		clamp(localPos.Z, -halfSize.Z, halfSize.Z)
	)
	return part.CFrame:PointToWorldSpace(clamped)
end

--[[
	Returns a <code>Vector3</code> that represents the closest surface position to <code>position</code>.
	<strong>shape</strong>: Default shape is 'Box'
]]
@native
function Module.getClosestSurfacePosition(cframe: CFrame, size: Vector3, position: Vector3, shape: ("Box" | "Sphere" | "Cylinder")?): Vector3
	debug.profilebegin("FunctionUtils::getClosestSurfacePosition")
	-- BALL: Use the smallest axis as the ball’s diameter.
	local shape = shape or "Box"
	local result: Vector3
	if shape == "Box" then
		local localPos = cframe:PointToObjectSpace(position)
		local halfSize = size * 0.5
		local clamped = vect3New(
			clamp(localPos.X, -halfSize.X, halfSize.X),
			clamp(localPos.Y, -halfSize.Y, halfSize.Y),
			clamp(localPos.Z, -halfSize.Z, halfSize.Z)
		)
		result = cframe:PointToWorldSpace(clamped)
	elseif shape == "Sphere" then
		local center = cframe.Position
		local diameter = min(size.X, size.Y, size.Z)
		local radius = diameter * 0.5
		local dir = position - center
		if dir.Magnitude == 0 then
			result = center + cframe.LookVector * radius
		else
			result = center + dir.Unit * radius
		end
	elseif shape == "Cylinder" then
		-- CYLINDER: Dominant (flat) axis is the local X-axis.
		local localPos = cframe:PointToObjectSpace(position)
		local halfLength = size.X * 0.5
		local radius = min(size.Y, size.Z) * 0.5
		local candidate

		if abs(localPos.X) > halfLength then
			-- Case 1: Outside the X-range (caps)
			local clampedX = clamp(localPos.X, -halfLength, halfLength)
			local radial = vect2New(localPos.Y, localPos.Z)
			local clampedRadial = (radial.Magnitude > radius and radial.Unit * radius or radial)
			candidate = vect3New(clampedX, clampedRadial.X, clampedRadial.Y)
		else
			-- Case 2: Within X-range
			local radial = vect2New(localPos.Y, localPos.Z)
			local radialMagnitude = radial.Magnitude
			local radialUnit = radial.Unit

			if radialMagnitude > radius then
				candidate = vect3New(localPos.X, radialUnit.X * radius, radialUnit.Y * radius)
			else
				-- Inside cylinder: choose the minimal push out: to the cap or the side.
				local dCap = halfLength - abs(localPos.X)
				local dSide = radius - radialMagnitude
				if dCap < dSide then
					candidate = vect3New(localPos.X >= 0 and halfLength or -halfLength, localPos.Y, localPos.Z)
				else
					if radialMagnitude == 0 then
						candidate = vect3New(localPos.X, radius, 0)
					else
						candidate = vect3New(localPos.X, radialUnit.X * radius, radialUnit.Y * radius)
					end
				end
			end
		end

		result = cframe:PointToWorldSpace(candidate)
	else
		error(`don't know how to handle shape: {shape}`, 2)
	end
	debug.profileend()
	return result
end

--[[
	Uses <code>Enum.PartType</code> of <code>part</code>.
	Does not support wedges.
]]
function Module.getClosestSurfacePositionOn(part: BasePart, position: Vector3)
	debug.profilebegin("FunctionUtils::getClosestSurfacePositionOn")
	local shape = if part:IsA("Part") then part.Shape else nil
	local result: Vector3
	if shape == Enum.PartType.Ball then
		result = Module.getClosestSurfacePosition(part.CFrame, part.Size, position, "Sphere")
	elseif shape == Enum.PartType.Cylinder then
		result = Module.getClosestSurfacePosition(part.CFrame, part.Size, position, "Cylinder")
	else
		result = Module.getClosestSurfacePosition(part.CFrame, part.Size, position, "Box")
	end
	debug.profileend()
	return result
end

function Module.getRandomPointOnSphereSurface(center: Vector3, radius: number): Vector3
	local u = rng:NextNumber()
	local v = rng:NextNumber()
	local theta = u * TAU
	local phi = acos(2 * v - 1)

	local x = radius * sin(phi) * cos(theta)
	local y = radius * sin(phi) * sin(theta)
	local z = radius * cos(phi)

	return center + vect3New(x, y, z)
end

-- Returns a point on a hemisphere's surface given a center, radius, and min/max from the origin.
-- <strong>radiusRange</strong>: Distance from the sphere's center for point. Must not exceed the radius. Default is (1, 1).
-- <strong>partial</strong>: Describes the partial sphere. 1 is a full sphere. Default is 0.5
function Module.getRandomPointOnPartialSphereSurface(center: Vector3, radiusRange: NumberRange?, partial: number?): Vector3
	local partial = partial or 0.5
	local radiusRange = radiusRange or NumberRange.new(1)
	local minRadius = radiusRange.Min
	local maxRadius = radiusRange.Max

	-- Random radius between minRadius and maxRadius.
	local r = rng:NextNumber() * (maxRadius - minRadius) + minRadius

	-- Compute the maximum polar angle allowed.
	-- For a full sphere (partial = 1), maxTheta is π.
	-- For an upper half-sphere (partial = 0.5), maxTheta is π/2.
	local maxTheta = PI * partial

	-- To ensure a uniform distribution over the spherical cap,
	-- pick cos(theta) uniformly in [cos(maxTheta), 1].
	local cosTheta = rng:NextNumber() * (1 - cos(maxTheta)) + cos(maxTheta)
	local theta = acos(cosTheta)

	-- φ (phi) is uniformly distributed from 0 to 2π.
	local phi = rng:NextNumber() * TAU

	-- Convert spherical coordinates (r, theta, phi) to Cartesian coordinates.
	local x = r * sin(theta) * cos(phi)
	local y = r * cos(theta)
	local z = r * sin(theta) * sin(phi)

	-- Return the final position by offsetting with the center.
	return center + vect3New(x, y, z)
end

-- <strong>up</strong>: Vector3.yAxis is the default.
function Module.getRightVector(look: Vector3, up: Vector3?): Vector3
	local up = up or Vector3.yAxis
	return look:Cross(up).Unit
end

-- Returns a closure that returns an incremented ID each time it is called.
-- The ID can reset back to 0 if given <code>resetAfter</code>
function Module.getIdGenerator(increment: number?, resetAfter: number?): (() -> (number))
	local increment = increment or 1
	local id = 0
	return function()
		if resetAfter and id >= resetAfter then
			id = 0
		end
		id += increment
		return id
	end
end

-- Stacks the <strong>increaseAmount</strong> linearly.
function Module.linearStacking(increaseAmount: number, stackCount: number): number
	return increaseAmount * stackCount
end

-- Stacks the <strong>increaseAmount</strong> exponentially.
-- This will cause rapid progression of the <strong>increaseAmount</strong> at higher stack counts.
function Module.exponentialStacking(increaseAmount: number, stackCount: number): number
	return (increaseAmount)^stackCount
end

-- Stacks the <strong>increaseAmount</strong> hyperbolically.
-- This is good for something that increases by, say, '25%', but you don't want to reach 100% after 4 stacks.
-- E.g. 'Reduce damage by 25% per stack', but you don't reach 100% damage reduction only at 4 stack count.
function Module.hyperbolicStacking(increaseAmount: number, stackCount: number): number
	return (1 - 1/(1 + increaseAmount * stackCount))
end

-- SweetSpot dropoff is 100% dmg from center to half radius, then 25% from half radius to edge.
function Module.sweetSpotDropoff(distanceFromOriginInStuds: number, radiusInStuds: number): number
	-- 100% damage from center to half radius, and then 25% damage from half radius to radius edge
	if distanceFromOriginInStuds > radiusInStuds then
		return 0
	end
	return if distanceFromOriginInStuds <= radiusInStuds / 2 then 1 else 0.25
end

-- Returns a damage multiplier between 0-1.
function Module.logarithmicDropoff(distanceFromOriginInStuds: number, radiusInStuds: number): number
	if distanceFromOriginInStuds > radiusInStuds then
		return 0
	end
	local normalizedDistance = distanceFromOriginInStuds / radiusInStuds
	return clamp(1 / log(radiusInStuds + 1) * log(radiusInStuds - (radiusInStuds * normalizedDistance) + 1), 0, 1)
end

-- Returns a damage multiplier between 0-1.
function Module.linearDropoff(distanceFromOriginInStuds: number, radiusInStuds: number): number
	if distanceFromOriginInStuds > radiusInStuds then
		return 0
	end
	return clamp(1 - (distanceFromOriginInStuds / radiusInStuds), 0, 1)
end

-- Returns a damage multiplier between 0-1.
function Module.exponentialDropoff(distanceFromOriginInStuds: number, radiusInStuds: number, attenuationFactor: number?): number
	local ATTENUATION_FACTOR = 0.2 -- looks best on desmos (a reflection of log dropoff)
	-- only good for small distances (less than 20 studs), larger distances require smaller factor!

	-- the larger the attenuation factor, the faster the drop off!
	if distanceFromOriginInStuds > radiusInStuds then
		return 0
	end
	local linearFactor = (radiusInStuds - distanceFromOriginInStuds) / radiusInStuds
	local expFactor = math.exp(-distanceFromOriginInStuds * (attenuationFactor or ATTENUATION_FACTOR))
	return clamp(linearFactor * expFactor, 0, 1)
end

-- Clamps the Vector3 values by the specified ranges. Does nothing if no range is provided.
function Module.clampVector3(v: Vector3, xClamp: NumberRange?, yClamp: NumberRange?, zClamp: NumberRange?): Vector3
	return vect3New(
		if xClamp then clamp(v.X, xClamp.Min, xClamp.Max) else v.X,
		if yClamp then clamp(v.Y, yClamp.Min, yClamp.Max) else v.Y,
		if zClamp then clamp(v.Z, zClamp.Min, zClamp.Max) else v.Z
	)
end

-- Calculates the distance a particle would travel from an emitter.
function Module.getParticleDistanceTravelled(drag: number, speed: number, lifetime: number): number
	if drag == 0 then
		return speed * lifetime
	end

	local ln2 = log(2)
	return (speed / (drag * ln2)) * (1 - 2 ^ (-drag * lifetime))
end

-- Calculates what a particle's speed should be in order to reach <code>distance</code>.
function Module.getParticleSpeedToCoverDistance(distance: number, drag: number, lifetime: number)
	if lifetime <= 0 or distance <= 0 then
		return 0
	end

	-- If there's no drag, then the velocity doesn't decay,
	-- and we just do distance = speed * lifetime
	if drag == 0 then
		return distance / lifetime
	end

	local ln2 = log(2)
	local factor = 1 - 2 ^ (-drag * lifetime)

	-- Avoid dividing by a tiny number (which would blow up speed).
	if abs(factor) < 1e-9 then
		-- Means we basically get almost zero distance from decay,
		-- so to travel a nonzero distance would require a huge speed.
		return HUGE
	end

	-- Solve for speed
	local speed = distance * (drag * ln2) / factor
	return speed
end

-- Returns the signed difference from angleA to angleB in the range (-π, π].
function Module.angleDiffSigned(angleA: number, angleB: number)
	local diff = (angleB - angleA) % TAU
	if diff > PI then
		diff = diff - TAU
	end
	return diff
end

-- Clamps <strong>toClamp</strong> within <strong>limitOrigin + lowerLimit</strong> and <strong>limitOrigin + upperLimit</strong>
-- and maintains continuous angle motion (no awkward flips to negative angles).
-- <strong>limitOrigin</strong>: 0 by default.
-- All values must be in radians.
function Module.clampAngle(toClamp: number, lowerLimit, upperLimitDeg: number, limitOrigin: number?): number
	local limitOrigin = limitOrigin or 0
	local diff = Module.angleDiffSigned(limitOrigin, toClamp)
	local clampedDiff = clamp(diff, lowerLimit, upperLimitDeg)
	return (limitOrigin + clampedDiff)
end

function Module.withinRange(x: number, min: number, max: number): boolean
	return x >= min and x <= max
end

function Module.lerp(start: any, goal: any, alpha: number): number
	return start + (goal - start) * alpha
end

function Module.getAlpha(start: any, goal: any, current: any): number
	return (current - start) / (goal - start)
end

-- Returns x if less than or equal to max and greater than or equal to min (1 by default).
-- Returns min if x is greater than max. Returns max if x is less than min.
function Module.loopNumber(x: number, max: number, min: number?): number
	local min = min or 1
	return if x > max then min elseif x < min then max else x
end

function Module.isNaN(num: number): boolean
	return num ~= num
end

function Module.isFinite(num: number): boolean
	return num > -HUGE and num < HUGE
end

-- Rounds to to the closest integer, or including decimal places.
function Module.round(number: number, decimalPlaces: number?): number
	if decimalPlaces and (typeof(decimalPlaces) ~= "number" or decimalPlaces <= 0) then
		error("Invalid decimalPlaces: must be a positive number or zero.", 2)
	end
	assert(t.number(number))

	local factor = if decimalPlaces then 10^decimalPlaces else 1

	return math.floor(number * factor + 0.5) / factor
end

function Module.roundUp(number: number, precision: number): number
	return math.ceil(number/precision) * precision
end

function Module.roundDown(number: number, precision: number): number
	return math.floor(number/precision) * precision
end

function Module.map(num: number, min0: number, max0: number, min1: number, max1: number): number
	assert(max0 > min0, "Invalid Range: Range must be greater than zero")

	return (((num - min0)*(max1 - min1)) / (max0 - min0)) + min1
end

@deprecated
-- Deprecated
function Module.roundToDecimal(number: number, decimalPlaces: number): number
	if typeof(decimalPlaces) ~= "number" or decimalPlaces <= 0 then
		error("Invalid number: must be a positive number or zero.", 2)
	end

	local factor = 10^(decimalPlaces or 0)

	return math.floor(number * factor + 0.5) / factor
end

-- Percent difference between two positive numbers greater than 0. Percentage difference is usually calculated 
-- when you want to know the difference in percentage between two numbers. The order of the numbers does not matter 
-- as we are simply dividing the difference between two numbers by the average of the two numbers.
function Module.percentDifference(v1: number, v2: number): number
	assert(v1 and v1 > 0, "Invalid v1 passed. Expected number greater than 0")
	assert(v2 and v2 > 0, "Invalid v2 passed. Expected number greater than 0")
	return abs(v1 - v2)/((v1+v2)/2)*100
end

--Quantifies the change from one number to another and expresses the change as an increase or decrease.
--Going from 10 apples to 20 apples is a 100% increase (change) in the number of apples.
--Vice verse would be 20 to 10 therefore 50% decrease. Negative numbers indicate a decrease and positive increase.
function Module.percentChange(originalValue: number, newValue: number): number
	return (newValue - originalValue)/abs(originalValue)*100
end

--Great for calculating percentages where you start at 0 and are aiming for a specific number.
function Module.getProgress(current: number, goal: number): number
	return (current/goal)*100
end

function Module.getFpsScale(deltaTime: number, targetFps: number)
	return targetFps / (1 / deltaTime)
end

-- Returns a bounding-box that can be aligned with the world-axes.
-- <strong>orientation</strong>: The reference orientation for calculating the bounding box.
-- If not specified, this bounding box will be aligned with the global axes, basically creating a 'static' bounding box
-- that resizes to fit the part based on its orientation.
function Module.getPartExtentsSize(part: BasePart, orientation: CFrame?): Vector3
	local orientation = orientation or CFrame.identity
	local partCFrame: CFrame = part.CFrame

	partCFrame = orientation:ToObjectSpace(partCFrame)

	local size: Vector3 = part.Size
	local sx: number, sy: number, sz: number = size.X, size.Y, size.Z

	local x: number, y: number, z: number,
	R00: number, R01: number, R02: number,
	R10: number, R11: number, R12: number,
	R20: number, R21: number, R22: number = partCFrame:GetComponents()

	local wsx: number = 0.5 * (abs(R00) * sx + abs(R01) * sy + abs(R02) * sz)
	local wsy: number = 0.5 * (abs(R10) * sx + abs(R11) * sy + abs(R12) * sz)
	local wsz: number = 0.5 * (abs(R20) * sx + abs(R21) * sy + abs(R22) * sz)

	return vect3New(x + wsx, y + wsy, z + wsz) - vect3New(x - wsx, y - wsy, z - wsz)
end

-- Grabs the world bounding box (a bounding box that is rotationally-static but resizes to fit the model).
-- For parts, use <code>getPartExtentsSize()</code> without an orientation.
function Module.getWorldBoundingBox(model: Model)
	debug.profilebegin("Functionutils::getWorldBoundingBox")
	local cf, size = model:GetBoundingBox()
	-- The bounding box from GetBoundingBox() is oriented to the model’s axes, 
	-- not the world’s. We need to figure out the axis-aligned bounding box in world space.

	-- Compute the 8 corners of that oriented bounding box
	local halfSize = size * 0.5
	local corners = {
		vect3New(-halfSize.X, -halfSize.Y, -halfSize.Z),
		vect3New(-halfSize.X, -halfSize.Y,  halfSize.Z),
		vect3New(-halfSize.X,  halfSize.Y, -halfSize.Z),
		vect3New(-halfSize.X,  halfSize.Y,  halfSize.Z),
		vect3New( halfSize.X, -halfSize.Y, -halfSize.Z),
		vect3New( halfSize.X, -halfSize.Y,  halfSize.Z),
		vect3New( halfSize.X,  halfSize.Y, -halfSize.Z),
		vect3New( halfSize.X,  halfSize.Y,  halfSize.Z),
	}

	-- Transform them into world space
	local minX, minY, minZ = HUGE, HUGE, HUGE
	local maxX, maxY, maxZ = -HUGE, -HUGE, -HUGE

	for _, corner in ipairs(corners) do
		local worldPos = cf:PointToWorldSpace(corner)
		if worldPos.X < minX then minX = worldPos.X end
		if worldPos.Y < minY then minY = worldPos.Y end
		if worldPos.Z < minZ then minZ = worldPos.Z end

		if worldPos.X > maxX then maxX = worldPos.X end
		if worldPos.Y > maxY then maxY = worldPos.Y end
		if worldPos.Z > maxZ then maxZ = worldPos.Z end
	end

	-- Compute final axis-aligned center & size
	local alignedSize = vect3New(maxX - minX, maxY - minY, maxZ - minZ)
	local alignedCenter = vect3New(
		0.5 * (minX + maxX),
		0.5 * (minY + maxY),
		0.5 * (minZ + maxZ)
	)

	debug.profileend()
	return alignedCenter, alignedSize
end

do
	local function defaultFilter(instance: Instance): boolean
		return instance:IsA("BasePart")
	end

	--[[
		Gets the oriented bounding box of the part/model. All parts are included by default.
		<strong>params</strong>: Optionally filter what instances are used to calculate the extents of the bounding box.
		Including a blank raycast parameter will automatically exclude all non-CanQuery parts!
		SUPPORTED:
		<strong>RespectCanCollide</strong>: Include only collideable parts.
		<strong>FilterDescendantsInstances</strong>: Include/exclude based on <strong>FilterType</strong>. An empty table will be ignored.
		NOT SUPPORTED YET:
		<strong>CollisionGroup</strong>
	]]
	@native
	function Module.getOrientedBoundingBox(target: Model | BasePart, params: RaycastParams?): (CFrame, Vector3)
		debug.profilebegin("FunctionUtils::getOrientedBoundingBox")
		local filter: (Instance) -> boolean
		if params then
			local roots = params.FilterDescendantsInstances or {}
			local filterType = params.FilterType or Enum.RaycastFilterType.Exclude
			local respectCanCollide = params.RespectCanCollide
			local rootCount = #roots

			filter = function(part)
				if not part:IsA("BasePart") then
					return false
				end
				if not part.CanQuery then
					return false
				end
				if respectCanCollide and not part.CanCollide then
					return false
				end

				if rootCount > 0 then
					if filterType == Enum.RaycastFilterType.Exclude then
						for _, r in ipairs(roots) do
							if part:IsDescendantOf(r) then
								return false
							end
						end
					else
						for _, r in ipairs(roots) do
							if part:IsDescendantOf(r) then
								return true
							end
						end
						return false
					end
				end

				return true
			end
		else
			filter = defaultFilter
		end

		-- collect all valid BaseParts
		local parts: { BasePart } = {}
		if target:IsA("Model") then
			local i = 0
			for _, desc: any in ipairs(target:GetDescendants()) do
				if filter(desc) then
					i += 1
					parts[i] = desc
				end
			end
		elseif target:IsA("BasePart") then
			if filter(target) then
				parts[1] = target
			end
		end

		if #parts == 0 then
			error("getOrientedBoundingBox: no valid parts to bound", 2)
		end

		-- pick the orientation CFrame
		local orientCFrame: CFrame
		if target:IsA("BasePart") then
			-- use the part’s CFrame but zero out translation
			local cf = target:GetPivot()
			orientCFrame = CFrame.fromMatrix(
				Vector3.zero,
				cf.RightVector,
				cf.UpVector,
				cf.LookVector
			)
		else
			-- model: use its PrimaryPart’s orientation
			local pivot = target:GetPivot()
			orientCFrame = CFrame.fromMatrix(
				Vector3.zero,
				pivot.RightVector,
				pivot.UpVector,
				pivot.LookVector
			)
		end

		-- accumulate min/max in the target’s local space
		local mMin, mMax, mAbs = min, max, abs

		local minX, minY, minZ = HUGE, HUGE, HUGE
		local maxX, maxY, maxZ = -HUGE, -HUGE, -HUGE

		-- cache the local‐space axes
		local localRight, localUp, localLook = orientCFrame.RightVector, orientCFrame.UpVector, orientCFrame.LookVector

		for _, part in ipairs(parts) do
			-- each part’s half‐size
			local halfSize = part.Size * 0.5
			-- world‐space axes of the part
			local right, up, left = part.CFrame.RightVector, part.CFrame.UpVector, part.CFrame.LookVector

			-- projected extents along each *local* axis
			local ex = halfSize.X * mAbs(right:Dot(localRight))
				+ halfSize.Y * mAbs(up:Dot(localRight))
				+ halfSize.Z * mAbs(left:Dot(localRight))

			local ey = halfSize.X * mAbs(right:Dot(localUp))
				+ halfSize.Y * mAbs(up:Dot(localUp))
				+ halfSize.Z * mAbs(left:Dot(localUp))

			local ez = halfSize.X * mAbs(right:Dot(localLook))
				+ halfSize.Y * mAbs(up:Dot(localLook))
				+ halfSize.Z * mAbs(left:Dot(localLook))

			-- center of the part in local coords
			local localPos = orientCFrame:PointToObjectSpace(part.CFrame.Position)

			-- update mins/maxs in local space
			minX = mMin(minX, localPos.X - ex)
			maxX = mMax(maxX, localPos.X + ex)
			minY = mMin(minY, localPos.Y - ey)
			maxY = mMax(maxY, localPos.Y + ey)
			minZ = mMin(minZ, localPos.Z - ez)
			maxZ = mMax(maxZ, localPos.Z + ez)
		end

		-- compute final center & extents, and reproject center back into world
		local centerLocal  = vect3New(
			(minX + maxX) * 0.5,
			(minY + maxY) * 0.5,
			(minZ + maxZ) * 0.5
		)
		local extentsLocal = vect3New(
			(maxX - minX),
			(maxY - minY),
			(maxZ - minZ)
		)

		-- world-space CFrame of the oriented box
		local worldCenterCFrame = orientCFrame * cfNew(centerLocal)

		debug.profileend()
		return worldCenterCFrame, extentsLocal
	end

	--[[
		Gets the world axis-aligned bounding box of the part/model. All parts are included by default.
		<strong>params</strong>: Optionally filter what instances are used to calculate the extents of the bounding box.
		Including a blank raycast parameter will automatically exclude all non-CanQuery parts!
		SUPPORTED:
		<strong>RespectCanCollide</strong>: Include only collideable parts.
		<strong>FilterDescendantsInstances</strong>: Include/exclude based on <strong>FilterType</strong>. An empty table will be ignored.
		NOT SUPPORTED YET:
		<strong>CollisionGroup</strong>
	]] 
	@native
	function Module.getAxisAlignedBoundingBox(target: any, params: RaycastParams?): (CFrame, Vector3)
		debug.profilebegin("FunctionUtils::getAxisAlignedBoundingBox")
		-- build filter once
		local filter: (any) -> (boolean)
		if params then
			local roots = params.FilterDescendantsInstances
			local filterType = params.FilterType or Enum.RaycastFilterType.Exclude
			local respectCanCollide = params.RespectCanCollide
			local rootCount = #roots

			filter = function(part)
				if not part:IsA("BasePart") then
					return false
				end
				if not part.CanQuery then
					return false
				end
				if respectCanCollide and not part.CanCollide then
					return false
				end

				if rootCount > 0 then
					if filterType == Enum.RaycastFilterType.Exclude then
						for _, root in ipairs(roots) do
							if part:IsDescendantOf(root) then
								return false
							end
						end
					else
						for _, root in ipairs(roots) do
							if part:IsDescendantOf(root) then
								return true
							end
						end
						return false
					end
				end

				return true
			end
		else
			filter = defaultFilter
		end

		-- collect parts
		local parts: { BasePart } = {}
		if target:IsA("Model") then
			local i = 0
			for _, desc in ipairs(target:GetDescendants()) do
				if filter(desc) then
					i += 1
					parts[i] = desc
				end
			end
		elseif target:IsA("BasePart") then
			if filter(target) then
				parts[1] = target
			end
		end

		if #parts == 0 then
			error("getAxisAlignedBoundingBox: no valid parts to bound", 2)
		end

		-- setup locals for math
		local mMin, mMax, mAbs = min, max, abs
		local minX, minY, minZ = HUGE, HUGE, HUGE
		local maxX, maxY, maxZ = -HUGE, -HUGE, -HUGE

		-- single-pass AABB per part
		for _, part in ipairs(parts) do
			local cf = part.CFrame
			local pos = cf.Position
			local halfSize = part.Size * 0.5
			local right, up, left = cf.RightVector, cf.UpVector, cf.LookVector

			local xExtent = halfSize.X * mAbs(right.X) 
				+ halfSize.Y * mAbs(up.X) 
				+ halfSize.Z * mAbs(left.X)
			local yExtent = halfSize.X * mAbs(right.Y) 
				+ halfSize.Y * mAbs(up.Y) 
				+ halfSize.Z * mAbs(left.Y)
			local zExtent = halfSize.X * mAbs(right.Z) 
				+ halfSize.Y * mAbs(up.Z) 
				+ halfSize.Z * mAbs(left.Z)

			minX = mMin(minX, pos.X - xExtent)
			maxX = mMax(maxX, pos.X + xExtent)
			minY = mMin(minY, pos.Y - yExtent)
			maxY = mMax(maxY, pos.Y + yExtent)
			minZ = mMin(minZ, pos.Z - zExtent)
			maxZ = mMax(maxZ, pos.Z + zExtent)
		end

		-- 6) build result
		local center  = vect3New((minX + maxX) * 0.5,
			(minY + maxY) * 0.5,
			(minZ + maxZ) * 0.5)
		local extents = vect3New(maxX - minX,
			maxY - minY,
			maxZ - minZ)

		debug.profileend()
		return cfNew(center), extents
	end
end

-- Grabs the bounding box of a part or model.
-- For a rotationally-static bounding box, use <code>getPartExtentsSize()</code> or <code>getWorldBoundingBox()</code>.
function Module.getBoundingBox(instance: BasePart | Model): (CFrame, Vector3)
	if instance:IsA("BasePart") then
		return instance.CFrame, instance.Size
	elseif instance:IsA("Model") then
		return instance:GetBoundingBox()
	end
	error("Invalid instance", 2)
end

-- Calculates the bounding box that perfectly encapsulates the part/model aligned with the camera's axes.
-- <strong>camera</strong>: Defaults to workspace.CurrentCamera if not provided.
function Module.getCameraAlignedBoundingBox(instance: BasePart | Model, camera: Camera?): (CFrame, Vector3)
	debug.profilebegin("FunctionUtils::getCameraAlignedBoundingBox")
	local camera = camera or workspace.CurrentCamera
	if not camera then
		return CFrame.identity, Vector3.zero
	end

	local baseCFrame, size do
		if instance:IsA("BasePart") then
			baseCFrame, size = instance.CFrame, instance.Size
		elseif instance:IsA("Model") then
			baseCFrame, size = instance:GetBoundingBox()
		else
			return CFrame.identity, Vector3.zero
		end
	end

	local halfSize = size * 0.5
	local corners = {
		vect3New(-halfSize.X, -halfSize.Y, -halfSize.Z),
		vect3New(-halfSize.X, -halfSize.Y,  halfSize.Z),
		vect3New(-halfSize.X,  halfSize.Y, -halfSize.Z),
		vect3New(-halfSize.X,  halfSize.Y,  halfSize.Z),
		vect3New( halfSize.X, -halfSize.Y, -halfSize.Z),
		vect3New( halfSize.X, -halfSize.Y,  halfSize.Z),
		vect3New( halfSize.X,  halfSize.Y, -halfSize.Z),
		vect3New( halfSize.X,  halfSize.Y,  halfSize.Z),
	}

	local camCF = camera.CFrame
	local minX, minY, minZ = HUGE, HUGE, HUGE
	local maxX, maxY, maxZ = -HUGE, -HUGE, -HUGE

	for _, cornerLocal in ipairs(corners) do
		local cornerWorld = baseCFrame:PointToWorldSpace(cornerLocal)
		local cornerCam   = camCF:PointToObjectSpace(cornerWorld)

		if cornerCam.X < minX then minX = cornerCam.X end
		if cornerCam.Y < minY then minY = cornerCam.Y end
		if cornerCam.Z < minZ then minZ = cornerCam.Z end

		if cornerCam.X > maxX then maxX = cornerCam.X end
		if cornerCam.Y > maxY then maxY = cornerCam.Y end
		if cornerCam.Z > maxZ then maxZ = cornerCam.Z end
	end

	local minCam = vect3New(minX, minY, minZ)
	local maxCam = vect3New(maxX, maxY, maxZ)
	local centerCam = (minCam + maxCam) * 0.5
	local extentCam = maxCam - minCam

	local centerWorld = camCF:PointToWorldSpace(centerCam)
	local rotationOnly = camCF - camCF.Position

	local boundingBoxCF = rotationOnly + centerWorld

	debug.profileend()
	return boundingBoxCF, extentCam
end

-- Returns the world position that represents the anchor point for the BillboardGui.
-- This calculation accurately takes into account the billboard's extents and studs offset properties.
function Module.getBillboardWorldPosition(billboardGui: BillboardGui, camera: Camera?): Vector3?
	local adornee: Attachment | BasePart | Model = (billboardGui.Adornee or billboardGui.Parent) :: any
	if not adornee then
		return
	end
	debug.profilebegin("FunctionUtils::getBillboardWorldPosition")

	local adorneeCFrame
	if adornee:IsA("Attachment") then
		adorneeCFrame = adornee.WorldCFrame
	elseif adornee:IsA("BasePart") then
		adorneeCFrame = adornee.CFrame
	elseif adornee:IsA("Model") then
		-- For a model, Roblox uses bounding-box CFrame instead of :GetPivot()
		local cf, _ = adornee:GetBoundingBox()
		adorneeCFrame = cf
	else
		debug.profileend()
		return
	end

	local camera = camera or workspace.CurrentCamera
	if not camera then
		debug.profileend()
		return
	end

	local finalPos = adorneeCFrame.Position

	-- 'StudsOffsetWorldSpace' is a bit misleading because the the offset is applied based on the adornee's axes and not the world axes.
	-- But technically the Vector offset is in world space.
	finalPos = finalPos + adorneeCFrame:VectorToWorldSpace(billboardGui.StudsOffsetWorldSpace)

	-- Offset based on camera's orientation (excluding position since the camera is not the adornee).
	local camCFrame = camera.CFrame
	local camRot = camCFrame - camCFrame.Position
	local studsOffset = billboardGui.StudsOffset
	local studsOffsetWorld = camRot:VectorToWorldSpace(studsOffset)
	finalPos = finalPos + studsOffsetWorld

	-- Extents properties are ignored for attachments!
	if not adornee:IsA("Attachment") then
		-- EXTENTS OFFSET WORLD SPACE --
		if billboardGui.ExtentsOffsetWorldSpace ~= Vector3.zero then
			local offset = billboardGui.ExtentsOffsetWorldSpace

			-- Get the bounding-box size in world axes
			local cframe, sizeWS = Module.getBoundingBox(adornee)
			local halfSizeWS = sizeWS * 0.5

			-- Multiply per-axis
			local offset = vect3New(
				halfSizeWS.X * offset.X,
				halfSizeWS.Y * offset.Y,
				halfSizeWS.Z * offset.Z
			)

			offset = cframe:VectorToWorldSpace(offset)
			finalPos += offset
		end

		-- EXTENTS OFFSET --
		if billboardGui.ExtentsOffset ~= Vector3.zero then
			local offset = billboardGui.ExtentsOffset

			-- Get camera-aligned bounding box size
			local _, sizeCam = Module.getCameraAlignedBoundingBox(adornee, camera)
			local halfSizeCam = sizeCam * 0.5

			-- Scale the offset by half the camera bounding box
			local offsetCamSpace = vect3New(
				halfSizeCam.X * offset.X,
				halfSizeCam.Y * offset.Y,
				halfSizeCam.Z * offset.Z
			)

			-- Rotate from camera space to world space
			-- We'll get pure rotation from the camera by subtracting translation:
			local camCFrame = camera.CFrame
			local camRotOnly = camCFrame - camCFrame.Position

			offset = camRotOnly:VectorToWorldSpace(offsetCamSpace)
			finalPos += offset
		end
	end

	debug.profileend()
	return finalPos
end

-- Given a ground position and model, this returns what the model should be :PivotTo() for a flush ground position.
function Module.getPivotFlushWithGround(groundPoint: CFrame, model: Model): CFrame
	local pivot = model:GetPivot()
	local center, size = model:GetBoundingBox()

	local bottomWorld = vect3New(
		center.X,
		center.Y - size.Y / 2,
		center.Z
	)

	local offset = pivot:PointToObjectSpace(bottomWorld)

	return groundPoint * cfNew(-offset)
end

-- Resizes the model via <code>:ScaleTo()</code> to ensure it's scaled to the given spherical volume.
function Module.resizeModelToFitRadius(model: Model, radius: number)
	assert(typeof(radius) == "number" and radius > 0, "Invalid radius")

	local pivotCFrame, size = model:GetBoundingBox()

	local currentRadius = size.Magnitude * 0.5
	if currentRadius <= 0 then return end

	local currentScale = model:GetScale()
	local desiredScale = (radius / currentRadius) * currentScale

	model:ScaleTo(desiredScale)
end

-- Returns the central bottom point of the model's bounding box (includes orientation)
function Module.getBottomPositionOfModel(model: Model): Vector3
	local boundingBox, size = model:GetBoundingBox()
	return (boundingBox * cfNew(0, -size.Y / 2, 0)).Position
end

-- A write-safe alternative to <code>TweenService:GetValue()</code> (which is not safe to call in parallel).
function Module.getTweenValue(alpha: number, easingStyle: Enum.EasingStyle, easingDirection: Enum.EasingDirection): number
	local easingStyleFunc = _easingStyle[easingStyle.Name]
	local easingDirectionFunc = _easingDirection[easingDirection.Name]
	return easingDirectionFunc(alpha, easingStyleFunc)
end

function Module.getActualFriction(propA: PhysicalProperties, propB: PhysicalProperties): number
	return (propA.Friction * propA.FrictionWeight + propB.Friction * propB.FrictionWeight) / (propA.FrictionWeight + propB.FrictionWeight)
end

-- Converts the Vector3 to a Vector2 by dropping the Z component
function Module.toVect2(v: Vector3): Vector2
	return vect2New(v.X, v.Y)
end

-- Returns 1 if true or -1 if false
function Module.fromBoolean(bool: boolean): number
	return if bool then 1 else -1
end

return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004324</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX4C36C5E0335E41AA9486AEEB792B5F80">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">384478d2831029b307b2adbd00005af6</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_easingStyle</string>
								<string name="ScriptGuid">{709AB7E2-112E-44F9-922D-C91FD6B46786}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
return {
	Back = require(script.Back),
	Bounce = require(script.Bounce),
	Circular = require(script.Circular),
	Cubic = require(script.Cubic),
	Elastic = require(script.Elastic),
	Exponential = require(script.Exponential),
	Linear = require(script.Linear),
	Quad = require(script.Quad),
	Quart = require(script.Quart),
	Quint = require(script.Quint),
	Sine = require(script.Sine)
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004325</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXC48A75EC598649CBBCC5FB39C4BB5854">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">384478d2831029b307b2adbd00005af7</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Quad</string>
									<string name="ScriptGuid">{C7C22027-380C-4FFF-8AE3-C6A0FAE0DD76}</string>
									<ProtectedString name="Source"><![CDATA[return function(completed)
	return completed ^ 2
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004326</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4D1BDB4D31684596AEE4C0670BB29F11">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">384478d2831029b307b2adbd00005af8</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Quart</string>
									<string name="ScriptGuid">{29DF8650-6105-43AB-A188-190B039846D2}</string>
									<ProtectedString name="Source"><![CDATA[return function(completed)
	return completed ^ 4
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004327</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBD52DC4045D64192968E59C8A7D444F8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">384478d2831029b307b2adbd00005af9</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Quint</string>
									<string name="ScriptGuid">{BFFC0437-F448-4E94-9B33-89D778214422}</string>
									<ProtectedString name="Source"><![CDATA[return function(completed)
	return completed ^ 5
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004328</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX0D1C1D1867D54D5DB626F36BCDFAA612">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">384478d2831029b307b2adbd00005afa</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Sine</string>
									<string name="ScriptGuid">{2FCCEDBE-9FBC-4245-AB10-2DB697C686D0}</string>
									<ProtectedString name="Source"><![CDATA[local sin = math.sin
local halfpi = math.pi / 2

return function(completed)
	return sin(completed * halfpi - halfpi) + 1
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004329</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX24D6823CA22E4C6A89B7D57C58D52718">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">384478d2831029b307b2adbd00005afb</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Linear</string>
									<string name="ScriptGuid">{ED4C362F-544D-4F21-A1A9-9A82A8AC6C7B}</string>
									<ProtectedString name="Source"><![CDATA[return function(completed)
	return completed
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000432a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX12CB8FA4B1224AD28FF208B68337F9E4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">384478d2831029b307b2adbd00005afc</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Cubic</string>
									<string name="ScriptGuid">{7113B5D2-145F-487C-BC4A-840A30733A78}</string>
									<ProtectedString name="Source"><![CDATA[return function(completed)
	return completed ^ 3
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000432b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA3E531BEE3224C4EB547FEBC84C9C48B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">384478d2831029b307b2adbd00005afd</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Circular</string>
									<string name="ScriptGuid">{ADD28EBF-73D7-4E1B-B1F4-828432911A27}</string>
									<ProtectedString name="Source"><![CDATA[return function(completed)
	return 1 - (1 - completed ^ 2) ^ .5
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000432c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5F0BCF5B28514412BB8E8FD0E79A33A3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">384478d2831029b307b2adbd00005afe</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Exponential</string>
									<string name="ScriptGuid">{D04F4D9E-29F8-4D48-B4F1-87E1389787BC}</string>
									<ProtectedString name="Source"><![CDATA[--https://github.com/jesusgollonet/ofpennereasing/blob/master/PennerEasing/Expo.cpp

return function(completed)
	return 2 ^ (10 * (completed - 1))
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000432d</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF3DA018661EB46BDAC2C7F095D443F33">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">384478d2831029b307b2adbd00005aff</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Bounce</string>
									<string name="ScriptGuid">{3C575B27-3896-4014-A0BF-E6C9912B0314}</string>
									<ProtectedString name="Source"><![CDATA[--https://github.com/jesusgollonet/ofpennereasing/blob/master/PennerEasing/Bounce.cpp


local bounce = function(completed)
	if completed < 1 / 2.75 then
		return 7.5625 * completed ^ 2
	elseif completed < 2 / 2.75 then
		completed = completed - 1.5 / 2.75
		return 7.5625 * completed ^ 2 + 0.75
	elseif completed < 2.5 / 2.75 then
		completed = completed - 2.25 / 2.75
		return 7.5625 * completed ^ 2 + 0.9375
	else
		completed = completed - 2.625 / 2.75
		return 7.5625 * completed ^ 2 + 0.984375
	end
end

return function(completed)
	return 1 - bounce(completed) --For some reason, the mathematician behind these easing styles decided that easing should be inverted on this style. For another reason, Roblox agreed.
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000432e</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX00CCC85378A74A4EBDE3E0B45C4E39E1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">384478d2831029b307b2adbd00005b00</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Elastic</string>
									<string name="ScriptGuid">{D3AC3A80-81C2-47ED-A5EE-011BA78339F4}</string>
									<ProtectedString name="Source"><![CDATA[--https://github.com/jesusgollonet/ofpennereasing/blob/master/PennerEasing/Elastic.cpp

local sin = math.sin
local tau = math.pi * 2

return function(completed)
	return -(2 ^ (10 * (completed - 1)) * sin((completed - 1 - 3 / 40) * tau / .3))
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000432f</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXEBB8054CA1FD4CF9B55711F24F2EC6A9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">384478d2831029b307b2adbd00005b01</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Back</string>
									<string name="ScriptGuid">{8FDCD4AA-3197-4B81-813D-6EF303475AD1}</string>
									<ProtectedString name="Source"><![CDATA[--https://github.com/jesusgollonet/ofpennereasing/blob/master/PennerEasing/Back.cpp

local s = 1.70158 --cool variable name penner

return function(completed)
	return completed ^ 2 * ((s + 1) * completed - s)
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004330</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXE9F26FB643F649009CCC610A507992D9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">384478d2831029b307b2adbd00005b02</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_easingDirection</string>
								<string name="ScriptGuid">{749A546E-FD9A-4512-85CF-AEB382A014B7}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
return {
	In = require(script.In),
	InOut = require(script.InOut),
	Out = require(script.Out),
	OutIn = require(script.OutIn)
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004331</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX46FAAF8AC66A42BA8A1D73AADB1DD699">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">384478d2831029b307b2adbd00005b03</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">In</string>
									<string name="ScriptGuid">{87E99040-D0E9-4497-B909-C17533B020CD}</string>
									<ProtectedString name="Source"><![CDATA[local easeIn = function(alpha, fun)
	return fun(alpha)
end

return easeIn]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004332</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD1E9988E5CFB42BC92F99505DF61A79D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">384478d2831029b307b2adbd00005b04</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Out</string>
									<string name="ScriptGuid">{E5D00FD4-766C-4C30-BC46-841E150725E1}</string>
									<ProtectedString name="Source"><![CDATA[local easeOut = function(alpha, fun)
	return 1 - fun(1 - alpha)
end

return easeOut]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004333</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF41A95B312BD4A0A964DCCF601BAD229">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">384478d2831029b307b2adbd00005b05</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">InOut</string>
									<string name="ScriptGuid">{7E99C2EF-CE25-4A61-977B-7F537B3EE228}</string>
									<ProtectedString name="Source"><![CDATA[local easeIn = require(script.Parent.In)
local easeOut = require(script.Parent.Out)

local easeInOut = function(alpha, fun)
	if alpha < .5 then
		return easeIn(alpha * 2, fun) * .5
	else
		return .5 + easeOut(alpha * 2 - 1, fun) * .5
	end
end

return easeInOut]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004334</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD4F0B3AA8AE74A3BA4642E7F221651B3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">384478d2831029b307b2adbd00005b06</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">OutIn</string>
									<string name="ScriptGuid">{023E1168-E893-43B8-B2E4-197048E26354}</string>
									<ProtectedString name="Source"><![CDATA[local easeIn = require(script.Parent.In)
local easeOut = require(script.Parent.Out)

local easeOutIn = function(alpha, fun)
	if alpha < .5 then
		return easeOut(alpha * 2, fun) * .5
	else
		return .5 + easeIn(alpha * 2 - 1, fun) * .5
	end
end

return easeOutIn]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004335</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX0A0DC2EAA27A423C8C1CDAC02E41D8CC">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009648</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_table</string>
							<string name="ScriptGuid">{2D593746-0305-458D-A33B-FA64BAC3B701}</string>
							<ProtectedString name="Source"><![CDATA[--!strict

-- TableUtil
-- Stephen Leitnick
-- September 13, 2017

--[=[
	@class TableUtil

	A collection of helpful table utility functions. Many of these functions are carried over from JavaScript or
	Python that are not present in Lua.

	Tables that only work specifically with arrays or dictionaries are marked as such in the documentation.

	:::info Immutability
	All functions (_except_ `SwapRemove`, `SwapRemoveFirstValue`, and `Lock`) treat tables as immutable and will return
	copies of the given table(s) with the operations performed on the copies.
]=]
local Module = {}

local HttpService = game:GetService("HttpService")
local rng = Random.new()

--[[
	Given an array of values (must be comparable with ==), remove any duplicate values.
]]
function Module.removeDuplicates<T>(array: { T }): { T }
	local result = table.create(#array)
	local seen: { [T]: boolean } = {}
	
	for _, value in ipairs(array) do
		if not seen[value] then
			table.insert(result, value)
			seen[value] = true
		end
	end
	
	return result
end

do
	local metatables = {
		k = { __mode = "k" },
		v = { __mode = "v" },
		kv = { __mode = "kv" }
	}
	-- Creates and returns a new weak table for caching purposes.
	function Module.weakCache(mode: "k" | "v" | "kv"): { [any]: any }
		return setmetatable({}, metatables[mode]) :: any
	end
end

--[=[
	@within TableUtil
	@function Copy
	@param tbl table -- Table to copy
	@param deep boolean? -- Whether or not to perform a deep copy
	@return table

	Creates a copy of the given table. By default, a shallow copy is
	performed. For deep copies, a second boolean argument must be
	passed to the function.

	:::caution No cyclical references
	Deep copies are _not_ protected against cyclical references. Passing
	a table with cyclical references _and_ the `deep` parameter set to
	`true` will result in a stack-overflow.
]=]
local function Copy<T>(t: T, deep: boolean?): T
	if not deep then
		return (table.clone(t :: any) :: any) :: T
	end
	local function deepCopy(object: any)
		assert(typeof(object) == "table", "Expected table for deepCopy!")
		-- Returns a deep copy of the provided table.
		local newObject = setmetatable({}, getmetatable(object)) -- Clone metaData

		for index: any, value: any in object do
			if typeof(value) == "table" then
				newObject[index] = deepCopy(value)
				continue
			end

			newObject[index] = value
		end

		return newObject
	end
	return deepCopy(t :: any) :: T
end



--[=[
	@within TableUtil
	@function Sync
	@param srcTbl table -- Source table
	@param templateTbl table -- Template table
	@return table

	Synchronizes the `srcTbl` based on the `templateTbl`. This will make
	sure that `srcTbl` has all of the same keys as `templateTbl`, including
	removing keys in `srcTbl` that are not present in `templateTbl`. This
	is a _deep_ operation, so any nested tables will be synchronized as
	well.

	```lua
	local template = {kills = 0, deaths = 0, xp = 0}
	local data = {kills = 10, experience = 12}
	data = TableUtil.Sync(data, template)
	print(data) --> {kills = 10, deaths = 0, xp = 0}
	```

	:::caution Data Loss Warning
	This is a two-way sync, so the source table will have data
	_removed_ that isn't found in the template table. This can
	be problematic if used for player data, where there might
	be dynamic data added that isn't in the template.

	For player data, use `TableUtil.Reconcile` instead.
]=]
local function Sync<S, T>(srcTbl: S, templateTbl: T): T
	assert(type(srcTbl) == "table", "First argument must be a table")
	assert(type(templateTbl) == "table", "Second argument must be a table")

	local tbl = table.clone(srcTbl)

	-- If 'tbl' has something 'templateTbl' doesn't, then remove it from 'tbl'
	-- If 'tbl' has something of a different type than 'templateTbl', copy from 'templateTbl'
	-- If 'templateTbl' has something 'tbl' doesn't, then add it to 'tbl'
	for k, v in pairs(tbl) do
		local vTemplate = templateTbl[k]

		-- Remove keys not within template:
		if vTemplate == nil then
			tbl[k] = nil

			-- Synchronize data types:
		elseif type(v) ~= type(vTemplate) then
			if type(vTemplate) == "table" then
				tbl[k] = Copy(vTemplate, true)
			else
				tbl[k] = vTemplate
			end

			-- Synchronize sub-tables:
		elseif type(v) == "table" then
			tbl[k] = Sync(v, vTemplate)
		end
	end

	-- Add any missing keys:
	for k, vTemplate in pairs(templateTbl) do
		local v = tbl[k]

		if v == nil then
			if type(vTemplate) == "table" then
				tbl[k] = Copy(vTemplate, true)
			else
				tbl[k] = vTemplate
			end
		end
	end

	return (tbl :: any) :: T
end

--[=[
	@within TableUtil
	@function Reconcile
	@param source table
	@param template table
	@return table

	Performs a one-way sync on the `source` table against the
	`template` table. Any keys found in `template` that are
	not found in `source` will be added to `source`. This is
	useful for syncing player data against data template tables
	to ensure players have all the necessary keys, while
	maintaining existing keys that may no longer be in the
	template.

	This is a deep operation, so nested tables will also be
	properly reconciled.

	```lua
	local template = {kills = 0, deaths = 0, xp = 0}
	local data = {kills = 10, abc = 20}
	local correctedData = TableUtil.Reconcile(data, template)
	
	print(correctedData) --> {kills = 10, deaths = 0, xp = 0, abc = 20}
	```
]=]
local function Reconcile<S, T>(src: S, template: T): S & T
	assert(type(src) == "table", "First argument must be a table")
	assert(type(template) == "table", "Second argument must be a table")

	local tbl = table.clone(src)

	for k, v in template do
		local sv = src[k]
		if sv == nil then
			if type(v) == "table" then
				tbl[k] = Copy(v, true)
			else
				tbl[k] = v
			end
		elseif type(sv) == "table" then
			if type(v) == "table" then
				tbl[k] = Reconcile(sv, v)
			else
				tbl[k] = Copy(sv, true)
			end
		end
	end

	return (tbl :: any) :: S & T
end

--[=[
	@within TableUtil
	@function SwapRemove
	@param tbl table -- Array
	@param i number -- Index

	Removes index `i` in the table by swapping the value at `i` with
	the last value in the array, and then trimming off the last
	value from the array.

	This allows removal of the value at `i` in `O(1)` time, but does
	not preserve array ordering. If a value needs to be removed from
	an array, but ordering of the array does not matter, using
	`SwapRemove` is always preferred over `table.remove`.

	In the following example, we remove "B" at index 2. SwapRemove does
	this by moving the last value "E" over top of "B", and then trimming
	off "E" at the end of the array:
	```lua
	local t = {"A", "B", "C", "D", "E"}
	TableUtil.SwapRemove(t, 2) -- Remove "B"
	print(t) --> {"A", "E", "C", "D"}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function SwapRemove<T>(t: { T }, i: number)
	local n = #t
	t[i] = t[n]
	t[n] = nil
end

--[=[
	@within TableUtil
	@function SwapRemoveFirstValue
	@param tbl table -- Array
	@param v any -- Value to find
	@return number?

	Performs `table.find(tbl, v)` to find the index of the given
	value, and then performs `TableUtil.SwapRemove` on that index.

	```lua
	local t = {"A", "B", "C", "D", "E"}
	TableUtil.SwapRemoveFirstValue(t, "C")
	print(t) --> {"A", "B", "E", "D"}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function SwapRemoveFirstValue<T>(t: { T }, v: T): number?
	local index: number? = table.find(t, v)
	if index then
		SwapRemove(t, index)
	end
	return index
end

--[=[
	@within TableUtil
	@function Map
	@param tbl table
	@param predicate (value: any, key: any, tbl: table) -> newValue: any
	@return table

	Performs a map operation against the given table, which can be used to
	map new values based on the old values at given keys/indices.

	For example:

	```lua
	local t = {A = 10, B = 20, C = 30}
	local t2 = TableUtil.Map(t, function(value)
		return value * 2
	end)
	print(t2) --> {A = 20, B = 40, C = 60}
	```
]=]
local function Map<T, M>(t: { T }, f: (T, number, { T }) -> M): { M }
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be a function")
	local newT = table.create(#t)
	for k, v in t do
		newT[k] = f(v, k, t)
	end
	return newT
end

--[=[
	@within TableUtil
	@function Filter
	@param tbl table
	@param predicate (value: any, key: any, tbl: table) -> keep: boolean
	@return table

	Performs a filter operation against the given table, which can be used to
	filter out unwanted values from the table.

	For example:

	```lua
	local t = {A = 10, B = 20, C = 30}
	local t2 = TableUtil.Filter(t, function(value, key)
		return value > 15
	end)
	print(t2) --> {B = 20, C = 30}
	```
]=]
local function Filter<T>(t: { T }, shouldKeep: (T, any, { T }) -> boolean): { T }
	assert(type(t) == "table", "First argument must be a table")
	assert(type(shouldKeep) == "function", "Second argument must be a function")
	local newT = table.create(#t)
	if #t > 0 then
		local n = 0
		for i, v in t do
			if shouldKeep(v, i, t) then
				n += 1
				newT[n] = v
			end
		end
	else
		for k, v in t do
			if shouldKeep(v, k, t) then
				newT[k] = v
			end
		end
	end
	return newT
end

--[=[
	@within TableUtil
	@function Reduce
	@param tbl table
	@param predicate (accumulator: any, value: any, index: any, tbl: table) -> result: any
	@return table

	Performs a reduce operation against the given table, which can be used to
	reduce the table into a single value. This could be used to sum up a table
	or transform all the values into a compound value of any kind.

	For example:

	```lua
	local t = {10, 20, 30, 40}
	local result = TableUtil.Reduce(t, function(accum, value)
		return accum + value
	end)
	print(result) --> 100
	```
]=]
local function Reduce<T, R>(t: { T }, predicate: (R, T, any, { T }) -> R, init: R): R
	assert(type(t) == "table", "First argument must be a table")
	assert(type(predicate) == "function", "Second argument must be a function")
	local result = init :: R
	if #t > 0 then
		local start = 1
		if init == nil then
			result = (t[1] :: any) :: R
			start = 2
		end
		for i = start, #t do
			result = predicate(result, t[i], i, t)
		end
	else
		local start = nil
		if init == nil then
			result = (next(t) :: any) :: R
			start = result
		end
		for k, v in next, t, start :: any? do
			result = predicate(result, v, k, t)
		end
	end
	return result
end

--[=[
	@within TableUtil
	@function Assign
	@param target table
	@param ... table
	@return table

	Copies all values of the given tables into the `target` table.

	```lua
	local t = {A = 10}
	local t2 = {B = 20}
	local t3 = {C = 30, D = 40}
	local newT = TableUtil.Assign(t, t2, t3)
	print(newT) --> {A = 10, B = 20, C = 30, D = 40}
	```
]=]
local function Assign<T>(target: { T }, ...: { any }): { T } & { any }
	local tbl = table.clone(target)
	for _, src in { ... } do
		for k, v in src do
			tbl[k] = v
		end
	end
	return tbl
end

--[=[
	@within TableUtil
	@function Extend
	@param target table
	@param extension table
	@return table

	Extends the target array with the extension array.

	```lua
	local t = {10, 20, 30}
	local t2 = {30, 40, 50}
	local tNew = TableUtil.Extend(t, t2)
	print(tNew) --> {10, 20, 30, 30, 40, 50}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function Extend<T, E>(target: { T }, extension: { E }): { T } & { E }
	local tbl = table.clone(target) :: { any }
	for _, v in extension do
		table.insert(tbl, v)
	end
	return tbl
end

--[=[
	@within TableUtil
	@function Reverse
	@param tbl table
	@return table

	Reverses the array.

	```lua
	local t = {1, 5, 10}
	local tReverse = TableUtil.Reverse(t)
	print(tReverse) --> {10, 5, 1}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function Reverse<T>(tbl: { T }): { T }
	local n = #tbl
	local tblRev = table.create(n)
	for i = 1, n do
		tblRev[i] = tbl[n - i + 1]
	end
	return tblRev
end

--[=[
	@within TableUtil
	@function Shuffle
	@param tbl table
	@param rngOverride Random?
	@return table

	Shuffles the table.

	```lua
	local t = {1, 2, 3, 4, 5, 6, 7, 8, 9}
	local shuffled = TableUtil.Shuffle(t)
	print(shuffled) --> e.g. {9, 4, 6, 7, 3, 1, 5, 8, 2}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function Shuffle<T>(tbl: { T }, rngOverride: Random?): { T }
	assert(type(tbl) == "table", "First argument must be a table")
	local shuffled = table.clone(tbl)
	local random = if typeof(rngOverride) == "Random" then rngOverride else rng
	for i = #tbl, 2, -1 do
		local j = random:NextInteger(1, i)
		shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
	end
	return shuffled
end

--[=[
	@within TableUtil
	@function Sample
	@param tbl table
	@param sampleSize number
	@param rngOverride Random?
	@return table

	Returns a random sample of the table.

	```lua
	local t = {1, 2, 3, 4, 5, 6, 7, 8, 9}
	local sample = TableUtil.Sample(t, 3)
	print(sample) --> e.g. {6, 2, 5}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function Sample<T>(tbl: { T }, size: number, rngOverride: Random?): { T }
	assert(type(tbl) == "table", "First argument must be a table")
	assert(type(size) == "number", "Second argument must be a number")

	-- If given table is empty, just return a new empty table:
	local len = #tbl
	if len == 0 then
		return {}
	end

	local shuffled = table.clone(tbl)
	local sample = table.create(size)
	local random = if typeof(rngOverride) == "Random" then rngOverride else rng

	-- Clamp sample size to be no larger than the given table size:
	size = math.clamp(size, 1, len)

	for i = 1, size do
		local j = random:NextInteger(i, len)
		shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
	end

	table.move(shuffled, 1, size, 1, sample)

	return sample
end

--[=[
	@within TableUtil
	@function Flat
	@param tbl table
	@param depth number?
	@return table

	Returns a new table where all sub-arrays have been
	bubbled up to the top. The depth at which the scan
	is performed is dictated by the `depth` parameter,
	which is set to `1` by default.

	```lua
	local t = {{10, 20}, {90, 100}, {30, 15}}
	local flat = TableUtil.Flat(t)
	print(flat) --> {10, 20, 90, 100, 30, 15}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function Flat<T>(tbl: { T }, depth: number?): { T }
	local maxDepth: number = if type(depth) == "number" then depth else 1
	local flatTbl = table.create(#tbl)
	local function Scan(t: { any }, d: number)
		for _, v in t do
			if type(v) == "table" and d < maxDepth then
				Scan(v, d + 1)
			else
				table.insert(flatTbl, v)
			end
		end
	end
	Scan(tbl, 0)
	return flatTbl
end

--[=[
	@within TableUtil
	@function FlatMap
	@param tbl table
	@param predicate (key: any, value: any, tbl: table) -> newValue: any
	@return table

	Calls `TableUtil.Map` on the given table and predicate, and then
	calls `TableUtil.Flat` on the result from the map operation.

	```lua
	local t = {10, 20, 30}
	local result = TableUtil.FlatMap(t, function(value)
		return {value, value * 2}
	end)
	print(result) --> {10, 20, 20, 40, 30, 60}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function FlatMap<T, M>(tbl: { T }, callback: (T, number, { T }) -> M): { M }
	return Flat(Map(tbl, callback))
end

--[=[
	@within TableUtil
	@function Keys
	@param tbl table
	@return table

	Returns an array with all the keys in the table.

	```lua
	local t = {A = 10, B = 20, C = 30}
	local keys = TableUtil.Keys(t)
	print(keys) --> {"A", "B", "C"}
	```

	:::caution Ordering
	The ordering of the keys is never guaranteed. If order is imperative, call
	`table.sort` on the resulting `keys` array.
	```lua
	local keys = TableUtil.Keys(t)
	table.sort(keys)
	```
]=]
local function Keys<K, V>(tbl: { [K]: V }): { K }
	local keys = table.create(#tbl)
	for k in tbl do
		table.insert(keys, k)
	end
	return keys
end

--[=[
	@within TableUtil
	@function Values
	@param tbl table
	@return table

	Returns an array with all the values in the table.

	```lua
	local t = {A = 10, B = 20, C = 30}
	local values = TableUtil.Values(t)
	print(values) --> {10, 20, 30}
	```

	:::caution Ordering
	The ordering of the values is never guaranteed. If order is imperative, call
	`table.sort` on the resulting `values` array.
	```lua
	local values = TableUtil.Values(t)
	table.sort(values)
	```
]=]
local function Values<K, V>(tbl: { [K]: V }): { V }
	local values = table.create(#tbl)
	for _, v in tbl do
		table.insert(values, v)
	end
	return values
end

--[=[
	@within TableUtil
	@function Find
	@param tbl table
	@param callback (value: any, index: any, tbl: table) -> boolean
	@return (value: any?, key: any?)

	Performs a linear scan across the table and calls `callback` on
	each item in the array. Returns the value and key of the first
	pair in which the callback returns `true`.

	```lua
	local t = {
		{Name = "Bob", Age = 20};
		{Name = "Jill", Age = 30};
		{Name = "Ann", Age = 25};
	}

	-- Find first person who has a name starting with J:
	local firstPersonWithJ = TableUtil.Find(t, function(person)
		return person.Name:sub(1, 1):lower() == "j"
	end)

	print(firstPersonWithJ) --> {Name = "Jill", Age = 30}
	```

	:::caution Dictionary Ordering
	While `Find` can also be used with dictionaries, dictionary ordering is never
	guaranteed, and thus the result could be different if there are more
	than one possible matches given the data and callback function.
]=]
local function Find<K, V>(tbl: { [K]: V }, callback: (V, K, { [K]: V }) -> boolean): (V?, K?)
	for k, v in tbl do
		if callback(v, k, tbl) then
			return v, k
		end
	end
	return nil, nil
end

--[=[
	@within TableUtil
	@function Every
	@param tbl table
	@param callback (value: any, index: any, tbl: table) -> boolean
	@return boolean

	Returns `true` if the `callback` also returns `true` for _every_
	item in the table.

	```lua
	local t = {10, 20, 40, 50, 60}

	local allAboveZero = TableUtil.Every(t, function(value)
		return value > 0
	end)

	print("All above zero:", allAboveZero) --> All above zero: true
	```
]=]
local function Every<K, V>(tbl: { [K]: V }, callback: (V, K, { [K]: V }) -> boolean): boolean
	for k, v in tbl do
		if not callback(v, k, tbl) then
			return false
		end
	end
	return true
end

--[=[
	@within TableUtil
	@function Some
	@param tbl table
	@param callback (value: any, index: any, tbl: table) -> boolean
	@return boolean

	Returns `true` if the `callback` also returns `true` for _at least
	one_ of the items in the table.

	```lua
	local t = {10, 20, 40, 50, 60}

	local someBelowTwenty = TableUtil.Some(t, function(value)
		return value < 20
	end)

	print("Some below twenty:", someBelowTwenty) --> Some below twenty: true
	```
]=]
local function Some<K, V>(tbl: { [K]: V }, callback: (V, K, { [K]: V }) -> boolean): boolean
	for k, v in tbl do
		if callback(v, k, tbl) then
			return true
		end
	end
	return false
end

--[=[
	@within TableUtil
	@function Truncate
	@param tbl table
	@param length number
	@return table

	Returns a new table truncated to the length of `length`. Any length
	equal or greater than the current length will simply return a
	shallow copy of the table.

	```lua
	local t = {10, 20, 30, 40, 50, 60, 70, 80}
	local tTruncated = TableUtil.Truncate(t, 3)
	print(tTruncated) --> {10, 20, 30}
	```
]=]
local function Truncate<T>(tbl: { T }, len: number): { T }
	local n = #tbl
	len = math.clamp(len, 1, n)
	return if len == n then table.clone(tbl) else table.move(tbl, 1, len, 1, table.create(len))
end

--[=[
	@within TableUtil
	@function Zip
	@param ... table
	@return (iter: (t: table, k: any) -> (key: any?, values: table?), tbl: table, startIndex: any?)

	Returns an iterator that can scan through multiple tables at the same time side-by-side, matching
	against shared keys/indices.

	```lua
	local t1 = {10, 20, 30, 40, 50}
	local t2 = {60, 70, 80, 90, 100}

	for key,values in TableUtil.Zip(t1, t2) do
		print(key, values)
	end

	--[[
		Outputs:
		1 {10, 60}
		2 {20, 70}
		3 {30, 80}
		4 {40, 90}
		5 {50, 100}
	--]]
	```
]=]
local function Zip(...: { [any]: any }): ((t: { any }, k: any) -> (any, any), { any }, any)
	assert(select("#", ...) > 0, "Must supply at least 1 table")
	local function ZipIteratorArray(all: { any }, k: number): (number?, { any }?)
		k += 1
		local values = {}
		for i, t in all do
			local v = t[k]
			if v ~= nil then
				values[i] = v
			else
				return nil, nil
			end
		end
		return k, values
	end
	local function ZipIteratorMap(all: { [any]: any }, k: any): (number?, { any }?)
		local values = {}
		for i, t in all do
			local v = next(t, k)
			if v ~= nil then
				values[i] = v
			else
				return nil, nil
			end
		end
		return k, values
	end
	local all = { ... }
	if #all[1] > 0 then
		return ZipIteratorArray, all, 0
	else
		return ZipIteratorMap, all, nil
	end
end

--[=[
	@within TableUtil
	@function Lock
	@param tbl table
	@return table

	Locks the table using `table.freeze`, as well as any
	nested tables within the given table. This will lock
	the whole deep structure of the table, disallowing any
	further modifications.

	```lua
	local tbl = {xyz = {abc = 32}}
	tbl.xyz.abc = 28 -- Works fine
	TableUtil.Lock(tbl)
	tbl.xyz.abc = 64 -- Will throw an error (cannot modify readonly table)
	```
]=]
local function Lock<T>(tbl: T): T
	local function Freeze(t: { [any]: any })
		for k, v in pairs(t) do
			if type(v) == "table" then
				t[k] = Freeze(v)
			end
		end
		return table.freeze(t)
	end
	return Freeze(tbl :: any)
end

--[=[
	@within TableUtil
	@function IsEmpty
	@param tbl table
	@return boolean

	Returns `true` if the given table is empty. This is
	simply performed by checking if `next(tbl)` is `nil`
	and works for both arrays and dictionaries. This is
	useful when needing to check if a table is empty but
	not knowing if it is an array or dictionary.

	```lua
	TableUtil.IsEmpty({}) -- true
	TableUtil.IsEmpty({"abc"}) -- false
	TableUtil.IsEmpty({abc = 32}) -- false
	```
]=]
local function IsEmpty(tbl: { [any]: any }): boolean
	return next(tbl) == nil
end

--[=[
	@within TableUtil
	@function EncodeJSON
	@param value any
	@return string

	Proxy for [`HttpService:JSONEncode`](https://developer.roblox.com/en-us/api-reference/function/HttpService/JSONEncode).
]=]
local function EncodeJSON(value: any): string
	return HttpService:JSONEncode(value)
end

--[=[
	@within TableUtil
	@function DecodeJSON
	@param value any
	@return string

	Proxy for [`HttpService:JSONDecode`](https://developer.roblox.com/en-us/api-reference/function/HttpService/JSONDecode).
]=]
local function DecodeJSON(str: string): any
	return HttpService:JSONDecode(str)
end

-- Checks if the tables store the exact same values. Can be used for __eq metamethod
function Module.checkTableEquality(table1: { [any]: any }, table2: { [any]: any }): boolean
	if type(table1) ~= type(table2) then return false end
	if table1 == table2 then
		return true
	end
	
	if rawequal(table1, table2) then
		return true
	end
	
	for i, v in pairs(table1) do
		if type(v) == 'table' then
			if not Module.checkTableEquality(v, table2[i]) then
				return false
			end
		else
			if table2[i] ~= v then
				return false
			end
		end
	end

	for i, v in pairs(table2) do
		if type(v) == 'table' then
			if not Module.checkTableEquality(v, table1[i]) then
				return false
			end
		else
			if table1[i] ~= v then
				return false
			end
		end
	end

	return true
end

function Module.getValueFromKeyRecursive(key: any, dictionary: {[any]: any}): any?
	if not rawget(dictionary, key) then
		for _, thing in pairs(dictionary) do
			if typeof(thing) ~= "table" then
				continue
			end

			local value = Module.getValueFromKeyRecursive(key, thing)
			if value then
				return value
			end
		end
	else
		return rawget(dictionary, key)
	end

	return nil
end

function Module.getValueFromStringPatternRecursive(pattern: string, dictionary: {[any]: any}): any?
	local pattern = string.lower(pattern)
	for key, thing in pairs(dictionary) do
		-- string.find() is faster than string.match() as we don't need to make a new substring
		local found = string.find(string.lower(key), pattern)
		if not found and typeof(thing) == "table" then
			local value = Module.getValueFromStringPatternRecursive(pattern, thing)
			if value then
				return value
			end
		elseif found then
			return thing
		end
	end

	return nil
end

-- Returns a new array that is the result of array1 and array2
function Module.mergeArrays(array1: {[number]: any}, array2: {[number]: any})
	local length = #array2
	local newArray = table.clone(array2)
	for i, v in ipairs(array1) do
		newArray[length + i] = v
	end
	return newArray
end

-- Returns a new dictionary that is the result of dict1 and dict2.
-- If any keys match, the first encountered key will have precendence!
function Module.mergeDict(...: { [any]: any })
	local dictionaries = {...}
	local result = {}

	for index, dict in ipairs(dictionaries) do
		assert(typeof(dict) == "table", "invalid table given")
		for key, value in pairs(dict) do
			-- Only set if this key hasn't been set yet
			if result[key] == nil then
				result[key] = value
			end
		end
	end

	return result
end

function Module.mergeTables(baseTable: { [any]: any }, targetTable: { [any]: any })
	for index: string, value in targetTable do
		if typeof(baseTable[index]) == typeof(value) then
			if baseTable[index] ~= (getmetatable(baseTable) or {})[index] then
				continue
			end
		end

		if type(value) == "table" then
			baseTable[index] = table.clone(value)
		else
			baseTable[index] = value
		end
	end

	return baseTable
end

function Module.match(list: {}, partial: string)
	assert(list, "list is invalid or nil")
	assert(partial, "partial is invalid or nil")

	local matches = {}
	for _, str in pairs(list) do
		if string.lower(str):sub(1, #partial) == string.lower(partial) then
			table.insert(matches, str)
		end
	end

	return matches
end

do
	-- Converts the dictionary to two arrays containing the keys and values.
	function Module.toArray<K, V>(dict: { [K]: V }): ({ V }, { K })
		assert(dict, "Dictionary is invalid or nil")
		local vResult = {}
		local kResult = {}
		for k, v in dict do
			table.insert(kResult, k)
			table.insert(vResult, v)
		end
		return vResult, kResult
	end
	
	local cache = Module.weakCache("k")
	-- Converts the dictionary to two arrays containing the keys and values.
	-- Results are cached for the same input and shallow copied versions are returned.
	-- Do not use if the input table is mutated during runtime.
	function Module.toArrayCached<K, V>(dict: { [K]: V }): ({ V }, { K })
		assert(dict, "Dictionary is invalid or nil")

		local cached = cache[dict]
		if cached then
			return table.clone(cached.Values), table.clone(cached.Keys)
		end

		local vResult, kResult = Module.toArray(dict)
		local result = { Values = vResult, Keys = kResult }
		cache[dict] = result
		return table.clone(result.Values), table.clone(result.Keys)
	end
end

do
	-- Converts the array to a dictionary where the values become the keys and the indexes become the values.
	function Module.toDict<I, V>(list: { [I]: V }): { [V]: I }
		assert(list, "list is invalid or nil")

		local newDict = {}
		for i, v in pairs(list) do
			newDict[v] = i
		end

		return newDict
	end
	
	local cache = Module.weakCache("k")
	-- Converts the list to a dictionary where the values become the keys and the indexes become the values.
	-- Results are cached for the same input and a shallow copied version is returned.
	-- Do not use if the input table is mutated during runtime.
	function Module.toDictCached<I, V>(list: { [I]: V }): { [V]: I }
		assert(list, "list is invalid or nil")

		local cached = cache[list]
		if cached then
			return table.clone(cached)
		end

		local newDict = Module.toDict(list)

		cache[list] = newDict
		return table.clone(newDict)
	end
end

function Module.getIndexes(listOrDict: {})
	assert(listOrDict, "listOrDict is invalid or nil")

	local indexes = {}
	for i, _ in pairs(listOrDict) do
		table.insert(indexes, i)
	end

	return indexes
end

function Module.getValues(listOrDict: {})
	assert(listOrDict, "listOrDict is invalid or nil")

	local values = {}
	for _, v in pairs(listOrDict) do
		table.insert(values, v)
	end

	return values
end

function Module.length(listOrDict: {}): number
	local count = 0
	for _, _ in listOrDict do
		count += 1
	end
	return count
end

-- Takes an array and segregates it into chunks based on the passed array size.
function Module.chunkArray<T>(array: { T }, chunkSize: number): { { T } }
	local chunks = {}
	for i = 1, #array, chunkSize do
		table.insert(chunks, { table.unpack(array, i, math.min(i + chunkSize - 1, #array)) })
	end
	return chunks
end

type RecursiveCallback = (key: any, value: any, path: {any}, current: { [any]: any }) -> ()
type CanTraverseCallback = (key: any, value: any, path: {any}, current: { [any]: any }) -> (boolean)
@deprecated
-- Recursively traverse over a table.
-- <strong>canTraverse</strong>: Determines if the given value (table) can be traversed or be passed to the <strong>callback</strong> instead.
-- <strong>callback</strong>: Called and given the key and value in the current traversal of a table.
function Module.traverse(inputTable: { [any]: any | { [any]: any } }, canTraverse: CanTraverseCallback, callback: RecursiveCallback, path: {any}?)
	local path = path or {}

	for key, value in pairs(inputTable) do
		local currentPath = { unpack(path) }
		table.insert(currentPath, key)

		if typeof(value) == "table" and canTraverse(key, value, currentPath, inputTable) then
			-- Recursive case for nested tables
			Module.traverse(value, canTraverse, callback, currentPath)
		else
			-- Base case for individual values
			callback(key, value, currentPath, inputTable)
		end
	end
end

-- Recursively traverse over a table with an optional predicate.
-- <strong>shouldVisit</strong>: Will be given all values (including other tables)
-- This automatically skips already-seen tables to prevent infinite loops.
function Module.simpleTraverse(
	sourceTbl: { [any]: any },
	onVisit: (key: any, value: any, path: { any }, node: { [any]: any }) -> (),
	shouldVisit: ( (key: any, value: any, path: { any }, node: { [any]: any }) -> (boolean) )?
)
	local seen = {}
	
	local function recurse(node: { [any]: any }, path: { any })
		if seen[node] then
			return -- avoid issues with cyclic table references
		end
		seen[node] = true
		
		for key, value in pairs(node) do
			path[#path + 1] = key

			if typeof(value) == "table" then
				if not shouldVisit or shouldVisit(key, value, path, node) then
					recurse(value, path)
				end
			elseif not shouldVisit or shouldVisit(key, value, path, node) then
				onVisit(key, value, path, node)
			end

			path[#path] = nil
		end
	end

	recurse(sourceTbl, {})
end

-- Checks whether the provided table has any duplicate values.
-- <strong>value</strong>: Optionally check a specific value for duplication.
function Module.containsDuplicates(source: { [any]: any }, value: any?): boolean
	if value ~= nil then
		-- Only count occurrences of value
		local count = 0
		for _, value in pairs(source) do
			if value == value then
				count += 1
				if count >= 2 then
					return true
				end
			end
		end
		return false
	else
		-- Check for any duplicate across all values
		local seenValues: { [any]: boolean } = {}
		for _, value in pairs(source) do
			if seenValues[value] then
				return true
			end
			seenValues[value] = true
		end
		return false
	end
end

do
	local function createLookupSet<T>(tbl: { [any]: T }): { [T]: boolean }
		local set = {}
		for _, value in tbl do
			set[value] = true
		end
		return set
	end
	
	--[[
		Returns true if any value in <strong>checkTable</strong> exists in <strong>baseTable</strong>
	]]
	function Module.containsAny(baseArray: { [any]: any }, checkTable: { [any]: any }): boolean
		local lookup = createLookupSet(baseArray)

		for _, value in checkTable do
			if lookup[value] then
				return true
			end
		end

		return false
	end
end

-- Grabs a random key/index pair out of the given table.
function Module.random<K>(source: { [K]: any }, rngOverride: Random?): (K?)
	assert(type(source) == "table", "First argument must be a table")
	local random = if typeof(rngOverride) == "Random" then rngOverride else rng

	-- array case
	local len = #source
	if len > 0 then
		return random:NextInteger(1, len) :: any
	end

	-- dictionary case
	local keyArray = Keys(source)
	if #keyArray == 0 then
		return nil
	end
	return keyArray[random:NextInteger(1, #keyArray)]
end

do
	local sortCache = Module.weakCache("k")

	--[[
		Adds caching to table.sort()
		This caches the results if the input array and comparator are the same and returns a shallow copy of the cached results.
		Do not use if the input array is frequently mutated during runtime
	]]
	function Module.sortCached<T>(
		array: { T },
		comparator: (a: T, b: T) -> boolean
	): { T }
		assert(typeof(array) == "table", "Expected a table")
		assert(typeof(comparator) == "function", "Expected a comparator function")
		local cacheForTable = sortCache[array]
		if cacheForTable then
			local cached = cacheForTable[comparator]
			if cached then
				return cached
			end
		else
			cacheForTable = Module.weakCache("k")
			sortCache[array] = cacheForTable
		end

		local copy = table.clone(array)
		table.sort(copy, comparator)
		cacheForTable[comparator] = copy
		return copy
	end
end

Module.copy = Copy
Module.sync = Sync
Module.reconcile = Reconcile
Module.swapRemove = SwapRemove
Module.swapRemoveFirstValue = SwapRemoveFirstValue
Module.map = Map
Module.filter = Filter
Module.reduce = Reduce
Module.assign = Assign
Module.extend = Extend
Module.reverse = Reverse
Module.shuffle = Shuffle
Module.sample = Sample
Module.flat = Flat
Module.flatMap = FlatMap
Module.keys = Keys
Module.values = Values
Module.find = Find
Module.every = Every
Module.some = Some
Module.truncate = Truncate
Module.zip = Zip
Module.lock = Lock
Module.isEmpty = IsEmpty
Module.encodeJSON = EncodeJSON
Module.decodeJSON = DecodeJSON

return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004336</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC0226C3260154B489DD174E850270A88">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009649</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_format</string>
							<string name="ScriptGuid">{5E858825-8D39-4EBD-9DD0-059AAE6278A3}</string>
							<ProtectedString name="Source"><![CDATA[--!strict

local suffixes = {"K", "M", "B", "T", "Qa", "Qi", "Sx", "Sp", "Oc", "No", "Dc", "Ud", "Dd", "Td", "Qad", "Qid", "Sxd", "Spd", "Ocd", "Nod", "Vg", "Uvg", "Dvg", "Tvg", "Qavg", "Qivg", "Sxvg", "Spvg", "Ocvg"}

local Module = {}

--[[ 
	Returns the possessive form of a given name.
	If the name ends in "s" (case-insensitive), appends just an apostrophe.
	Otherwise, appends `'s`.
]]
function Module.getPossessiveName(name: string): string
	assert(typeof(name) == "string", "getPossessiveName(): name must be a string")

	local lastCharacter = string.sub(name, -1)
	if lastCharacter:lower() == "s" then
		return name .. "'"
	end

	return name .. "'s"
end

-- Calls tostring() on input and removes all special characters (except for underscores).
function Module.getAttributeSafeString(input: any): string
	return tostring(input):gsub("[^%w_]", "")
end

-- Formats a number into float with a suffix (if applicable).
-- <strong>precision</strong>: Default is 1 decimal place.
function Module.abbreviateNumber(x: number, precision: number?)
	local precision = precision or 1

	if x < 1000 then
		return tostring(x)
	end

	local suffixIndex = math.floor(math.log10(x) / 3)
	local suffix = suffixes[suffixIndex]

	if not suffix then
		return tostring(x)
	end

	local divisor = 10 ^ (suffixIndex * 3)
	local shortValue = x / divisor

	local multiplier = 10 ^ precision
	local roundedValue = math.floor(shortValue * multiplier + 0.5) / multiplier

	-- If rounding pushes the value to 1000, switch to next suffix
	if roundedValue >= 1000 and suffixes[suffixIndex + 1] then
		suffixIndex += 1
		suffix = suffixes[suffixIndex]
		divisor = 10 ^ (suffixIndex * 3)
		roundedValue = math.floor((x / divisor) * multiplier + 0.5) / multiplier
	end

	local formatted = string.format(`%.{precision}f`, roundedValue)
	formatted = formatted:gsub("%.?0+$", "")

	return `{formatted}{suffix}`
end

function Module.removeRichTextTags(input: string): string
	return input:gsub("<[^<>]->", "")
end

-- Formats a number into float with a suffix (if applicable).
-- <strong>precision</strong>: Default is 1 decimal place.
function Module.abbreviateCash(x: number, precision: number?)
	local precision = precision or 1

	if x < 1000 then
		return Module.formatCash(x)
	end

	local suffixIndex = math.floor(math.log10(x) / 3)
	local suffix = suffixes[suffixIndex]

	if not suffix then
		return Module.formatCash(x)
	end

	local divisor = 10 ^ (suffixIndex * 3)
	local shortValue = x / divisor

	local multiplier = 10 ^ precision
	local roundedValue = math.floor(shortValue * multiplier + 0.5) / multiplier

	-- If rounding pushes the value to 1000, switch to next suffix
	if roundedValue >= 1000 and suffixes[suffixIndex + 1] then
		suffixIndex += 1
		suffix = suffixes[suffixIndex]
		divisor = 10 ^ (suffixIndex * 3)
		roundedValue = math.floor((x / divisor) * multiplier + 0.5) / multiplier
	end

	local formatted = string.format(`%.{precision}f`, roundedValue)
	formatted = formatted:gsub("%.?0+$", "")

	return `{formatted}{suffix}`
end

-- Removes all rich text tags from the string, including replacing `\n` breaks with their rich text counterpart.
-- Use this to get an accurate utf8.graphemes count that excludes rich text markup.
function Module.removeTags(str: string): string
	-- replace line break tags (otherwise grapheme loop will miss those linebreak characters)
	str = str:gsub("<br%s*/>", "\n")
	return (str:gsub("<[^<>]->", ""))
end

--[[
	Formats numbers into a 'cash' format.
	100 -> 100
	0.011 -> 0.01
	1000.155 -> 1,000.16
]]
function Module.formatCash(amount: number): string
	assert(typeof(amount) == "number", "FormatCash expects a number")
	-- Round to the nearest cent
	local roundedAmount = math.floor(amount * 100 + 0.5) / 100

	-- Get a two-decimal string
	local formattedString = string.format("%.2f", roundedAmount)

	-- Handle a leading minus-sign
	local isNegative = false
	if formattedString:sub(1, 1) == "-" then
		isNegative = true
		formattedString = formattedString:sub(2)
	end

	-- Split into integer + fractional parts
	local integerPart, fractionalPart =
		formattedString:match("^(%d+)(%.%d%d)$")

	-- Sanity checks in case of unexpected strings
	if not integerPart or not fractionalPart then
		error(`FormatCash failed to parse '{formattedString}'`, 2)
	end

	local integerNumber = tonumber(integerPart)
	if not integerNumber then
		error(`FormatCash invalid integer '{integerPart}'`, 2)
	end

	-- Insert commas, reattach sign, and decide whether to include cents
	local withCommas = Module.formatWithCommas(integerNumber)
	local result = (isNegative and "-" or "") .. withCommas

	if fractionalPart ~= ".00" then
		result = result .. fractionalPart
	end

	return result
end

-- Formats any number to include commas (if applicable).
function Module.formatWithCommas(num: number): string
	local negative = false
	if num < 0 then
		negative = true
		num = -num
	end

	local str = tostring(num)
	local integer, fractional = str:match("^(%d+)(%.%d+)$")
	if not integer then
		integer = str
		fractional = ""
	end

	local reversed = (integer :: string):reverse()
	local parts = {}
	for i = 1, #reversed, 3 do
		parts[#parts + 1] = reversed:sub(i, i + 2)
	end

	local withCommas = table.concat(parts, ","):reverse()
	if negative then
		withCommas = `-{withCommas}`
	end

	return `{withCommas}{fractional}`
end

-- DEPRECATED, use formatWithCommas() instead
function Module.formatLgInt(value : number)
	warn(`formatLgInt is deprecated and has been replaced by .formatWithCommas()`)
	local valueStr = tostring(value)

	if #valueStr <= 3 then
		return valueStr
	end

	local revStr = string.reverse(valueStr)
	local formatted = ""
	for i = 1, string.len(revStr) do
		formatted = formatted .. string.sub(revStr, i, i)
		if i % 3 == 0 and i ~= string.len(revStr) then
			formatted = formatted .. ","
		end
	end

	formatted = string.reverse(formatted)
	return formatted
end

function Module.nearest2DecimalPlaces(float : number)
	float *= 100
	return (math.floor(float) / 100)
end

--[[
	Formats the duration in seconds to a time string.
	Example: 125 -> 2:05, 3605 -> 1:00:05
	<strong>minUnit</strong>: Default is 'minutes'
]]
function Module.formatTime(seconds: number, minUnit: ("hours" | "minutes" | "seconds")?): string
	assert(typeof(seconds) == "number", "formatTime expects a number")
	local precision = minUnit or "minutes"

	local totalSeconds = math.floor(seconds)
	local hours = math.floor(totalSeconds / 3600)
	local minutes = math.floor((totalSeconds % 3600) / 60)
	local secs = totalSeconds % 60

	local parts = {}

	if precision == "hours" or hours > 0 then
		table.insert(parts, string.format("%02d", hours))
		table.insert(parts, string.format("%02d", minutes))
		table.insert(parts, string.format("%02d", secs))
	elseif precision == "minutes" or minutes > 0 then
		table.insert(parts, tostring(minutes))
		table.insert(parts, string.format("%02d", secs))
	else
		table.insert(parts, tostring(secs))
	end

	return table.concat(parts, ":")
end

--[[
	Formats the duration in seconds to a time string (including milliseconds).
	Example: 125.3559 -> 2:05.356, 3605.15 -> 1:00:05.150
	<strong>precision</strong>: How many decimal places. Any missing spaces will be filled with zeros. Must be value of 0-3.
	<strong>minUnit</strong>: Default is 'minutes'
]]
function Module.formatTimeWithMilliseconds(timeInSeconds: number, precision: number, minUnit: "hours" | "minutes" | "seconds"?): string
	assert(typeof(timeInSeconds) == "number", "Expected number for timeInSeconds")
	assert(typeof(precision) == "number" and precision >= 0 and precision <= 3, "Precision must be between 0 and 3")

	local base = Module.formatTime(timeInSeconds, minUnit)

	if precision == 0 then
		return base
	end

	local factor = 10 ^ precision
	local fraction = timeInSeconds % 1
	local fractionalRounded = math.floor(fraction * factor + 0.5)
	return base .. string.format(`.%0{precision}d`, fractionalRounded)
end

-- Attempts to convert a string to PascalCase
-- Examples:
-- HELLOTHERE -> Hellothere
-- hello_there -> HelloThere
function Module.toPascalCase(input: string): string
	local parts = {}
	-- iterate over runs of letters and digits (ignore underscores, punctuation, etc.)
	for word in string.gmatch(input, "[A-Za-z0-9]+") do
		local firstChar = string.sub(word, 1, 1)
		local rest = string.sub(word, 2)
		-- uppercase the first letter, lowercase the rest
		local capitalized = string.upper(firstChar) .. string.lower(rest)
		table.insert(parts, capitalized)
	end
	return table.concat(parts)
end

-- Get the correspending ordinal suffix for a number returns as a string. It accounts for 11 - 13
-- Examples:
-- 1 -> 1st
-- 11 -> 11th
function Module.getOrdinalString(input: number): string
	local suffix = "th"
	if input % 100 < 11 or input % 100 > 13 then
		local lastDigit = input % 10
		if lastDigit == 1 then
			suffix = "st"
		elseif lastDigit == 2 then
			suffix = "nd"
		elseif lastDigit == 3 then
			suffix = "rd"
		end
	end
	return tostring(input) .. suffix
end

-- Simply adds a space before an uppercase letter
-- Input: HelloWorld
-- Output: Hello World
function Module.addSpaceBeforeUpperCase(input: string): string
	return input:gsub("(%u)", " %1"):gsub("^ ", "")
end

--Separates all strings by uppercase and inserts into a table.
function Module.splitByUppercase(input: string): {string}
	local result = {}
	for word in input:gmatch("[A-Z][^A-Z]*") do
		table.insert(result, word)
	end
	return result
end

return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004337</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0231A4A9315C4B01803B8EE98F6A8509">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc082180130000964a</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_observers</string>
							<string name="ScriptGuid">{2A8ABA8B-0F95-40AD-A547-5DA4EC32A4FF}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
return {
	observeAttribute = require(script._observeAttribute),
	observeAllAttributes = require(script._observeAllAttributes),
	observeCharacter = require(script._observeCharacter),
	observeLocalCharacter = require(script._observeLocalCharacter),
	observePlayer = require(script._observePlayer),
	observeProperty = require(script._observeProperty),
	observeTag = require(script._observeTag),
	observeChildren = require(script._observeChildren),
	observeDescendants = require(script._observeDescendants),
	observeAncestry = require(script._observeAncestry)
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004338</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXB636553B11984E57871EDCA56C62CD19">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">1d49ecd7c5d71268082cfdad00006e70</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_observeAllAttributes</string>
								<string name="ScriptGuid">{B7CB32F6-2D94-4509-BAF4-D8956100DBBE}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

type GuardPredicate = (attributeName: string, value: any) -> (boolean)

local function defaultGuard(_attributeName: string, _value: any): boolean
	return true
end

--[=[
	Creates an observer that watches all attributes on a given instance.
	Your callback is invoked for existing attributes on start and
	for every subsequent change where guard(attributeName, value) returns true.

	-- Only observe numeric attributes
	local stop = observeAllAttributes(
		workspace.Part,
		function(name, value)
			print(name, "=", value)
			return function()
				print(name, "was removed or no longer passes guard")
			end
		end,
		function(name, value)
			return typeof(value) == "number"
		end
	)
	
	Returns a function that stops observing and runs any outstanding cleanup callbacks.
]=]
local function observeAllAttributes(
	instance: any,
	callback: (attributeName: string, value: any) -> (() -> ())?,
	guardPredicate: (GuardPredicate)?
): () -> ()
	local cleanupFunctionsPerAttribute: { [string]: () -> () } = {}
	local changeIds: { [string]: number } = {}
	local attributeGuard: GuardPredicate = if guardPredicate ~= nil then guardPredicate else defaultGuard
	local attributeChangedConnection: RBXScriptConnection
	
	local function onAttributeChanged(attributeName: string)
		if not attributeChangedConnection.Connected then
			return
		end
		-- Tear down any prior callback for this attribute
		local previousCleanup = cleanupFunctionsPerAttribute[attributeName]
		if typeof(previousCleanup) == "function" then
			task.spawn(previousCleanup)
			cleanupFunctionsPerAttribute[attributeName] = nil
		end
		
		if not changeIds[attributeName] then
			changeIds[attributeName] = 0
		end
		changeIds[attributeName] += 1
		local id = changeIds[attributeName]
		
		-- Fire new callback if guard passes
		local newValue = instance:GetAttribute(attributeName)
		
		if newValue == nil or not attributeGuard(attributeName, newValue) then
			return
		end
		
		-- Run the callback in protected mode:
		local success, cleanup = xpcall(function(attributeName, newValue)
			local clean = callback(attributeName, newValue)
			if clean ~= nil then
				assert(typeof(clean) == "function", "callback must return a function or nil")
			end
			return clean
		end, debug.traceback, attributeName :: any, newValue :: any)

		-- If callback errored, print out the traceback:
		if not success then
			local err = ""
			local firstLine = string.split(cleanup :: any, "\n")[1]
			local lastColon = string.find(firstLine, ": ")
			if lastColon then
				err = firstLine:sub(lastColon + 1)
			end
			warn(`error while calling observeAllAttributes({instance}) callback:{err}\n{cleanup}`)
			return
		end
		
		if cleanup then
			-- Only keep it if we're still connected and the value hasn't changed again
			if attributeChangedConnection.Connected and changeIds[attributeName] == id then
				cleanupFunctionsPerAttribute[attributeName] = cleanup
			else
				task.spawn(cleanup)
			end
		end
	end

	-- Connect the global AttributeChanged event
	attributeChangedConnection = instance.AttributeChanged:Connect(onAttributeChanged)

	-- Seed with existing attributes
	for name, _ in instance:GetAttributes() do
		task.defer(onAttributeChanged, name)
	end

	-- Return a stopper that disconnects and cleans up everything
	return function()
		attributeChangedConnection:Disconnect()
		for name, cleanup in pairs(cleanupFunctionsPerAttribute) do
			cleanupFunctionsPerAttribute[name] = nil
			if typeof(cleanup) == "function" then
				task.spawn(cleanup)
			end
		end
	end
end

return observeAllAttributes]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004339</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA1C7A80801804730B57E17FC8870E591">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c89</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_observeAncestry</string>
								<string name="ScriptGuid">{C23D2F49-F87D-4481-95A3-33CB87D9C5F2}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

type GuardPredicate = (
	changed: Instance,
	newParent: Instance?
) -> boolean

local function defaultAncestryGuard(
	_changed: Instance,
	_newParent: Instance?
): boolean
	return true
end

--[=[
	@within Observers

	Observes when an instance's ancestry changes.
	Observer will not be called if the ancestry becomes nil.

	Returns a function that stops observing and runs any outstanding cleanup.
]=]
local function observeAncestry(
	instance: any,
	callback: (
		changed: Instance,
		newParent: Instance?
	) -> (() -> ())?,
	guard: GuardPredicate?
): () -> ()
	assert(typeof(instance) == "Instance", "Bad argument #1 to observeAncestry, expected Instance")

	-- choose the guard (default always true)
	local ancestryGuard: GuardPredicate = guard or defaultAncestryGuard

	-- holds the cleanup function from the last callback
	local cleanupFunction: (() -> ())?
	local connection: RBXScriptConnection

	local function onAncestryChanged(
		changed: Instance,
		newParent: Instance?
	)
		if not connection.Connected then
			return
		end
		-- run previous cleanup, if any
		if cleanupFunction then
			task.spawn(cleanupFunction)
			cleanupFunction = nil
		end

		-- skip if the changed instance is no longer in DataModel
		if not changed:IsDescendantOf(game) then
			return
		end

		-- skip if guard rejects this change
		if not ancestryGuard(changed, newParent) then
			return
		end
		
		-- Run the callback in protected mode:
		local success, cleanup = xpcall(function(changed, newParent)
			local clean = callback(changed, newParent)
			if clean ~= nil then
				assert(typeof(clean) == "function", "callback must return a function or nil")
			end
			return clean
		end, debug.traceback, changed :: any, newParent :: any)

		-- If callback errored, print out the traceback:
		if not success then
			local err = ""
			local firstLine = string.split(cleanup :: any, "\n")[1]
			local lastColon = string.find(firstLine, ": ")
			if lastColon then
				err = firstLine:sub(lastColon + 1)
			end
			warn(`error while calling observeAncestry({instance}) callback:{err}\n{cleanup}`)
			return
		end
		
		if cleanup then
			if connection.Connected then
				cleanupFunction = cleanup
			else
				task.spawn(cleanup)
			end
		end
	end

	-- hook up the AncestryChanged event
	connection = instance.AncestryChanged:Connect(onAncestryChanged)

	-- seed with the instance's current parent
	task.defer(onAncestryChanged, instance, instance.Parent)

	-- return a stopper
	return function()
		if connection.Connected then
			connection:Disconnect()
		end

		if cleanupFunction then
			task.spawn(cleanupFunction)
			cleanupFunction = nil
		end
	end
end

return observeAncestry
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000433a</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2A6A637DB8F44396BA430CB55160B394">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc082180130000964b</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_observeAttribute</string>
								<string name="ScriptGuid">{6616EF15-98AE-424A-929F-0D28FE478C68}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
local function defaultGuard(_value: any)
	return true
end

--[=[
	@within Observers

	Creates an observer around an attribute of a given instance. The callback will fire for any non-nil
	attribute value.

	```lua
	observeAttribute(workspace.Model, "MyAttribute", function(value)
		print("MyAttribute is now:", value)

		return function()
			-- Cleanup
			print("MyAttribute is no longer:", value)
		end
	end)
	```

	An optional `guard` predicate function can be supplied to further narrow which values trigger the observer.
	For instance, if only strings are wanted:

	```lua
	observeAttribute(
		workspace.Model,
		"MyAttribute",
		function(value) print("value is a string", value) end,
		function(value) return typeof(value) == "string" end
	)
	```

	The observer also returns a function that can be called to clean up the observer:
	```lua
	local stopObserving = observeAttribute(workspace.Model, "MyAttribute", function(value) ... end)

	task.wait(10)
	stopObserving()
	```
]=]
local function observeAttribute(
	instance: any,
	name: string,
	callback: (value: any) -> ( () -> () )?,
	guard: ((value: any) -> boolean)?
): () -> ()
	local cleanFn: (() -> ())? = nil

	local onAttrChangedConn: RBXScriptConnection
	local changedId = 0

	local valueGuard: (value: any) -> boolean = if guard ~= nil then guard else defaultGuard

	local function OnAttributeChanged()
		if not onAttrChangedConn.Connected then
			return
		end
		if cleanFn ~= nil then
			task.spawn(cleanFn)
			cleanFn = nil
		end

		changedId += 1
		local id = changedId

		local value = instance:GetAttribute(name)
		
		if value == nil or not valueGuard(value) then
			return
		end
		
		-- Run the callback in protected mode:
		local success, cleanup = xpcall(function(value)
			local clean = callback(value)
			if clean ~= nil then
				assert(typeof(clean) == "function", "callback must return a function or nil")
			end
			return clean
		end, debug.traceback, value :: any)

		-- If callback errored, print out the traceback:
		if not success then
			local err = ""
			local firstLine = string.split(cleanup :: any, "\n")[1]
			local lastColon = string.find(firstLine, ": ")
			if lastColon then
				err = firstLine:sub(lastColon + 1)
			end
			warn(`error while calling observeAttribute("{name}") callback:{err}\n{cleanup}`)
			return
		end
		
		if cleanup then
			if id == changedId and onAttrChangedConn.Connected then
				cleanFn = cleanup
			else
				task.spawn(cleanup)
			end
		end
	end

	-- Get changed values:
	onAttrChangedConn = instance:GetAttributeChangedSignal(name):Connect(OnAttributeChanged)

	-- Get initial value:
	task.defer(OnAttributeChanged)

	-- Cleanup:
	return function()
		onAttrChangedConn:Disconnect()
		if cleanFn ~= nil then
			task.spawn(cleanFn)
			cleanFn = nil
		end
	end
end

return observeAttribute]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000433b</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXD6C7A05388D845FB91F1D0A51A88DC8F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc082180130000964c</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_observeCharacter</string>
								<string name="ScriptGuid">{E012E663-FE8C-4126-A607-D2B17385D5F9}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

local observePlayer = require(script.Parent._observePlayer)

--[=[
	@within Observers

	Creates an observer that captures each character in the game.

	```lua
	observeCharacter(function(player, character)
		print("Character spawned for " .. player.Name)

		return function()
			-- Cleanup
			print("Character removed for " .. player.Name)
		end
	end)
	```
]=]
local function observeCharacter(callback: (player: Player, character: Model) -> (() -> ())?): () -> ()
	return observePlayer(function(player)
		local cleanupFn: (() -> ())? = nil
		local handledCharacter = false
		local characterAddedConn: RBXScriptConnection

		local function OnCharacterAdded(character: Model)
			if not characterAddedConn.Connected then
				return
			end
			if handledCharacter then
				return
			end
			handledCharacter = true
			local currentCharCleanup: (() -> ())? = nil
			
			-- Watch for the character to be removed from the game hierarchy:
			local ancestryChangedConn: RBXScriptConnection
			ancestryChangedConn = character.AncestryChanged:Connect(function(_, newParent)
				if newParent == nil and ancestryChangedConn.Connected then
					handledCharacter = false
					ancestryChangedConn:Disconnect()
					if currentCharCleanup ~= nil then
						task.spawn(currentCharCleanup)
						if cleanupFn == currentCharCleanup then
							cleanupFn = nil
						end
						currentCharCleanup = nil
					end
				end
			end)
			
			-- Run the callback in protected mode:
			local success, cleanup = xpcall(function(player, character)
				local clean = callback(player, character)
				if clean ~= nil then
					assert(typeof(clean) == "function", "callback must return a function or nil")
				end
				return clean
			end, debug.traceback, player :: any, character :: any)

			-- If callback errored, print out the traceback:
			if not success then
				local err = ""
				local firstLine = string.split(cleanup :: any, "\n")[1]
				local lastColon = string.find(firstLine, ": ")
				if lastColon then
					err = firstLine:sub(lastColon + 1)
				end
				warn(`error while calling observeCharacter() callback:{err}\n{cleanup}`)
				return
			end

			if cleanup then
				if characterAddedConn.Connected and character.Parent then
					currentCharCleanup = cleanup
					cleanupFn = cleanup
				else
					-- Character is already gone or observer has stopped; call cleanup immediately:
					task.spawn(cleanup)
				end
			end
		end

		-- Handle character added:
		characterAddedConn = player.CharacterAdded:Connect(OnCharacterAdded)

		-- Handle initial character:
		if player.Character then
			task.defer(OnCharacterAdded, player.Character)
		end

		-- Cleanup:
		return function()
			characterAddedConn:Disconnect()
			if cleanupFn ~= nil then
				task.spawn(cleanupFn)
				cleanupFn = nil
			end
		end
	end)
end

return observeCharacter]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000433c</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0C6CEC91C53147FFB55B700427D8BFD3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">539d39d0180180d7082524b700020c8e</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_observeChildren</string>
								<string name="ScriptGuid">{659BB9A9-9CD8-4048-84A0-5B5C6102CD42}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

type GuardPredicate = (child: any) -> (boolean)

local function defaultChildGuard(_child: any): boolean
	return true
end

--[=[
	Creates an observer that captures each child for the given instance.
	An optional `guard` predicate can be supplied to filter which children trigger the observer.

	```lua
	-- Only observe Parts
	observeChildren(
		workspace,
		function(child)
			print("Part added:", child:GetFullName())
			return function()
				print("Part removed (or observer stopped):", child:GetFullName())
			end
		end,
		function(child)
			return child:IsA("Part")
		end
	)
	```
]=]
local function observeChildren(
	instance: any,
	callback: (child: any) -> (() -> ())?,
	guard: ( GuardPredicate )?
): () -> ()
	local childAddedConn: RBXScriptConnection
	local childRemovedConn: RBXScriptConnection
	local handledChild: { [Instance]: boolean } = {}
	
	-- Map each child to its cleanup function
	local cleanupFunctionsPerChild: { [Instance]: () -> () } = {}

	-- Choose the guard (either the one passed in, or a default that always returns true)
	local childGuard: GuardPredicate = if guard ~= nil then guard else defaultChildGuard

	-- Fires when a new child appears
	local function OnChildAdded(child: Instance)
		-- skip if the observer was already disconnected
		if not childAddedConn.Connected then
			return
		end
		if handledChild[child] then
			-- already executed callback for this child
			return
		end
		handledChild[child] = true

		-- skip if guard rejects this child
		if not childGuard(child) then
			return
		end
		
		-- Run the callback in protected mode:
		local success, cleanup = xpcall(function(child)
			local clean = callback(child)
			if clean ~= nil then
				assert(typeof(clean) == "function", "callback must return a function or nil")
			end
			return clean
		end, debug.traceback, child :: any)

		-- If callback errored, print out the traceback:
		if not success then
			local err = ""
			local firstLine = string.split(cleanup :: any, "\n")[1]
			local lastColon = string.find(firstLine, ": ")
			if lastColon then
				err = firstLine:sub(lastColon + 1)
			end
			warn(`error while calling observeChildren({instance}) callback:{err}\n{cleanup}`)
			return
		end
		
		if cleanup then
			-- only keep the cleanup if child is still parented and we're still observing
			if childAddedConn.Connected and child.Parent ~= nil then
				cleanupFunctionsPerChild[child] = cleanup
			else
				-- otherwise run it immediately
				task.spawn(cleanup)
			end
		end
	end

	-- Fires when a child is removed
	local function OnChildRemoved(child: Instance)
		handledChild[child] = nil
		local cleanup = cleanupFunctionsPerChild[child]
		cleanupFunctionsPerChild[child] = nil
		if typeof(cleanup) == "function" then
			task.spawn(cleanup)
		end
	end

	-- Connect events
	childAddedConn = instance.ChildAdded:Connect(OnChildAdded)
	childRemovedConn = instance.ChildRemoved:Connect(OnChildRemoved)

	-- Fire for existing children
	for _, child in instance:GetChildren() do
		task.defer(OnChildAdded, child)
	end

	-- Return a disconnect function
	return function()
		childAddedConn:Disconnect()
		childRemovedConn:Disconnect()

		-- Clean up any remaining children
		for child, _ in pairs(cleanupFunctionsPerChild) do
			OnChildRemoved(child)
		end
	end
end

return observeChildren]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000433d</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX69CC2E8C9AA74850A677387C1BD54A21">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00c47e3b9c386800082bbba70000a3bb</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_observeDescendants</string>
								<string name="ScriptGuid">{275AE594-4B08-4A4C-85A8-0BB122F19EF5}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

type GuardPredicate = (descendant: any) -> (boolean)

local function defaultDescendantGuard(_descendant: Instance): boolean
	return true
end

--[=[
	Creates an observer that captures every descendant of the given instance.
	An optional guard predicate can filter which descendants trigger the observer.

	-- Only observe Parts anywhere under workspace.Model
	local stop = observeDescendants(
		workspace.Model,
		function(part)
			print("Part added:", part:GetFullName())
			return function()
				print("Part removed (or observer stopped):", part:GetFullName())
			end
		end,
		function(desc)
			return desc:IsA("BasePart")
		end
	)
]=]
local function observeDescendants(
	instance: any,
	callback: (descendant: any) -> (() -> ())?,
	guard: ( GuardPredicate )?
): () -> ()
	local descAddedConn: RBXScriptConnection
	local descRemovingConn: RBXScriptConnection
	local handledDescendant: { [Instance]: boolean } = {}
	-- Map each descendant to its cleanup function
	local cleanupPerDescendant: { [Instance]: () -> () } = {}

	-- Use provided guard or default
	local descendantGuard: GuardPredicate = if guard ~= nil then guard else defaultDescendantGuard

	-- When a new descendant appears
	local function OnDescendantAdded(descendant: Instance)
		if not descAddedConn.Connected then
			return
		end
		if handledDescendant[descendant] then
			-- already executed callback for this child
			return
		end
		handledDescendant[descendant] = true

		if not descendantGuard(descendant) then
			return
		end
		
		-- Run the callback in protected mode:
		local success, cleanup = xpcall(function(descendant)
			local clean = callback(descendant)
			if clean ~= nil then
				assert(typeof(clean) == "function", "callback must return a function or nil")
			end
			return clean
		end, debug.traceback, descendant :: any)

		-- If callback errored, print out the traceback:
		if not success then
			local err = ""
			local firstLine = string.split(cleanup :: any, "\n")[1]
			local lastColon = string.find(firstLine, ": ")
			if lastColon then
				err = firstLine:sub(lastColon + 1)
			end
			warn(`error while calling observeDescendants({instance}) callback:{err}\n{cleanup}`)
			return
		end
		
		if cleanup then
			-- only keep cleanup if still valid
			if descAddedConn.Connected and descendant:IsDescendantOf(instance) then
				cleanupPerDescendant[descendant] = cleanup
			else
				task.spawn(cleanup)
			end
		end
	end

	-- When a descendant is removed
	local function OnDescendantRemoving(descendant: Instance)
		handledDescendant[descendant] = nil
		local cleanup = cleanupPerDescendant[descendant]
		cleanupPerDescendant[descendant] = nil
		if typeof(cleanup) == "function" then
			task.spawn(cleanup)
		end
	end

	-- Connect the events
	descAddedConn = instance.DescendantAdded:Connect(OnDescendantAdded)
	descRemovingConn = instance.DescendantRemoving:Connect(OnDescendantRemoving)

	-- Initialize existing descendants
	for _, descendant in instance:GetDescendants() do
		task.defer(OnDescendantAdded, descendant)
	end

	-- Return a stop function
	return function()
		descAddedConn:Disconnect()
		descRemovingConn:Disconnect()

		-- Clean up any still-tracked descendants
		for descendant in pairs(cleanupPerDescendant) do
			OnDescendantRemoving(descendant)
		end
	end
end

return observeDescendants]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000433e</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX123C812A9DD744A0B6AA24E9FA0473F8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c8e</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_observeLocalCharacter</string>
								<string name="ScriptGuid">{BDA99516-DFF2-4388-8657-3442000F5ED3}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--[=[
	@within Observers

	Observes the local player's character, similar to `observeCharacter` but client-only.

	```lua
	observeLocalCharacter(function(character)
		print("Local character spawned")

		return function()
			print("Local character removed")
		end
	end)
	```
]=]
local function observeLocalCharacter(callback: (character: Model) -> (() -> ())?): () -> ()
	assert(RunService:IsClient(), "observeLocalCharacter() is client-only!")
	local player = Players.LocalPlayer
	local handledCharacter = false
	local cleanupFn: (() -> ())? = nil
	local characterAddedConn: RBXScriptConnection

	local function onCharacterAdded(character: Model)
		if not characterAddedConn.Connected then
			return
		end
		if handledCharacter then
			return
		end
		handledCharacter = true
		local currentCharCleanup: (() -> ())? = nil
		
		local ancestryChangedConn: RBXScriptConnection
		ancestryChangedConn = character.AncestryChanged:Connect(function(_, newParent)
			if newParent == nil and ancestryChangedConn.Connected then
				handledCharacter = false
				ancestryChangedConn:Disconnect()
				if currentCharCleanup ~= nil then
					task.spawn(currentCharCleanup)
					if cleanupFn == currentCharCleanup then
						cleanupFn = nil
					end
					currentCharCleanup = nil
				end
			end
		end)
		
		-- Run the callback in protected mode:
		local success, cleanup = xpcall(function(character)
			local clean = callback(character)
			if clean ~= nil then
				assert(typeof(clean) == "function", "callback must return a function or nil")
			end
			return clean
		end, debug.traceback, character :: any)

		-- If callback errored, print out the traceback:
		if not success then
			local err = ""
			local firstLine = string.split(cleanup :: any, "\n")[1]
			local lastColon = string.find(firstLine, ": ")
			if lastColon then
				err = firstLine:sub(lastColon + 1)
			end
			warn(`error while calling observeLocalCharacter() callback:{err}\n{cleanup}`)
			return
		end
		
		if cleanup then
			if characterAddedConn.Connected and character.Parent then
				currentCharCleanup = cleanup
				cleanupFn = cleanup
			else
				task.spawn(cleanup)
			end
		end
	end

	characterAddedConn = player.CharacterAdded:Connect(onCharacterAdded)

	if player.Character then
		task.defer(onCharacterAdded, player.Character)
	end

	return function()
		characterAddedConn:Disconnect()
		if cleanupFn ~= nil then
			task.spawn(cleanupFn)
			cleanupFn = nil
		end
	end
end

return observeLocalCharacter]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000433f</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF14725FFE58844A395DA8262C0122B5A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc082180130000964d</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_observePlayer</string>
								<string name="ScriptGuid">{64B86A7D-6928-4B9A-95D0-917AD6176574}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

local Players = game:GetService("Players")

--[=[
	@within Observers

	Creates an observer that captures each player in the game.

	```lua
	observePlayer(function(player)
		print("Player entered game", player.Name)

		return function()
			-- Cleanup
			print("Player left game (or observer stopped)", player.Name)
		end
	end)
	```
]=]
local function observePlayer(callback: (player: Player) -> (() -> ())?): () -> ()
	local playerAddedConn: RBXScriptConnection
	local playerRemovingConn: RBXScriptConnection
	local handledPlayer: { [Player]: boolean } = {}
	local cleanupsPerPlayer: { [Player]: () -> () } = {}

	local function OnPlayerAdded(player: Player)
		if not playerAddedConn.Connected then
			return
		end
		if handledPlayer[player] then
			return
		end
		handledPlayer[player] = true
		
		-- Run the callback in protected mode:
		local success, cleanup = xpcall(function(player)
			local clean = callback(player)
			if clean ~= nil then
				assert(typeof(clean) == "function", "callback must return a function or nil")
			end
			return clean
		end, debug.traceback, player :: any)

		-- If callback errored, print out the traceback:
		if not success then
			local err = ""
			local firstLine = string.split(cleanup :: any, "\n")[1]
			local lastColon = string.find(firstLine, ": ")
			if lastColon then
				err = firstLine:sub(lastColon + 1)
			end
			warn(`error while calling observePlayer() callback:{err}\n{cleanup}`)
			return
		end
		
		if cleanup then
			if playerAddedConn.Connected and player.Parent then
				cleanupsPerPlayer[player] = cleanup
			else
				task.spawn(cleanup)
			end
		end
	end

	local function OnPlayerRemoving(player: Player)
		handledPlayer[player] = nil
		local cleanup = cleanupsPerPlayer[player]
		cleanupsPerPlayer[player] = nil
		if typeof(cleanup) == "function" then
			task.spawn(cleanup)
		end
	end

	-- Listen for changes:
	playerAddedConn = Players.PlayerAdded:Connect(OnPlayerAdded)
	playerRemovingConn = Players.PlayerRemoving:Connect(OnPlayerRemoving)

	-- Initial:
	for _, player in Players:GetPlayers() do
		task.defer(OnPlayerAdded, player)
	end

	-- Cleanup:
	return function()
		playerAddedConn:Disconnect()
		playerRemovingConn:Disconnect()

		local player = next(cleanupsPerPlayer)
		while player do
			OnPlayerRemoving(player)
			player = next(cleanupsPerPlayer)
		end
	end
end

return observePlayer]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004340</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF4CB6B309B914ECF8CDDD41A2CC8EA97">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc082180130000964e</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_observeProperty</string>
								<string name="ScriptGuid">{3806C1B9-1B39-4950-9480-DF394301F228}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

local function defaultValueGuard(_value: any): boolean
	return true
end

--[=[
	@within Observers

	Creates an observer around a property of a given instance.
	An optional `guard` predicate can be supplied to filter which values trigger the observer.

	```lua
	-- Only observe Name changes when they’re non-empty strings
	local stop = observeProperty(
		workspace.Model,
		"Name",
		function(newName: string)
			print("New name:", newName)
			return function()
				print("Name changed away from:", newName)
			end
		end,
		function(value)
			return typeof(value) == "string" and #value > 0
		end
	)
	```

	Returns a function that stops observing and runs any outstanding cleanup.
]=]
local function observeProperty(
	instance: Instance,
	propertyName: string,
	callback: (value: any) -> ( () -> () )?,
	guard: ((value: any) -> boolean)?
): () -> ()
	local cleanFn: (() -> ())?
	local propChangedConn: RBXScriptConnection
	local changeCounter = 0

	-- decide which guard to use
	local valueGuard: (value: any) -> boolean = if guard ~= nil then guard else defaultValueGuard

	local function onPropertyChanged()
		if not propChangedConn.Connected then
			return
		end
		-- run previous cleanup (if any)
		if cleanFn then
			task.spawn(cleanFn)
			cleanFn = nil
		end

		changeCounter += 1
		local currentId = changeCounter
		local newValue = (instance :: any)[propertyName]
		
		if not valueGuard(newValue) then
			return
		end
		
		-- Run the callback in protected mode:
		local success, cleanup = xpcall(function(newValue)
			local clean = callback(newValue)
			if clean ~= nil then
				assert(typeof(clean) == "function", "callback must return a function or nil")
			end
			return clean
		end, debug.traceback, newValue :: any)

		-- If callback errored, print out the traceback:
		if not success then
			local err = ""
			local firstLine = string.split(cleanup :: any, "\n")[1]
			local lastColon = string.find(firstLine, ": ")
			if lastColon then
				err = firstLine:sub(lastColon + 1)
			end
			warn(`error while calling observeProperty("{propertyName}") callback:{err}\n{cleanup}`)
			return
		end
		
		if currentId == changeCounter and propChangedConn.Connected then
			cleanFn = cleanup
		elseif cleanup then
			-- otherwise run it immediately
			task.spawn(cleanup)
		end
	end
	
	-- connect to the property‑changed signal
	propChangedConn = instance:GetPropertyChangedSignal(propertyName):Connect(onPropertyChanged)

	-- fire once on startup
	task.defer(onPropertyChanged)

	-- return stop function
	return function()
		propChangedConn:Disconnect()
		if cleanFn then
			task.spawn(cleanFn)
			cleanFn = nil
		end
	end
end

return observeProperty]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004341</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX9DAF715CE239421FBA1A3C6927A8B193">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc082180130000964f</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_observeTag</string>
								<string name="ScriptGuid">{B35DB009-A6F0-4C5F-A83D-2FC95F8728CD}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

local CollectionService = game:GetService("CollectionService")

type InstanceStatus = "__inflight__" | "__dead__"

--[=[
	@within Observers

	Creates an observer around a CollectionService tag. The given callback will fire for each instance
	that has the given tag.

	The callback should return a function, which will be called when the given instance's tag is either
	destroyed, loses the given tag, or (if the `ancestors` table is provided) goes outside of the allowed
	ancestors.

	The function itself returns a function that can be called to stop the observer. This will also call
	any cleanup functions of currently-observed instances.

	```lua
	local stopObserver = Observers.observeTag("MyTag", function(instance: Instance)
		print("Observing", instance)

		-- The "cleanup" function:
		return function()
			print("Stopped observing", instance)
		end
	end)

	-- Optionally, the `stopObserver` function can be called to completely stop the observer:
	task.wait(10)
	stopObserver()
	```

	#### Ancestor Inclusion List
	By default, the `observeTag` function will observe a tagged instance anywhere in the Roblox game
	hierarchy. The `ancestors` table can optionally be used, which will restrict the observer to only
	observe tagged instances that are descendants of instances within the `ancestors` table.

	For instance, if a tagged instance should only be observed when it is in the Workspace, the Workspace
	can be added to the `ancestors` list. This might be useful if a tagged model prefab exist somewhere
	such as ServerStorage, but shouldn't be observed until placed into the Workspace.

	```lua
	local allowedAncestors = { workspace }

	Observers.observeTag(
		"MyTag",
		function(instance: Instance)
			...
		end,
		allowedAncestors
	)
	```
]=]
function observeTag<T>(tag: string, callback: (instance: T) -> (() -> ())?, ancestors: { Instance }?): () -> ()
	local instances: { [Instance]: InstanceStatus | () -> () } = {}
	local ancestryConn: { [Instance]: RBXScriptConnection } = {}

	local onInstAddedConn: RBXScriptConnection
	local onInstRemovedConn: RBXScriptConnection

	local function IsGoodAncestor(instance: Instance)
		if ancestors == nil then
			return true
		end

		for _, ancestor in ancestors do
			if instance:IsDescendantOf(ancestor) then
				return true
			end
		end

		return false
	end

	local function AttemptStartup(instance: Instance)
		-- Mark instance as starting up:
		instances[instance] = "__inflight__"

		-- Attempt to run the callback:
		task.spawn(function()
			if instances[instance] ~= "__inflight__" then
				return
			end
			
			-- Make sure it still lives under a valid ancestor (double-guard):
			if not IsGoodAncestor(instance) then
				instances[instance] = "__dead__"
				return
			end
			
			-- Run the callback in protected mode:
			local success, cleanup = xpcall(function(inst: T)
				local clean = callback(inst)
				if clean ~= nil then
					assert(typeof(clean) == "function", "callback must return a function or nil")
				end
				return clean
			end, debug.traceback, instance :: any)

			-- If callback errored, print out the traceback:
			if not success then
				local err = ""
				local firstLine = string.split(cleanup :: any, "\n")[1]
				local lastColon = string.find(firstLine, ": ")
				if lastColon then
					err = firstLine:sub(lastColon + 1)
				end
				warn(`error while calling observeTag("{tag}") callback:{err}\n{cleanup}`)
				return
			end
			
			if instances[instance] ~= "__inflight__" then
				-- Instance lost its tag or was destroyed before callback completed; call cleanup immediately:
				if cleanup ~= nil then
					task.spawn(cleanup :: any)
				end
			else
				-- Good startup; mark the instance with the associated cleanup function:
				instances[instance] = cleanup :: any
			end
		end)
	end

	local function AttemptCleanup(instance: Instance)
		local cleanup = instances[instance]
		instances[instance] = "__dead__"

		if typeof(cleanup) == "function" then
			task.spawn(cleanup)
		end
	end

	local function OnAncestryChanged(instance: Instance)
		if IsGoodAncestor(instance) then
			if instances[instance] == "__dead__" then
				AttemptStartup(instance)
			end
		else
			AttemptCleanup(instance)
		end
	end

	local function OnInstanceAdded(instance: Instance)
		if not onInstAddedConn.Connected then
			return
		end
		if instances[instance] ~= nil then
			return
		end

		instances[instance] = "__dead__"

		ancestryConn[instance] = instance.AncestryChanged:Connect(function()
			OnAncestryChanged(instance)
		end)
		OnAncestryChanged(instance)
	end

	local function OnInstanceRemoved(instance: Instance)
		AttemptCleanup(instance)

		local ancestry = ancestryConn[instance]
		if ancestry then
			ancestry:Disconnect()
			ancestryConn[instance] = nil
		end

		instances[instance] = nil
	end

	-- Hook up added/removed listeners for the given tag:
	onInstAddedConn = CollectionService:GetInstanceAddedSignal(tag):Connect(OnInstanceAdded)
	onInstRemovedConn = CollectionService:GetInstanceRemovedSignal(tag):Connect(OnInstanceRemoved)

	-- Attempt to mark already-existing tagged instances right away:
	for _, instance in CollectionService:GetTagged(tag) do
		task.defer(OnInstanceAdded, instance)
	end

	-- Full observer cleanup function:
	return function()
		onInstAddedConn:Disconnect()
		onInstRemovedConn:Disconnect()

		-- Clear all instances:
		local instance = next(instances)
		while instance do
			OnInstanceRemoved(instance)
			instance = next(instances)
		end
	end
end

return observeTag]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004342</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX389AF350AA824A12B6BA213684B8055F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009650</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_debugDraw</string>
							<string name="ScriptGuid">{A159B6FC-C61A-4BE1-9C14-D6B2E1EF18F1}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--[=[
	Debug drawing library useful for debugging 3D abstractions. One of
	the more useful utility libraries.

	These functions are incredibly easy to invoke for quick debugging.
	This can make debugging any sort of 3D geometry really easy.

	```lua
	-- A sample of a few API uses
	Draw.point(Vector3.new(0, 0, 0))
	Draw.terrainCell(Vector3.new(0, 0, 0))
	Draw.cframe(CFrame.new(0, 10, 0))
	Draw.text(Vector3.new(0, -10, 0), "Testing!")
	```

	:::tip
	This library should not be used to render things in production for
	normal players, as it is optimized for debug experience over performance.
	:::

	@class Draw
]=]

local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")
local TextService = game:GetService("TextService")
local Debris = game:GetService("Debris")

local Terrain = Workspace.Terrain

local ORIGINAL_DEFAULT_COLOR = Color3.new(1, 0, 0)
local DEFAULT_DEBRIS_TIME = 30

local Draw = {}
Draw._defaultColor = ORIGINAL_DEFAULT_COLOR

--[=[
	Sets the Draw's drawing color.
	@param color Color3 -- The color to set
]=]
function Draw.setColor(color)
	Draw._defaultColor = color
end

--[=[
	Resets the drawing color.
]=]
function Draw.resetColor()
	Draw._defaultColor = ORIGINAL_DEFAULT_COLOR
end

--[=[
	Sets the Draw library to use a random color.
]=]
function Draw.setRandomColor()
	Draw.setColor(Color3.fromHSV(math.random(), 0.5+0.5*math.random(), 1))
end

--[=[
	Draws a line between two points

	@param start Vector3
	@param finish Vector3
	@param color Color3 -- Optional
	@param parent Instance? -- Optional
	@param diameter number -- Optional
	@return Instance
]=]
function Draw.line(start, finish, color, parent, diameter)
	start = assert(Draw._toVector3(start), "Bad start")
	finish = assert(Draw._toVector3(finish), "Bad finish")
	color = Draw._toColor3(color)

	return Draw.ray(Ray.new(start, finish - start), color, parent, diameter)
end

--[=[
	Draws a line between directions

	@param origin Vector3
	@param direction Vector3
	@param color Color3 -- Optional
	@param parent Instance? -- Optional
	@param meshDiameter number -- Optional
	@param diameter number -- Optional
	@return Instance
]=]
function Draw.direction(origin: Vector3, direction: Vector3, color: Color3?, parent: Instance?, diameter: number?): Part
	origin = assert(Draw._toVector3(origin), "Bad origin")
	direction = assert(Draw._toVector3(direction), "Bad direction")
	color = Draw._toColor3(color)
	
	return Draw.ray(Ray.new(origin, direction), color, parent, diameter)
end

--[=[
	Draws a spherecast

	:::tip
	Unlike WorldRoot:GetPartsInPart(), spherecast does not detect BaseParts
	that initially intersect the shape. So this draw doesn't render that initial sphere.
	:::

	@param origin Vector3
	@param radius number
	@param direction Vector3
	@param color Color3
	@param parent Parent
]=]
function Draw.spherecast(origin, radius, direction, color, parent)
	origin = assert(Draw._toVector3(origin), "Bad cframe")
	assert(type(radius) == "number", "Bad radius")
	direction = assert(Draw._toVector3(direction), "Bad direction")
	color = Draw._toColor3(color)
	parent = parent or Draw.getDefaultParent()

	local folder = Instance.new("Folder")
	folder.Name = "SphereCast"
	folder.Archivable = false

	Draw.ray(Ray.new(origin, direction), color, folder, 2*radius)
	Draw.sphere(origin + direction, radius, color, folder)

	folder.Parent = parent

	return folder
end

--[=[
	Draws a block cast

	@param cframe CFrame
	@param size Vector3
	@param direction Vector3
	@param color Color3
	@param parent Parent
]=]
function Draw.blockcast(cframe, size, direction, color, parent)
	cframe = assert(Draw._toCFrame(cframe), "Bad cframe")
	size = assert(Draw._toVector3(size), "Bad size")
	direction = assert(Draw._toVector3(direction), "Bad direction")
	color = Draw._toColor3(color)
	parent = parent or Draw.getDefaultParent()

	local folder = Instance.new("Folder")
	folder.Name = "Blockcast"
	folder.Archivable = false

	-- Draw beginning and end for now...
	-- TODO: Convex hull
	Draw.box(cframe, size, color).Parent = folder
	Draw.box(cframe + direction, size, color).Parent = folder

	folder.Parent = parent

	return folder
end

function Draw.triangle(a: Vector3, b: Vector3, c: Vector3, color: Color3?, parent: Instance?)
	a = assert(Draw._toVector3(a), "Bad a")
	b = assert(Draw._toVector3(b), "Bad b")
	c = assert(Draw._toVector3(c), "Bad c")
	color = Draw._toColor3(color) or Draw._defaultColor
	parent = parent or Draw.getDefaultParent()

	local edges = {
		{longest = (c - a), other = (b - a), origin = a},
		{longest = (a - b), other = (c - b), origin = b},
		{longest = (b - c), other = (a - c), origin = c}
	};

	local edge = edges[1]
	for i = 2, #edges do
		if edges[i].longest.Magnitude > edge.longest.Magnitude then
			edge = edges[i]
		end
	end

	local theta = math.acos(edge.longest.Unit:Dot(edge.other.Unit))
	local w1 = math.cos(theta) * edge.other.Magnitude
	local w2 = edge.longest.Magnitude - w1
	local h = math.sin(theta) * edge.other.Magnitude

	local p1 = edge.origin + edge.other * 0.5;
	local p2 = edge.origin + edge.longest + (edge.other - edge.longest) * 0.5

	local right = edge.longest:Cross(edge.other).Unit
	local up = right:Cross(edge.longest).Unit
	local back = edge.longest.Unit

	local cf1 = CFrame.new(
		p1.X, p1.Y, p1.Z,
		-right.X, up.X, back.X,
		-right.Y, up.Y, back.Y,
		-right.Z, up.Z, back.Z
	);

	local cf2 = CFrame.new(
		p2.X, p2.Y, p2.Z,
		right.X, up.X, -back.X,
		right.Y, up.Y, -back.Y,
		right.Z, up.Z, -back.Z
	);

	-- put it all together by creating the wedges
	local triangle = Instance.new("Folder")
	triangle.Name = "Triangle"
	triangle.Archivable = false

	local wedge1 = Instance.new("WedgePart")
	wedge1.Material = Enum.Material.SmoothPlastic
	wedge1.Transparency = 0
	wedge1.Anchored = true
	wedge1.CanCollide = false
	wedge1.CanQuery = false
	wedge1.CanTouch = false
	wedge1.Archivable = false
	wedge1.CastShadow = false
	wedge1.Size = Vector3.new(0.05, h, w1)
	wedge1.CFrame = cf1
	wedge1.Color = color :: Color3

	local mesh1 = Instance.new("SpecialMesh")
	mesh1.MeshType = Enum.MeshType.Wedge
	mesh1.Scale = Vector3.new(0, 1, 1)
	mesh1.Parent = wedge1

	local wedge2 = Instance.new("WedgePart")
	wedge2.Material = Enum.Material.SmoothPlastic
	wedge2.Transparency = 0
	wedge2.Anchored = true
	wedge2.CanCollide = false
	wedge2.CanQuery = false
	wedge2.CanTouch = false
	wedge2.Archivable = false
	wedge2.CastShadow = false
	wedge2.Size = Vector3.new(0.05, h, w2)
	wedge2.CFrame = cf2
	wedge2.Color = color :: Color3

	local mesh2 = Instance.new("SpecialMesh")
	mesh2.MeshType = Enum.MeshType.Wedge
	mesh2.Scale = Vector3.new(0, 1, 1)
	mesh2.Parent = wedge2

	wedge1.Parent = triangle
	wedge2.Parent = triangle

	return triangle
end

--[=[
	Draws a raycast for debugging

	```lua
	Draw.raycast(origin, direction)
	```

	@param origin Vector3
	@param direction Vector3
	@param color Color3 -- Optional
	@param parent Instance? -- Optional
	@param meshDiameter number -- Optional
	@param diameter number -- Optional
	@return Instance
]=]
function Draw.raycast(origin: Vector3, direction: Vector3, color: Color3?, parent: Instance?, diamater: number?, cleanUpTime: number?): Part
	local rayPart = Draw.direction(origin, direction, color, parent, diamater)
	
	if cleanUpTime and typeof(cleanUpTime) == "number" and cleanUpTime > 0 then
		Debris:AddItem(rayPart, cleanUpTime)
	else
		Debris:AddItem(rayPart, DEFAULT_DEBRIS_TIME)
	end
	
	return rayPart
end

--[=[
	Draws a ray for debugging.

	```lua
	local ray = Ray.new(Vector3.new(0, 0, 0), Vector3.new(0, 10, 0))
	Draw.ray(ray)
	```

	@param ray Ray
	@param color Color3? -- Optional color to draw in
	@param parent Instance? -- Optional parent
	@param diameter number? -- Optional diameter
	@return BasePart
]=]
function Draw.ray(ray, color: Color3?, parent: Instance?, diameter: number?): Part
	assert(typeof(ray) == "Ray", "Bad typeof(ray) for Ray")

	local color = Draw._toColor3(color) or Draw._defaultColor
	local parent = parent or Draw.getDefaultParent()
	local diameter = diameter or 0.2

	local rayCenter = ray.Origin + ray.Direction/2
	local distance = ray.Direction.Magnitude

	local part = Instance.new("Part")
	part.Material = Enum.Material.ForceField
	part.Anchored = true
	part.Archivable = false
	part.CanCollide = false
	part.CanQuery = false
	part.CanTouch = false
	part.CastShadow = false
	part.CFrame = CFrame.new(rayCenter, ray.Origin + ray.Direction) * CFrame.Angles(0, math.pi/2, 0)
	part.Color = color :: Color3
	part.Name = "DebugRay"
	part.Shape = Enum.PartType.Cylinder
	part.Size = Vector3.new(distance, diameter, diameter)
	part.TopSurface = Enum.SurfaceType.Smooth
	part.Transparency = 0.5

	local cylinderHandleAdornment = Instance.new("CylinderHandleAdornment")
	cylinderHandleAdornment.Name = "CylinderHandleAdornment"
	cylinderHandleAdornment.Height = ray.Direction.Magnitude
	cylinderHandleAdornment.InnerRadius = 0
	cylinderHandleAdornment.Radius = diameter/4
	cylinderHandleAdornment.ZIndex = 3
	cylinderHandleAdornment.Color3 = color :: Color3
	cylinderHandleAdornment.AlwaysOnTop = true
	cylinderHandleAdornment.Transparency = 0.25
	cylinderHandleAdornment.CFrame = CFrame.Angles(0, math.pi/2, 0)
	cylinderHandleAdornment.Adornee = part
	cylinderHandleAdornment.Parent = part

	local partSize = part.Size

	local mesh = Instance.new("SpecialMesh")
	mesh.MeshType = Enum.MeshType.Cylinder
	mesh.Name = "DrawRayMesh"
	mesh.Scale = Vector3.new(distance/partSize.X, diameter/partSize.Y, diameter/partSize.Z)
	mesh.Parent = part

	part.Parent = parent

	return part
end

--[=[
	Updates the rendered ray to the new color and position.
	Used for certain scenarios when updating a ray on
	renderstepped would impact performance, even in debug mode.

	```lua
	local ray = Ray.new(Vector3.new(0, 0, 0), Vector3.new(0, 10, 0))
	local drawn = Draw.ray(ray)

	RunService.RenderStepped:Connect(function()
		local newRay = Ray.new(Vector3.new(0, 0, 0), Vector3.new(0, 10*math.sin(os.clock()), 0))
		Draw.updateRay(drawn, newRay Color3.new(1, 0.5, 0.5))
	end)
	```

	@param rayPart Instance -- Ray part
	@param ray Ray -- New ray
	@param color Color3 -- New color
	@param diameter number -- Number
]=]
function Draw.updateRay(rayPart: BasePart, ray: Ray, color: Color3?, diameter: number?)
	assert(typeof(rayPart) == "Instance", "Bad rayPart")
	assert(typeof(ray) == "Ray", "Bad typeof(ray) for Ray")
	local color = Draw._toColor3(color) or rayPart.Color
	local diameter = diameter or rayPart.Size.X

	local rayCenter = ray.Origin + ray.Direction/2
	local distance = ray.Direction.Magnitude

	rayPart.Color = color
	rayPart.Size = Vector3.new(distance, diameter, diameter)
	rayPart.CFrame = CFrame.new(rayCenter, ray.Origin + ray.Direction) * CFrame.Angles(0, math.pi/2, 0)

	local lineHandleAdornment = rayPart:FindFirstChildWhichIsA("CylinderHandleAdornment")
	if lineHandleAdornment then
		lineHandleAdornment.Height = ray.Direction.Magnitude
		lineHandleAdornment.Radius = 5*diameter
		lineHandleAdornment.Color3 = color
	end

	local partSize = rayPart.Size
	local mesh = rayPart:FindFirstChildWhichIsA("SpecialMesh")
	if mesh then
		mesh.Scale = Vector3.new(distance/partSize.X, diameter/partSize.Y, diameter/partSize.Z)
	end
end

--[=[
	Render text in 3D for debugging. The text container will
	be sized to fit the text.

	```lua
	Draw.text(Vector3.new(0, 10, 0), "Point")
	```

	@param adornee Instance | Vector3 -- Adornee to rener on
	@param text string -- Text to render
	@param color Color3? -- Optional color to render
	@return Instance
]=]
function Draw.text(adornee: Instance | Vector3, text: string, color: Color3?): BillboardGui | Attachment
	color = Draw._toColor3(color)

	if typeof(adornee) == "Vector3" then
		local attachment = Instance.new("Attachment")
		attachment.WorldPosition = adornee
		attachment.Parent = Terrain
		attachment.Name = "DebugTextAttachment"

		Draw._textOnAdornee(attachment, text, color)

		return attachment
	elseif typeof(adornee) == "Instance" then
		return Draw._textOnAdornee(adornee, text, color)
	else
		error("Bad adornee")
	end
end

function Draw._textOnAdornee(adornee: any, text: string, color: Color3?)
	local TEXT_HEIGHT_STUDS = 2
	local PADDING_PERCENT_OF_LINE_HEIGHT = 0.5

	local billboardGui = Instance.new("BillboardGui")
	billboardGui.Name = "DebugBillboardGui"
	billboardGui.SizeOffset =  Vector2.new(0, 0.5)
	billboardGui.ExtentsOffset = Vector3.new(0, 1, 0)
	billboardGui.AlwaysOnTop = true
	billboardGui.Adornee = adornee
	billboardGui.StudsOffset = Vector3.new(0, 0, 0.01)

	local background = Instance.new("Frame")
	background.Name = "Background"
	background.Size = UDim2.new(1, 0, 1, 0)
	background.Position = UDim2.new(0.5, 0, 1, 0)
	background.AnchorPoint = Vector2.new(0.5, 1)
	background.BackgroundTransparency = 0.3
	background.BorderSizePixel = 0
	background.BackgroundColor3 = color or Draw._defaultColor
	background.Parent = billboardGui

	local textLabel = Instance.new("TextLabel")
	textLabel.Text = tostring(text)
	textLabel.TextScaled = true
	textLabel.TextSize = 32
	textLabel.BackgroundTransparency = 1
	textLabel.BorderSizePixel = 0
	textLabel.TextColor3 = Color3.new(1, 1, 1)
	textLabel.Size = UDim2.new(1, 0, 1, 0)
	textLabel.Parent = background

	if tonumber(text) then
		textLabel.Font = Enum.Font.Code
	else
		textLabel.Font = Enum.Font.GothamMedium
	end

	local textSize = TextService:GetTextSize(
		textLabel.Text,
		textLabel.TextSize,
		textLabel.Font,
		Vector2.new(1024, 1e6))

	local lines = textSize.Y/textLabel.TextSize

	local paddingOffset = textLabel.TextSize*PADDING_PERCENT_OF_LINE_HEIGHT
	local paddedHeight = textSize.Y + 2*paddingOffset
	local paddedWidth = textSize.X + 2*paddingOffset
	local aspectRatio = paddedWidth/paddedHeight

	local uiAspectRatio = Instance.new("UIAspectRatioConstraint")
	uiAspectRatio.AspectRatio = aspectRatio
	uiAspectRatio.Parent = background

	local uiPadding = Instance.new("UIPadding")
	uiPadding.PaddingBottom = UDim.new(paddingOffset/paddedHeight, 0)
	uiPadding.PaddingTop = UDim.new(paddingOffset/paddedHeight, 0)
	uiPadding.PaddingLeft = UDim.new(paddingOffset/paddedWidth, 0)
	uiPadding.PaddingRight = UDim.new(paddingOffset/paddedWidth, 0)
	uiPadding.Parent = background

	local uiCorner = Instance.new("UICorner")
	uiCorner.CornerRadius = UDim.new(paddingOffset/paddedHeight/2, 0)
	uiCorner.Parent = background

	local height = lines*TEXT_HEIGHT_STUDS * TEXT_HEIGHT_STUDS*PADDING_PERCENT_OF_LINE_HEIGHT

	billboardGui.Size = UDim2.new(height*aspectRatio, 0, height, 0)
	billboardGui.Parent = adornee

	return billboardGui
end

--[=[
	Renders a sphere at the given point in 3D space.

	```lua
	Draw.sphere(Vector3.new(0, 10, 0), 10)
	```

	Great for debugging explosions and stuff.

	@param position Vector3 -- Position of the sphere
	@param radius number -- Radius of the sphere
	@param color Color3? -- Optional color
	@param parent Instance? -- Optional parent
	@return BasePart
]=]
function Draw.sphere(position: Vector3, radius: number, color: Color3?, parent: Instance?)
	return Draw.point(position, color, parent, radius*2)
end

function Draw.path(path: Path, pointRadius: number?, color: Color3?): { BasePart }
	local color = color or Draw._toColor3(color)
	local pointRadius = pointRadius or 0.5
	local parts = {}
	for _, point: PathWaypoint in ipairs(path:GetWaypoints()) do
		table.insert(parts, Draw.sphere(point.Position, pointRadius, color))
	end
	return parts
end

--[=[
	Draws a point for debugging in 3D space.

	```lua
	Draw.point(Vector3.new(0, 25, 0), Color3.new(0.5, 1, 0.5))
	```

	@param position Vector3 | CFrame -- Point to Draw
	@param color Color3? -- Optional color
	@param parent Instance? -- Optional parent
	@param diameter number? -- Optional diameter
	@return BasePart
]=]
function Draw.point(position: Vector3, color: Color3?, parent: Instance?, diameter: number?): BasePart
	position = assert(Draw._toVector3(position), "Bad position")
	local color = Draw._toColor3(color) or Draw._defaultColor

	parent = parent or Draw.getDefaultParent()
	local diameter = diameter or 1

	local part = Instance.new("Part")
	part.Material = Enum.Material.ForceField
	part.Anchored = true
	part.Archivable = false
	part.BottomSurface = Enum.SurfaceType.Smooth
	part.CanCollide = false
	part.CanQuery = false
	part.CanTouch = false
	part.CastShadow = false
	part.CFrame = CFrame.new(position)
	part.Color = color
	part.Name = "DebugPoint"
	part.Shape = Enum.PartType.Ball
	part.Size = Vector3.new(diameter, diameter, diameter)
	part.TopSurface = Enum.SurfaceType.Smooth
	part.Transparency = 0.5

	local sphereHandle = Instance.new("SphereHandleAdornment")
	sphereHandle.Archivable = false
	sphereHandle.Transparency = 0.25
	sphereHandle.Radius = diameter/4
	sphereHandle.Color3 = color
	sphereHandle.AlwaysOnTop = true
	sphereHandle.Adornee = part
	sphereHandle.ZIndex = 2
	sphereHandle.Parent = part

	part.Parent = parent

	return part
end

--[=[
	Renders a point with a label in 3D space.

	```lua
	Draw.labelledPoint(Vector3.new(0, 10, 0), "AI target")
	```

	@param position Vector3 | CFrame -- Position to render
	@param label string -- Label to render on the point
	@param color Color3? -- Optional color
	@param parent Instance? -- Optional parent
	@return BasePart
]=]
function Draw.labelledPoint(position, label, color, parent)
	position = assert(Draw._toVector3(position), "Bad position")
	color = Draw._toColor3(color)

	local part = Draw.point(position, color, parent)

	Draw.text(part, label, color)

	return part
end

--[=[
	Renders a CFrame in 3D space. Includes each axis.

	```lua
	Draw.cframe(CFrame.Angles(0, math.pi/8, 0))
	```

	@param cframe CFrame
	@return Model
]=]
function Draw.cframe(cframe)
	cframe = assert(Draw._toCFrame(cframe), "Bad cframe")

	local model = Instance.new("Model")
	model.Name = "DebugCFrame"

	local position = cframe.Position
	Draw.point(position, nil, model, 0.1)

	local xRay = Draw.ray(Ray.new(
		position,
		cframe.XVector
		), Color3.new(0.75, 0.25, 0.25), model, 0.1)
	xRay.Name = "XVector"

	local yRay = Draw.ray(Ray.new(
		position,
		cframe.YVector
		), Color3.new(0.25, 0.75, 0.25), model, 0.1)
	yRay.Name = "YVector"

	local zRay = Draw.ray(Ray.new(
		position,
		cframe.ZVector
		), Color3.new(0.25, 0.25, 0.75), model, 0.1)
	zRay.Name = "ZVector"

	model.Parent = Draw.getDefaultParent()

	return model
end

--[=[
	Draws a part in 3D space

	```lua
	Draw.part(part, Color3.new(1, 1, 1))
	```

	@param template BasePart
	@param cframe CFrame
	@param color Color3?
	@param transparency number
	@return BasePart
]=]
function Draw.part(template, cframe, color, transparency)
	assert(typeof(template) == "Instance" and template:IsA("BasePart"), "Bad template")
	cframe = Draw._toCFrame(cframe)
	color = Draw._toColor3(color)

	local part = template:Clone()
	for _, child in pairs(part:GetChildren()) do
		if child:IsA("MeshPart") then
			Draw._sanitize(child)
			child:ClearAllChildren()
		else
			child:Destroy()
		end
	end

	part.Color = color or Draw._defaultColor
	part.Material = Enum.Material.ForceField
	part.Transparency = transparency or 0.75
	part.Name = "Debug" .. template.Name
	part.Anchored = true
	part.CanCollide = false
	part.CanQuery = false
	part.CanTouch = false
	part.CastShadow = false
	part.Archivable = false

	if cframe then
		part.CFrame = cframe
	end

	Draw._sanitize(part)

	part.Parent = Draw.getDefaultParent()

	return part
end

function Draw._sanitize(inst)
	for key, _ in pairs(inst:GetAttributes()) do
		inst:SetAttribute(key, nil)
	end

	for _, tag in pairs(CollectionService:GetTags(inst)) do
		CollectionService:RemoveTag(inst, tag)
	end
end

--[=[
	Renders a box in 3D space. Great for debugging bounding boxes.

	```lua
	Draw.box(Vector3.new(0, 5, 0), Vector3.new(10, 10, 10))
	```

	@param cframe CFrame | Vector3 -- CFrame of the box
	@param size Vector3 -- Size of the box
	@param color Color3 -- Optional Color3
	@return BasePart
]=]
function Draw.box(cframe: CFrame, size: Vector3, color: Color3?)
	cframe = assert(Draw._toCFrame(cframe), "Bad cframe")
	size = assert(Draw._toVector3(size), "Bad size")
	local color = Draw._toColor3(color) or Draw._defaultColor

	assert(typeof(cframe) == "CFrame", "Bad cframe")
	assert(typeof(size) == "Vector3", "Bad size")

	local part = Instance.new("Part")
	part.Color = color
	part.Material = Enum.Material.ForceField
	part.Name = "DebugPart"
	part.Anchored = true
	part.CanCollide = false
	part.CanQuery = false
	part.CanTouch = false
	part.CastShadow = false
	part.Archivable = false
	part.BottomSurface = Enum.SurfaceType.Smooth
	part.TopSurface = Enum.SurfaceType.Smooth
	part.Transparency = 0.75
	part.Size = size
	part.CFrame = cframe

	local boxHandleAdornment = Instance.new("BoxHandleAdornment")
	boxHandleAdornment.Adornee = part
	boxHandleAdornment.Size = size
	boxHandleAdornment.Color3 = color
	boxHandleAdornment.AlwaysOnTop = true
	boxHandleAdornment.Transparency = 0.75
	boxHandleAdornment.ZIndex = 1
	boxHandleAdornment.Parent = part

	part.Parent = Draw.getDefaultParent()

	return part
end

--[=[
	Renders a region3 in 3D space.

	```lua
	Draw.region3(Region3.new(Vector3.new(0, 0, 0), Vector3.new(10, 10, 10)))
	```

	@param region3 Region3 -- Region3 to render
	@param color Color3? -- Optional color3
	@return BasePart
]=]
function Draw.region3(region3, color)
	color = Draw._toColor3(color)

	return Draw.box(region3.CFrame, region3.Size, color)
end

--[=[
	Renders a terrain cell in 3D space. Snaps the position
	to the nearest position.

	```lua
	Draw.terrainCell(Vector3.new(0, 0, 0))
	```

	@param position Vector3 -- World space position
	@param color Color3? -- Optional color to render
	@return BasePart
]=]
function Draw.terrainCell(position: Vector3, color: Color3?)
	position = assert(Draw._toVector3(position), "Bad position")
	color = Draw._toColor3(color)

	local size = Vector3.new(4, 4, 4)

	local solidCell = Terrain:WorldToCell(position)
	local terrainPosition = Terrain:CellCenterToWorld(solidCell.X, solidCell.Y, solidCell.Z)

	local part = Draw.box(CFrame.new(terrainPosition), size, color)
	part.Name = "DebugTerrainCell"

	return part
end

function Draw.screenPointLine(a: Vector3, b: Vector3, parent: Instance?, color: Color3?)
	local color = Draw._toColor3(color) or Draw._defaultColor

	local offset = (b - a)
	local pos = a + offset/2


	local frame = Instance.new("Frame")
	frame.Name = "DebugScreenLine"
	frame.Size = UDim2.fromScale(math.abs(offset.X), math.abs(offset.Y))

	frame.BackgroundTransparency = 1
	frame.Position = UDim2.fromScale(pos.X, pos.Y)
	frame.AnchorPoint = Vector2.new(0.5, 0.5)
	frame.BorderSizePixel = 0
	frame.ZIndex = 10000
	frame.Parent = parent

	local length = offset.Magnitude
	if length == 0 then
		return frame
	end

	local diameter = 3
	local count = 25

	local slope = offset.Y/offset.X
	if slope > 0 then
		for i=0, count do
			Draw.screenPoint(Vector2.new(i/count, i/count), frame, color, diameter)
		end
	else
		for i=0, count do
			Draw.screenPoint(Vector2.new(i/count, 1 - i/count), frame, color, diameter)
		end
	end

	return frame
end

function Draw.screenPoint(position: Vector2, parent: Instance?, color: Color3?, diameter: number?): Frame
	color = Draw._toColor3(color)

	local frame = Instance.new("Frame")
	frame.Name = "DebugScreenPoint"
	frame.Size = UDim2.new(0, diameter or 10, 0, diameter or 10)
	frame.BackgroundColor3 = color or Color3.new(1, 0.1, 0.1)
	frame.BackgroundTransparency = 0.5
	frame.Position = UDim2.fromOffset(position.X, position.Y)
	frame.AnchorPoint = Vector2.new(0.5, 0.5)
	frame.BorderSizePixel = 0
	frame.ZIndex = 20000

	local uiCorner = Instance.new("UICorner")
	uiCorner.CornerRadius = UDim.new(0.5, 0)
	uiCorner.Parent = frame

	frame.Parent = parent
	return frame
end

--[=[
	Draws a vector in 3D space.

	```lua
	Draw.vector(Vector3.new(0, 0, 0), Vector3.new(0, 1, 0))
	```

	@param position Vector3 -- Position of the vector
	@param direction Vector3 -- Direction of the vector. Determines length.
	@param color Color3? -- Optional color
	@param parent Instance? -- Optional instance
	@param meshDiameter number? -- Optional diameter
	@return BasePart
]=]
function Draw.vector(position: Vector3, direction: Vector3, color: Color3?, parent: Instance?, meshDiameter: number?)
	position = assert(Draw._toVector3(position), "Bad position")
	direction = assert(Draw._toVector3(direction), "Bad direction")
	color = Draw._toColor3(color)

	return Draw.ray(Ray.new(position, direction), color, parent, meshDiameter)
end

--[=[
	Draws a ring in 3D space.

	```lua
	Draw.ring(Vector3.new(0, 0, 0), Vector3.new(0, 1, 0), 10)
	```

	@param ringPos Vector3 -- Position of the center of the ring
	@param ringNorm Vector3 -- Direction of the ring.
	@param ringRadius number? -- Optional radius for the ring
	@param color Color3? -- Optional color
	@param parent Instance? -- Optional instance
	@return BasePart
]=]
function Draw.ring(ringPos, ringNorm, ringRadius, color, parent)
	ringPos = assert(Draw._toVector3(ringPos), "Bad ringPos")
	ringNorm = assert(Draw._toVector3(ringNorm), "Bad ringNorm")

	local ringCFrame = CFrame.new(ringPos, ringPos + ringNorm)

	local points = {}
	for angle = 0, 2*math.pi, math.pi/8 do
		local x = math.cos(angle)*ringRadius
		local y = math.sin(angle)*ringRadius
		local vector = ringCFrame:PointToWorldSpace(Vector3.new(x, y, 0))
		table.insert(points, vector)
	end

	local folder = Instance.new("Folder")
	folder.Name = "DebugRing"

	for i=1, #points do
		local pos = points[i]
		local nextPos = points[(i%#points)+1]
		local ray = Ray.new(pos, nextPos - pos)
		Draw.ray(ray, color, folder)
	end

	folder.Parent = parent or Draw.getDefaultParent()

	return folder
end

function Draw._toVector3(position: any): Vector3?
	if typeof(position) == "Vector3" then
		return position
	elseif typeof(position) == "CFrame" then
		return position.Position
	elseif typeof(position) == "Instance" then
		if position:IsA("Attachment") then
			return position.WorldPosition
		elseif position:IsA("BasePart") then
			return position.Position
		elseif position:IsA("Model") then
			return position:GetBoundingBox().Position
		else
			return nil
		end
	elseif typeof(position) == "RaycastResult" then
		return position.Position
	elseif typeof(position) == "PathWaypoint" then
		return position.Position
	else
		return nil
	end
end

function Draw._toColor3(color: any): Color3?
	if typeof(color) == "Color3" then
		return color
	elseif typeof(color) == "BrickColor" then
		return color.Color
	elseif typeof(color) == "Instance" then
		if color:IsA("BasePart") then
			return color.Color
		else
			return nil
		end
	else
		return nil
	end
end

function Draw._toCFrame(cframe: any): CFrame?
	if typeof(cframe) == "CFrame" then
		return cframe
	elseif typeof(cframe) == "Vector3" then
		return CFrame.new(cframe)
	elseif typeof(cframe) == "Instance" then
		if cframe:IsA("Attachment") then
			return cframe.WorldCFrame
		elseif cframe:IsA("BasePart") then
			return cframe.CFrame
		elseif cframe:IsA("Model") then
			return (cframe:GetBoundingBox())
		else
			return nil
		end
	elseif typeof(cframe) == "RaycastResult" then
		return CFrame.new(cframe.Position, cframe.Normal)
	elseif typeof(cframe) == "PathWaypoint" then
		return CFrame.new(cframe.Position)
	else
		return nil
	end
end

--[=[
	Retrieves the default parent for the current execution context.
	@return Instance
]=]
function Draw.getDefaultParent()
	if not RunService:IsRunning() then
		return Workspace.CurrentCamera
	end

	if RunService:IsServer() then
		return Workspace
	else
		return Workspace.CurrentCamera
	end
end

return Draw]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004343</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX141608DCCBD34D1FAF3549FE3CF722E8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025c93</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_dateTime</string>
							<string name="ScriptGuid">{85814759-F3E3-4BB7-B0AF-4D21DD34565B}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 6/3/25
--[[@description:

]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-----------------------------
-- DEPENDENCIES --
-----------------------------

-----------------------------
-- TYPES --
-----------------------------
local GlobalTypes = require("../GlobalTypes")

export type UniversalTimestamp = GlobalTypes.UniversalTimestamp

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}

-- CONSTANTS --

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

function Module.getOneHourInSeconds(): number
	return 3600
end

function Module.getOneDayInSeconds(): number
	return 86400
end

-- Converts a UniversalTimestamp into a DateTime object
function Module.fromTimestamp(timestamp: UniversalTimestamp): DateTime
	return DateTime.fromUniversalTime(
		timestamp.Year,
		timestamp.Month,
		timestamp.Day,
		timestamp.Hour,
		timestamp.Minute,
		timestamp.Second,
		timestamp.Millisecond
	)
end

-- Returns the number of whole seconds between two DateTime values
function Module.secondsBetween(a: DateTime, b: DateTime): number
	return math.abs(a.UnixTimestamp - b.UnixTimestamp)
end

-- Returns the number of full days between two DateTime values
function Module.daysBetween(a: DateTime, b: DateTime): number
	return math.floor(Module.secondsBetween(a, b) / 86400)
end

-- Returns a new DateTime offset by the given number of seconds
function Module.offsetBySeconds(dateTime: DateTime, seconds: number): DateTime
	return DateTime.fromUnixTimestamp(dateTime.UnixTimestamp + seconds)
end

function Module.now(): DateTime
	return DateTime.now()
end

-- Returns the current UniversalTimestamp
function Module.nowTimestamp(): UniversalTimestamp
	return DateTime.now():ToUniversalTime()
end

-- Returns the elapsed seconds since a given DateTime
function Module.elapsedSince(start: DateTime): number
	return DateTime.now().UnixTimestamp - start.UnixTimestamp
end

-- Returns true if the given duration (in seconds) has passed since start
function Module.hasElapsed(start: DateTime, durationSeconds: number): boolean
	return Module.elapsedSince(start) >= durationSeconds
end

-- Returns true if both timestamps fall on the same calendar day
function Module.isSameDay(a: DateTime, b: DateTime): boolean
	local aUtc = a:ToUniversalTime()
	local bUtc = b:ToUniversalTime()

	return aUtc.Year == bUtc.Year
		and aUtc.Month == bUtc.Month
		and aUtc.Day == bUtc.Day
end

-- Rounds down to the start of the day (00:00:00) in UTC
function Module.floorToStartOfDay(dateTime: DateTime): DateTime
	local utc = dateTime:ToUniversalTime()
	return DateTime.fromUniversalTime(utc.Year, utc.Month, utc.Day, 0, 0, 0)
end

-- Rounds down to the start of the hour in UTC
function Module.floorToStartOfHour(dateTime: DateTime): DateTime
	local utc = dateTime:ToUniversalTime()
	return DateTime.fromUniversalTime(utc.Year, utc.Month, utc.Day, utc.Hour, 0, 0)
end

-----------------------------
-- MAIN --
-----------------------------
return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004344</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0091238EB8F54B26B26905BCEFB95543">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009652</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_player</string>
							<string name="ScriptGuid">{96661731-C813-4BA7-95EE-357A51EAC44C}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 11/7/24
--[[@description:

]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local AvatarEditorService = game:GetService("AvatarEditorService")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local Cache = require("../ModuleUtils/_Cache")
local _game = require(script.Parent._game)
local Future = require("../ModuleUtils/_Future")

-----------------------------
-- TYPES --
-----------------------------

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}

-- CONSTANTS --
local THUMBNAIL_TYPE = Enum.ThumbnailType.AvatarBust
local THUMBNAIL_SIZE = Enum.ThumbnailSize.Size100x100

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

--[[
	Evaluates if the player's character can be teleported (CFrame changed).
	- Must have character model
	- Must be alive
	- Must not be seated
]]
function Module.canTeleport(player: Player): (boolean, string?)
	local character = player.Character
	if not character then
		return false, "Player has no character model!"
	end
	local humanoid = character and character:FindFirstChildWhichIsA("Humanoid")
	if not humanoid then
		return false, "Player has no humanoid!"
	end
	if humanoid:GetState() == Enum.HumanoidStateType.Seated then
		return false, "Can't teleport while seated!"
	end
	if humanoid:GetState() == Enum.HumanoidStateType.Dead then
		return false, "Can't teleport while dead!"
	end
	return true
end

function Module.getPlayerList(exclude: { Player }?): { Player }
	return _game.getPlayerList(exclude)
end

function Module.getRankInGroupFuture(player: Player, groupId: number)
	return Future.try(function()
		return player:GetRankInGroup(groupId)
	end)
end

--[[
	Client-only!
	Returns a Future if the player has favorited the game.
	Note: PromptReadAccess must be granted or this will fail
]]
function Module.hasFavoritedFuture()
	assert(RunService:IsClient(), "hasFavoritedFuture is client-only")
	return Future.try(function()
		return AvatarEditorService:GetFavorite(game.PlaceId, Enum.AvatarItemType.Asset)
	end)
end

do
	local inProgress = false
	
	--[[
		Client-only!
		Prompts the local player to favorite the game.
	]]
	function Module.promptFavoriteGame()
		if inProgress then
			return
		end
		inProgress = true
		AvatarEditorService:PromptSetFavorite(game.PlaceId, Enum.AvatarItemType.Asset, true)
		AvatarEditorService.PromptSetFavoriteCompleted:Once(function()
			inProgress = false
		end)
	end
end

-- Returns a Future containing an array of players who are friends with <code>player</code>.
function Module.getFriendsInGameFuture(player: Player)
	return Future.new(function()
		local playersInGame = Module.getPlayerList({ player })
		local futures = table.create(#playersInGame)

		for i, otherPlayer in ipairs(playersInGame) do
			futures[i] = Module.isFriendsWithFuture(player, otherPlayer)
		end

		local results = Future.all(futures):Await()
		local friends = {}

		for i, result in ipairs(results) do
			local success, isFriend = table.unpack(result)
			if success and isFriend then
				table.insert(friends, playersInGame[i])
			end
		end

		return friends
	end)
end

function Module.isFriendsWithFuture(player: Player, potentialFriend: Player)
	return Future.try(function(player: Player, potentialFriend: Player)
		return player:IsFriendsWith(potentialFriend.UserId)
	end, player, potentialFriend)
end

do
	local thumbnailTypeToString = {
		[Enum.ThumbnailType.HeadShot] = "AvatarHeadShot",
		[Enum.ThumbnailType.AvatarBust] = "AvatarBust",
		[Enum.ThumbnailType.AvatarThumbnail] = "Avatar"
	}
	local thumbnailSizeToPixels = {
		[Enum.ThumbnailSize.Size48x48] = 48,
		[Enum.ThumbnailSize.Size60x60] = 60,
		[Enum.ThumbnailSize.Size100x100] = 100,
		[Enum.ThumbnailSize.Size150x150] = 150,
		[Enum.ThumbnailSize.Size180x180] = 180,
		[Enum.ThumbnailSize.Size352x352] = 352,
		[Enum.ThumbnailSize.Size420x420] = 420,
	}
	
	-- Retrieves the player's thumbnail string content ID. This function does not yield unlike :GetUserThumbnailAsync()
	function Module.getPlayerThumbnail(userId: number, thumbnailType: Enum.ThumbnailType?, thumbnailSize: Enum.ThumbnailSize?): string
		local thumbnailType = thumbnailType or THUMBNAIL_TYPE
		local thumbnailSize = thumbnailSize or THUMBNAIL_SIZE

		local contentType = thumbnailTypeToString[thumbnailType]
		local pixelSize = thumbnailSizeToPixels[thumbnailSize]
		return `rbxthumb://type={contentType}&id={userId}&w={pixelSize}&h={pixelSize}`
	end
end

local usernameCache = Cache.new(1000)
-- <strong><code>!YIELDS!</code></strong>
-- Retrieves the player's username. Caches the result.
function Module.getPlayerUsername(userId: number): string?
	if not usernameCache:Get(userId) then
		local success, content = pcall(function()
			return Players:GetNameFromUserIdAsync(userId)
		end)
		
		if success then
			usernameCache:Set(userId, content)
		end
	end
	
	return usernameCache:Get(userId)
end

-- A function that checks the network ownership of <code>part</code>. Safe to call from client & server unlike <code>:GetNetworkOwner()</code>.
-- If called from the server without the <code>player</code> argument, the server will check if it owns the part.
-- If called from the client, the local player will check if they have network ownership.
function Module.isNetworkOwner(part: BasePart, player: Player?): boolean
	if RunService:IsServer() then
		-- If player is nil, then the server is checking if the owner is itself.
		return if part:IsGrounded() then not player else part:GetNetworkOwner() == player
	else
		local assemblyRoot = part.AssemblyRootPart
		if not assemblyRoot then
			return false
		end
		return not part:IsGrounded() and (part.AssemblyRootPart :: BasePart).ReceiveAge == 0
	end
end

-- Indicates if the part(s) the motor influences are owned by the <code>player</code>.
function Module.ownsMotor6D(player: Player, motor: Motor6D): boolean
	if not motor.Part0 and not motor.Part1 then
		return false
	end
	if motor.Part0 and (not motor.Part0:IsDescendantOf(workspace) or not Module.isNetworkOwner(motor.Part0, player)) then
		return false
	end
	if motor.Part1 and (not motor.Part1:IsDescendantOf(workspace) or not Module.isNetworkOwner(motor.Part1, player)) then
		return false
	end
	return true
end

-----------------------------
-- MAIN --
-----------------------------
return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004345</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX188877DEFE4D4801B3AEA8CAF2D7BFD8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009653</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_t</string>
							<string name="ScriptGuid">{F2C2A114-66F7-4B60-A6C5-3D9367A8E47E}</string>
							<ProtectedString name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

local t = {}

function t.type(typeName)
	return function(value)
		local valueType = type(value)
		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end

function t.typeof(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false, "any expected, got nil"
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = t.typeof("boolean")

--[[**
	ensures Lua primitive buffer type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.buffer = t.typeof("buffer")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = t.typeof("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = t.typeof("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = t.typeof("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = t.typeof("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = t.typeof("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = t.type("userdata")

--[[**
	ensures Lua primitive vector type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.vector = t.type("vector")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false, "unexpected NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value ~= value then
			return true
		else
			return false, "unexpected non-NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = t.typeof("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = t.typeof("BrickColor")

--[[**
	ensures Roblox CatalogSearchParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CatalogSearchParams = t.typeof("CatalogSearchParams")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = t.typeof("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = t.typeof("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = t.typeof("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = t.typeof("ColorSequenceKeypoint")

--[[**
	ensures Roblox DateTime type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DateTime = t.typeof("DateTime")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = t.typeof("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = t.typeof("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = t.typeof("EnumItem")

--[[**
	ensures Roblox Enums type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enums = t.typeof("Enums")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = t.typeof("Faces")

--[[**
	ensures Roblox FloatCurveKey type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.FloatCurveKey = t.typeof("FloatCurveKey")

--[[**
	ensures Roblox Font type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Font = t.typeof("Font")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = t.typeof("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = t.typeof("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = t.typeof("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = t.typeof("NumberSequenceKeypoint")

--[[**
	ensures Roblox OverlapParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.OverlapParams = t.typeof("OverlapParams")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = t.typeof("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = t.typeof("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = t.typeof("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = t.typeof("Ray")

--[[**
	ensures Roblox RaycastParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastParams = t.typeof("RaycastParams")

--[[**
	ensures Roblox RaycastResult type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastResult = t.typeof("RaycastResult")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = t.typeof("RBXScriptConnection")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = t.typeof("RBXScriptSignal")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = t.typeof("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = t.typeof("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = t.typeof("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = t.typeof("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = t.typeof("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = t.typeof("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = t.typeof("Vector2")

--[[**
	ensures Roblox Vector2int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2int16 = t.typeof("Vector2int16")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = t.typeof("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = t.typeof("Vector3int16")

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false, string.format("expected %s, got %s", tostring(literal), tostring(value))
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.union(table.unpack(literals, 1, size))
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success, errMsg = t.number(value)
	if not success then
		return false, errMsg or ""
	end

	if value % 1 == 0 then
		return true
	else
		return false, string.format("integer expected, got %s", value)
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if value >= min then
			return true
		else
			return false, string.format("number >= %s expected, got %s", min, value)
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg
		end

		if value <= max then
			return true
		else
			return false, string.format("number <= %s expected, got %s", max, value)
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if min < value then
			return true
		else
			return false, string.format("number > %s expected, got %s", min, value)
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if value < max then
			return true
		else
			return false, string.format("number < %s expected, got %s", max, value)
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess, stringErrMsg = t.string(value)
		if not stringSuccess then
			return false, stringErrMsg
		end

		if string.match(value, pattern) == nil then
			return false, string.format("%q failed to match pattern %q", value, pattern)
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success, errMsg = check(value)
		if success then
			return true
		else
			return false, string.format("(optional) %s", errMsg or "")
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success, errMsg = check(args[i])
			if success == false then
				return false, string.format("Bad tuple index #%s:\n\t%s", i, errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key in pairs(value) do
			local success, errMsg = check(key)
			if success == false then
				return false, string.format("bad key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key, val in pairs(value) do
			local success, errMsg = check(val)
			if success == false then
				return false, string.format("bad value for key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess, keyErr = keyChecker(value)
		if not keySuccess then
			return false, keyErr or ""
		end

		local valueSuccess, valueErr = valueChecker(value)
		if not valueSuccess then
			return false, valueErr or ""
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)
			if keySuccess == false then
				return false, string.format("[array] %s", keyErrMsg or "")
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false, string.format("[array] key %s must be sequential", tostring(key))
				end
			end

			local valueSuccess, valueErrMsg = valuesCheck(value)
			if not valueSuccess then
				return false, string.format("[array] %s", valueErrMsg or "")
			end

			return true
		end
	end

--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)
			if keySuccess == false then
				return false, string.format("[strictArray] %s", keyErrMsg or "")
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false, string.format("[strictArray] Array size exceeds limit of %d", #valueTypes)
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess, typeErrMsg = typeFn(value[idx])
				if not typeSuccess then
					return false, string.format("[strictArray] Array index #%d - %s", idx, typeErrMsg)
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false, "bad type for union"
		end
	end

--[[**
		Alias for t.union
	**--]]
	t.some = t.union

--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success, errMsg = check(value)
				if not success then
					return false, errMsg or ""
				end
			end

			return true
		end
	end

--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end

			return true
		end
	end

--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false, string.format("[interface] unexpected field %q", tostring(key))
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if value.ClassName ~= className then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		if childrenCheck then
			local childrenSuccess, childrenErrMsg = childrenCheck(value)
			if not childrenSuccess then
				return false, childrenErrMsg
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if not value:IsA(className) then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		if childrenCheck then
			local childrenSuccess, childrenErrMsg = childrenCheck(value)
			if not childrenSuccess then
				return false, childrenErrMsg
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess, enumItemErrMsg = t.EnumItem(value)
		if not enumItemSuccess then
			return false, enumItemErrMsg
		end

		if value.EnumType == enum then
			return true
		else
			return false, string.format("enum of %s expected, got enum of %s", tostring(enum), tostring(value.EnumType))
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The function to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess, instanceErrMsg = t.Instance(value)
			if not instanceSuccess then
				return false, instanceErrMsg or ""
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false, string.format("Cannot process multiple children with the same name %q", name)
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success, errMsg = check(childrenByName[name])
				if not success then
					return false, string.format("[%s.%s] %s", value:GetFullName(), name, errMsg or "")
				end
			end

			return true
		end
	end
end

--[[**
	ensures value is a Player
	
	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Player = t.instanceIsA('Player')

return t]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004346</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6ABAA98F93754113BD901533DE966F3B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">213d093af61314e10798e9e000005876</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_base64</string>
							<string name="ScriptGuid">{F744C2F5-B212-46AB-9EDF-E214549603DC}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
local alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+/"
local base: { [any]: any } = {}

for i = 0, 63 do
	base[i] = alphabet:sub(i+1,i+1)
	base[alphabet:sub(i+1,i+1)] = i
end

local S1 = {}  --B64 Character 1-2 for ASCII character 1-2
local S2 = {}  --B64 Character 3-4 for ASCII character 2-3
local S3 = {}  --ASCII Character 1 for B64 characters 1-2
local S4 = {}  --ASCII Character 2 for B64 characters 2-3
local S5 = {}  --ASCII Character 3 for B64 characters 3-4

--[[
for C1 = 0, 255 do
	for C2 = 0, 255 do
		for C3 = 0, 255 do
			local Sum = C1 * 65536 + C2 * 256 + C3
			
			local B1 = base[ bit32.extract(Sum, 0,6) ]
			local B2 = base[ bit32.extract(Sum, 6,6) ]
			local B3 = base[ bit32.extract(Sum,12,6) ]
			local B4 = base[ bit32.extract(Sum,18,6) ]
			
			S1[string.char(C1, C2)] = B1 .. B2
			S2[string.char(C2, C3)] = B3 .. B4
			S3[B1 .. B2] = string.char(C1)
			S4[B2 .. B3] = string.char(C2)
			S5[B3 .. B4] = string.char(C3)
		end
	end
end
]]

local C1 = 0
local C2 = 0
local C3 = 0

for C1 = 0, 255 do
	for C2 = 0, 255 do
		local Sum = C3 * 65536 + C2 * 256 + C1

		local B1 = base[ bit32.extract(Sum, 0,6) ]
		local B2 = base[ bit32.extract(Sum, 6,6) ]

		S1[string.char(C1, C2)] = B1 .. B2
		S3[B1 .. B2] = string.char(C1)
	end
end

for C2 = 0, 255 do
	for C3 = 0, 255 do
		local Sum = C3 * 65536 + C2 * 256 + C1

		local B3 = base[ bit32.extract(Sum,12,6) ]
		local B4 = base[ bit32.extract(Sum,18,6) ]

		S2[string.char(C2, C3)] = B3 .. B4
		S5[B3 .. B4] = string.char(C3)
	end
end

for C1 = 0, 192, 64 do
	for C2 = 0, 255 do
		for C3 = 0, 3 do
			local Sum = C3 * 65536 + C2 * 256 + C1

			local B2 = base[ bit32.extract(Sum, 6,6) ]
			local B3 = base[ bit32.extract(Sum,12,6) ]

			S4[B2 .. B3] = string.char(C2)
		end
	end
end

local function encode(data: string): string
	if data == "" then return data end --Empty string

	local padding = -#data % 3
	data ..= string.rep("\0", padding) --Add padding

	local result = table.create(#data/3*2+1, "    ")
	result[1] = base[padding] --The first entry to hold how much padding there is

	local index = 2
	for i = 1, #data, 3 do
		--Get the B64 characters for ascii characters
		result[index  ] = S1[data:sub(i,  i+1)]
		result[index+1] = S2[data:sub(i+1,i+2)]
		index += 2
	end

	return table.concat(result,"")
end

local function decode(data: string): string
	if data == "E" or data == "" then return "" end --Indicator of empty data

	local padding = base[data:sub(1,1)] --How many characters are to remove from the end
	local result = table.create((#data-1)/4*3, "   ")

	local index = 1
	for i = 2, #data, 4 do --Start at second character
		--Get the ascii characters for B64 characters
		result[index  ] = S3[data:sub(i,  i+1)]
		result[index+1] = S4[data:sub(i+1,i+2)]
		result[index+2] = S5[data:sub(i+2,i+3)]
		index += 3
	end

	local concatted = table.concat(result)
	return concatted:sub(1, #concatted-padding) --remove last characters
end

local rng = Random.new(tick())
-- Returns a random Base64 value.
-- Default <strong>length</strong> is 12, resulting in a possible 64^12 combinations.
local function random(length: number?): string
	local randomBase64 = {}
	for i = 1, (length or 12) do
		randomBase64[i] = base[rng:NextInteger(0, 63)]
	end
	return table.concat(randomBase64)
end

return {encode = encode, decode = decode, random = random}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004347</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXBC6295205EBC4846BED07782C4411E68">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">384478d2831029b307b2adbd00005b13</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_camera</string>
							<string name="ScriptGuid">{6E13FB94-3D90-40DC-9E91-897FB2919DE6}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 12/28/24
--[[@description:
	Camera utility functions. Great for Viewport Frames!
]]
-----------------------------
-- SERVICES --
-----------------------------
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

-----------------------------
-- DEPENDENCIES --
-----------------------------

-----------------------------
-- TYPES --
-----------------------------

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Computes the diameter of a cuboid.
function Module.getCuboidDiameter(size: Vector3): number
	return math.sqrt(size.X^2 + size.Y^2 + size.Z^2)
end

-- Fits a sphere to the camera, computing how far back to zoom the camera from the center of the sphere.
function Module.fitSphereToCamera(radius: number, fovDeg: number, aspectRatio: number)
	local halfFov = 0.5 * math.rad(fovDeg)
	if aspectRatio < 1 then
		halfFov = math.atan(aspectRatio * math.tan(halfFov))
	end
	return radius / math.sin(halfFov)
end

-- Uses spherical bounding box to calculate how far back to move a camera.
-- If you need a more accurate calculation for rectangular bounding boxes, use <code>fitCameraAlignedBoundingBoxToCamera()</code>.
function Module.fitBoundingBoxToCamera(size: Vector3, fovDeg: number, aspectRatio: number): number
	-- See: https://community.khronos.org/t/zoom-to-fit-screen/59857/12
	local radius = Module.getCuboidDiameter(size) / 2
	return Module.fitSphereToCamera(radius, fovDeg, aspectRatio)
end

-- Given the camera-aligned bounding box of an object, this calculates how far back to move the camera.
-- Use <code>Math.getCameraAlignedBoundingBox()</code>.
function Module.fitCameraAlignedBoundingBoxToCamera(size: Vector3, cameraFovDeg: number, aspectRatio: number): number
	-- Convert vertical FOV to radians
	local vFov = math.rad(cameraFovDeg)

	-- Compute horizontal FOV based on aspect ratio
	local hFov = 2 * math.atan(aspectRatio * math.tan(vFov / 2))

	-- Extract the box width/height
	local boxWidth  = size.X
	local boxHeight = size.Y

	-- Compare box aspect ratio to screen aspect ratio
	local boxAspect = boxWidth / boxHeight
	local screenAspect = aspectRatio

	if boxAspect > screenAspect then
		-- Box is relatively wide -> horizontal dimension is the limiting factor.
		-- Distance = (boxWidth/2) / tan(horizontalHalfFov)
		return (boxWidth / 2) / math.tan(hFov / 2)
	else
		-- Box is tall (or square-ish) -> vertical dimension is the limiting factor.
		-- Distance = (boxHeight/2) / tan(verticalHalfFov)
		return (boxHeight / 2) / math.tan(vFov / 2)
	end
end

-- Checks if a position is on screen on a camera.
function Module.isOnScreen(camera: Camera, position: Vector3): boolean
	local _, onScreen = camera:WorldToScreenPoint(position)
	return onScreen
end

-- Takes <code>worldPos</code> and converts it to a screen position that is clamped along the screen's edges if <code>worldPos</code> is out of the camera's view.
-- <strong>padding</strong>: Optional padding for calculating the clamped screen position.
-- <strong>camera</strong>: Default camera is <code>workspace.CurrentCamera</code>
-- Returns the clamped screen position & a boolean indicating if the position was clamped.
function Module.toClampedScreenSpace(worldPos: Vector3, padding: Vector2?, camera: Camera?): (Vector2, boolean)
	local camera = camera or workspace.CurrentCamera
	local padding = padding or Vector2.zero
	
	local viewportSize = camera.ViewportSize
	local screenCenter = Vector2.new(viewportSize.X/2, viewportSize.Y/2)
	local viewPos, onScreen = camera:WorldToViewportPoint(worldPos)
	
	local screenPos = Vector2.new(viewPos.X, viewPos.Y)
	local direction = (screenPos - screenCenter)
	
	local wasBehind = viewPos.Z < 0
	if wasBehind then
		direction = -direction
	end
	
	local maxX = viewportSize.X - padding.X
	local maxY = viewportSize.Y - padding.Y

	-- Proposed position, relative to center
	local proposed = screenCenter + direction

	-- Then clamp
	local clampedX = math.clamp(proposed.X, padding.X, maxX)
	local clampedY = math.clamp(proposed.Y, padding.Y, maxY)
	
	local wasXClamped = (clampedX ~= proposed.X)
	local wasYClamped = (clampedY ~= proposed.Y)
	local wasClamped = wasXClamped or wasYClamped or wasBehind
	
	if (wasBehind) and (not wasXClamped and not wasYClamped) and direction.Magnitude > 0 then
		-- Calculate how far we can go in X or Y before hitting the boundary
		local scaleX, scaleY

		if direction.X > 0 then
			scaleX = (maxX - screenCenter.X) / direction.X
		else
			scaleX = (padding.X - screenCenter.X) / direction.X
		end

		if direction.Y > 0 then
			scaleY = (maxY - screenCenter.Y) / direction.Y
		else
			scaleY = (padding.Y - screenCenter.Y) / direction.Y
		end

		-- Pick the smaller absolute scale so that we hit an edge on X or Y
		local scale = math.min(math.abs(scaleX), math.abs(scaleY))
		direction = direction * scale

		-- Recompute proposed and clamp again
		proposed = screenCenter + direction
		clampedX = math.clamp(proposed.X, padding.X, maxX)
		clampedY = math.clamp(proposed.Y, padding.Y, maxY)
	end
	
	return Vector2.new(clampedX, clampedY), wasClamped
end

-- Client-only!
-- Returns what the camera's default CFrame would be calculated by the Roblox camera scripts.
-- Also accounts for <code>CameraOffset</code> on <code>myHumanoid</code>.
-- <strong>zoomDist</strong>: Default is 12.5 or <code>LocalPlayer.CameraMinZoomDistance</code> if greater than 12.5
function Module.getDefaultCameraCFrame(myHumanoid: Humanoid, zoomDist: number?): CFrame
	assert(RunService:IsClient(), "getDefaultCameraCFrame() is client-only!")
	local myRoot = myHumanoid.RootPart :: BasePart
	local zoomDist = math.max(Players.LocalPlayer.CameraMinZoomDistance, 12.5)
	local lookAt = myRoot.CFrame.Position + Vector3.new(0, myRoot.Size.Y/2 + 0.5, 0) + myHumanoid.CameraOffset
	local at = (myRoot.CFrame * CFrame.new(0, zoomDist/2.6397830596715992, zoomDist/1.0352760971197642)).Position + myHumanoid.CameraOffset
	return CFrame.lookAt(at, lookAt)
end

function Module.getAspectRatio(camera: Camera?): number
	local camera = camera or workspace.CurrentCamera
	return camera.ViewportSize.X / camera.ViewportSize.Y
end

function Module.getViewportCenter(camera: Camera?): Vector2
	local camera = camera or workspace.CurrentCamera
	return Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
end

-----------------------------
-- HANDLERS --
-----------------------------

-----------------------------
-- MAIN --
-----------------------------
return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004348</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX543EA1833D3F43EB8BB61249999904DB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">384478d2831029b307b2adbd00005b12</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_buffer</string>
							<string name="ScriptGuid">{EE08084B-C31B-4C53-8E94-DD25C1DCA9D5}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 12/21/24
--[[@description:
	Extra utility functions for buffers for working with Roblox Data Types
]]
-----------------------------
-- SERVICES --
-----------------------------

-----------------------------
-- DEPENDENCIES --
-----------------------------
local Sera = require("./_Sera")
local t = require("./_t")

-----------------------------
-- TYPES --
-----------------------------

type ReceiptInfo = {
	PurchaseId: number,
	PlayerId: number,
	ProductId: number,
	PlaceIdWherePurchased: number,
	CurrencySpent: number,
	CurrencyType: Enum.CurrencyType,
	ProductPurchaseChannel: Enum.ProductPurchaseChannel
}

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}

local raycastParamsSchema = Sera.Schema({
	FilterTypeEnumId = Sera.Int8,
	IgnoreWater = Sera.Boolean,
	CollisionGroup = Sera.String16,
	RespectCanCollide = Sera.Boolean,
	BruteForceAllSlow = Sera.Boolean
})

local raycastResultSchema = Sera.Schema({
	Position = Sera.Vector3,
	Normal = Sera.Vector3,
	MaterialEnumId = Sera.Int8,
	Distance = Sera.Float32
})

local receiptInfoSchema = Sera.Schema({
	PurchaseId = Sera.Float64,
	PlayerId = Sera.Float64,
	ProductId = Sera.Float64,
	PlaceIdWherePurchased = Sera.Float64,
	CurrencySpent = Sera.Uint16,
	CurrencyType = Sera.Enum,
	ProductPurchaseChannel = Sera.Enum
})

local VECTOR_ONES = Vector3.new(1, 1, 1)

local NORMAL_ID_VECTORS = { -- [Enum.Value] = Vector3.fromNormalId(Enum)
	[0] = Vector3.new(1, 0, 0), -- Enum.NormalId.Right
	[1] = Vector3.new(0, 1, 0), -- Enum.NormalId.Top
	[2] = Vector3.new(0, 0, 1), -- Enum.NormalId.Back
	[3] = Vector3.new(-1, 0, 0), -- Enum.NormalId.Left
	[4] = Vector3.new(0, -1, 0), -- Enum.NormalId.Bottom
	[5] = Vector3.new(0, 0, -1) -- Enum.NormalId.Front
}

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-- Serializes a raycast result for use in remote events.
function Module.serializeRaycastResult(result: RaycastResult): (boolean, any)
	local b, err = Sera.Serialize(raycastResultSchema, {
		Position = result.Position,
		Normal = result.Normal,
		MaterialEnumId = result.Material.Value,
		Distance = result.Distance
	})
	if err then
		return false, err
	end
	return true, { b :: any, result.Instance }
end

function Module.deserializeRaycastResult(serialized: any): (boolean, string | RaycastResult)
	if not t.table(serialized) then
		return false, "invalid table"
	end
	if not t.buffer(serialized[1]) then
		return false, "invalid buffer"
	end
	if not t.Instance(serialized[2]) then
		return false, "invalid instance"
	end
	local data = Sera.Deserialize(raycastResultSchema, serialized[1])
	return true, {
		Position = data.Position,
		Material = Enum.Material:FromValue(data.MaterialEnumId) :: any,
		Normal = data.Normal,
		Distance = data.Distance,
		Instance = serialized[2]
	} :: RaycastResult
end

-- Serializes a raycast param for use in remote events.
-- CollisionGroup must be no longer than 16 characters long.
function Module.serializeRaycastParams(params: RaycastParams): (boolean, any)
	if params.CollisionGroup:len() > 16 then
		return false, "CollisionGroup name too long"
	end
	local b, err = Sera.Serialize(raycastParamsSchema, {
		FilterTypeEnumId = params.FilterType.Value,
		IgnoreWater = params.IgnoreWater,
		CollisionGroup = params.CollisionGroup,
		RespectCanCollide = params.RespectCanCollide,
		BruteForceAllSlow = params.BruteForceAllSlow
	})
	if err then
		return false, err
	end
	return true, { b :: any, params.FilterDescendantsInstances }
end

function Module.deserializeRaycastParams(serialized: any): (boolean, string | RaycastParams)
	if not t.table(serialized) then
		return false, "invalid table"
	end
	if not t.buffer(serialized[1]) then
		return false, "invalid buffer"
	end
	if not t.array(t.Instance)(serialized[2]) then
		return false, "invalid FilterDescendantInstances"
	end
	local data = Sera.Deserialize(raycastParamsSchema, serialized[1])
	local params = RaycastParams.new()
	params.FilterDescendantsInstances = serialized[2]
	params.FilterType = Enum.RaycastFilterType:FromValue(data.FilterTypeEnumId) :: any
	params.CollisionGroup = data.CollisionGroup
	params.IgnoreWater = data.IgnoreWater
	params.RespectCanCollide = data.RespectCanCollide
	params.BruteForceAllSlow = data.BruteForceAllSlow
	return true, params
end

function Module.fromReceiptInfo(info: ReceiptInfo): buffer
	local b, err = Sera.Serialize(receiptInfoSchema, {
		PurchaseId = info.PurchaseId,
		PlayerId = info.PlayerId,
		ProductId = info.ProductId,
		PlaceIdWherePurchased = info.PlaceIdWherePurchased,
		CurrencySpent = info.CurrencySpent,
		CurrencyType = info.CurrencyType,
		ProductPurchaseChannel = info.ProductPurchaseChannel,
	})
	if err then
		error(err, 2)
	end
	return b :: buffer
end

function Module.toReceiptInfo(b: buffer): ReceiptInfo
	local info = Sera.Deserialize(receiptInfoSchema, b)
	return info
end

-- Creates a buffer with a terminated string (strings of bytes that end in a 0 byte). This allows you to easily know when a string ends in a buffer.
-- <strong>extraOffset</strong>: Increases buffer byte size if needing to store extra data in the buffer. Default size is length of the string.
-- Returns the buffer & total length of the buffer.
function Module.writeTerminatedString(str: string, extraOffset: number?): (buffer, number)
	local strLength = #str
	local padding = extraOffset or 0
	local bufferLength = strLength + 1 + padding
	local b = buffer.create(bufferLength) -- +1 for the 0 byte
	for i = 1, strLength do
		buffer.writeu8(b, i - 1, string.byte(str, i, i))
	end
	buffer.writeu8(b, strLength + 1, 0)
	return b, bufferLength
end

-- Reads the buffer and builds a string. Reading stops if a null-character is reached or the buffer ends.
function Module.readTerminatedString(b: buffer): (string)
	local outputCharacters = {}
	local maxLength = buffer.len(b)
	local length = 0
	-- Bytes are read continuously until a null-character is reached or until the buffer ends.
	while true do
		local byte = buffer.readu8(b, length)
		if length == maxLength then
			-- End of buffer reached
			break
		elseif byte == 0 then
			-- String has ended
			break
		else
			length += 1
			outputCharacters[length] = byte
		end
	end
	
	return string.char(table.unpack(outputCharacters))
end

-- Stores the BrickColor to a buffer as a 16-bit unsigned integer.
function Module.fromBrickColor(c: BrickColor): buffer
	local b = buffer.create(2)
	buffer.writeu16(b, 0, c.Number)
	return b
end

function Module.toBrickColor(b: buffer): BrickColor
	return BrickColor.new(buffer.readu16(b, 0))
end

-- Stores the Color3 to a buffer as a 24-bit integer.
-- R, G, B values are expected to be whole integers.
function Module.fromColor3(c: Color3): buffer
	local b = buffer.create(3)
	buffer.writeu8(b, 0, c.R)
	buffer.writeu8(b, 1, c.B)
	buffer.writeu8(b, 2, c.G)
	return b
end

function Module.toColor3(b: buffer): Color3
	return Color3.fromRGB(buffer.readu8(b, 0), buffer.readu8(b, 1), buffer.readu8(b, 2))
end

-- Stores the Vector3 in a buffer with three 32-bit floats (12 bytes).
function Module.fromVector3(v: Vector3): buffer
	local b = buffer.create(12)
	buffer.writef32(b, 0, v.X)
	buffer.writef32(b, 4, v.Y)
	buffer.writef32(b, 8, v.Z)
	return b
end

-- <strong>offset</strong> Optional starting point to read values from the buffer. Default is 0.
function Module.toVector3(b: buffer, offset: number?): Vector3
	local offset = offset or 0
	return Vector3.new(buffer.readf32(b, 0 + offset), buffer.readf32(b, 4 + offset), buffer.readf32(b, 8 + offset))
end

-- Stores the Vector2 in a buffer with two 32-bit floats (8 bytes).
function Module.fromVector2(v: Vector2): buffer
	local b = buffer.create(8)
	buffer.writef32(b, 0, v.X)
	buffer.writef32(b, 4, v.Y)
	return b
end

function Module.toVector2(b: buffer): Vector2
	return Vector2.new(buffer.readf32(b, 0), buffer.readf32(b, 4))
end

-- Stores the UDim2 in a buffer with two 32-bit floats and two signed 32-bit integers (16 bytes total).
function Module.fromUDim2(u: UDim2): buffer
	local b = buffer.create(16)
	buffer.writef32(b, 0, u.X.Scale)
	buffer.writei32(b, 4, u.X.Offset)
	buffer.writef32(b, 8, u.Y.Scale)
	buffer.writei32(b, 12, u.Y.Offset)
	return b
end

function Module.toUDim2(b: buffer): UDim2
	return UDim2.new(buffer.readf32(b, 0), buffer.readi32(b, 4), buffer.readf32(b, 8), buffer.readi32(b, 12))
end

-- Stores the ray as two Vector2's representing Origin and Direction (24 bytes total).
function Module.fromRay(r: Ray)
	local b = buffer.create(24)
	local origin = Module.fromVector3(r.Origin)
	local direction = Module.fromVector3(r.Direction)
	buffer.copy(b, 0, origin, 0)
	buffer.copy(b, 12, direction, 0)
	return b
end

function Module.toRay(b: buffer): Ray
	local origin = Module.toVector3(b)
	local direction = Module.toVector3(b, 12)
	return Ray.new(origin, direction)
end

-- Stores the CFrame to a buffer. If the CFrame is axis aligned, it takes up 13 bytes. Otherwise, it takes 49 bytes.
function Module.fromCFrame(cf: CFrame): buffer
	local upVector = cf.UpVector
	local rightVector = cf.RightVector
	
	-- Source for how to store CFrame in a buffer:
	-- https://github.com/Dekkonot/bitbuffer/blob/main/src/roblox.lua
	
	-- This is an easy trick to check if a CFrame is axis-aligned:
	-- Essentially, in order for a vector to be axis-aligned, two of the components have to be 0
	-- This means that the dot product between the vector and a vector of all 1s will be 1 (0*x = 0)
	-- Since these are all unit vectors, there is no other combination that results in 1.
	local rightAligned = math.abs(rightVector:Dot(VECTOR_ONES))
	local upAligned = math.abs(upVector:Dot(VECTOR_ONES))
	
	local axisAligned = (math.abs(1 - rightAligned) < 0.00001 or rightAligned == 0)
		and (math.abs(1 - upAligned) < 0.00001 or upAligned == 0)
	
	if axisAligned then
		local position = cf.Position
		-- The ID of an orientation is generated through what can best be described as 'hand waving';
		-- This is how Roblox does it and it works, so it was chosen to do it this way too.
		local rightNormal, upNormal
		for i = 0, 5 do
			local v = NORMAL_ID_VECTORS[i]
			if 1 - v:Dot(rightVector) < 0.00001 then
				rightNormal = i
			end
			if 1 - v:Dot(upVector) < 0.00001 then
				upNormal = i
			end
		end
		-- The ID generated here is technically off by 1 from what Roblox would store, but that's not important
		-- It just means that 0x02 is actually 0x01 for the purposes of this module's implementation.
		
		local b = buffer.create(13)
		buffer.writeu8(b, 0, rightNormal * 6 + upNormal) -- Indicates this CFrame is axis-aligned.
		buffer.writef32(b, 1, position.X)
		buffer.writef32(b, 5, position.Y)
		buffer.writef32(b, 9, position.Z)
		return b
	else
		local b = buffer.create(49)
		local x, y, z, r00, r01, r02, r10, r11, r12, r20, r21, r22 = cf:GetComponents()
		buffer.writeu8(b, 0, 0) -- Indicates this CFrame is not axis-aligned.
		buffer.writef32(b, 1, x)
		buffer.writef32(b, 5, y)
		buffer.writef32(b, 9, z)
		buffer.writef32(b, 13, r00)
		buffer.writef32(b, 17, r01)
		buffer.writef32(b, 21, r02)
		buffer.writef32(b, 25, r10)
		buffer.writef32(b, 29, r11)
		buffer.writef32(b, 33, r12)
		buffer.writef32(b, 37, r20)
		buffer.writef32(b, 41, r21)
		buffer.writef32(b, 45, r22)
		return b
	end
end

function Module.toCFrame(b: buffer): CFrame
	local id = buffer.readu8(b, 0)
	
	if id == 0 then
		-- this is not an axis-aligned CFrame
		return CFrame.new(
			buffer.readf32(b, 1), buffer.readf32(b, 5), buffer.readf32(b, 9),
			buffer.readf32(b, 13), buffer.readf32(b, 17), buffer.readf32(b, 21),
			buffer.readf32(b, 25), buffer.readf32(b, 29), buffer.readf32(b, 33),
			buffer.readf32(b, 37), buffer.readf32(b, 41), buffer.readf32(b, 45)
		)
	else
		local rightVector = NORMAL_ID_VECTORS[math.floor(id / 6)]
		local upVector = NORMAL_ID_VECTORS[id % 6]
		local lookVector = rightVector:Cross(upVector)
		
		return CFrame.new(
			buffer.readf32(b, 1), buffer.readf32(b, 5), buffer.readf32(b, 9),
			rightVector.X, upVector.X, lookVector.X,
			rightVector.Y, upVector.Y, lookVector.Y,
			rightVector.Z, upVector.Z, lookVector.Z
		)
	end
end

-- Buffer size varies due to the nature of this data type. Each value of a keypoint is stored as a 32-bit float.
function Module.fromNumberSequence(s: NumberSequence): buffer
	local numOfKeypoints = #s.Keypoints
	local bufferSize = numOfKeypoints * 3 * 4 -- 3 values per keypoint, 4 bytes for each value
	local b = buffer.create(bufferSize + 4) -- extra 4 bytes to indicate num of keypoints
	
	buffer.writeu32(b, 0, numOfKeypoints)
	local offset = 4
	for _, keypoint in ipairs(s.Keypoints) do
		buffer.writef32(b, offset, keypoint.Time)
		offset += 4
		buffer.writef32(b, offset, keypoint.Value)
		offset += 4
		buffer.writef32(b, offset, keypoint.Envelope)
		offset += 4
	end
	return b
end

function Module.toNumberSequence(b: buffer): NumberSequence
	local keypointCount = buffer.readu32(b, 0)
	local keypoints = table.create(keypointCount)
	
	-- As it turns out, creating a NumberSequence with a negative value as its first argument (in the first and second constructor)
	-- creates NumberSequenceKeypoints with negative envelopes. The envelope is read and saved properly, as you would expect,
	-- but you can't create a NumberSequence with a negative envelope if you're using a table of keypoints (which is happening here).
	-- If you're confused, run this snippet: NumberSequence.new(NumberSequence.new(-1).Keypoints)
	-- As a result, there has to be some branching logic in this function.
	-- ColorSequences don't have envelopes so it's not necessary for them.
	
	local offset = 4
	for i = 1, keypointCount do
		local time = buffer.readf32(b, offset)
		offset += 4
		local value = buffer.readf32(b, offset)
		offset += 4
		local envelope: number? = buffer.readf32(b, offset)
		if value < 0 then
			envelope = nil
		end
		offset += 4
		keypoints[i] = NumberSequenceKeypoint.new(time, value, envelope)
	end
	
	return NumberSequence.new(keypoints)
end

-- Stores the number range in a buffer with two 32-bit floats for the Min and Max (8 bytes total).
-- If the min and max is the same, then the buffer is 4 bytes.
function Module.fromNumberRange(r: NumberRange): buffer
	if r.Min ~= r.Max then
		local b = buffer.create(8)
		buffer.writef32(b, 0, r.Min)
		buffer.writef32(b, 4, r.Max)
		return b
	else
		local b = buffer.create(4)
		buffer.writef32(b, 0, r.Min)
		return b
	end
end

function Module.toNumberRange(b: buffer): NumberRange
	if buffer.len(b) == 4 then
		local num = buffer.readf32(b, 0)
		return NumberRange.new(num)
	else
		return NumberRange.new(buffer.readf32(b, 0), buffer.readf32(b, 4))
	end
end

-- Stores the number as a 32-bit float.
function Module.fromFloat(num: number): buffer
	local b = buffer.create(4)
	buffer.writef32(b, 0, num)
	return b
end

function Module.toFloat(b: buffer): number
	return buffer.readf32(b, 0)
end

-- Given an integer, this function will store the number in the buffer with the smallest possible size.
-- Floats passed to this function will lose all precision.
-- Accepts numbers below 0.
-- You can optionally specify the size in bytes instead (1, 2, 4, or 8)
function Module.fromSigned(num: number, bytes: number?): buffer
	if bytes and not t.literal(1, 2, 4, 8)(bytes) then
		error("Invalid byte size", 2)
	end
	local b: buffer

	if bytes == 1 or (not bytes and num >= -128 and num <= 127) then -- 8 bit
		b = buffer.create(bytes or 1)
		buffer.writei8(b, 0, num)
	elseif bytes == 2 or (num >= -32768 and num <= 32767) then -- 16 bit
		b = buffer.create(bytes or 2)
		buffer.writei16(b, 0, num)
	elseif bytes == 4 or (not bytes and num >= -2147483648 and num <= 2147483647) then -- 32 bit
		b = buffer.create(bytes or 4)
		buffer.writei32(b, 0, num)
	else
		b = buffer.create(bytes or 8) -- 64 bit
		buffer.writef64(b, 0, num)
	end
	
	return b
end

-- Returns the integer stored in the buffer returned by .fromUnsigned()
function Module.toSigned(b: buffer): number
	local len = buffer.len(b)
	
	if len == 1 then
		return buffer.readi8(b, 0)
	elseif len == 2 then
		return buffer.readi16(b, 0)
	elseif len == 4 then
		return buffer.readi32(b, 0)
	else
		return buffer.readf64(b, 0)
	end
end

-- Given an integer, this function will store the number in the buffer with the smallest possible size.
-- Floats passed to this function will lose all precision.
-- Do not pass any numbers below 0.
-- You can optionally specify the size in bytes instead (1, 2, 4, or 8)
function Module.fromUnsigned(num: number, bytes: number?): buffer
	assert(num >= 0, "Received signed integer!")
	if bytes and not t.literal(1, 2, 4, 8)(bytes) then
		error("Invalid byte size", 2)
	end
	local b: buffer
	
	if bytes == 1 or (not bytes and num <= 0xFF) then -- 8 bit
		b = buffer.create(1)
		buffer.writeu8(b, 0, num)
	elseif bytes == 2 or (not bytes and num <= 0xFFFF) then -- 16 bit
		b = buffer.create(2)
		buffer.writeu16(b, 0, num)
	elseif bytes == 4 or (not bytes and num <= 0xFFFFFFFF) then -- 32 bit
		b = buffer.create(4)
		buffer.writeu32(b, 0, num)
	else
		b = buffer.create(8) -- 64 bit
		buffer.writef64(b, 0, num)
	end
	
	return b
end

-- Returns the integer stored in the buffer returned by .fromUnsigned()
function Module.toUnsigned(b: buffer): number
	local len = buffer.len(b)
	if len == 1 then
		return buffer.readu8(b, 0)
	elseif len == 2 then
		return buffer.readu16(b, 0)
	elseif len == 4 then
		return buffer.readu32(b, 0)
	else
		return buffer.readf64(b, 0)
	end
end

-- Buffer size varies due to the nature of this data type.
function Module.fromEnum(e: EnumItem): buffer
	local b, bufferLength = Module.writeTerminatedString(tostring(e.EnumType), 2)
	buffer.writeu16(b, bufferLength - 2, e.Value) -- Assuming enum IDs never go beyond 16-bit unsigned integers
	return b
end

function Module.toEnum(b: buffer)
	local name = Module.readTerminatedString(b)
	local value = buffer.readu16(b, buffer.len(b) - 2) -- Assuming enum IDs never go beyond 16-bit unsigned integers

	for _, v in ipairs(Enum[name]:GetEnumItems()) do
		if v.Value == value then
			return v
		end
	end
	
	error(`toEnum() could not get value!\n{value} is not a valid member of {name}`, 2)
end

-----------------------------
-- MAIN --
-----------------------------
return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004349</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX14A89B2FA0694B2DA587F74A059A2231">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">384478d2831029b307b2adbd00005b14</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_vfx</string>
							<string name="ScriptGuid">{D4478697-F2C8-48EA-A70E-E61F766F51B8}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 12/30/24
--[[@description:
	Useful utility functions for VFX
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

-----------------------------
-- DEPENDENCIES --
-----------------------------

-----------------------------
-- TYPES --
-----------------------------
local FastCastTypes = require("../ModuleUtils/_FastCastRedux/FastCastTypes")

type BulletTrailData = {
	T0: number?,
	P0: Vector3?,
	V0: Vector3?,
	T1: number,
	P1: Vector3,
	V1: Vector3?,
	BulletSize: number,
	BulletBloom: number,
	BulletBrightness: number,
}

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}

local bulletTrail = script:WaitForChild('BulletTracer')
local rng = Random.new(tick())

local CAMERA = workspace.CurrentCamera

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Creates an explosion of unanchored parts.
-- <strong>force</strong>: Used to apply a direct force on the Y-axis and used for spread on X and Z axes.
-- <strong>sizeMultiplier</strong>: Randomly picks between the Min and Max to adjust the size of cloned parts from the template array.
function Module.explosion(templateParts: { BasePart }, origin: Vector3, force: number, count: number, sizeMultiplier: NumberRange?, collisionGroup: string?)
	local arrayLen = #templateParts
	assert(arrayLen > 0, "no parts found in array")
	local sizeMultiplier = sizeMultiplier or NumberRange.new(1)
	local spread = force * 1.25
	local tweenInfo = TweenInfo.new(0.75)
	for i = 1, count do
		local part = templateParts[rng:NextInteger(1, arrayLen)]:Clone()
		part.Name = "_explosionDebris"
		part.Parent = workspace
		part.Size = part.Size * rng:NextNumber(sizeMultiplier.Min, sizeMultiplier.Max)
		local tau = math.pi * 2
		part.CFrame = CFrame.new(origin) * CFrame.Angles(rng:NextNumber(0, tau), rng:NextNumber(0, tau), rng:NextInteger(0, tau))
		part.Anchored = false
		part.CanCollide = true
		part.CollisionGroup = collisionGroup or part.CollisionGroup
		part.Parent = workspace
		part:ApplyImpulse(Vector3.new(rng:NextNumber(-spread, spread), force, rng:NextNumber(-spread, spread)))
		task.delay(rng:NextNumber(3, 4), function()
			local tween = TweenService:Create(part, tweenInfo, { Size = Vector3.new(0.01, 0.01, 0.01) })
			tween:Play()
			tween.Completed:Wait()
			part:Destroy()
		end)
	end
end

-- Returns the bullet trail VFX to be used in a cast.
function Module.getBulletTrail()
	return bulletTrail
end

-- Adds <code>BulletTrailData</code> to the activeCast's <code>UserData</code> for use in <code>updateBulletTrail</code>.
function Module.createBulletTrailData(activeCast: FastCastTypes.ActiveCast, trailSize: number?, bloom: number?, brightness: number?): BulletTrailData
	local trailSize = trailSize or 0.2
	local bloom = bloom or 0.005
	local brightness = brightness or 1500
	local origin = activeCast:GetPosition()
	
	activeCast.UserData.BulletTrailData = {
		T0 = nil,
		P0 = nil,
		V0 = nil,
		T1 = os.clock(),
		P1 = CAMERA.CFrame:PointToObjectSpace(origin),
		V1 = nil,
		BulletSize = 0.2,
		BulletBloom = 0.005,
		BulletBrightness = 1500,
	} :: BulletTrailData
	return activeCast.UserData.BulletTrailData
end

-- Call this each time the LengthChanged event fires for a caster. This dynamically changes the look of the beam for
-- the bullet trail to provide a realistic looking effect. The activeCast should have BulletTrailData and the correct CosmeticBulletObject!
function Module.updateBulletTrail(activeCast: FastCastTypes.ActiveCast, lastPosition: Vector3)
	assert(activeCast.UserData.BulletTrailData, "activeCast does not have BulletTrailData")
	assert(activeCast.RayInfo.CosmeticBulletObject, "missing CosmeticBulletObject")
	
	-- Calculate the new position of the beam attachments
	local trailData = activeCast.UserData.BulletTrailData :: BulletTrailData
	local cameraCFrame = CAMERA.CFrame
	local position = activeCast:GetPosition()
	local vfx = activeCast.RayInfo.CosmeticBulletObject :: any
	local attachment1: Attachment = vfx.Attachment1
	local attachment0: Attachment = vfx.Attachment0
	local beam: Beam = vfx.Beam
	
	local T2 = os.clock()
	local P2 = CAMERA.CFrame:PointToObjectSpace(position)
	local V2
	if trailData.T0 then
		V2 = 2 / (T2 - trailData.T1) * (P2 - trailData.P1) - (P2 - trailData.P0) / (T2 - trailData.T0)
	else
		V2 = (P2 - trailData.P1) / (T2 - trailData.T1)
		trailData.V1 = V2
	end
	trailData.T0, trailData.V0, trailData.P0 = trailData.T1, trailData.V1, trailData.P1
	trailData.T1, trailData.V1, trailData.P1 = T2, V2, P2
	local deltaTime = trailData.T1 - trailData.T0 :: number
	local M0 = (trailData.V0 :: Vector3).Magnitude
	local M1 = (trailData.V1 :: Vector3).Magnitude
	attachment0.Position = CAMERA.CFrame * trailData.P0
	attachment1.Position = CAMERA.CFrame * trailData.P1
	if M0 > 1.0E-8 then
		attachment0.Axis = CAMERA.CFrame:VectorToWorldSpace(trailData.V0 :: Vector3 / M0)
	end
	if M1 > 1.0E-8 then
		attachment1.Axis = CAMERA.CFrame:VectorToWorldSpace(trailData.V1 :: Vector3 / M1)
	end
	local dist0 = -(trailData.P0 :: Vector3).Z
	local dist1 = -(trailData.P1 :: Vector3).Z
	dist0 = math.max(0, dist0)
	dist1 = math.max(0, dist1)
	local W0 = trailData.BulletSize + trailData.BulletBloom * dist0
	local W1 = trailData.BulletSize + trailData.BulletBloom * dist1
	local L = ((trailData.P1 :: Vector3 - trailData.P0 :: Vector3) * Vector3.new(1, 1, 0)).Magnitude
	local transparency = 1 - 4 * trailData.BulletSize * trailData.BulletSize / ((W0 + W1) * (2 * L + W0 + W1)) * trailData.BulletBrightness
	beam.CurveSize0 = deltaTime / 3 * M0
	beam.CurveSize1 = deltaTime / 3 * M1
	beam.Width0 = W0
	beam.Width1 = W1
	beam.Transparency = NumberSequence.new(transparency)
end

-- Tweens a blur in and out for impact effects.
function Module.blurFrame(fadeInTime: number, fadeOutTime: number, size: number)
	local blur = Instance.new("BlurEffect")
	blur.Name = "_VFXBlur"
	blur.Size = 0
	blur.Parent = workspace.CurrentCamera
	
	local t = TweenService:Create(blur, TweenInfo.new(fadeInTime), { Size = size })
	t:Play()
	
	t.Completed:Once(function()
		local t = TweenService:Create(blur, TweenInfo.new(fadeOutTime), { Size = 0 })
		t:Play()
		t.Completed:Once(function()
			task.wait(0.05)
			blur:Destroy()
		end)
	end)
end

function Module.colorFrame(fadeInTime: number, fadeOutTime: number, color: Color3)
	local colorCorrection = Instance.new("ColorCorrectionEffect")
	local white = Color3.new(1, 1, 1)
	colorCorrection.TintColor = white
	colorCorrection.Parent = workspace.CurrentCamera
	
	local t = TweenService:Create(colorCorrection, TweenInfo.new(fadeInTime), { TintColor = color })
	t:Play()

	t.Completed:Once(function()
		local t = TweenService:Create(colorCorrection, TweenInfo.new(fadeOutTime), { TintColor = white })
		t:Play()
		t.Completed:Once(function()
			task.wait(0.05)
			colorCorrection:Destroy()
		end)
	end)
end

-- Goes through <code>container</code>'s children and sets <code>.Enabled</code> to <code>enable</code>.
-- You can optionally include beams/trails and search through all descendants.
function Module.toggleAllEmitters(container: Instance, enable: boolean, includeBeams: boolean?, descendants: boolean?)
	local function handleChild(child: Instance)
		if child:IsA("ParticleEmitter") then
			child.Enabled = enable
		elseif includeBeams and (child:IsA("Beam") or child:IsA("Trail")) then
			(child :: any).Enabled = enable
		end
	end
	
	if descendants then
		for _, descendant in ipairs(container:GetDescendants()) do
			handleChild(descendant)
		end
	else
		for _, child in ipairs(container:GetChildren()) do
			handleChild(child)
		end
	end
end

-- Goes through the <code>container</code> and copies any child emitters into <code>target</code>.
-- <strong>copyAttachments</strong>: Optionally copy over any child attachments. If attachments are present and copied, then
-- <code>target</code> must be a BasePart! Otherwise, this function will error.
-- <strong>copyBeams</strong>: If true, will also automatically copy attachments. Attachment property references will be maintained.
-- Returns all copied child instances.
function Module.copyEmittersTo(container: Instance, target: Instance, copyAttachments: boolean?, copyBeams: boolean?): { any }
	local result: { any } = {}
	local dontClone: { [Instance]: boolean } = {}
	for _, child in ipairs(container:GetChildren()) do
		if 
			not (child:IsA("ParticleEmitter")
			or ((copyAttachments or copyBeams) and child:IsA("Attachment"))
			or (copyBeams and (child:IsA("Beam") or child:IsA("Trail"))))
		then
			continue
		end
		if dontClone[child] then
			continue
		end
		local clone = child:Clone() :: Instance
		
		if clone:IsA("Beam") or clone:IsA("Trail") then
			if clone.Attachment0 then
				local a0 = clone.Attachment0:Clone()
				dontClone[clone.Attachment0] = true
				a0.Parent = target;
				(clone :: any).Attachment0 = a0
				table.insert(result, a0)
			end
			if clone.Attachment1 then
				local a1 = clone.Attachment1:Clone();
				dontClone[clone.Attachment1] = true
				a1.Parent = target;
				(clone :: any).Attachment1 = a1
				table.insert(result, a1)
			end
		end
		
		clone.Parent = target
		table.insert(result, clone)
	end
	return result
end

-- Goes through the array and destroys the instances. Useful for cleaning up instances returned from <code>copyEmittersTo()</code>.
function Module.destroyVFX(instances: { any })
	for _, instance in ipairs(instances) do
		instance:Destroy()
	end
end

-- Emits the emitter according to <code>count</code> or <code>EmitCount</code> attribute or 1 by default.
function Module.emit(emitter: ParticleEmitter, count: number?)
	emitter:Emit(count or emitter:GetAttribute("EmitCount") or 1)
end

-- Goes through <code>container</code>'s children and emits particles from emitters based on their <code>EmitCount</code> attribute.
-- Also accounts for <code>EmitDelay</code> attribute (if it exists).
-- You can optionally search through all descendants.
function Module.emitAll(container: Instance, descendants: boolean?)
	local function handleChild(child: Instance)
		if child:IsA("ParticleEmitter") then
			local delay = child:GetAttribute("EmitDelay")
			local count = child:GetAttribute("EmitCount")
			if not count then
				warn(`emitter: {child} missing EmitCount attribute, defaulting to 1`)
				count = 1
			end
			if delay then
				task.delay(delay, function()
					child:Emit(count)
				end)
			else
				child:Emit(count)
			end
		end
	end
	
	if descendants then
		for _, descendant in ipairs(container:GetDescendants()) do
			handleChild(descendant)
		end
	else
		for _, child in ipairs(container:GetChildren()) do
			handleChild(child)
		end
	end
end

-----------------------------
-- MAIN --
-----------------------------
return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000434a</UniqueId>
						</Properties>
						<Item class="Folder" referent="RBX2702ADE610B74F08A65C582C59657F43">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">BulletTracer</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b8a</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXA3D3B25BBE78465BAC0B7B9A25624FF3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">384478d2831029b307b2adbd00005b1b</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_remotes</string>
							<string name="ScriptGuid">{3162E50B-0E18-4DAB-8235-19171D7B1660}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 1/30/25
--[[@description:
	Utility functions for remotes/remote related utility.
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local _game = require("./_game")

-----------------------------
-- TYPES --
-----------------------------

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}

-- CONSTANTS --

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

function Module.fireToAllClientsExcept(exception: { Player }, remote: RemoteEvent, ...: any)
	local players = _game.getPlayerList(exception)
	for _, player in players do
		remote:FireClient(player, ...)
	end
end

-----------------------------
-- MAIN --
-----------------------------
return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000434f</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX2F8417C938924942860FB6B1CCE4585F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">384478d2831029b307b2adbd00005b19</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_cframe</string>
							<string name="ScriptGuid">{CE4948E9-AFBE-41C2-ADB6-77FB66B40787}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: YOUR_NAME_HERE
--@date: CREATION_DATE_HERE
--[[@description:

]]
-----------------------------
-- SERVICES --
-----------------------------

-----------------------------
-- DEPENDENCIES --
-----------------------------

-----------------------------
-- TYPES --
-----------------------------

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Grabs the orientation of the CFrame and stores it in a Vector3 (in degrees).
function Module.getOrientation(cframe: CFrame): Vector3
	assert(cframe, "cframe is invalid or nil")
	local rx, ry, rz = cframe:ToOrientation()
	return Vector3.new(math.deg(rx), math.deg(ry), math.deg(rz))
end

-- Returns a CFrame.Angles that represents a rotation on the specified axis that is oriented towards lookAt along with the radian rotation value.
function Module.getLookRotation(axis: "X" | "Y", origin: Vector3, lookAt: Vector3): (CFrame, number)
	local unit = origin - lookAt
	if axis == "X" then
		local angle = math.atan2(unit.Y, unit.Z)
		return CFrame.Angles(-angle, 0, 0), -angle
	elseif axis == "Y" then
		local angle = math.atan2(unit.X, unit.Z)
		return CFrame.Angles(0, angle, 0), angle
	else
		error(`Invalid axis: {axis}`, 2)
	end
end

-- Aligns vector <code>a</code> to vector <code>b</code> by giving a CFrame rotation in world-space that represents the smallest rotation to get there.
function Module.cframeFromTo(a: Vector3, b: Vector3): CFrame
	local dr = a:Dot(b)
	local di = a:Cross(b)

	local d = math.sqrt(dr*dr + di:Dot(di))
	if d < 1e-6 then
		return CFrame.identity
	end

	if dr < 0 and -di.Magnitude/dr < 1e-6 then
		-- this is a degenerate case where a ~ -b
		-- so we must arbitrate a perpendicular axis to a and b to disambiguate.
		local r = b - a
		local r2 = r*r
		local min = math.min(r2.X, r2.Y, r2.Z)
		if min == r2.X and min == r2.Y then

			return CFrame.new(0, 0, 0, 0, 0, r.Z, 0)
		elseif min == r2.Y and min == r2.Z then
			return CFrame.new(0, 0, 0, 0, r.X, 0, 0)
		elseif min == r2.X and min == r2.Z then
			return CFrame.new(0, 0, 0, r.Y, 0, 0, 0)
		elseif min == r2.X then
			return CFrame.new(0, 0, 0, 0, -r.Z, r.Y, 0)
		elseif min == r2.Y then
			return CFrame.new(0, 0, 0, r.Z, 0, -r.X, 0)
		else --if min == r2.Z then
			return CFrame.new(0, 0, 0, -r.Y, r.X, 0, 0)
		end
	end

	return CFrame.new(0, 0, 0, di.X, di.Y, di.Z, dr + d)
end

-- Returns a CFrame that keeps only the rotation of <code>cframe</code>.
function Module.onlyRotation(cframe: CFrame): CFrame
	return cframe - cframe.Position
end

--[[
	Returns a CFrame which is minimally rotated from <code>cframe</code> such that the following condition is true:
	<code>returnedCFrame:VectorToWorldSpace(localAxis) == worldGoal</code>
	AKA: You take one of a local axis (-Vector3.xAxis, Vector3.yAxis, etc) and reorient it so that this local-axis points
	exactly in the direction of <code>worldGoal</code> (in world-space).
]]
function Module.redirectLocalAxis(cframe: CFrame, localAxis: Vector3, worldGoal: Vector3): CFrame
	local localGoal = cframe:VectorToObjectSpace(worldGoal)
	local m = localAxis.Magnitude * localGoal.Magnitude
	local d = localAxis:Dot(localGoal)
	local c = localAxis:Cross(localGoal)
	local R = CFrame.new(0, 0, 0, c.X, c.Y, c.Z, d + m)

	if R == R then
		return cframe * R
	else
		return cframe
	end
end

-- Returns a CFrame from an axis angle, handling NaN values.
-- <strong>axisAngle</strong>: A Vector3 that represents the axis to rotate around as well as how much to
-- rotate around that axis (based on its <code>Magnitude</code>).
-- <code>axisAngle == a * b</code> where <code>a</code> is a unit vector and <code>b</code> is the rotation in radians.
-- <strong>position</strong>: Provide an optional positional value for the CFrame.
function Module.axisAngleToCFrame(axisAngle: Vector3, position: Vector3?): CFrame
	local angle = axisAngle.Magnitude
	local cframe = CFrame.fromAxisAngle(axisAngle, angle)

	if cframe ~= cframe then
		-- warn("[AxisAngleUtils.toCFrame] - cframe is NAN")
		if position then
			return CFrame.new(position)
		else
			return CFrame.new()
		end
	end

	if position then
		cframe = cframe + position
	end

	return cframe
end

--[[
	Constructs a CFrame from a <code>position</code>, <code>upVector</code>, and <code>rightVector</code> even if these
	upVector and rightVectors are not orthogonal to each other.
]]
function Module.fromUpRight(position: Vector3, upVector: Vector3, rightVector: Vector3): CFrame?
	local forwardVector = rightVector:Cross(upVector)
	if forwardVector.Magnitude == 0 then
		return nil
	end

	forwardVector = forwardVector.Unit
	local rightVector2 = forwardVector:Cross(upVector)

	return CFrame.fromMatrix(position, rightVector2, upVector)
end

-- Scales the positional component of <code>cframe</code>.
function Module.scalePosition(cframe: CFrame, scale: number): CFrame
	if scale == 1 then
		return cframe
	else
		local position = cframe.Position
		return cframe - position + position*scale
	end
end

function Module.mirror(cframe: CFrame, mirror: CFrame): CFrame
	local x, y, z, r00, r01, r02, r10, r11, r12, r20, r21, r22 = mirror:ToObjectSpace(cframe):GetComponents()
	-- Reflect along X/Y plane (Z axis).
	local reflection = CFrame.new(
		x, y, -z,
		-r00, r01, r02,
		-r10, r11, r12,
		r20, -r21, -r22
	)
	return mirror:ToWorldSpace(reflection)
end

-----------------------------
-- MAIN --
-----------------------------
return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004350</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF8B355A4A52A46EAB37D74B9467CAA81">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">4b3eb3fd3335c14307beb0ae00005edc</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_region3</string>
							<string name="ScriptGuid">{FB03C516-1650-40E1-9A63-C5F4395788AB}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 2/12/25
--[[@description:

]]
-----------------------------
-- SERVICES --
-----------------------------

-----------------------------
-- DEPENDENCIES --
-----------------------------

-----------------------------
-- TYPES --
-----------------------------

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- This isn't perfect since terrain may not fill up an entire voxel.
function Module.getTerrainMaterialAtPosition(pos: Vector3): Enum.Material
	local region = Module.fromPositionAndSize(pos, Vector3.one / 50):ExpandToGrid(4)
	local materials = workspace.Terrain:ReadVoxels(region, 4)
	return materials[1][1][1]
end

function Module.getTerrainRegion3(position: Vector3, size: Vector3, resolution: number): Region3
	return Module.fromPositionAndSize(position, size):ExpandToGrid(resolution)
end

function Module.fromPositionAndSize(pos: Vector3, size: Vector3): Region3
	local halfSize = size / 2
	return Region3.new(pos - halfSize, pos + halfSize)
end

-----------------------------
-- MAIN --
-----------------------------
return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004351</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX98065E779B014DB1975E40DA57AF4019">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">6466fc660aa7a6b007c7ca060000ce5b</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Sera</string>
							<string name="ScriptGuid">{7BB37DE5-3247-4038-A53C-16B8C4563811}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--!native

--[[
MAD STUDIO

-[Sera]---------------------------------------

	Low-level schematized serialization library

	Members:

		Sera.Boolean

		Sera.Uint8
		Sera.Uint16
		Sera.Uint32
		Sera.Int8
		Sera.Int16
		Sera.Int32
		Sera.Float32
		Sera.Float64

		Sera.CFrame -- 48 bytes; Full precision
		Sera.LossyCFrame -- 28 bytes; Less than 0.0005 degree precision error for rotation
		Sera.Vector3
		Sera.Color3
		Sera.ColorV3 -- Input and output are Vector3's with [0, 1] color values

		Sera.String8  -- Max 255 size
		Sera.String16 -- Max 65,535 size
		Sera.String32 -- Max 4,294,967,295 size

		Sera.Buffer8  -- Max 255 size
		Sera.Buffer16 -- Max 65,535 size
		Sera.Buffer32 -- Max 4,294,967,295 size
		
		Sera.Angle8 -- (Unsigned) Radian representation in one byte while preserving cardinal direction accuracy (Every 45 degrees)

	Functions:

		Sera.Schema(params): Schema -- Maximum 255 fields
			params:
				{
					["FieldName"]: SeraType,
					...
				}

		-- "Serialize", "Push", "DeltaSerialize" and "DeltaPush" will return first argument if succeeded,
		-- Or return an error message as the second argument if failed.

		-- When all fields are present (Non-schema fields are ignored; Missing fields will throw an error):

		Sera.Deserialize(schema: Schema, b: buffer, offset: number?): ({[string]: any}, offset: number)
		Sera.Serialize(schema: Schema, t: {[string]: any}): (buffer?, err: string?)
		Sera.Push(schema: Schema, t: {[string]: any}, b: buffer, offset: number?): (offset: number?, err: string?)

		-- When only some fields are present (Non-schema fields will throw an error):

		Sera.DeltaDeserialize(schema: Schema, b: buffer, offset: number?): ({[string]: any}, offset: number)
		Sera.DeltaSerialize(schema: Schema, t: {[string]: any}): (buffer?, err: string?)
		Sera.DeltaPush(schema: Schema, t: {[string]: any}, b: buffer, offset: number?): (offset: number?, err: string?)

		-- Delta serialization has an additional size cost of (n + 1) bytes where "n" is the number of fields present
		-- in a table that's being serialized (1 byte for present field count, 1 enumerating byte for each field)

--]]

local BIG_BUFFER_SIZE = 1000000 -- "Serialize" and "DeltaSerialize" will fail if resulting buffer size is larger than this value

local SIZE_8 = 2 ^ 8 - 1
local SIZE_16 = 2 ^ 16 - 1
local SIZE_32 = 2 ^ 32 - 1

local MAX_FIELDS = 2 ^ 8 - 1

local BB = buffer.create(BIG_BUFFER_SIZE) -- Big reusable buffer

----- Public -----

export type Ser = (b: buffer, offset: number, value: any) -> (number)
export type Des = (b: buffer, offset: number) -> (any, number)

export type SeraType = {
	Name: string,
	Ser: Ser,
	Des: Des,
}

type Field = {Key: string, Name: string, Ser: Ser, Des: Des, Index: number}

export type Schema = {
	Numeric: {Field},
	String: {[string]: Field},
}

local Sera = {
	BB = BB,
}

Sera.Boolean = table.freeze({
	Name = "Boolean",
	Ser = function(b: buffer, offset: number, value: boolean): number
		if value == true then
			buffer.writeu8(b, offset, 1)
		elseif value == false then
			buffer.writeu8(b, offset, 0)
		else
			error("Expected boolean")
		end
		return offset + 1
	end,
	Des = function(b: buffer, offset: number): (boolean, number)
		return buffer.readu8(b, offset) == 1, offset + 1
	end,
})

Sera.Uint8 = table.freeze({
	Name = "Uint8",
	Ser = function(b: buffer, offset: number, value: number): number
		buffer.writeu8(b, offset, value)
		return offset + 1
	end,
	Des = function(b: buffer, offset: number): (number, number)
		return buffer.readu8(b, offset), offset + 1
	end,
})

Sera.Uint16 = table.freeze({
	Name = "Uint16",
	Ser = function(b: buffer, offset: number, value: number): number
		buffer.writeu16(b, offset, value)
		return offset + 2
	end,
	Des = function(b: buffer, offset: number): (number, number)
		return buffer.readu16(b, offset), offset + 2
	end,
})

Sera.Uint32 = table.freeze({
	Name = "Uint32",
	Ser = function(b: buffer, offset: number, value: number): number
		buffer.writeu32(b, offset, value)
		return offset + 4
	end,
	Des = function(b: buffer, offset: number): (number, number)
		return buffer.readu32(b, offset), offset + 4
	end,
})

Sera.Int8 = table.freeze({
	Name = "Int8",
	Ser = function(b: buffer, offset: number, value: number): number
		buffer.writei8(b, offset, value)
		return offset + 1
	end,
	Des = function(b: buffer, offset: number): (number, number)
		return buffer.readi8(b, offset), offset + 1
	end,
})

Sera.Int16 = table.freeze({
	Name = "Int16",
	Ser = function(b: buffer, offset: number, value: number): number
		buffer.writei16(b, offset, value)
		return offset + 2
	end,
	Des = function(b: buffer, offset: number): (number, number)
		return buffer.readi16(b, offset), offset + 2
	end,
})

Sera.Int32 = table.freeze({
	Name = "Int32",
	Ser = function(b: buffer, offset: number, value: number): number
		buffer.writei32(b, offset, value)
		return offset + 4
	end,
	Des = function(b: buffer, offset: number): (number, number)
		return buffer.readi32(b, offset), offset + 4
	end,
})

Sera.Float32 = table.freeze({
	Name = "Float32",
	Ser = function(b: buffer, offset: number, value: number): number
		buffer.writef32(b, offset, value)
		return offset + 4
	end,
	Des = function(b: buffer, offset: number): (number, number)
		return buffer.readf32(b, offset), offset + 4
	end,
})

Sera.Float64 = table.freeze({
	Name = "Float64",
	Ser = function(b: buffer, offset: number, value: number): number
		buffer.writef64(b, offset, value)
		return offset + 8
	end,
	Des = function(b: buffer, offset: number): (number, number)
		return buffer.readf64(b, offset), offset + 8
	end,
})

Sera.CFrame = table.freeze({
	Name = "CFrame",
	Ser = function(b: buffer, offset: number, value: CFrame): number
		local v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11 = value:GetComponents()
		buffer.writef32(b, offset, v0)
		buffer.writef32(b, offset + 4, v1)
		buffer.writef32(b, offset + 8, v2)
		buffer.writef32(b, offset + 12, v3)
		buffer.writef32(b, offset + 16, v4)
		buffer.writef32(b, offset + 20, v5)
		buffer.writef32(b, offset + 24, v6)
		buffer.writef32(b, offset + 28, v7)
		buffer.writef32(b, offset + 32, v8)
		buffer.writef32(b, offset + 36, v9)
		buffer.writef32(b, offset + 40, v10)
		buffer.writef32(b, offset + 44, v11)
		return offset + 48
	end,
	Des = function(b: buffer, offset: number): (CFrame, number)
		return CFrame.new(
			buffer.readf32(b, offset),
			buffer.readf32(b, offset + 4),
			buffer.readf32(b, offset + 8),
			buffer.readf32(b, offset + 12),
			buffer.readf32(b, offset + 16),
			buffer.readf32(b, offset + 20),
			buffer.readf32(b, offset + 24),
			buffer.readf32(b, offset + 28),
			buffer.readf32(b, offset + 32),
			buffer.readf32(b, offset + 36),
			buffer.readf32(b, offset + 40),
			buffer.readf32(b, offset + 44)
		), offset + 48
	end,
})

Sera.LossyCFrame = table.freeze({
	Name = "LossyCFrame",
	Ser = function(b: buffer, offset: number, value: CFrame): number
		local axis, angle = value:ToAxisAngle()
		buffer.writef32(b, offset, value.X)
		buffer.writef32(b, offset + 4, value.Y)
		buffer.writef32(b, offset + 8, value.Z)
		buffer.writef32(b, offset + 12, axis.X)
		buffer.writef32(b, offset + 16, axis.Y)
		buffer.writef32(b, offset + 20, axis.Z)
		buffer.writef32(b, offset + 24, angle)
		return offset + 28
	end,
	Des = function(b: buffer, offset: number): (CFrame, number)
		return CFrame.fromAxisAngle(
			Vector3.new(
				buffer.readf32(b, offset + 12),
				buffer.readf32(b, offset + 16),
				buffer.readf32(b, offset + 20)
			),
			buffer.readf32(b, offset :: number + 24)
		)
			+ Vector3.new(
				buffer.readf32(b, offset),
				buffer.readf32(b, offset + 4),
				buffer.readf32(b, offset + 8)
			), offset + 28
	end,
})

Sera.Vector3 = table.freeze({
	Name = "Vector3",
	Ser = function(b: buffer, offset: number, value: Vector3): number
		buffer.writef32(b, offset, value.X)
		buffer.writef32(b, offset + 4, value.Y)
		buffer.writef32(b, offset + 8, value.Z)
		return offset + 12
	end,
	Des = function(b: buffer, offset: number): (Vector3, number)
		return Vector3.new(
			buffer.readf32(b, offset),
			buffer.readf32(b, offset + 4),
			buffer.readf32(b, offset + 8)
		), offset + 12
	end,
})

Sera.Color3 = table.freeze({
	Name = "Color3",
	Ser = function(b: buffer, offset: number, value: Color3): number
		buffer.writeu8(b, offset, value.R * 255)
		buffer.writeu8(b, offset + 1, value.G * 255)
		buffer.writeu8(b, offset + 2, value.B * 255)
		return offset + 3
	end,
	Des = function(b: buffer, offset: number): (Color3, number)
		return Color3.fromRGB(
			buffer.readu8(b, offset),
			buffer.readu8(b, offset + 1),
			buffer.readu8(b, offset + 2)
		), offset + 3
	end,
})

Sera.ColorV3 = table.freeze({
	Name = "ColorV3",
	Ser = function(b: buffer, offset: number, value: Vector3): number
		buffer.writeu8(b, offset, value.X * 255)
		buffer.writeu8(b, offset + 1, value.Y * 255)
		buffer.writeu8(b, offset + 2, value.Z * 255)
		return offset + 3
	end,
	Des = function(b: buffer, offset: number): (Vector3, number)
		return Vector3.new(
			buffer.readu8(b, offset) / 255,
			buffer.readu8(b, offset + 1) / 255,
			buffer.readu8(b, offset + 2) / 255
		), offset + 3
	end,
})

-- Handles strings up to 255 characters long.
Sera.String8 = table.freeze({
	Name = "String8",
	Ser = function(b: buffer, offset: number, value: string): number
		local length = value:len()
		if length > SIZE_8 then
			error(`String too long`)
		end
		buffer.writeu8(b, offset, length)
		buffer.writestring(b, offset + 1, value)
		return offset + 1 + length
	end,
	Des = function(b: buffer, offset: number): (string, number)
		local length = buffer.readu8(b, offset)
		return buffer.readstring(b, offset + 1, length), offset + 1 + length
	end,
})

-- Handles strings up to 65,535 characters long.
Sera.String16 = table.freeze({
	Name = "String16",
	Ser = function(b: buffer, offset: number, value: string): number
		local length = value:len()
		if length > SIZE_16 then
			error(`String too long`)
		end
		buffer.writeu16(b, offset, length)
		buffer.writestring(b, offset + 2, value)
		return offset + 2 + length
	end,
	Des = function(b: buffer, offset: number): (string, number)
		local length = buffer.readu16(b, offset)
		return buffer.readstring(b, offset + 2, length), offset + 2 + length
	end,
})

-- Handles strings up to (2^32 - 1) characters long.
Sera.String32 = table.freeze({
	Name = "String32",
	Ser = function(b: buffer, offset: number, value: string): number
		local length = value:len()
		if length > SIZE_32 then
			error(`String too long`)
		end
		buffer.writeu32(b, offset, length)
		buffer.writestring(b, offset + 4, value)
		return offset + 4 + length
	end,
	Des = function(b: buffer, offset: number): (string, number)
		local length = buffer.readu32(b, offset)
		return buffer.readstring(b, offset + 4, length), offset + 4 + length
	end,
})

do
	local enumTypeToIndex: { [Enum]: number } = {}
	local indexToEnum: { Enum } = {}
	local enumTypeByteCount: { [Enum]: number } = {}
	
	for i, enum in Enum:GetEnums() do
		local largestValue = 0
		for _, item in enum:GetEnumItems() do
			largestValue = math.max(largestValue, item.Value)
		end
		enumTypeByteCount[enum] = if largestValue > 255 then 2 else 1
		enumTypeToIndex[enum] = i
		indexToEnum[i] = enum
	end
	
	-- The mapping of numbers to a specific enum is NOT safe for long-term storage!
	-- Size of the buffer varies 5-6 bytes depending on the largest size of the Value of the enum items.
	Sera.Enum = table.freeze({
		Name = "Enum",
		Ser = function(b: buffer, offset: number, enumItem: EnumItem): number
			if typeof(enumItem) ~= "EnumItem" then
				error(`expected EnumItem, got {typeof(enumItem)}`, 2)
			end
			if enumItem.Value > 0xFFFF then
				error(`enumItem value too large: {enumItem}`, 2)
			end
			local enumType = enumItem.EnumType
			local enumTypeIndex = enumTypeToIndex[enumType]
			local byteCount = enumTypeByteCount[enumType]

			buffer.writeu16(b, offset, enumTypeIndex) -- first 16bit is the enum type
			offset += 2
			
			-- second is the enum value (depending on value sizes for the enum)
			if byteCount == 1 then
				buffer.writeu8(b, offset, enumItem.Value)
				offset += 1
			else
				buffer.writeu16(b, offset, enumItem.Value)
				offset += 2
			end
			return offset
		end,
		Des = function(b: buffer, offset: number): (EnumItem, number)
			local enumTypeIndex = buffer.readu16(b, offset)
			offset += 2
			local enumType: any = indexToEnum[enumTypeIndex]
			if not enumType then
				error(`invalid enum type index: {enumTypeIndex} for indexToEnum: {indexToEnum}`, 2)
			end
			local byteCount = enumTypeByteCount[enumType]
			
			local enumValue
			if byteCount == 1 then
				enumValue = buffer.readu8(b, offset)
				offset += 1
			else
				enumValue = buffer.readu16(b, offset)
				offset += 2
			end
			local enumItem = enumType:FromValue(enumValue)
			if not enumItem then
				error(`invalid enum value: {enumValue} for enum: {enumType}`, 2)
			end
			return enumItem, offset
		end,
	})
end

-- Handles buffers up to 255 bytes.
Sera.Buffer8 = table.freeze({
	Name = "Buffer8",
	Ser = function(b: buffer, offset: number, value: buffer): number
		local length = buffer.len(value)
		if length > SIZE_8 then
			error(`Buffer too long`)
		end
		buffer.writeu8(b, offset, length)
		buffer.copy(b, offset + 1, value)
		return offset + 1 + length
	end,
	Des = function(b: buffer, offset: number): (buffer, number)
		local length = buffer.readu8(b, offset)
		local value = buffer.create(length)
		buffer.copy(value, 0, b, offset + 1, length)
		return value, offset + 1 + length
	end,
})

-- Handles buffers up to 65,535 bytes.
Sera.Buffer16 = table.freeze({
	Name = "Buffer16",
	Ser = function(b: buffer, offset: number, value: buffer): number
		local length = buffer.len(value)
		if length > SIZE_16 then
			error(`Buffer too long`)
		end
		buffer.writeu16(b, offset, length)
		buffer.copy(b, offset + 2, value)
		return offset + 2 + length
	end,
	Des = function(b: buffer, offset: number): (buffer, number)
		local length = buffer.readu16(b, offset)
		local value = buffer.create(length)
		buffer.copy(value, 0, b, offset + 2, length)
		return value, offset + 2 + length
	end,
})

-- Handles buffers up to (2^32 - 1) bytes.
Sera.Buffer32 = table.freeze({
	Name = "Buffer32",
	Ser = function(b: buffer, offset: number, value: buffer): number
		local length = buffer.len(value)
		if length > SIZE_32 then
			error(`Buffer too long`)
		end
		buffer.writeu32(b, offset, length)
		buffer.copy(b, offset + 4, value)
		return offset + 4 + length
	end,
	Des = function(b: buffer, offset: number): (buffer, number)
		local length = buffer.readu32(b, offset)
		local value = buffer.create(length)
		buffer.copy(value, 0, b, offset + 4, length)
		return value, offset + 4 + length
	end,
})

-- Handles an array of up to 255 buffers, each up to 255 bytes.
Sera.BufferArray8 = table.freeze({
	Name = "BufferArray",
	Ser = function(b: buffer, offset: number, value: {buffer}): number
		local count = #value
		if count > SIZE_8 then
			error(`Array too long`)
		end
		buffer.writeu8(b, offset, count)
		offset = offset + 1
		for i = 1, count do
			local buf = value[i]
			local len = buffer.len(buf)
			if len > SIZE_8 then
				error(`Buffer element {i} too long`)
			end
			buffer.writeu8(b, offset, len)
			offset = offset + 1
			buffer.copy(b, offset, buf)
			offset = offset + len
		end
		return offset
	end,
	Des = function(b: buffer, offset: number): ({buffer}, number)
		local count = buffer.readu8(b, offset)
		offset = offset + 1
		local result = {}
		for i = 1, count do
			local len = buffer.readu8(b, offset)
			offset = offset + 1
			local buf = buffer.create(len)
			buffer.copy(buf, 0, b, offset, len)
			offset = offset + len
			table.insert(result, buf)
		end
		return result, offset
	end,
})

-- Handles an array of up to 65535 buffers, each up to 65535 bytes.
Sera.BufferArray16 = table.freeze({
	Name = "BufferArray",
	Ser = function(b: buffer, offset: number, value: {buffer}): number
		local count = #value
		if count > SIZE_16 then
			error(`Array too long`)
		end
		buffer.writeu16(b, offset, count)
		offset = offset + 2
		for i = 1, count do
			local buf = value[i]
			local len = buffer.len(buf)
			if len > SIZE_16 then
				error(`Buffer element {i} too long`)
			end
			buffer.writeu16(b, offset, len)
			offset = offset + 2
			buffer.copy(b, offset, buf)
			offset = offset + len
		end
		return offset
	end,
	Des = function(b: buffer, offset: number): ({buffer}, number)
		local count = buffer.readu16(b, offset)
		offset = offset + 2
		local result = {}
		for i = 1, count do
			local len = buffer.readu16(b, offset)
			offset = offset + 2
			local buf = buffer.create(len)
			buffer.copy(buf, 0, b, offset, len)
			offset = offset + len
			table.insert(result, buf)
		end
		return result, offset
	end,
})

do
	local rad2 = math.pi * 2
	local angle8range = math.rad(359)

	local function DegEncode(deg: number): number
		return math.round((deg % rad2) * 255 / angle8range)
	end

	local DegDecodeLookup: {number} = {}

	for i = 0, 255 do
		DegDecodeLookup[i] = i * angle8range / 255
	end

	for i = 0, 315, 45 do
		local r = math.rad(i)
		local index = DegEncode(r)
		DegDecodeLookup[index] = r
	end

	Sera.Angle8 = table.freeze({
		Name = "Angle8",
		Ser = function(b: buffer, offset: number, value: number): number
			buffer.writeu8(b, offset, DegEncode(value))
			return offset + 1
		end,
		Des = function(b: buffer, offset: number): (number, number)
			return DegDecodeLookup[buffer.readu8(b, offset)], offset + 1
		end,
	})

end

----

-- Returns dictionary of deserialized schema.
function Sera.Deserialize(schema: Schema, b: buffer, offset: number?): ({[string]: any}, number)

	offset = offset or 0
	local result = {}

	for _, field in schema.Numeric do
		result[field.Key], offset = field.Des(b, offset :: number)
	end

	return result, offset :: number

end

local function SerializeUnsafe(schema: Schema, t: {[string]: any}): number

	local offset = 0

	for _, field in schema.Numeric do
		offset = field.Ser(BB, offset, t[field.Key])
	end

	return offset

end

-- Returns new buffer of serialized schema or error message if fail.
function Sera.Serialize(schema: Schema, t: any): (buffer?, string?)

	local success, offset = pcall(SerializeUnsafe, schema, t)

	if not success then

		local ser_success
		offset = 0

		for _, field in schema.Numeric do

			local value = t[field.Key]

			if value ~= nil then
				ser_success, offset = pcall(field.Ser, BB, offset, value)
				if not ser_success then
					return nil, `Couldn't serialize field "{field.Key}" (Expected: {field.Name};Received: "{typeof(value)}"); Message: {offset}`
				end
			else
				return nil, `Missing field "{field.Key}"`
			end

		end

		return nil, `Unknown error`

	end

	local b = buffer.create(offset)
	buffer.copy(b, 0, BB, 0, offset)

	return b

end

local function PushUnsafe(schema: Schema, t: {[string]: any}, b: buffer, offset: number): number

	for _, field in schema.Numeric do
		offset = field.Ser(b, offset, t[field.Key])
	end

	return offset

end

-- Pushes serialized schema to an existing buffer; Returns new buffer offset or error message if fail.
function Sera.Push(schema: Schema, t: any, b: buffer, offset: number?): (number?, string?)

	offset = offset or 0
	local original_offset = offset :: number
	local success
	success, offset = pcall(PushUnsafe, schema, t, b, offset :: number)

	if not success then

		local ser_success
		offset = original_offset

		for _, field in schema.Numeric do

			local value = t[field.Key]

			if value ~= nil then
				ser_success, offset = pcall(field.Ser, b, offset :: number, value)
				if not ser_success then
					return nil, `Couldn't serialize field "{field.Key}" (Expected: {field.Name};Received: "{typeof(value)}"); Message: {offset}`
				end
			else
				return nil, `Missing field "{field.Key}"`
			end

		end

		return nil, `Unknown error`

	end

	return offset

end

-- Returns dictionary of deserialized deltas.
function Sera.DeltaDeserialize(schema: Schema, b: buffer, offset: number?): ({[string]: any}, number)

	offset = (offset or 0) + 1
	local field_count = buffer.readu8(b, offset :: number - 1)
	local result = {}

	local lookup = schema.Numeric

	for i = 1, field_count do
		local field = lookup[buffer.readu8(b, offset :: number)]
		result[field.Key], offset = field.Des(b, offset :: number + 1)
	end

	return result, offset :: number

end

local function DeltaSerializeUnsafe(schema: Schema, t: {[string]: any}): number

	local field_count = 0
	local offset = 1

	local lookup = schema.String

	for key, value in t do
		field_count += 1
		local field = lookup[key]
		buffer.writeu8(BB, offset, field.Index)
		offset = field.Ser(BB, offset + 1, t[field.Key])
	end

	buffer.writeu8(BB, 0, field_count)

	return offset

end

-- Returns new buffer of serialized deltas or error message if fail.
function Sera.DeltaSerialize(schema: Schema, t: any): (buffer?, string?)

	local success, offset = pcall(DeltaSerializeUnsafe, schema, t)

	if not success then

		local ser_success
		offset = 1

		local lookup = schema.String

		for key, value in t do

			local field = lookup[key]

			if field == nil then
				return nil, `Key "{key}" not specified in schema`
			end

			buffer.writeu8(BB, offset, field.Index)
			ser_success, offset = pcall(field.Ser, BB, offset + 1, value)
			if not ser_success then
				return nil, `Couldn't serialize field "{field.Key}" (Expected: {field.Name};Received: "{typeof(value)}"); Message: {offset}`
			end

		end

		return nil, `Unknown error`

	end

	local b = buffer.create(offset)
	buffer.copy(b, 0, BB, 0, offset)

	return b

end

local function DeltaPushUnsafe(schema: Schema, t: {[string]: any}, b: buffer, offset: number): number

	local field_count = 0
	local start_offset = offset
	offset += 1

	local lookup = schema.String

	for key, value in t do
		field_count += 1
		local field = lookup[key]
		buffer.writeu8(b, offset, field.Index)
		offset = field.Ser(b, offset + 1, t[field.Key])
	end

	buffer.writeu8(b, start_offset, field_count)

	return offset

end

-- Pushes serialized deltas to an existing buffer; Returns new buffer offset or error message if fail.
function Sera.DeltaPush(schema: Schema, t: any, b: buffer, offset: number?): (number?, string?)

	offset = offset or 0
	local original_offset = offset :: number
	local success
	success, offset = pcall(DeltaPushUnsafe, schema, t, b, offset :: number)

	if not success then

		local ser_success
		offset = 1

		local lookup = schema.String

		for key, value in t do

			local field = lookup[key]

			if field == nil then
				return nil, `Key "{key}" not specified in schema`
			end

			buffer.writeu8(b, offset :: number, field.Index)
			ser_success, offset = pcall(field.Ser, b, offset :: number + 1, value)
			if not ser_success then
				return nil, `Couldn't serialize field "{field.Key}" (Expected: {field.Name};Received: "{typeof(value)}"); Message: {offset}`
			end

		end

		return nil, `Unknown error`

	end

	return offset

end

function Sera.Schema(params: {[string]: SeraType}): Schema

	local fields: {Field} = {}

	for key, sera_type: SeraType in params do
		if typeof(key) ~= "string" then
			error(`[{script.Name}]: Expected string for field name; Received "{typeof(key)}"`)
		end
		if typeof(sera_type) ~= "table" or typeof(sera_type.Ser) ~= "function"
			or typeof(sera_type.Des) ~= "function" or typeof(sera_type.Name) ~= "string" then
			error(`[{script.Name}]: Expected SeraType for field "{key}"`)
		end
		table.insert(fields, {Key = key, Name = sera_type.Name, Ser = sera_type.Ser, Des = sera_type.Des, Index = 0})
	end

	if #fields == 0 then
		error(`[{script.Name}]: Schema must have fields`)
	end

	if #fields > MAX_FIELDS then
		error(`[{script.Name}]: Schema exceeded {MAX_FIELDS} fields; Received {#fields} fields`)
	end

	table.sort(fields, function(a, b)
		return a.Key < b.Key
	end)

	local string_fields: {[string]: Field} = {}

	for index, field in fields do
		field.Index = index
		string_fields[field.Key] = field
	end

	return table.freeze({
		Numeric = fields,
		String = string_fields,
	})

end

return Sera]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004352</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFE798C0DB9BF44E6A0E6E0925D6DF6C6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009660</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_proxy</string>
							<string name="ScriptGuid">{2A3FBB8B-787F-4046-9FBF-8B2CE116F460}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 4/24/25
--[[@description:
	For creating proxies that fire a signal when a value is added to the original table.
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local Signal = require("../ModuleUtils/_Signal")
local _math = require("./_math")

-----------------------------
-- TYPES --
-----------------------------

type CallbackFunc = (origProxy: any, keys: { any }, newValue: any) -> ()
type ProxyUpdatedSignal = Signal.SignalType<CallbackFunc, (any, { any }, any)>

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}

local proxyCache = setmetatable({}, { __mode = "k" }) -- prevent proxies keeping tables alive
local idGenerator = _math.getIdGenerator()

-- CONSTANTS --

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

local function isProxy(value: any): boolean
	if typeof(value) ~= "table" then
		return false
	end
	local mt = getmetatable(value)
	if not mt or not mt.__isproxy then
		return false
	end
	return true
end

local function wrapTable(orig: { [any]: any }, _path: { any }, _head: any?): (any, ProxyUpdatedSignal)
	assert(typeof(orig) == "table", "invalid table")
	-- return already proxied tables
	if proxyCache[orig] then
		local proxy = proxyCache[orig]
		return proxy, getmetatable(proxy).__headSignal
	end

	local proxyId = idGenerator()
	local proxy = {}
	local headProxy = _head or proxy
	local headMt = getmetatable(headProxy)
	local headSignal = if headMt then headMt.__headSignal else Signal.new()
	
	local mt = {}
	-- store the current path so it can be updated later if needed
	mt.__head = headProxy
	mt.__headSignal = headSignal
	mt.__path = _path

	mt.__index = function(self, key)
		local m = getmetatable(self)
		local value = orig[key]
		if typeof(value) == "table" and not proxyCache[value] then
			local newPath = {table.unpack(m.__path)}
			newPath[#newPath + 1] = key
			wrapTable(value, newPath, headProxy)
		end
		-- always return proxies if available
		value = proxyCache[value] or value
		return value
	end
	mt.__newindex = function(self, key, newValue)
		local m = getmetatable(self)
		local newPath = {table.unpack(m.__path)}
		newPath[#newPath + 1] = key

		if isProxy(newValue) then
			--warn("Attempt set proxy as new value. Please use :Get() to retrieve the original table value.\n", debug.traceback())
			newValue = Module.get(newValue)
		elseif proxyCache[newValue] then
			-- update stored path
			local cachedProxy = proxyCache[newValue]
			local mtCached = getmetatable(cachedProxy)
			mtCached.__path = newPath
		elseif typeof(newValue) == "table" then
			-- wrap unproxied table
			wrapTable(newValue, newPath, headProxy)
		end
		-- Store the raw newValue so orig doesn't store any proxies!
		orig[key] = newValue
		mt.__headSignal:Fire(headProxy, newPath, newValue)
	end

	local function iter(tbl: { [any]: any }, key: any): (any, any)
		local k, v = next(tbl, key)
		if k ~= nil and typeof(v) == "table" and not proxyCache[v] then
			local m = getmetatable(proxy :: any)
			local newPath = {table.unpack(m.__path)}
			newPath[#newPath + 1] = k
			wrapTable(v, newPath, headProxy)
		end
		v = proxyCache[v] or v -- always return proxies
		return k, v
	end
	mt.__iter = function()
		return iter, orig, nil
	end
	mt.__tostring = function()
		return `[proxy: {proxyId} for {orig}]`
	end
	mt.__len = function()
		return #orig
	end
	mt.__original = orig
	mt.__isproxy = true

	proxyCache[orig] = setmetatable(proxy, mt)

	return proxy, headSignal
end

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Create a proxy that updates the original table _t and fires a signal.
-- This signal is fired for all descendant tables that are converted to proxies as well.
-- <strong>You should clean up connections to this signal if the proxy is no longer used!</strong>
function Module.create<T>(_t: T): (T, ProxyUpdatedSignal)
	assert(typeof(_t) == "table", "Invalid table")
	return wrapTable(_t, {}, nil)
end

-- Creates a proxy and automatically calls <code>callback</code> when any values get updated.
-- Returns the proxy and connection
-- <strong>You should clean up the connection if the proxy is no longer used!</strong>
function Module.watch<T>(_t: T, callback: CallbackFunc): (T, Signal.SignalConnection)
	local proxy, signal = Module.create(_t)
	local conn = signal:Connect(callback)
	return proxy, conn
end

-- Get the original table from a proxy.
function Module.get<T>(proxy: T): T
	assert(typeof(proxy) == "table", "Invalid table")
	local mt = getmetatable(proxy)
	if mt and mt.__original then
		return mt.__original
	end
	error("Given table is not a proxy!")
end

-- Get the head signal for the proxy.
-- <strong>You should clean up connections to this signal if the proxy is no longer used!</strong>
function Module.getHeadSignal(proxy: any): ProxyUpdatedSignal
	assert(isProxy(proxy), "invalid proxy")
	local mt = getmetatable(proxy)
	return mt.__headSignal
end

Module.isProxy = isProxy

-- Proxy-safe table.insert()
-- Inserts value at end by default
-- The whole array is passed through the proxy's head signal rather than the index-value pair.
function Module.insert(proxy: any, value: any, pos: number?)
	if value == nil then
		value, pos = pos, nil
	end
	assert(isProxy(proxy), "Insert: must pass a proxy")
	local mt = getmetatable(proxy)
	local orig = mt.__original
	local head = mt.__head
	local headSignal = mt.__headSignal
	local pathBase = mt.__path

	if pos then
		table.insert(orig, pos, value)
	else
		table.insert(orig, value)
		pos = #orig
	end

	if typeof(value) == "table" then
		wrapTable(value, {table.unpack(pathBase, 1, #pathBase)}, head)
	end

	headSignal:Fire(head, pathBase, orig)
end

-- Proxy-safe table.remove()
-- The whole array is passed through the proxy's head signal rather than the index-value pair.
function Module.remove(proxy: any, pos: number?): any?
	assert(isProxy(proxy), "Remove: must pass a proxy")
	local mt = getmetatable(proxy)
	local orig = mt.__original
	local head = mt.__head
	local headSignal = mt.__headSignal
	local pathBase = mt.__path
	local removed = table.remove(orig, pos)
	if typeof(removed) == "table" then
		proxyCache[removed] = nil
	end
	headSignal:Fire(head, pathBase, orig)
	return removed
end

-- Proxy-safe table.copy()
-- Returns a proxy
function Module.copy<T>(proxy: T)
	assert(isProxy(proxy), "Copy: must pass a proxy")
	local orig = Module.get(proxy)
	local clone = table.clone(orig :: any)
	return Module.create(clone)
end

-- Proxy safe table.clear()
function Module.clear(proxy: any)
	assert(isProxy(proxy), "Clear: must pass a proxy")
	local mt = getmetatable(proxy)
	local orig = mt.__original
	local head = mt.__head
	local headSignal = mt.__headSignal
	local pathBase = mt.__path

	for k,v in pairs(orig) do
		if typeof(v) == "table" then
			proxyCache[v] = nil
		end
	end

	table.clear(orig)

	-- signal this table was wiped; listeners see an empty table
	-- keys == pathBase (path to this table), newValue == orig (now empty)
	headSignal:Fire(head, pathBase, orig)
end

-----------------------------
-- MAIN --
-----------------------------
return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004353</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB30792FE04514D7F8051CCF5E6A066BD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025ca3</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_input</string>
							<string name="ScriptGuid">{A17FD0EC-F9D1-4CC5-8E1A-53315B377AB6}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
local Module = {}

local UserInputService = game:GetService("UserInputService")

local KEYCODE_INT_MAP = {
	[0] = Enum.KeyCode.Zero,
	[1] = Enum.KeyCode.One,
	[2] = Enum.KeyCode.Two,
	[3] = Enum.KeyCode.Three,
	[4] = Enum.KeyCode.Four,
	[5] = Enum.KeyCode.Five,
	[6] = Enum.KeyCode.Six,
	[7] = Enum.KeyCode.Seven,
	[8] = Enum.KeyCode.Eight,
	[9] = Enum.KeyCode.Nine
}
local KEY_CODE_REPLACEMENTS = {
	[Enum.KeyCode.Space] = "Spacebar",
	[Enum.KeyCode.LeftShift] = "LShift",
	[Enum.KeyCode.RightShift] = "RShift",
	[Enum.KeyCode.LeftControl] = "LCtrl",
	[Enum.KeyCode.RightControl] = "RCtrl",
	[Enum.KeyCode.LeftAlt] = "LAlt",
	[Enum.KeyCode.RightAlt] = "RAlt",
}

-- Grabs a string that represents the keycode with some shortened strings for specific strings.
-- This is an artistic preference.
function Module.getStringForKeyCode(keyCode: Enum.KeyCode): string
	-- Use shortened/modified version for a few of the keycodes, this is simply artistic preference
	if KEY_CODE_REPLACEMENTS[keyCode] then
		return KEY_CODE_REPLACEMENTS[keyCode]
	end

	-- Get the correct string to display for the keycode. This allows us to display the
	-- correct key for non-QWERTY keyboard layouts.
	local str = UserInputService:GetStringForKeyCode(keyCode)
	-- If there is no defined string for the keycode, simply return the keycode name
	if str == "" then
		return keyCode.Name
	else
		return str
	end
end

-- Returns a string image id for the keycode.
function Module.getImageForKeyCode(keyCode: Enum.KeyCode): string?
	return UserInputService:GetImageForKeyCode(keyCode)
end

-- Returns the number keycode (keys 1-9 & 0) for the given integer, or unknown
function Module.getKeycodeFromInteger(integer: number): Enum.KeyCode
	local keycode = KEYCODE_INT_MAP[integer]
	if keycode then
		return keycode
	end
	return Enum.KeyCode.Unknown
end

return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004354</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4E903D06DB70479FB236AF2109C2E941">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025ca4</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_color</string>
							<string name="ScriptGuid">{38C71B8C-6796-4285-BAD5-2827AA195A67}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 5/26/25
--[[@description:

]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local t = require("./_t")

-----------------------------
-- TYPES --
-----------------------------

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}

-- CONSTANTS --

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Offsets the value in the HSV of the color. Values are represented as 0-255.
function Module.offsetValue(color: Color3, value: number): Color3
	local h, s, v = color:ToHSV()
	return Color3.fromHSV(h, s, v + (value/255))
end

-- Multiplies the value in the HSV of the color.
function Module.multiplyValue(color: Color3, multiplier: number): Color3
	local h, s, v = color:ToHSV()
	return Color3.fromHSV(h, s, v * multiplier)
end

-----------------------------
-- MAIN --
-----------------------------
return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004355</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXF67940C7EADC4B30B663F365E18DD231">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025ca5</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GlobalTypes</string>
						<string name="ScriptGuid">{BC310084-51F8-4C9E-8142-7D8AF149525F}</string>
						<ProtectedString name="Source"><![CDATA[--!strict
--[[
	Types that can be utilized across any module for consistency and maintaining types in a single location.
]]

export type UniversalTimestamp = {
	Year: number,
	Month: number,
	Day: number,
	Hour: number,
	Minute: number,
	Second: number,
	Millisecond: number,
}

export type PlayerJoinData = {
	SourceGameId: number?,
	SourcePlaceId: number?,
	ReferredByPlayerId: number?,
	Members: { number }?, -- Players teleported alongside this player.
	TeleportData: any, -- teleportData specified in original teleport.
	LaunchData: string, -- Plain or JSON econded string containing launch data
	GameJoinContext: {
		JoinSource: Enum.JoinSource,
		ItemType: Enum.AvatarItemType?,
		AssetId: string?,
		OutfitId: string?,
		AssetType: Enum.AssetType?
	}
}

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004356</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7CB6701E2CD04F6E80E192C69866F7ED">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025ca6</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ClientModuleUtils</string>
						<string name="ScriptGuid">{0DC877FC-DC24-4BB0-A940-85CC3BF95A45}</string>
						<ProtectedString name="Source"><![CDATA[--!strict
if game:GetService("RunService"):IsServer() then
	return {}
end
local _CinematicClass = require(script._CinematicClass)
export type Cinematic = _CinematicClass.Cinematic
export type CinematicStartArgs = _CinematicClass.CinematicStartArgs

local _Icon = require(script._Icon)
export type Icon = _Icon.Icon

local _GuiButtonClass = require(script._GuiButtonClass)
export type WrappedGuiButton = _GuiButtonClass.WrappedGuiButton

local _GuiImageClass = require(script._GuiImageClass)
export type WrappedGuiImage = _GuiImageClass.WrappedGuiImage

local _GuiObjectClass = require(script._GuiObjectClass)
export type WrappedGuiObject = _GuiObjectClass.WrappedGuiObject

local _GuiStrokeClass = require(script._GuiStrokeClass)
export type WrappedGuiStroke = _GuiStrokeClass.WrappedUiStroke

local _GuiTextClass = require(script._GuiTextClass)
export type WrappedTextLabel = _GuiTextClass.WrappedTextLabel

local _SurfaceGuiClass = require(script._SurfaceGuiClass)
export type WrappedSurfaceGui = _SurfaceGuiClass.WrappedSurfaceGui

local _BillboardGuiClass = require(script._BillboardGuiClass)
export type WrappedBillboardGui = _BillboardGuiClass.WrappedBillboardGui

local _EasyVisuals = require(script._EasyVisuals)
export type InterfaceEffect = _EasyVisuals.InterfaceEffect

local _LightningEffects = require(script._LightningEffects)
export type LightningBolt = _LightningEffects.LightningBolt
export type LightningSparks = _LightningEffects.LightningSparks
export type LightningExplosion = _LightningEffects.LightningExplosion

local _ParallaxWindows = require(script._ParallaxWindows)
export type ParallaxWindow = _ParallaxWindows.ParallaxWindow

local _Streamable = require(script._Streamable)
export type StreamableType = _Streamable.StreamableType

local _StreamableUtil = require(script._StreamableUtil)

local _WindLineCreator = require(script._WindLineCreator)
export type WindLineCreator = _WindLineCreator.WindLineCreator
export type WindLineCreatorParams = _WindLineCreator.WindLineCreatorParams

local _WindShake = require(script._WindShake)
export type WindShakeSettings = _WindShake.WindShakeSettings

local _Input = require(script._Input)
export type GamepadType = _Input.GamepadType
export type MouseType = _Input.MouseType
export type KeyboardType = _Input.KeyboardType
export type TouchType = _Input.TouchType

local _Screen3D = require(script._Screen3D)
export type screen3D = _Screen3D.screen3D
export type screenGen = _Screen3D.screenGen
export type component3D = _Screen3D.component3D
export type componentGen = _Screen3D.componentGen

return {
	Screen3D = _Screen3D,
	CinematicClass = _CinematicClass,
	Icon = _Icon,
	GuiButtonClass = _GuiButtonClass,
	GuiImageClass = _GuiImageClass,
	GuiObjectClass = _GuiObjectClass,
	GuiStrokeClass = _GuiStrokeClass,
	GuiTextClass = _GuiTextClass,
	SurfaceGuiClass = _SurfaceGuiClass,
	BillboardGuiClass = _BillboardGuiClass,
	EasyVisuals = _EasyVisuals,
	LightningEffects = _LightningEffects,
	ParallaxWindows = _ParallaxWindows,
	Streamable = _Streamable,
	StreamableUtil = _StreamableUtil,
	WindLineCreator = _WindLineCreator,
	WindShake = _WindShake,
	Input = _Input,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004357</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBXD360E77F76FA46AFB272C7AFACC037F5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006471</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_EasyVisuals</string>
							<string name="ScriptGuid">{9002663F-6B94-4560-A8C0-D5ECDBC72008}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author Arxk (modified by @crusherfire because the type annotations were not correctly done)

local Presets = script.Presets;

local require = require

local Effect = {};
Effect.Gradient = require(script.Gradient);
Effect.Stroke = require(script.Stroke);
Effect.Dropshadow = require(script.Dropshadow);
Effect.Templates = require(script.GradientTemplates);
Effect.CurrentEffects = {};

local MT = {}
MT.__index = MT;

type self = {
	UIInstance: GuiObject,
	EffectObjects: { any },
	SavedObjects: { any },
	Speed: number,
	Size: number,
	IsPaused: boolean,
	
	Diagnostic: string,
	ResumesOnShown: boolean?,
	Connections: { any },
	Connection: any,
}
export type InterfaceEffect = typeof(setmetatable({} :: self, MT))

local VisibleOrEnabledChart = {
	["GuiObject"] = "Visible",
	["ScreenGui"] = "Enabled",
	["BillboardGui"] = "Enabled",
	["SurfaceGui"] = "Enabled",
};

local function ValidateIsPreset(presetName: string): boolean
	return Presets:FindFirstChild(presetName) ~= nil;
end

-- Creates a new effect on the given <code>GuiObject</code>
function Effect.new(uiInstance: GuiObject, effectType: string, speed: number?, size: number?, saveInstanceObjects: boolean?, customColor: ColorSequence | Color3?, customTransparency: NumberSequence | number?, resumesOnVisible: boolean?): InterfaceEffect
	assert(uiInstance, "UIInstance not provided");
	assert(effectType, "EffectType not provided");
	assert(uiInstance:IsA("GuiObject"), "UIInstance is not a GuiObject");
	assert(typeof(effectType) == "string", "effectType is not a string");
	assert(ValidateIsPreset(effectType), "effectType is not a valid preset");
	if (speed) then
		assert(typeof(speed) == "number", "speed is not a number");
	end;
	if (size) then
		assert(typeof(size) == "number", "size is not a number");
	end;
	if (customColor) then
		assert(typeof(customColor) == "ColorSequence" or typeof(customColor) == "Color3", "customColor is not a ColorSequence or Color3");
	end;
	if (customTransparency) then
		assert(typeof(customTransparency) == "NumberSequence" or typeof(customTransparency) == "number", "customTransparency is not a NumberSequence or number");
	end;

	local self = setmetatable({} :: self, MT)

	self.IsPaused = false;
	self.Diagnostic = "DIAGNOSTIC VALUE";
	self.UIInstance = uiInstance;
	self.ResumesOnShown = resumesOnVisible == nil and true or resumesOnVisible;
	self.EffectObjects = {};
	self.SavedObjects = {};
	self.Connections = {};
	self.Speed = speed or 0.007;
	self.Size = size or 1;

	-- Climb up the parent tree of the UIInstance and attach GetPropertyChangedSignal to the Visible property of each object
	-- If the Visible property changes to false, destroy the effect
	local function RecursiveAncestryChanged(Object: Instance)
		if (not Object) then
			return;
		end;

		-- If the object is a PlayerGui or Workspace, stop climbing
		if (Object:IsA("PlayerGui") or Object:IsA("Workspace")) then
			return;
		end;

		-- If the object is a ScreenGui, BillboardGui, or SurfaceGui, check if it's enabled
		local IsVisibleOrEnabled = VisibleOrEnabledChart[Object.ClassName];
		if (not IsVisibleOrEnabled) then
			RecursiveAncestryChanged(Object.Parent :: Instance);
			return;
		end;
		
		table.insert(self.Connections, Object:GetPropertyChangedSignal(IsVisibleOrEnabled):Connect(function()
			local Object = Object :: any -- fixes dynamically accessed members type annotation error
			self.IsPaused = not Object[IsVisibleOrEnabled]
			if (self.IsPaused) then
				self:Pause();
			else
				if (self.ResumesOnShown) then
					self:Resume();
				end;
			end;
		end));

		RecursiveAncestryChanged(Object.Parent :: Instance);
	end;
	RecursiveAncestryChanged(uiInstance);

	if (saveInstanceObjects) then
		for _, Object in uiInstance:GetChildren() do
			if (Object:IsA("UIStroke") or Object:IsA("UIGradient")) then
				local Object = Object :: Instance
				table.insert(self.SavedObjects, Object);
				Object.Parent = nil;
			end;
		end;
	end;

	local Preset = require(Presets:FindFirstChild(effectType));
	local Objects = Preset(uiInstance, self.Speed, self.Size, customColor, customTransparency);

	if (Objects["Connections"]) then
		for _, Connection in Objects["Connections"] do
			table.insert(self.Connections, Connection);
		end;
	end;
	if (Objects["Effects"]) then
		for _, ObjectEffect in Objects["Effects"] do
			table.insert(self.EffectObjects, ObjectEffect);
		end;
	end;

	self.Connection = uiInstance.AncestryChanged:Connect(function()
		if (not uiInstance:IsDescendantOf(game)) then
			self:Destroy();
		end;
	end);

	return self;
end

function MT.Pause(self: InterfaceEffect)
	-- print("Effect paused");
	for _, Object in self.EffectObjects do
		if (Object.Pause) then
			Object:Pause();
		end;
	end;
end

function MT.Resume(self: InterfaceEffect)
	-- print("Effect resumed");
	for _, Object in self.EffectObjects do
		if (Object.Resume) then
			Object:Resume();
		end;
	end;
end

function MT:Destroy()
	for _, Object in self.SavedObjects do
		Object.Parent = self.UIInstance;
	end;
	for _, Connection in self.Connections do
		Connection:Disconnect();
	end;

	table.clear(self.SavedObjects);
	table.clear(self.Connections);

	for _, Object in self.EffectObjects do
		if (not Object.Destroy) then
			continue;
		end;
		Object:Destroy();
	end;

	self.Connection:Disconnect();
end

return table.freeze(Effect);
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004358</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX9B3420433C8C49CB8C61506BF3A31D85">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006472</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Dropshadow</string>
								<string name="ScriptGuid">{4FE0928E-18F8-4DAB-8F6D-86E4884BAA20}</string>
								<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService");

export type Dropshadow<T...> = {
	UIInstance: GuiObject,
	Instance: GuiObject,
	IsPaused: boolean,
	Color: Color3,
	ColorTarget: Color3,
	ColorAcceleration: number,
	Transparency: number,
	TransparencyTarget: number,
	TransparencyAcceleration: number,
	Offset: Vector2,
	OffsetTarget: Vector2,
	OffsetAcceleration: number,
	Connection: RBXScriptConnection,
	IsText: boolean,

	Pause: (self: Dropshadow<T...>) -> nil,
	Resume: (self: Dropshadow<T...>) -> nil,
	SetOffset: (self: Dropshadow<T...>, offset: Vector2, acceleration: number) -> nil,
	SetTransparency: (self: Dropshadow<T...>, transparency: number, acceleration: number) -> nil,
	SetColor: (self: Dropshadow<T...>, color: Color3, acceleration: number) -> nil,
	Destroy: (self: Dropshadow<T...>) -> nil,
};

local Dropshadow = {};
Dropshadow.__index = Dropshadow;

function Dropshadow.new<T...>(uiInstance: GuiObject | UIStroke, color: Color3?, transparency: number?, offset: Vector2?): Dropshadow<T...>
	assert(uiInstance, "UIInstance not provided");
	assert(uiInstance:IsA("GuiObject") or uiInstance:IsA("UIStroke"), "UIInstance is not a GuiObject or UIStroke");
	if (color) then
		assert(typeof(color) == "Color3", "Color is not a Color3");
	end;
	if (transparency) then
		assert(typeof(transparency) == "number", "Transparency is not a number");
	end;
	if (offset) then
		assert(typeof(offset) == "Vector2", "Offset is not a Vector2");
	end;

	local self = {};

	self.UIInstance = uiInstance;
	self.Instance = uiInstance:Clone();
	self.IsPaused = false;

	self.Color = color or Color3.new();
	self.ColorTarget = color or Color3.new();
	self.ColorAcceleration = 1;
	self.Transparency = transparency or 0;
	self.TransparencyTarget = transparency or 0;
	self.TransparencyAcceleration = 1;
	self.Offset = offset or Vector2.new(-4, 4);
	self.OffsetTarget = offset or Vector2.new();
	self.OffsetAcceleration = 1;
	self.Connection = nil;
	self.IsText = false;

	self.Instance.Size = UDim2.new(1, 0, 1, 0);
	self.Instance:ClearAllChildren();

	self.Instance.Position = UDim2.new(0, self.Offset.X, 0, self.Offset.Y);

	if (uiInstance:IsA("TextLabel") or uiInstance:IsA("TextBox") or uiInstance:IsA("TextButton")) then
		self.Instance.TextColor3 = self.Color;
		self.IsText = true;
	end;

	self.Instance.Parent = self.UIInstance;

	self.Connection = RunService.Heartbeat:Connect(function(dt)
		if (self.IsPaused) then
			return;
		end;

		if (not self.UIInstance or self.UIInstance.Parent == nil) then
			self:Destroy();
			return;
		end;

		self.Color = self.Color:Lerp(self.ColorTarget, self.ColorAcceleration);
		self.Offset = self.Offset:Lerp(self.OffsetTarget, self.OffsetAcceleration);
		self.Transparency = self.Transparency + ((self.TransparencyTarget - self.Transparency) * self.TransparencyAcceleration);

		self.Instance.Position = UDim2.new(0, self.Offset.X, 0, self.Offset.Y);

		if (self.IsText) then
			self.Instance.Text = self.UIInstance.Text;
			self.Instance.TextTransparency = self.Transparency;
			self.Instance.TextColor3 = self.Color;
		end;

		self.Instance.ZIndex = self.UIInstance.ZIndex - 1;
	end);

	return setmetatable(self, Dropshadow);
end

function Dropshadow:SetOffset(offset: Vector2, acceleration: number)
	-- Accepts a Vector2 as the first argument and a number as the second argument.
	-- Values below 0 or above 1 for the acceleration argument do not make sense.
	assert(typeof(offset) == "Vector2", "Offset isn't a Vector2");
	assert(typeof(acceleration) == "number", "Acceleration isn't a number");

	self.OffsetTarget = offset;
	self.OffsetAcceleration = math.clamp(acceleration, 0, 1);
end

function Dropshadow:SetTransparency(transparency: number, acceleration: number)
	-- Accepts a number as the first argument and a number as the second argument.
	-- Values below 0 or above 1 for the acceleration argument do not make sense.
	assert(typeof(transparency) == "number", "Transparency isn't a number");
	assert(typeof(acceleration) == "number", "Acceleration isn't a number");

	self.TransparencyTarget = transparency;
	self.TransparencyAcceleration = math.clamp(acceleration, 0, 1);
end

function Dropshadow:SetColor(color: Color3, acceleration: number)
	-- Accepts a Color3 as the first argument and a number as the second argument.
	-- Values below 0 or above 1 for the acceleration argument do not make sense.
	assert(typeof(color) == "Color3", "Color isn't a Color3");
	assert(typeof(acceleration) == "number", "Acceleration isn't a number");

	self.ColorTarget = color;
	self.ColorAcceleration = math.clamp(acceleration, 0, 1);
end

function Dropshadow:Pause()
	self.IsPaused = true;
end

function Dropshadow:Resume()
	self.IsPaused = false;
end

function Dropshadow:Destroy()
	self.Connection:Disconnect();
	if (self.Instance) then
		self.Instance:Destroy();
		self.Instance = nil;
	end;
end

return table.freeze(Dropshadow);]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004359</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX87FDF31D984C4846A7D1D632F55AD9B7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006473</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Gradient</string>
								<string name="ScriptGuid">{A50B7A62-DD84-4057-952B-048FA81488C1}</string>
								<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService");

type ColorSequenceKeypoints = typeof(ColorSequence.new(Color3.new()).Keypoints);
type NumberSequenceKeypoints = typeof(NumberSequence.new(0).Keypoints);
export type Gradient<T...> = {
	UIInstance: GuiObject,
	Instance: UIGradient,
	IsPaused: boolean,

	ColorSequence: ColorSequence,
	ColorSequenceTarget: ColorSequence,
	TrueColorSequence: ColorSequence?,
	ColorSequenceBlendRate: number,

	TransparencySequence: NumberSequence,
	TransparencySequenceTarget: NumberSequence,
	TrueTransparencySequence: NumberSequence?,
	TransparencySequenceBlendRate: number,

	Offset: number,
	OffsetTarget: number?,
	OffsetSpeed: number,
	OffsetSpeedTarget: number,
	OffsetAcceleration: number,

	TransparencyOffset: number,
	TransparencyOffsetTarget: number?,
	TransparencyOffsetSpeed: number,
	TransparencyOffsetSpeedTarget: number,
	TransparencyOffsetAcceleration: number,

	Rotation: number,
	RotationTarget: number?,
	RotationSpeed: number,
	RotationSpeedTarget: number,
	RotationAcceleration: number,

	Connection: RBXScriptConnection,
	IsText: boolean,

	Pause: (self: Gradient<T...>) -> nil,
	Resume: (self: Gradient<T...>) -> nil,
	SetColorSequence: (self: Gradient<T...>, sequence: ColorSequence, blendRate: number?) -> ColorSequence,
	SetOffset: (self: Gradient<T...>, offset: number, acceleration: number?) -> nil,
	SetOffsetSpeed: (self: Gradient<T...>, offset: number, acceleration: number?) -> nil,
	SetRotation: (self: Gradient<T...>, rotation: number, acceleration: number?) -> nil,
	SetRotationSpeed: (self: Gradient<T...>, rotation: number, acceleration: number?) -> nil,
	SetTransparencyOffset: (self: Gradient<T...>, offset: number, acceleration: number?) -> nil,
	SetTransparencyOffsetSpeed: (self: Gradient<T...>, offset: number, acceleration: number?) -> nil,
	SetTransparencySequence: (self: Gradient<T...>, transparency: number | NumberSequence, acceleration: number?) -> nil,
	EqualizeColorSequenceKeypoints: (self: Gradient<T...>) -> nil,
	EqualizeTransparencySequenceKeypoints: (self: Gradient<T...>) -> nil,
	CalculateTrueColorSequence: (self: Gradient<T...>) -> ColorSequence,
	CalculateTrueTransparencySequence: (self: Gradient<T...>) -> NumberSequence,
	Destroy: (self: Gradient<T...>) -> nil,
};

local function evalColorSequence(inputSequence: ColorSequenceKeypoints, time: number)
	local sequence = {};
	time += 1;

	for x = 0, 2 do
		for i = 1, #inputSequence do
			local datapoint = {Time = inputSequence[i].Time + x, Value = inputSequence[i].Value};
			table.insert(sequence, datapoint);
		end;
	end;

	-- Otherwise, step through each sequential pair of keypoints
	for i = 1, #sequence - 1 do
		local thisKeypoint = sequence[i];
		local nextKeypoint = sequence[i + 1];
		if (time >= thisKeypoint.Time and time < nextKeypoint.Time) then
			-- Calculate how far alpha lies between the points
			local alpha = (time - thisKeypoint.Time) / (nextKeypoint.Time - thisKeypoint.Time);
			-- Evaluate the real value between the points using alpha
			return Color3.new(
				(nextKeypoint.Value.R - thisKeypoint.Value.R) * alpha + thisKeypoint.Value.R,
				(nextKeypoint.Value.G - thisKeypoint.Value.G) * alpha + thisKeypoint.Value.G,
				(nextKeypoint.Value.B - thisKeypoint.Value.B) * alpha + thisKeypoint.Value.B
			);
		end;
	end;
end

local function evalNumberSequence(inputSequence: NumberSequenceKeypoints, time: number)
	local sequence = {};
	time += 1;

	for x = 0, 2 do
		for i = 1, #inputSequence do
			local datapoint = {Time = inputSequence[i].Time + x, Value = inputSequence[i].Value};
			table.insert(sequence, datapoint);
		end;
	end;

	-- Otherwise, step through each sequential pair of keypoints
	for i = 1, #sequence - 1 do
		local thisKeypoint = sequence[i];
		local nextKeypoint = sequence[i + 1];
		if (time >= thisKeypoint.Time and time < nextKeypoint.Time) then
			-- Calculate how far alpha lies between the points
			local alpha = (time - thisKeypoint.Time) / (nextKeypoint.Time - thisKeypoint.Time);
			-- Evaluate the real value between the points using alpha
			return thisKeypoint.Value + (nextKeypoint.Value - thisKeypoint.Value) * alpha;
		end;
	end;
end

local MAX_COLORSEQUENCE_KEYPOINTS = 19;
local MAX_NUMBERSEQUENCE_KEYPOINTS = 19;
local Gradient = {};
Gradient.__index = Gradient;

function Gradient.new<T...>(uiInstance: GuiObject | UIStroke, colorSequence: ColorSequence, transparencySequence: number | NumberSequence): Gradient<T...>
	assert(uiInstance, "UIInstance not provided");
	assert(uiInstance:IsA("GuiObject") or uiInstance:IsA("UIStroke"), "UIInstance is not a GuiObject or UIStroke");
	assert(colorSequence, "ColorSequence not provided");
	assert(transparencySequence, "TransparencySequence not provided")
	assert(typeof(colorSequence) == "ColorSequence", "ColorSequence is not a ColorSequence");
	assert(typeof(transparencySequence) == "number" or typeof(transparencySequence) == "NumberSequence", "TransparencySequence is not a number or NumberSequence");
	assert(#colorSequence.Keypoints <= MAX_COLORSEQUENCE_KEYPOINTS, "ColorSequence has too many keypoints");
	if (typeof(transparencySequence) == "NumberSequence") then
		assert(#transparencySequence.Keypoints <= MAX_NUMBERSEQUENCE_KEYPOINTS, "TransparencySequence has too many keypoints");
	end;

	local self = {};

	self.UIInstance = uiInstance;
	self.Instance = uiInstance:FindFirstChildWhichIsA("UIGradient") or Instance.new("UIGradient");
	self.IsPaused = false;

	self.ColorSequenceTarget = colorSequence;
	self.ColorSequence = colorSequence;
	self.TrueColorSequence = nil;
	self.ColorSequenceBlendRate = 1;

	self.TransparencySequenceTarget = nil;
	self.TransparencySequence = nil;
	self.TrueTransparencySequence = nil;
	self.TransparencySequenceBlendRate = 1;

	self.Offset = 0;
	self.OffsetTarget = nil;
	self.OffsetSpeed = 0;
	self.OffsetSpeedTarget = 0;
	self.OffsetAcceleration = 1;

	self.TransparencyOffset = 0;
	self.TransparencyOffsetTarget = nil;
	self.TransparencyOffsetSpeed = 0;
	self.TransparencyOffsetSpeedTarget = 0;
	self.TransparencyOffsetAcceleration = 1;

	self.Rotation = 0;
	self.RotationSpeed = 0;
	self.RotationSpeedTarget = 0;
	self.RotationAcceleration = 0;
	self.RotationTarget = nil;

	self.Connection = nil;
	self.IsText = false;

	if (typeof(transparencySequence) == "number") then
		self.TransparencySequenceTarget = NumberSequence.new({NumberSequenceKeypoint.new(0, transparencySequence), NumberSequenceKeypoint.new(1, transparencySequence)});
	elseif (typeof(transparencySequence) == "NumberSequence") then
		self.TransparencySequenceTarget = transparencySequence;
	else
		warn("Weird type of data?");
	end;

	self.TransparencySequence = self.TransparencySequenceTarget;

	if (uiInstance:IsA("TextLabel") or uiInstance:IsA("TextBox") or uiInstance:IsA("TextButton")) then
		self.IsText = true;
	end;

	self.Connection = RunService.Heartbeat:Connect(function(dt)
		if (self.IsPaused) then
			return;
		end;

		if (not self.UIInstance or self.UIInstance.Parent == nil) then
			self:Destroy();
			return;
		end;

		if (self.ColorSequenceBlendRate == 1) then
			self.ColorSequence = self.ColorSequenceTarget;
		else
			self:EqualizeColorSequenceKeypoints();
		end;

		if (self.TransparencySequenceBlendRate == 1) then
			self.TransparencySequence = self.TransparencySequenceTarget;
		end;

		if (self.OffsetTarget) then
			self.Offset = self.Offset + (self.OffsetTarget - self.Offset) * self.OffsetAcceleration;
		else
			self.OffsetSpeed = self.OffsetSpeed + (self.OffsetSpeedTarget - self.OffsetSpeed) * self.OffsetAcceleration * dt;
			self.Offset += self.OffsetSpeed * dt;
		end;

		if (self.TransparencyOffsetTarget) then
			self.TransparencyOffset = self.TransparencyOffset + (self.TransparencyOffsetTarget - self.TransparencyOffset) * self.TransparencyOffsetAcceleration;
		else
			self.TransparencyOffsetSpeed = self.TransparencyOffsetSpeed + (self.TransparencyOffsetSpeedTarget - self.TransparencyOffsetSpeed) * self.TransparencyOffsetAcceleration * dt;
			self.TransparencyOffset += self.TransparencyOffsetSpeed * dt;
		end;

		if (self.RotationTarget) then
			self.Rotation = self.Rotation + (self.RotationTarget - self.Rotation) * self.RotationAcceleration;
		else
			self.RotationSpeed = self.RotationSpeed + (self.RotationSpeedTarget - self.RotationSpeed) * self.RotationAcceleration * dt;
			self.Rotation += self.RotationSpeed * dt;
		end;

		self.Instance.Rotation = self.Rotation;
		self.Instance.Color = self:CalculateTrueColorSequence();
		self.Instance.Transparency = self:CalculateTrueTransparencySequence();
	end);

	self.Instance.Parent = self.UIInstance;
	return setmetatable(self, Gradient);
end

function Gradient:SetColorSequence(sequence: ColorSequence, blendRate: number?): ColorSequence
	assert(typeof(sequence) == "ColorSequence", "Sequence argument is nil or not a ColorSequence");

	self.ColorSequenceBlendRate = blendRate or 1;
	self.ColorSequenceTarget = sequence;

	return self.ColorSequenceTarget;
end

function Gradient:SetOffset(offset: number, acceleration: number?)
	-- Accepts a number as the first argument and a number as the second argument.
	-- Values below 0 or above 1 for the acceleration argument do not make sense.
	assert(typeof(offset) == "number", "Offset isn't a number");
	assert(typeof(acceleration) == "number", "Acceleration isn't a number");

	self.OffsetTarget = offset;
	self.OffsetSpeed = 0;
	self.OffsetSpeedTarget = 0;
	self.OffsetAcceleration = math.clamp(acceleration, 0, 1);
end

function Gradient:SetOffsetSpeed(offset: number, acceleration: number?)
	-- Accepts a number as the first argument and a number as the second argument.
	-- Values below 0 or above 1 for the acceleration argument do not make sense.
	assert(typeof(offset) == "number", "Offset isn't a number");
	assert(typeof(acceleration) == "number", "Acceleration isn't a number");

	self.OffsetSpeedTarget = offset;
	self.OffsetTarget = nil;
	self.OffsetAcceleration = math.clamp(acceleration, 0, 1);
end

function Gradient:SetRotation(rotation: number, acceleration: number?)
	-- Accepts a number as the first argument and a number as the second argument.
	-- Values below 0 or above 1 for the acceleration argument do not make sense.
	assert(typeof(rotation) == "number", "Offset isn't a number");
	assert(typeof(acceleration) == "number", "Acceleration isn't a number");

	self.RotationTarget = rotation;
	self.RotationSpeed = 0;
	self.RotationSpeedTarget = 0;
	self.RotationAcceleration = math.clamp(acceleration, 0, 1);
end

function Gradient:SetRotationSpeed(rotation: number, acceleration: number?)
	-- Accepts a number as the first argument and a number as the second argument.
	-- Values below 0 or above 1 for the acceleration argument do not make sense.
	assert(typeof(rotation) == "number", "Offset isn't a number");
	assert(typeof(acceleration) == "number", "Acceleration isn't a number");

	self.RotationSpeedTarget = rotation;
	self.RotationTarget = nil;
	self.RotationAcceleration = math.clamp(acceleration, 0, 1);
end

function Gradient:SetTransparencyOffset(offset: number, acceleration: number)
	-- Accepts a number as the first argument and a number as the second argument.
	-- Values below 0 or above 1 for the acceleration argument do not make sense.
	assert(typeof(offset) == "number", "Offset isn't a number");
	assert(typeof(acceleration) == "number", "Acceleration isn't a number");

	self.TransparencyOffsetTarget = offset;
	self.TransparencyOffsetSpeed = 0;
	self.TransparencyOffsetSpeedTarget = 0;
	self.TransparencyOffsetAcceleration = math.clamp(acceleration, 0, 1);
end

function Gradient:SetTransparencyOffsetSpeed(offset: number, acceleration: number)
	-- Accepts a number as the first argument and a number as the second argument.
	-- Values below 0 or above 1 for the acceleration argument do not make sense.
	assert(typeof(offset) == "number", "Offset isn't a number");
	assert(typeof(acceleration) == "number", "Acceleration isn't a number");

	self.TransparencyOffsetSpeedTarget = offset;
	self.TransparencyOffsetTarget = nil;
	self.TransparencyOffsetAcceleration = math.clamp(acceleration, 0, 1);
end

function Gradient:SetTransparencySequence(transparency: number | NumberSequence, acceleration: number?)
	-- Accepts a number or a NumberSequence as the first argument and a number as the second argument.
	-- Values below 0 or above 1 for the acceleration argument do not make sense.
	assert(transparency, "Transparency is nil");
	assert(typeof(acceleration) == "number", "Acceleration isn't a number");

	if (typeof(transparency) == "number") then
		self.TransparencyTarget = NumberSequence.new({NumberSequenceKeypoint.new(0, transparency), NumberSequenceKeypoint.new(1, transparency)});
	elseif (typeof(transparency) == "NumberSequence") then
		self.TransparencyTarget = transparency;
	else
		warn("Weird type of data?");
	end;

	self.TransparencyAcceleration = math.clamp(acceleration, 0, 1);
end

function Gradient:EqualizeColorSequenceKeypoints()
	local keypointsA = self.ColorSequenceTarget.Keypoints;
	local keypointsB = self.ColorSequence.Keypoints;
	local newkeypoints = {};

	if (#keypointsA ~= #keypointsB) then
		for i, v in keypointsA do
			local new = ColorSequenceKeypoint.new(v.Time, evalColorSequence(keypointsB, v.Time));
			table.insert(newkeypoints, new);
		end;
	else
		for _, v in keypointsA do
			local sample = evalColorSequence(keypointsB, v.Time);
			local blend = sample:Lerp(v.Value, self.ColorSequenceBlendRate);
			local new = ColorSequenceKeypoint.new(v.Time, blend);
			table.insert(newkeypoints, new);
		end;
	end;

	self.ColorSequence = ColorSequence.new(newkeypoints);
end

function Gradient:EqualizeTransparencySequenceKeypoints()
	local keypointsA = self.TransparencySequenceTarget.Keypoints;
	local keypointsB = self.TransparencySequence.Keypoints;
	local newkeypoints = {};

	if (#keypointsA ~= #keypointsB) then
		for i, v in keypointsA do
			local new = NumberSequenceKeypoint.new(v.Time, evalNumberSequence(keypointsB, v.Time));
			table.insert(newkeypoints, new);
		end;
	else
		for _, v in keypointsA do
			local sample = evalNumberSequence(keypointsB, v.Time);
			local blend = sample:Lerp(v.Value, self.TransparencySequenceBlendRate);
			local new = NumberSequenceKeypoint.new(v.Time, blend);
			table.insert(newkeypoints, new);
		end;
	end;

	print(newkeypoints[1].Value, newkeypoints[2].Value, newkeypoints[3].Value, newkeypoints[4].Value, newkeypoints[5].Value)
	self.TransparencySequence = NumberSequence.new(newkeypoints);
end

function Gradient:CalculateTrueColorSequence()
	local temp = {};
	local lowestKeypointIndex = 5;
	local lowestTime = 100;

	for _, v in self.ColorSequence.Keypoints do
		local newKeypoint = ColorSequenceKeypoint.new((v.Time + self.Offset) % 1, v.Value);
		if (newKeypoint.Time <= lowestTime) then
			temp[lowestKeypointIndex - 1] = newKeypoint;
			lowestKeypointIndex = lowestKeypointIndex - 1;
			lowestTime = newKeypoint.Time;
		else
			temp[#temp + 1] = newKeypoint;
		end;
	end;

	local keypoints = {};
	for i,v in temp do
		table.insert(keypoints, v);
	end;

	table.sort(keypoints, function(a, b)
		return a.Time < b.Time;
	end);

	if keypoints[1].Time ~= 0 then
		local newPoint = ColorSequenceKeypoint.new(0, evalColorSequence(keypoints, 0));
		table.insert(keypoints, 1, newPoint);
	end;

	if keypoints[#keypoints].Time ~= 1 then
		local newPoint = ColorSequenceKeypoint.new(1, evalColorSequence(keypoints, 1));
		table.insert(keypoints, newPoint);
	end;

	self.TrueColorSequence = ColorSequence.new(keypoints);
	return self.TrueColorSequence;
end

function Gradient:CalculateTrueTransparencySequence()
	if (#self.TransparencySequenceTarget.Keypoints == 2) then
		if (self.TransparencySequenceTarget.Keypoints[1].Value == self.TransparencySequenceTarget.Keypoints[2].Value) then
			self.TrueTransparencySequence = self.TransparencySequenceTarget;
			return self.TrueTransparencySequence;
		end;
	end;

	local temp = {};
	local lowestKeypointIndex = #self.TransparencySequence.Keypoints + 1;
	local lowestTime = math.huge;

	for _, v in self.TransparencySequence.Keypoints do
		local evaledTime = (v.Time + self.TransparencyOffset);
		if (evaledTime > 1 or evaledTime < 0) then
			evaledTime = evaledTime % 1;
		end;
		local newKeypoint = NumberSequenceKeypoint.new(evaledTime, v.Value);
		if (newKeypoint.Time <= lowestTime) then
			temp[lowestKeypointIndex - 1] = newKeypoint;
			lowestKeypointIndex = lowestKeypointIndex - 1;
			lowestTime = newKeypoint.Time;
		else
			temp[#temp + 1] = newKeypoint;
		end;
	end;

	local keypoints = {};
	for _, v in temp do
		table.insert(keypoints, v);
	end;

	table.sort(keypoints, function(a, b)
		return a.Time < b.Time;
	end)

	if (keypoints[1].Time ~= 0) then
		local newPoint = NumberSequenceKeypoint.new(0, evalNumberSequence(keypoints, 0));
		table.insert(keypoints, 1, newPoint);
	end;

	if (keypoints[#keypoints].Time ~= 1) then
		local value = evalNumberSequence(keypoints, 1);
		local newPoint = NumberSequenceKeypoint.new(1, value);
		table.insert(keypoints, newPoint);
	end;

	self.TrueTransparencySequence = NumberSequence.new(keypoints);
	return self.TrueTransparencySequence;
end

function Gradient:Pause()
	self.IsPaused = true;
end

function Gradient:Resume()
	self.IsPaused = false;
end

function Gradient:Destroy()
	self.Connection:Disconnect();
	if (self.Instance) then
		self.Instance:Destroy();
		self.Instance = nil;
	end;
end

return table.freeze(Gradient);]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000435a</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXD0B3068AA77C4D5EA661F454EF52E6DD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a0000648c</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Stroke</string>
								<string name="ScriptGuid">{1D6654CE-747F-4FA3-8110-600968C602F7}</string>
								<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService");

-- Fingeroo was here ( ͡° ͜ʖ ͡°)

export type Stroke<T...> = {
	UIInstance: GuiObject,
	Instance: UIStroke,
	IsPaused: boolean,
	Color: Color3,
	ColorTarget: Color3,
	ColorAcceleration: number,
	Transparency: number,
	TransparencyTarget: number,
	TransparencyAcceleration: number,
	Size: number,
	SizeTarget: number,
	SizeAcceleration: number,
	Connection: RBXScriptConnection,
	IsText: boolean,

	Pause: (self: Stroke<T...>) -> nil,
	Resume: (self: Stroke<T...>) -> nil,
	SetSize: (self: Stroke<T...>, size: number, acceleration: number) -> nil,
	SetTransparency: (self: Stroke<T...>, transparency: number, acceleration: number) -> nil,
	SetColor: (self: Stroke<T...>, color: Color3, acceleration: number) -> nil,
	Destroy: (self: Stroke<T...>) -> nil,
};

local Stroke = {};
Stroke.__index = Stroke;

function Stroke.new<T...>(uiInstance: GuiObject | UIStroke, size: number, color: Color3?, transparency: number?): Stroke<T...>
	assert(uiInstance, "UIInstance not provided");
	assert(uiInstance:IsA("GuiObject") or uiInstance:IsA("UIStroke"), "UIInstance is not a GuiObject or UIStroke");
	assert(size, "Size not provided");
	assert(typeof(size) == "number", "Size is not a number");
	if (color) then
		assert(typeof(color) == "Color3", "Color is not a Color3");
	end;
	if (transparency) then
		assert(typeof(transparency) == "number", "Transparency is not a number");
	end;

	local self = {};

	self.UIInstance = uiInstance;
	self.Instance = uiInstance:FindFirstChildWhichIsA("UIStroke") or Instance.new("UIStroke");
	self.IsPaused = false;

	self.Color = color or Color3.new(1, 1, 1);
	self.ColorTarget = color or Color3.new(1, 1, 1);
	self.ColorAcceleration = 1;

	self.Transparency = transparency or 0;
	self.TransparencyTarget = transparency or 0;
	self.TransparencyAcceleration = 1;

	self.Size = size;
	self.SizeTarget = size;
	self.SizeAcceleration = 1;
	self.Connection = nil;
	self.IsText = false;

	if (uiInstance:IsA("TextLabel") or uiInstance:IsA("TextBox") or uiInstance:IsA("TextButton")) then
		self.IsText = true;
	end;

	self.Instance.Parent = self.UIInstance;

	self.Connection = RunService.Heartbeat:Connect(function(dt)
		if (self.IsPaused) then
			return;
		end;

		if (not self.UIInstance or self.UIInstance.Parent == nil) then
			self:Destroy();
			return;
		end;

		self.Color = self.Color:Lerp(self.ColorTarget, self.ColorAcceleration * dt);
		self.Size = self.Size + ((self.SizeTarget - self.Size) * self.SizeAcceleration * dt);
		self.Transparency = self.Transparency + ((self.TransparencyTarget - self.Transparency) * self.TransparencyAcceleration * dt);

		self.Instance.Transparency = self.Transparency;
		self.Instance.Color = self.Color;
		self.Instance.Thickness = self.Size;
	end);

	return setmetatable(self, Stroke);
end

function Stroke:SetSize(size: number, acceleration: number)
	-- Accepts a Vector2 as the first argument and a number as the second argument.
	-- Values below 0 or above 1 for the acceleration argument do not make sense.
	assert(typeof(size) == "number", "Size isn't a number");
	assert(typeof(acceleration) == "number", "Acceleration isn't a number");

	self.SizeTarget = size;
	self.SizeAcceleration = math.clamp(acceleration, 0, 1);
end

function Stroke:SetTransparency(transparency: number, acceleration: number)
	-- Accepts a number as the first argument and a number as the second argument.
	-- Values below 0 or above 1 for the acceleration argument do not make sense.
	assert(typeof(transparency) == "number", "Transparency isn't a number");
	assert(typeof(acceleration) == "number", "Acceleration isn't a number");

	self.TransparencyTarget = transparency;
	self.TransparencyAcceleration = math.clamp(acceleration, 0, 1);
end

function Stroke:SetColor(color: Color3, acceleration: number)
	-- Accepts a Color3 as the first argument and a number as the second argument.
	-- Values below 0 or above 1 for the acceleration argument do not make sense.
	assert(typeof(color) == "Color3", "Color isn't a Color3");
	assert(typeof(acceleration) == "number", "Acceleration isn't a number");

	self.ColorTarget = color;
	self.ColorAcceleration = math.clamp(acceleration, 0, 1);
end

function Stroke:Pause()
	self.IsPaused = true;
end

function Stroke:Resume()
	self.IsPaused = false;
end

function Stroke:Destroy()
	self.Connection:Disconnect();
	if (self.Instance) then
		self.Instance:Destroy();
		self.Instance = nil;
	end;
end

return table.freeze(Stroke);]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000435b</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXCBBB880F138B430FB5781FE64A1BFAA4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a0000648d</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">GradientTemplates</string>
								<string name="ScriptGuid">{225AF5B5-199D-432C-B490-C997FE7A1AC4}</string>
								<ProtectedString name="Source"><![CDATA[local Modules = script:GetDescendants();
local SubModules = {};

for _, module in Modules do
    if (not module:IsA("ModuleScript")) then continue end;
    SubModules[module.Name] = require(module)();
end

return SubModules;]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000435c</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXA260D48706B5401F8357A25E55C90C1D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a0000649a</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Matrix</string>
									<string name="ScriptGuid">{6969951B-648C-413C-B5DE-E0AA09D4B87B}</string>
									<ProtectedString name="Source"><![CDATA[return function()
    local Gradient = Instance.new("UIGradient");
    Gradient.Color = ColorSequence.new({
        -- matrix colors
        ColorSequenceKeypoint.new(0, Color3.new(0.243137, 0.937254, 0.007843)),
        ColorSequenceKeypoint.new(0.015625, Color3.new(0.243137, 0.937254, 0.007843)),
        ColorSequenceKeypoint.new(0.1458333283662796, Color3.new(0.243137, 0.937254, 0.007843)),
        ColorSequenceKeypoint.new(0.2482638955116272, Color3.new(0.243137, 0.937254, 0.007843)),
        ColorSequenceKeypoint.new(0.3559027910232544, Color3.new(0.243137, 0.937254, 0.007843)),
        ColorSequenceKeypoint.new(0.4970000088214874, Color3.new(0.243137, 0.937254, 0.007843)),
        ColorSequenceKeypoint.new(0.503000020980835, Color3.new(0, 0, 0)),
        ColorSequenceKeypoint.new(0.647569477558136, Color3.new(0, 0, 0)),
        ColorSequenceKeypoint.new(0.7829861044883728, Color3.new(0, 0, 0)),
        ColorSequenceKeypoint.new(0.890625, Color3.new(0, 0, 0)),
        ColorSequenceKeypoint.new(0.9774305820465088, Color3.new(0, 0, 0)),
        ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0)),
    })
    return Gradient;
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000435d</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXCAF3EB23403D43969EBCA13752194630">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006499</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Fire</string>
									<string name="ScriptGuid">{AFDA3B9F-C172-40A1-AB74-57A9E1E59343}</string>
									<ProtectedString name="Source"><![CDATA[return function()
    local Gradient = Instance.new("UIGradient");
    Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(1, 0.917647, 0)),
        ColorSequenceKeypoint.new(0.1510416716337204, Color3.new(1, 0.917647, 0)),
        ColorSequenceKeypoint.new(0.3072916567325592, Color3.new(1, 0.6, 0)),
        ColorSequenceKeypoint.new(0.4965277910232544, Color3.new(0.545098, 0.368627, 0.035294)),
        ColorSequenceKeypoint.new(0.6649305820465088, Color3.new(1, 0.666666, 0)),
        ColorSequenceKeypoint.new(0.8385416865348816, Color3.new(0.678431, 0.490196, 0.113725)),
        ColorSequenceKeypoint.new(1, Color3.new(1, 0.917647, 0)),
    });
    return Gradient;
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000435e</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX70F1273E9DFB4E60B190D52981D00D5A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006498</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Ice</string>
									<string name="ScriptGuid">{78B18C72-0EE2-41EA-B009-6B068D1D8F55}</string>
									<ProtectedString name="Source"><![CDATA[return function()
    local Gradient = Instance.new("UIGradient");
    Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(109, 210, 212)),
        ColorSequenceKeypoint.new(0.171875, Color3.new(0.8784313797950745, 0.9411764740943909, 1)),
        ColorSequenceKeypoint.new(0.3177083432674408, Color3.fromRGB(140, 208, 209)),
        ColorSequenceKeypoint.new(0.4670138955116272, Color3.fromRGB(109, 210, 212)),
        ColorSequenceKeypoint.new(0.4982638955116272, Color3.fromRGB(109, 210, 212)),
        ColorSequenceKeypoint.new(0.5034722089767456, Color3.new(1, 1, 1)),
        ColorSequenceKeypoint.new(0.71875, Color3.new(0.7058823704719543, 1, 0.9529411792755127)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(109, 210, 212)),
    })
    return Gradient;
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000435f</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB9CB9BB2DC0E48049B21FDE9EFBB46E5">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006497</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Death</string>
									<string name="ScriptGuid">{7235C445-9CF7-4337-9D24-DDB0DEA8E63B}</string>
									<ProtectedString name="Source"><![CDATA[return function()
    local Gradient = Instance.new("UIGradient");
    Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(0.6, 0, 0)),
        ColorSequenceKeypoint.new(0.125, Color3.new(1, 0, 0)),
        ColorSequenceKeypoint.new(0.2552083432674408, Color3.new(0.411764, 0, 0)),
        ColorSequenceKeypoint.new(0.3767361044883728, Color3.new(0.3, 0, 0)),
        ColorSequenceKeypoint.new(0.5, Color3.new(0.690196, 0, 0)),
        ColorSequenceKeypoint.new(0.6197916865348816, Color3.new(0.3, 0, 0)),
        ColorSequenceKeypoint.new(0.7378472089767456, Color3.new(1, 0, 0)),
        ColorSequenceKeypoint.new(0.8680555820465088, Color3.new(0.3, 0, 0)),
        ColorSequenceKeypoint.new(1, Color3.new(0.6, 0, 0))
    })
    return Gradient;
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004360</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXABE0131BF3254E9FB1A6DD646C1BB0C7">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006496</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Zebra</string>
									<string name="ScriptGuid">{9EE75829-EC35-4991-B278-189CAF8A3269}</string>
									<ProtectedString name="Source"><![CDATA[return function()
    local Gradient = Instance.new("UIGradient");
    Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
        ColorSequenceKeypoint.new(0.015625, Color3.new(1, 1, 1)),
        ColorSequenceKeypoint.new(0.1458333283662796, Color3.new(1, 1, 1)),
        ColorSequenceKeypoint.new(0.2482638955116272, Color3.new(1, 1, 1)),
        ColorSequenceKeypoint.new(0.3559027910232544, Color3.new(1, 1, 1)),
        ColorSequenceKeypoint.new(0.4970000088214874, Color3.new(1, 1, 1)),
        ColorSequenceKeypoint.new(0.503000020980835, Color3.new(0, 0, 0)),
        ColorSequenceKeypoint.new(0.647569477558136, Color3.new(0, 0, 0)),
        ColorSequenceKeypoint.new(0.7829861044883728, Color3.new(0, 0, 0)),
        ColorSequenceKeypoint.new(0.890625, Color3.new(0, 0, 0)),
        ColorSequenceKeypoint.new(0.9774305820465088, Color3.new(0, 0, 0)),
        ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0)),
    })
    return Gradient;
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004361</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX250E2BCB637246F588C81A242EC04A7C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006495</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Silver</string>
									<string name="ScriptGuid">{27F55F9B-4CAB-4EC6-9599-343BDFC60E51}</string>
									<ProtectedString name="Source"><![CDATA[return function()
    local Gradient = Instance.new("UIGradient");
    Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(0.8352941274642944, 0.8352941274642944, 0.8352941274642944)),
        ColorSequenceKeypoint.new(0.284722238779068, Color3.new(0.7333333492279053, 0.7843137383460999, 0.8352941274642944)),
        ColorSequenceKeypoint.new(0.4982638955116272, Color3.new(0.3333333432674408, 0.3333333432674408, 0.43921568989753723)),
        ColorSequenceKeypoint.new(0.5034722089767456, Color3.new(1, 1, 1)),
        ColorSequenceKeypoint.new(0.7152777910232544, Color3.new(0.7333333492279053, 0.7843137383460999, 0.8352941274642944)),
        ColorSequenceKeypoint.new(1, Color3.new(0.8352941274642944, 0.8352941274642944, 0.8352941274642944)),
    })
    return Gradient;
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004362</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA5CEF5B1F632435286EC3FB1E2BFBE73">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006494</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Rainbow</string>
									<string name="ScriptGuid">{321C826A-C9DB-4CEB-B138-1D8C95F35B98}</string>
									<ProtectedString name="Source"><![CDATA[return function()
    local Gradient = Instance.new("UIGradient");
    Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(1, 0, 0)),
        ColorSequenceKeypoint.new(0.1510416716337204, Color3.new(0.615686297416687, 0, 1)),
        ColorSequenceKeypoint.new(0.3072916567325592, Color3.new(0.06666667014360428, 0, 1)),
        ColorSequenceKeypoint.new(0.4965277910232544, Color3.new(0, 1, 1)),
        ColorSequenceKeypoint.new(0.6649305820465088, Color3.new(0.01568627543747425, 1, 0)),
        ColorSequenceKeypoint.new(0.8385416865348816, Color3.new(1, 1, 0)),
        ColorSequenceKeypoint.new(1, Color3.new(1, 0, 0)),
    });
    return Gradient;
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004363</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX00B5A09C28C84DD0A2F958A8D0F0D952">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006493</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Oceanic</string>
									<string name="ScriptGuid">{2E3D8C56-EBA5-497A-A47F-577A4FB5DD68}</string>
									<ProtectedString name="Source"><![CDATA[return function()
    local Gradient = Instance.new("UIGradient");
    Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(0, 0.45098039507865906, 1)),
        ColorSequenceKeypoint.new(0.125, Color3.new(1, 0, 0)),
        ColorSequenceKeypoint.new(0.2552083432674408, Color3.new(0, 0.45098039507865906, 1)),
        ColorSequenceKeypoint.new(0.3767361044883728, Color3.new(1, 0, 0)),
        ColorSequenceKeypoint.new(0.5, Color3.new(0, 0.45098039507865906, 1)),
        ColorSequenceKeypoint.new(0.6197916865348816, Color3.new(1, 0, 0)),
        ColorSequenceKeypoint.new(0.7374784350395203, Color3.new(0, 0.45098039507865906, 1)),
        ColorSequenceKeypoint.new(0.8680555820465088, Color3.new(1, 0, 0)),
        ColorSequenceKeypoint.new(1, Color3.new(0, 0.45098039507865906, 1)),
    })
    return Gradient;
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004364</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6F5B4535C238426788F6D7A86C4ADD0C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006492</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Lava</string>
									<string name="ScriptGuid">{8A1D40A4-FCAF-4DA1-BEA8-0450DFACA81F}</string>
									<ProtectedString name="Source"><![CDATA[return function()
    local Gradient = Instance.new("UIGradient");
    Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(1, 0, 0)),
        ColorSequenceKeypoint.new(0.125, Color3.new(1, 0.7843137383460999, 0)),
        ColorSequenceKeypoint.new(0.2552083432674408, Color3.new(1, 0, 0)),
        ColorSequenceKeypoint.new(0.3767361044883728, Color3.new(1, 0.7843137383460999, 0)),
        ColorSequenceKeypoint.new(0.5, Color3.new(1, 0, 0)),
        ColorSequenceKeypoint.new(0.6197916865348816, Color3.new(1, 0.7843137383460999, 0)),
        ColorSequenceKeypoint.new(0.7378472089767456, Color3.new(1, 0, 0)),
        ColorSequenceKeypoint.new(0.8680555820465088, Color3.new(1, 0.7843137383460999, 0)),
        ColorSequenceKeypoint.new(1, Color3.new(1, 0, 0)),
    });
    return Gradient;
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004365</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA206BFDD0C314B30BCB347751DB28E26">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006491</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Gold</string>
									<string name="ScriptGuid">{BE8FE41E-8340-47F6-B654-6E3B9C0650F5}</string>
									<ProtectedString name="Source"><![CDATA[return function()
    local Gradient = Instance.new("UIGradient");
    Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(0.8352941274642944, 0.6823529601097107, 0.21960784494876862)),
        ColorSequenceKeypoint.new(0.220486119389534, Color3.new(0.8352941274642944, 0.6823529601097107, 0.21960784494876862)),
        ColorSequenceKeypoint.new(0.3680555522441864, Color3.new(0.7803921699523926, 0.5960784554481506, 0.0470588244497776)),
        ColorSequenceKeypoint.new(0.4982638955116272, Color3.new(0.8509804010391235, 0.6980392336845398, 0.0117647061124444)),
        ColorSequenceKeypoint.new(0.5034722089767456, Color3.new(1, 0.9254902005195618, 0.5058823823928833)),
        ColorSequenceKeypoint.new(0.6927083134651184, Color3.new(0.8352941274642944, 0.6823529601097107, 0.21960784494876862)),
        ColorSequenceKeypoint.new(0.7916666865348816, Color3.new(0.8352941274642944, 0.6823529601097107, 0.21960784494876862)),
        ColorSequenceKeypoint.new(1, Color3.new(0.8352941274642944, 0.6823529601097107, 0.21960784494876862)),
    })
    return Gradient;
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004366</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6BEE9D14D6B44A9EAC7A5C607A1080FA">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006490</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Ghost</string>
									<string name="ScriptGuid">{04A76539-8620-4B28-84DF-D091E8180AD8}</string>
									<ProtectedString name="Source"><![CDATA[return function()
    local Gradient = Instance.new("UIGradient");
    Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
        ColorSequenceKeypoint.new(0.5, Color3.new(0.7098039388656616, 0.7215686440467834, 0.7372549176216125)),
        ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1)),
    })
    Gradient.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.09894459694623947, 0),
        NumberSequenceKeypoint.new(0.5, 1),
        NumberSequenceKeypoint.new(0.8997361660003662, 0),
        NumberSequenceKeypoint.new(1, 0),
    })
    return Gradient;
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004367</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX479263EF62AC48168F745122B773700B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a0000649b</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Green</string>
									<string name="ScriptGuid">{9254A072-710E-4ECE-B87C-B7EC78DF29B7}</string>
									<ProtectedString name="Source"><![CDATA[return function()
    local Gradient = Instance.new("UIGradient");
    Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 0)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 0)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 0))
    });
    Gradient.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.7, 1),
        NumberSequenceKeypoint.new(1, 1)
    })
    return Gradient;
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004368</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX2C984A8A6B3C45B3ADBA9552103D74F0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a0000648e</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Bubblegum</string>
									<string name="ScriptGuid">{A7C983FE-622C-4897-9981-5D12F683B69E}</string>
									<ProtectedString name="Source"><![CDATA[return function()
    local Gradient = Instance.new("UIGradient");
    Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(0.9529411792755127, 0.3960784375667572, 0.6941176652908325)),
        ColorSequenceKeypoint.new(0.5, Color3.new(1, 0.6549019813537598, 0.8901960849761963)),
        ColorSequenceKeypoint.new(1, Color3.new(0.9529411792755127, 0.3960784375667572, 0.6941176652908325)),
    })
    Gradient.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.09894459694623947, 0),
        NumberSequenceKeypoint.new(0.5, 1),
        NumberSequenceKeypoint.new(0.8997361660003662, 0),
        NumberSequenceKeypoint.new(1, 0),
    })
    return Gradient;
end;]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004369</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX8BAF72D68060411CB2CA48E3A2B49370">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a0000648f</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Chrome</string>
									<string name="ScriptGuid">{9F2C55B7-73E7-4497-B02A-3BE56F023C51}</string>
									<ProtectedString name="Source"><![CDATA[return function()
    local Gradient = Instance.new("UIGradient");
    Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(0, 0.062745101749897, 0.3529411852359772)),
        ColorSequenceKeypoint.new(0.0677083358168602, Color3.new(0.686274528503418, 0.7882353067398071, 0.8352941274642944)),
        ColorSequenceKeypoint.new(0.171875, Color3.new(0.8784313797950745, 0.9411764740943909, 1)),
        ColorSequenceKeypoint.new(0.3177083432674408, Color3.new(1, 0.7058823704719543, 1)),
        ColorSequenceKeypoint.new(0.4670138955116272, Color3.new(0.2666666805744171, 0, 0.49803921580314636)),
        ColorSequenceKeypoint.new(0.4982638955116272, Color3.new(0.019607843831181526, 0.003921568859368563, 0.03529411926865578)),
        ColorSequenceKeypoint.new(0.5034722089767456, Color3.new(1, 1, 1)),
        ColorSequenceKeypoint.new(0.71875, Color3.new(0.7058823704719543, 1, 0.9529411792755127)),
        ColorSequenceKeypoint.new(0.9409722089767456, Color3.new(0.15203255414962769, 0.6226686239242554, 0.6860832571983337)),
        ColorSequenceKeypoint.new(1, Color3.new(0, 0.062745101749897, 0.3529411852359772)),
    })
    return Gradient;
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000436a</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXCD368372D03E402CA276E877DB4BF09C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006474</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Presets</string>
								<string name="ScriptGuid">{0A6F6509-DF42-4FD8-9966-B9BBF6C9EA09}</string>
								<ProtectedString name="Source"><![CDATA[local Modules = script:GetDescendants();
local SubModules = {};

for _, module in Modules do
    if (not module:IsA("ModuleScript")) then continue end;
    SubModules[module.Name] = require(module);
end

return SubModules;]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000436b</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX22A0C451742E4894B71A90F16C4A4150">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a0000648b</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ShineOutline</string>
									<string name="ScriptGuid">{53D2C16B-60C5-43A8-ABB0-DABF0A030F79}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService");
local TextEffects = require(script.Parent.Parent);

-- Making colors lighter
local function makeLighter(color: Color3, amount: number): Color3
    return color:Lerp(Color3.fromRGB(255, 255, 255), amount);
end

local function findColorFromObject(uiInstance: GuiObject): Color3
    local Data = {
        ["TextButton"] = "BackgroundColor3",
        ["TextLabel"] = "TextColor3",
        ["ImageLabel"] = "ImageColor3",
        ["ImageButton"] = "ImageColor3",
        ["Frame"] = "BackgroundColor3",
        ["ScrollingFrame"] = "BackgroundColor3",
        ["ViewportFrame"] = "BackgroundColor3",
    };

    local color = uiInstance[Data[uiInstance.ClassName]];
    if (color) then
        return color;
    end;

    -- If we can't find a color, we'll just use white
    return Color3.fromRGB(255, 255, 255);
end

return function(uiInstance: GuiObject, speed: number, size: number, customColor: Color3)
    customColor = customColor or findColorFromObject(uiInstance);

    -- We're not going to use a GradientTemplate because this requires us to do some things with the customColor
    local color1 = customColor;
    local color2 = makeLighter(customColor, 0.6);
    local color3 = customColor;

    local colorSequenceForShine = ColorSequence.new({
        ColorSequenceKeypoint.new(0, color1),
        ColorSequenceKeypoint.new(0.5, color2),
        ColorSequenceKeypoint.new(1, color3)
	});
		
	local mainStroke = TextEffects.Stroke.new(uiInstance, size);
	local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, colorSequenceForShine, 0);
	local Rotation = 0.75;
	
	local Connection
	Connection = RunService.Heartbeat:Connect(function(dt)
		if (not mainStroke.Instance or mainStroke.Instance.Parent == nil) then
			Connection:Disconnect();
		end;
		
		Rotation = Rotation + speed * dt;
		strokeGradient:SetRotation(Rotation, 1);
	end);

	return {
		Effects = { strokeGradient, mainStroke },
		Connections = { Connection }
	};
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000436c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX8CA51CA9313B4BEB9A2E6165FDEB1B91">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006489</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Shine</string>
									<string name="ScriptGuid">{53F59DBA-CBCF-4662-ACBC-8F31648AAB6D}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

-- Making colors lighter
local function makeLighter(color: Color3, amount: number): Color3
    return color:Lerp(Color3.fromRGB(255, 255, 255), amount);
end

local function findColorFromObject(uiInstance: GuiObject): Color3
    local Data = {
        ["TextButton"] = "BackgroundColor3",
        ["TextLabel"] = "TextColor3",
        ["ImageLabel"] = "ImageColor3",
        ["ImageButton"] = "ImageColor3",
        ["Frame"] = "BackgroundColor3",
        ["ScrollingFrame"] = "BackgroundColor3",
        ["ViewportFrame"] = "BackgroundColor3",
    };

    local color = uiInstance[Data[uiInstance.ClassName]];
    if (color) then
        return color;
    end;

    -- If we can't find a color, we'll just use white
    return Color3.fromRGB(255, 255, 255);
end

return function(uiInstance: GuiObject, speed: number, size: number, customColor: Color3)
    customColor = customColor or findColorFromObject(uiInstance);

    -- We're not going to use a GradientTemplate because this requires us to do some things with the customColor
    local color1 = customColor;
    local color2 = makeLighter(customColor, 0.417505);
    local color3 = customColor;

    local colorSequenceForShine = ColorSequence.new({
        ColorSequenceKeypoint.new(0, color1),
        ColorSequenceKeypoint.new(0.5, color2),
        ColorSequenceKeypoint.new(1, color3)
    });

    local mainGradient = TextEffects.Gradient.new(uiInstance, colorSequenceForShine, 0);
    mainGradient:SetOffsetSpeed(speed * 0.6, 1);
    mainGradient:SetRotation(60, 1);
    return {
        Effects = { mainGradient }
    };
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000436d</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX43C4BE8E3B7247A18CBC28E49F98E77E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006487</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Matrix</string>
									<string name="ScriptGuid">{02078AAB-4A78-46C0-BA50-FDE7619220EA}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number, size: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Matrix.Color, 0);
    mainGradient:SetOffsetSpeed(speed, 1);
    mainGradient:SetRotation(90, 1);

    local mainStroke = TextEffects.Stroke.new(uiInstance, size);

    local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, TextEffects.Templates.Matrix.Color, 0);
    strokeGradient:SetOffset(0.5, 1);
    strokeGradient:SetRotation(90, 1);

    task.delay(0.1, function()
        strokeGradient:SetOffsetSpeed(speed, 1);
    end);

    return {
        Effects = { mainGradient, strokeGradient, mainStroke }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000436e</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX618CA88679A24237981E97B36F8513B1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006486</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">FireStroke</string>
									<string name="ScriptGuid">{8B5ADE8F-FC0B-424F-9AC8-3EEB32984DA1}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService");

local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number, size: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Fire.Color, 0);
    mainGradient:SetRotation(-75, 1);
    mainGradient:SetOffsetSpeed(speed, 1);

    local Rotation = 0;
	local Connection
	Connection = RunService.Heartbeat:Connect(function(dt)
		if (not mainGradient.Instance or mainGradient.Instance.Parent == nil) then
			Connection:Disconnect();
		end;
		Rotation = Rotation + speed * dt;
		mainGradient:SetRotation(Rotation, 1);
	end);

    local mainStroke = TextEffects.Stroke.new(uiInstance, size);
    local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, TextEffects.Templates.Fire.Color, 0);
    strokeGradient:SetRotation(75, 1);
    strokeGradient:SetOffsetSpeed(-speed, 1);

	return {
		Effects = { mainGradient, strokeGradient, mainStroke },
		Connections = { Connection }
	};
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000436f</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9FDD06F6A265499EBD0936C48D7C8270">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006484</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">DeathStroke</string>
									<string name="ScriptGuid">{F3AE373A-5B56-4674-B619-764B6E6B2AF2}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number, size: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Death.Color, 0);
    mainGradient:SetRotation(-90, 1);
    mainGradient:SetOffsetSpeed(speed, 1);

    local mainStroke = TextEffects.Stroke.new(uiInstance, size);
    local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, TextEffects.Templates.Death.Color, 0);
    strokeGradient:SetOffsetSpeed(-speed - 0.001, 1);
    strokeGradient:SetRotation(-85, 1);
    return {
        Effects = { mainGradient, strokeGradient, mainStroke }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004370</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5692DEA214A746F2AAB17EA7E3A4A0F4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006483</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">RainbowOutline</string>
									<string name="ScriptGuid">{110B83F6-015A-4A14-9C15-D210530CE02E}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService");

local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number, size: number)
    local mainStroke = TextEffects.Stroke.new(uiInstance, size);
    local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, TextEffects.Templates.Rainbow.Color, 0);
    local Rotation = 5;

	local Connection
	Connection = RunService.Heartbeat:Connect(function(dt)
		if (not mainStroke.Instance or mainStroke.Instance.Parent == nil) then
			Connection:Disconnect();
		end;
		Rotation = Rotation + speed * dt;
		strokeGradient:SetRotation(Rotation, 1);
	end);

	return {
		Effects = { strokeGradient, mainStroke },
		Connections = { Connection }
	};
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004371</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX83B9890700BD4DCBB7854FC823A58BF8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006482</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Ghost</string>
									<string name="ScriptGuid">{0A2A8518-75FD-477E-9A25-BC3F8588C5A8}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Ghost.Color, TextEffects.Templates.Ghost.Transparency);
    mainGradient:SetOffsetSpeed(speed, 1);
    mainGradient:SetTransparencyOffsetSpeed(speed * 0.9, 1);
    return {
        Effects = { mainGradient }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004372</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXFDD02FA909164DDDB65A27B6DC9AF635">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006481</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Zebra</string>
									<string name="ScriptGuid">{3207DA53-0E3D-4002-875B-0E6430BA5CC9}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number, size: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Zebra.Color, 0);
    mainGradient:SetOffsetSpeed(speed, 1);
    mainGradient:SetRotation(90, 1);

    local mainStroke = TextEffects.Stroke.new(uiInstance, size);

    local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, TextEffects.Templates.Zebra.Color, 0);
    strokeGradient:SetOffset(0.5, 1);
    strokeGradient:SetRotation(90, 1);

    task.delay(0.1, function()
        strokeGradient:SetOffsetSpeed(speed, 1);
    end);

    return {
        Effects = { mainGradient, strokeGradient, mainStroke }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004373</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX0218C8AE9F98424190C7F74E60810BD1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006480</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SilverStroke</string>
									<string name="ScriptGuid">{A8BABADB-22A8-4C1C-BCF9-50EF68A5CD32}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number, size: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Silver.Color, 0);
    mainGradient:SetRotation(-80, 1);
    mainGradient:SetOffsetSpeed(speed, 1);

    local mainStroke = TextEffects.Stroke.new(uiInstance, size);
    local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, TextEffects.Templates.Silver.Color, 0);
    strokeGradient:SetRotation(-79, 1);
    strokeGradient:SetOffsetSpeed(speed * 0.56, 1);
    return {
        Effects = { mainGradient, strokeGradient, mainStroke }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004374</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5DFD14B8288244C68FF6222D8E81F9FD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a0000647e</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">RainbowStroke</string>
									<string name="ScriptGuid">{D69D1531-B6FE-4499-A93C-A16E1368898B}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number, size: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Rainbow.Color, 0);
    mainGradient:SetOffsetSpeed(speed, 1);

    local mainStroke = TextEffects.Stroke.new(uiInstance, size);
    local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, TextEffects.Templates.Rainbow.Color, 0);
    strokeGradient:SetOffsetSpeed(-speed, 1);
    return {
        Effects = { mainGradient, strokeGradient, mainStroke }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004375</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX46F34DD2834D454FBE0696DA2AE5AB2C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006485</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">IceStroke</string>
									<string name="ScriptGuid">{AF362AC9-22DA-420F-A1ED-631260A0C7BE}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number, size: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Ice.Color, 0);
    mainGradient:SetRotation(-65, 1);
    mainGradient:SetOffsetSpeed(speed, 1);

    local mainStroke = TextEffects.Stroke.new(uiInstance, size);
    local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, TextEffects.Templates.Ice.Color, 0);
    strokeGradient:SetRotation(-61, 1);
    strokeGradient:SetOffsetSpeed(speed * 0.23, 1);
    return {
        Effects = { mainGradient, strokeGradient, mainStroke }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004376</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXDF89389C9796480BB695BF539C8551C3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006476</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ChromeStroke</string>
									<string name="ScriptGuid">{C9B610AB-F76C-421C-BFE6-30070D72C84C}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number, size: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Chrome.Color, 0);
    mainGradient:SetRotation(-90, 1);
    mainGradient:SetOffsetSpeed(speed, 1);

    local mainStroke = TextEffects.Stroke.new(uiInstance, size);
    local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, TextEffects.Templates.Chrome.Color, 0);
    strokeGradient:SetRotation(-89, 1);
    strokeGradient:SetOffsetSpeed(speed * 0.58, 1);
    return {
        Effects = { mainGradient, strokeGradient, mainStroke }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004377</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD45FC04165A9401EA4D8F6EB2F7BA9EC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006477</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">GhostStroke</string>
									<string name="ScriptGuid">{CC484E3B-3408-421C-A551-28F5BD2DAAAE}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number, size: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Ghost.Color, TextEffects.Templates.Ghost.Transparency);
    mainGradient:SetOffsetSpeed(speed, 1);
    mainGradient:SetTransparencyOffsetSpeed(speed * 0.9, 1);

    local mainStroke = TextEffects.Stroke.new(uiInstance, size);
    local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, TextEffects.Templates.Ghost.Color, TextEffects.Templates.Ghost.Transparency);
    strokeGradient:SetOffsetSpeed(-speed * 0.9, 1);
    strokeGradient:SetTransparencyOffsetSpeed(-speed * 0.9, 1);
    return {
        Effects = { mainGradient, strokeGradient, mainStroke }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004378</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX141A68717CFA4F9E8197705E0BC3C31B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006478</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Gold</string>
									<string name="ScriptGuid">{87F8C752-9EC5-4C2C-80AB-DDF392044125}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Gold.Color, 0);
    mainGradient:SetRotation(-75, 1);
    mainGradient:SetOffsetSpeed(speed, 1);
    return {
        Effects = { mainGradient }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004379</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD49001EC356A4DE8A4D55256FD032481">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006479</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">GoldStroke</string>
									<string name="ScriptGuid">{299556EA-ED75-4760-AA10-562FC7592CBE}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number, size: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Gold.Color, 0);
    mainGradient:SetRotation(-75, 1);
    mainGradient:SetOffsetSpeed(speed, 1);

    local mainStroke = TextEffects.Stroke.new(uiInstance, size);
    local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, TextEffects.Templates.Gold.Color, 0);
    strokeGradient:SetRotation(75, 1);
    strokeGradient:SetOffsetSpeed(-speed, 1);
    return {
        Effects = { mainGradient, strokeGradient, mainStroke }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000437a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX18100E16BB5C4BFDBB9C0B63155417EF">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a0000647a</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Lava</string>
									<string name="ScriptGuid">{AF947E6E-BFD4-4552-A935-21132D6EC79A}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Lava.Color, 0);
    mainGradient:SetOffsetSpeed(speed, 1);
    return {
        Effects = { mainGradient }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000437b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXAE78C2AC60AA48B6BCCAEFEABF766B5D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a0000647b</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">LavaStroke</string>
									<string name="ScriptGuid">{36257C81-BBCD-40D7-B328-940BD7DC595F}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number, size: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Lava.Color, 0);
    mainGradient:SetOffsetSpeed(speed, 1);

    local mainStroke = TextEffects.Stroke.new(uiInstance, size);
    local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, TextEffects.Templates.Lava.Color, 0);
    strokeGradient:SetOffsetSpeed(-speed, 1);
    return {
        Effects = { mainGradient, strokeGradient, mainStroke }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000437c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX062A9781E6494A1DBDE208C80B7CD2C1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a0000647c</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">OceanicStroke</string>
									<string name="ScriptGuid">{4880A8E0-291D-4F1C-B2DC-636EE4D3FC15}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number, size: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Oceanic.Color, 0);
    mainGradient:SetOffsetSpeed(speed, 1);
    mainGradient:SetRotation(-75, 1);
    mainGradient:SetRotationSpeed(0.1, 1);

    local mainStroke = TextEffects.Stroke.new(uiInstance, size);
    local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, TextEffects.Templates.Oceanic.Color, 0);
    strokeGradient:SetOffsetSpeed(-speed, 1);
    return {
        Effects = { mainGradient, strokeGradient, mainStroke }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000437d</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX0FDB0EC3D27F4A4B86F0D7A12EEA2A57">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a0000647d</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Rainbow</string>
									<string name="ScriptGuid">{467AE77D-6CE3-4AE3-953B-736CAB5C418D}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Rainbow.Color, 0);
    mainGradient:SetOffsetSpeed(speed, 1);
    return {
        Effects = { mainGradient }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000437e</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE3BFC9991D1E4AD4A2248B9B3CA45020">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a0000647f</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Silver</string>
									<string name="ScriptGuid">{A0CD0D59-4190-4DF5-BD15-0E97BB7C5F09}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Silver.Color, 0);
    mainGradient:SetRotation(-75, 1);
    mainGradient:SetOffsetSpeed(speed, 1);
    return {
        Effects = { mainGradient }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000437f</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX11AE563A267743F1ABFD9411BF09E510">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a0000648a</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">WaveStroke</string>
									<string name="ScriptGuid">{AE0374BB-191C-4750-B9AA-CFD977E2A491}</string>
									<ProtectedString name="Source"><![CDATA[local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number, size: number, customColor: Color3)
    local colorSequence = ColorSequence.new({
        ColorSequenceKeypoint.new(0, customColor),
        ColorSequenceKeypoint.new(0.5, customColor),
        ColorSequenceKeypoint.new(1, customColor)
    });

    local transparencySequence = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.25, 1),
        NumberSequenceKeypoint.new(0.5, 1),
        NumberSequenceKeypoint.new(0.75, 1),
        NumberSequenceKeypoint.new(1, 0)
    });

    local mainStroke = TextEffects.Stroke.new(uiInstance, size);
    local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, colorSequence, transparencySequence);
    strokeGradient:SetOffsetSpeed(speed, 1);
    strokeGradient:SetTransparencyOffsetSpeed(speed * 0.9, 1);
    return {
        Effects = { strokeGradient, mainStroke }
    };
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004380</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD6D65D9806414AC9B68124B856CF1BBC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006475</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Bubblegum</string>
									<string name="ScriptGuid">{B6A34506-E84B-4470-A4A2-51EEB4C48361}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService");

local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number, size: number)
    local mainGradient = TextEffects.Gradient.new(uiInstance, TextEffects.Templates.Bubblegum.Color, 0);
    mainGradient:SetRotation(-90, 1);
    mainGradient:SetOffsetSpeed(speed, 1);

    local mainStroke = TextEffects.Stroke.new(uiInstance, size);
    local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, TextEffects.Templates.Bubblegum.Color, 0);
    strokeGradient:SetRotation(-45, 1);
	strokeGradient:SetOffsetSpeed(speed * 0.9, 1);

	local Scale = size * 3;
	local Connection;
	Connection = RunService.Heartbeat:Connect(function()
		if (not mainStroke.Instance or mainStroke.Instance.Parent == nil) then
			Connection:Disconnect();
			return;
		end;

		local t = tick() * speed;
		local sizeMultiplier = 1 + Scale * math.sin(t);
		mainStroke:SetSize(size * sizeMultiplier, 0.055);
	end);

	return {
		Effects = { mainGradient, strokeGradient, mainStroke },
		Connections = { Connection }
	};
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004381</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX73C3B1264A454C44968BEFFEFC01FA27">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">4a8ebb93eb4c639c073fdb3a00006488</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">GreenOutline</string>
									<string name="ScriptGuid">{BE4D39EC-93AF-4867-B53E-E9E54B18BF9E}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService");

local TextEffects = require(script.Parent.Parent);

return function(uiInstance: GuiObject, speed: number, size: number)
    local mainStroke = TextEffects.Stroke.new(uiInstance, size);
    local strokeGradient = TextEffects.Gradient.new(mainStroke.Instance, TextEffects.Templates.Green.Color, TextEffects.Templates.Green.Transparency);
    local Rotation = 5;

	local Connection
	Connection = RunService.Heartbeat:Connect(function(dt)
		if (not mainStroke.Instance or mainStroke.Instance.Parent == nil) then
			Connection:Disconnect();
		end;
		Rotation = Rotation + speed * dt;
		strokeGradient:SetRotation(Rotation, 1);
	end);

	return {
		Effects = { strokeGradient, mainStroke },
		Connections = { Connection }
	};
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004382</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX61A62013378E42B08F1869AE491EE9F6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">1af24096c87c37d507ec96ca00005f69</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_LightningEffects</string>
							<string name="ScriptGuid">{3BA6D94F-9383-4DB0-A438-564F2D373C15}</string>
							<ProtectedString name="Source"><![CDATA[--!strict

local LightningBolt = require(script._LightningBolt)
local LightningExplosion = require(script._LightningExplosion)
local LightningSparks = require(script._LightningSparks)

export type LightningBolt = LightningBolt.LightningBolt
export type LightningExplosion = LightningExplosion.LightningExplosion
export type LightningSparks = LightningSparks.LightningSparks

return {
	LightningBolt = LightningBolt,
	LightningExplosion = LightningExplosion,
	LightningSparks = LightningSparks
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004383</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX503BD1CA1BFE4A2EABB0EE51A4FEBF8E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">1af24096c87c37d507ec96ca00005f88</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_LightningBolt</string>
								<string name="ScriptGuid">{A2619026-99C5-4DEE-BC06-43C264B75FBE}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--!native
--[[
	Procedural Lightning Effect Module. By Quasiduck
	License: https://github.com/SamyBlue/Lightning-Beams/blob/main/LICENSE
	See README for guide on how to use or scroll down to see all properties in LightningBolt.new
	All properties update in real-time except PartCount which requires a new LightningBolt to change
	i.e. You can change a property at any time after a LightningBolt instance is created and it will still update the look of the bolt
--]]
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Signal = require("../../ModuleUtils/_Signal")

local cachedProperties = setmetatable({}, { __mode = "k" })

-- Tolerance values for detecting significant changes.
local SIZE_TOLERANCE = 0.05
local TRANSPARENCY_TOLERANCE = 0.05
local COLOR_TOLERANCE = 0.1

local PARTS_IN_CACHE = 10000 -- Default was 5000, recommended higher if using sparks.
local RunService = game:GetService("RunService")
local parent = workspace:FindFirstChildOfClass("Terrain")
local rng = Random.new()
local math = math
local Vector3 = Vector3
local CFrame = CFrame

--*Part Cache Setup
--New parts automatically get added to cache if more parts are requested for use where a warning is thrown

local BoltPart = Instance.new("Part") --Template primitive that will make up the entire bolt
BoltPart.TopSurface, BoltPart.BottomSurface = Enum.SurfaceType.Smooth, Enum.SurfaceType.Smooth
BoltPart.Anchored, BoltPart.CanCollide = true, false
BoltPart.Locked, BoltPart.CastShadow = true, false
BoltPart.CanTouch, BoltPart.CanQuery = false, false
BoltPart.Shape = Enum.PartType.Cylinder
BoltPart.Name = "BoltPart"
BoltPart.Material = Enum.Material.Neon
BoltPart.Color = Color3.new(1, 1, 1)
BoltPart.Transparency = 1
BoltPart.CastShadow = false

local PartCache = require("../../ModuleUtils/_PartCache")
local LightningCache = PartCache.new(BoltPart, PARTS_IN_CACHE, parent)

local function CubicBezier(PercentAlongBolt, p0: Vector3, p1: Vector3, p2: Vector3, p3: Vector3): Vector3
	PercentAlongBolt = tonumber(PercentAlongBolt) or 0
	return p0 * (1 - PercentAlongBolt) ^ 3
		+ p1 * 3 * PercentAlongBolt * (1 - PercentAlongBolt) ^ 2
		+ p2 * 3 * (1 - PercentAlongBolt) * PercentAlongBolt ^ 2
		+ p3 * PercentAlongBolt ^ 3
end

local function DiscretePulse(PercentAlongBolt, TimePassed, s, k, f, min, max): number
	PercentAlongBolt = tonumber(PercentAlongBolt) or 0
	TimePassed = tonumber(TimePassed) or 0
	s = tonumber(s) or 1
	k = tonumber(k) or 1000000
	f = tonumber(f) or 0.5
	min = tonumber(min) or 0
	max = tonumber(max) or 1
	-- Ensure the lower bound is not greater than the upper bound.
	local lowerBound = math.min(min, max)
	local upperBound = math.max(min, max)
	return math.clamp(k / (2 * f) - math.abs((PercentAlongBolt - TimePassed * s + 0.5 * k) / f), lowerBound, upperBound)
end

local function ExtrudeCenter(PercentAlongBolt): number
	PercentAlongBolt = tonumber(PercentAlongBolt) or 0
	return math.exp(-5000 * (PercentAlongBolt - 0.5) ^ 10)
end

local function NoiseBetween(x: number, y: number?, z: number?, min, max)
	min = tonumber(min) or 0
	max = tonumber(max) or 1
	return min + (max - min) * (math.noise(x, y, z) + 0.5)
end

local xInverse = CFrame.new(Vector3.zero, Vector3.xAxis):Inverse()
local offsetAngle = math.cos(math.pi*0.5) --math.cos(math.rad(90))

local ActiveBranches : {LightningBolt} = {} --Contains all LightningBolt instances
local LightningBolt = {} --Define new class
LightningBolt.__type = "LightningBolt"
LightningBolt.__index = LightningBolt

--Small tip: You don't need to use actual Roblox Attachments below. You can also create "fake" ones as follows:
--[[
	local A1, A2 = {}, {}
	A1.WorldPosition, A1.WorldAxis = chosenPos1, chosenAxis1
	A2.WorldPosition, A2.WorldAxis = chosenPos2, chosenAxis2
	local NewBolt = LightningBolt.new(A1, A2, 40)
--]]
export type FakeAttachment = {
	WorldPosition: Vector3,
	WorldAxis: Vector3,
}
export type LightningBolt = typeof(setmetatable({} :: {
	Enabled: boolean,
	Attachment0: Attachment | FakeAttachment,
	Attachment1: Attachment | FakeAttachment,
	CurveSize0: number,
	CurveSize1: number,
	MinRadius: number,
	MaxRadius: number,
	Frequency: number,
	AnimationSpeed: number,
	Thickness: number,
	MinThicknessMultiplier: number,
	MaxThicknessMultiplier: number,
	MinTransparency: number,
	MaxTransparency: number,
	PulseSpeed: number,
	PulseLength: number,
	FadeLength: number,
	ContractFrom: number,
	Color: ColorSequence | Color3,
	ColorOffsetSpeed: number,
	SpaceCurveFunction: (...any) -> Vector3,
	OpacityProfileFunction: (...any) -> number,
	RadialProfileFunction: (...any) -> number,
	Velocity: Vector3?,
	Destroying: Signal.GenericSignal,
	Destroyed: boolean,
	_Parts: {BasePart},
	_PartsHidden: boolean,
	_DisabledTransparency: number,
	_StartT: number,
	_RanNum: number,
	_RefIndex: number,
}, LightningBolt))

function LightningBolt.new(Attachment0: Attachment | FakeAttachment, Attachment1: Attachment | FakeAttachment, PartCount): LightningBolt
	PartCount = tonumber(PartCount) or 30
	local self = setmetatable({
		-- Bolt Appearance Properties
		Enabled = true, -- Hides bolt without removing any parts when false
		Attachment0 = Attachment0, Attachment1 = Attachment1, -- Bolt originates from Attachment0 and ends at Attachment1
		CurveSize0 = 0, CurveSize1 = 0, -- Works similarly to roblox beams. See https://dk135eecbplh9.cloudfront.net/assets/blt160ad3fdeadd4ff2/BeamCurve1.png
		MinRadius = 0, MaxRadius = 2.4, -- Governs the amplitude of fluctuations throughout the bolt
		Frequency = 1, -- Governs the frequency of fluctuations throughout the bolt. Lower this to remove jittery-looking lightning
		AnimationSpeed = 7, -- Governs how fast the bolt oscillates (i.e. how fast the fluctuating wave travels along bolt)
		Thickness = 1, -- The thickness of the bolt
		MinThicknessMultiplier = 0.2, MaxThicknessMultiplier = 1, -- Multiplies Thickness value by a fluctuating random value between MinThicknessMultiplier and MaxThicknessMultiplier along the Bolt

		-- Bolt Kinetic Properties
		--[[
			Allows for fading in (or out) of the bolt with time. Can also create a "projectile" bolt
			Recommend setting AnimationSpeed to 0 if used as projectile (for better aesthetics)
			Works by passing a "wave" function which travels from left to right where the wave height represents opacity (opacity being 1 - Transparency)
			See https://www.desmos.com/calculator/hg5h4fpfim to help customise the shape of the wave with the below properties
		--]]
		MinTransparency = 0, MaxTransparency = 1,
		PulseSpeed = 2, -- Bolt arrives at Attachment1 1/PulseSpeed seconds later
		PulseLength  = 1000000,
		FadeLength = 0.2,
		ContractFrom = 0.5, -- Parts shorten or grow once their Transparency exceeds this value. Set to a value above 1 to turn effect off. See https://imgur.com/OChA441

		-- Bolt Color Properties
		Color = Color3.new(1, 1, 1), -- Can be a Color3 or ColorSequence
		ColorOffsetSpeed = 3, -- Sets speed at which ColorSequence travels along Bolt

		-- Advanced Properties
		--[[
			Allows you to pass a custom space curve for the bolt to be defined along
			Constraints: 
				-First input passed must be a parameter representing PercentAlongBolt between values 0 and 1
			Example: self.SpaceCurveFunction = VivianiCurve(PercentAlongBolt)
		--]]
		SpaceCurveFunction = CubicBezier,

		--[[
			Allows you to pass a custom opacity profile which controls the opacity along the bolt
			Constraints: 
				-First input passed must be a parameter representing PercentAlongBolt between values 0 and 1
				-Second input passed must be a parameter representing TimePassed since instantiation 
			Example: self.OpacityProfileFunction = MovingSineWave(PercentAlongBolt, TimePassed)
			Note: You may want to set self.ContractFrom to a value above 1 if you pass a custom opacity profile as contraction was designed to work with DiscretePulse
		--]]
		OpacityProfileFunction = DiscretePulse,

		--[[
			Allows you to pass a custom radial profile which controls the radius of control points along the bolt
			Constraints: 
				-First input passed must be a parameter representing PercentAlongBolt between values 0 and 1
		--]]
		RadialProfileFunction = ExtrudeCenter,

		-- Private variables, should not be changed manually.
		Destroying = Signal.new(), -- fake .Destroying Signal
		Destroyed = false, -- true if :Destroy() is called on it.
		_Parts = table.create(tonumber(PartCount) or 30), -- The BoltParts which make up the Bolt
		_PartsHidden = false,
		_DisabledTransparency = 1,
		_StartT = os.clock(),
		_RanNum = rng:NextNumber(0, 100),
		_RefIndex = #ActiveBranches + 1,
	}, LightningBolt)

	for i = 1, PartCount do
		self._Parts[i] = LightningCache:GetPart()
	end
	ActiveBranches[self._RefIndex] = self
	return self
end

function LightningBolt:Destroy()
	if getmetatable(self) ~= LightningBolt then return end -- make sure it works lol
	self = self :: LightningBolt

	ActiveBranches[self._RefIndex] = nil
	--task.synchronize()
	for i = 1, #self._Parts do
		LightningCache:ReturnPart(self._Parts[i])
	end

	self.Destroying:Fire()
	self.Destroyed = true
	self = nil :: any
end

--Calls Destroy() after TimeLength seconds where a dissipating effect takes place in the meantime
function LightningBolt:DestroyDissipate(TimeLength, Strength)
	if getmetatable(self) ~= LightningBolt then return end -- make sure it works lol
	self = self :: LightningBolt

	TimeLength = tonumber(TimeLength) or 0.2
	Strength = tonumber(Strength) or 0.5
	local DissipateStartT = os.clock()
	local start, mid, goal = self.MinTransparency, self.ContractFrom, self.ContractFrom
		+ 1 / (#self._Parts * self.FadeLength)
	local StartRadius = self.MaxRadius
	local StartMinThick = self.MinThicknessMultiplier
	local DissipateLoop: RBXScriptConnection?
	
	--task.synchronize()
	DissipateLoop = RunService.Heartbeat:Connect(function()
		local TimeSinceDissipate = os.clock() - DissipateStartT
		self.MinThicknessMultiplier = StartMinThick + (-2 - StartMinThick) * TimeSinceDissipate / TimeLength

		if TimeSinceDissipate < TimeLength * 0.4 then
			local interp = (TimeSinceDissipate / (TimeLength * 0.4))
			self.MinTransparency = start + (mid - start) * interp
		elseif TimeSinceDissipate < TimeLength then
			local interp = ((TimeSinceDissipate - TimeLength * 0.4) / (TimeLength * 0.6))
			self.MinTransparency = mid + (goal - mid) * interp
			self.MaxRadius = StartRadius * (1 + Strength * interp)
			self.MinRadius = self.MinRadius + (self.MaxRadius - self.MinRadius) * interp
		else
			-- Destroy Bolt
			local TimePassed = os.clock() - self._StartT
			local Lifetime = (self.PulseLength + 1) / self.PulseSpeed

			--task.synchronize()
			if TimePassed < Lifetime then --prevents Destroy()ing twice
				self:Destroy()
			end

			-- Disconnect Loop
			if DissipateLoop then
				DissipateLoop:Disconnect()
				DissipateLoop = nil
			end
		end
	end)
	--task.desynchronize()
end

function LightningBolt:_UpdateGeometry(BPart: BasePart, PercentAlongBolt: number, TimePassed: number, ThicknessNoiseMultiplier: number, PrevPoint: Vector3, NextPoint: Vector3): (CFrame?)
	debug.profilebegin("UPDATE_GEOMETRY")
	self = self :: LightningBolt

	-- Compute opacity for this particular section
	local MinOpa, MaxOpa = 1 - self.MaxTransparency, 1 - self.MinTransparency
	local Opacity = self.OpacityProfileFunction(PercentAlongBolt, TimePassed, self.PulseSpeed, self.PulseLength, self.FadeLength, MinOpa, MaxOpa)

	-- Compute thickness for this particular section
	local Thickness = (tonumber(self.Thickness) or 1) * ThicknessNoiseMultiplier * Opacity
	Opacity = Thickness > 0 and Opacity or 0

	-- Compute + update sizing and orientation of this section
	local contractf = 1 - self.ContractFrom
	local PartsN = #self._Parts
	local posDifference = NextPoint - PrevPoint

	local newSize, newTransparency, newCFrame

	if Opacity > contractf then
		newSize = Vector3.new(posDifference.Magnitude, Thickness, Thickness)
		newCFrame = CFrame.new((PrevPoint + NextPoint) * 0.5, NextPoint) * xInverse
		newTransparency = 1 - Opacity
	elseif Opacity > contractf - 1 / (PartsN * self.FadeLength) then
		local interp = (1 - (Opacity - (contractf - 1 / (PartsN * self.FadeLength))) * PartsN * self.FadeLength)
			* (PercentAlongBolt < TimePassed * self.PulseSpeed - 0.5 * self.PulseLength and 1 or -1)
		newSize = Vector3.new((1 - math.abs(interp)) * posDifference.Magnitude, Thickness, Thickness)
		newCFrame = CFrame.new(PrevPoint + posDifference * (math.max(0, interp) + 0.5 * (1 - math.abs(interp))), NextPoint) * xInverse
		newTransparency = 1 - Opacity
	else
		newTransparency = 1
	end

	-- Get or create the cached properties for this part.
	local cache = cachedProperties[BPart]
	if not cache then
		cache = {}
		cachedProperties[BPart] = cache
	end

	-- Update Size only if significantly different.
	if newSize then
		-- Use the cached size instead of doing BPart.Size (a namecall) every frame.
		if not cache.Size or (cache.Size - newSize).Magnitude > SIZE_TOLERANCE then
			BPart.Size = newSize
			cache.Size = newSize
		end
	end

	-- Update Transparency only if significantly different.
	if cache.Transparency == nil then
		cache.Transparency = BPart.Transparency
	end
	if math.abs(cache.Transparency - newTransparency) > TRANSPARENCY_TOLERANCE then
		BPart.Transparency = newTransparency
		cache.Transparency = newTransparency
	end
	
	debug.profileend()
	return newCFrame
end

local function colorDifference(a: Color3, b: Color3): number
	return math.abs(a.R - b.R) + math.abs(a.G - b.G) + math.abs(a.B - b.B)
end

function LightningBolt:_UpdateColor(BPart, PercentAlongBolt, TimePassed): ()
	self = self :: LightningBolt

	local col: Color3 = self.Color
	if typeof(col) == "ColorSequence" then
		local t1 = (self._RanNum + PercentAlongBolt - TimePassed * self.ColorOffsetSpeed) % 1
		local keypoints = self.Color.Keypoints
		for i = 1, #keypoints - 1 do
			if keypoints[i].Time < t1 and t1 < keypoints[i + 1].Time then
				col = keypoints[i].Value:Lerp(
					keypoints[i + 1].Value,
					(t1 - keypoints[i].Time) / (keypoints[i + 1].Time - keypoints[i].Time)
				)
				break
			end
		end
	end

	-- Get or create the cache for Color.
	local cache = cachedProperties[BPart]
	if not cache then
		cache = {}
		cachedProperties[BPart] = cache
	end

	if not cache.Color then
		cache.Color = BPart.Color
	end

	if colorDifference(cache.Color, col) > COLOR_TOLERANCE then
		BPart.Color = col
		cache.Color = col
	end
end

function LightningBolt:_Disable()
	if getmetatable(self) ~= LightningBolt then return end
	self = self :: LightningBolt

	self.Enabled = false
	--task.synchronize() -- property changes aren't allowed in parallel
	for _, BPart in self._Parts do
		BPart.Transparency = self._DisabledTransparency
	end
end

local bulkParts = {}
local bulkCFrames = {}
RunService.Heartbeat:Connect(function()
	for _, ThisBranch in ActiveBranches do
		if ThisBranch.Enabled ~= true then
			if not ThisBranch._PartsHidden then
				ThisBranch._PartsHidden = true
				ThisBranch:_Disable()
			end
			continue
		end

		ThisBranch._PartsHidden = false

		-- Extract important variables
		local MinRadius, MaxRadius = ThisBranch.MinRadius, ThisBranch.MaxRadius
		local Parts = ThisBranch._Parts
		local PartsN = #Parts
		local RanNum = ThisBranch._RanNum
		local spd = ThisBranch.AnimationSpeed
		local freq = ThisBranch.Frequency
		local MinThick, MaxThick = ThisBranch.MinThicknessMultiplier, ThisBranch.MaxThicknessMultiplier
		local TimePassed = os.clock() - ThisBranch._StartT
		local SpaceCurveFunction, RadialProfileFunction =
			ThisBranch.SpaceCurveFunction, ThisBranch.RadialProfileFunction
		local Lifetime = (ThisBranch.PulseLength + 1) / ThisBranch.PulseSpeed

		-- Extract control points
		local a0, a1, CurveSize0, CurveSize1 =
			ThisBranch.Attachment0, ThisBranch.Attachment1, ThisBranch.CurveSize0, ThisBranch.CurveSize1
		local p0, p1, p2, p3 = a0.WorldPosition, a0.WorldPosition
			+ a0.WorldAxis * CurveSize0, a1.WorldPosition
		- a1.WorldAxis * CurveSize1, a1.WorldPosition

		-- Initialise iterative scheme for generating points along space curve
		local init = SpaceCurveFunction(0, p0, p1, p2, p3)
		local PrevPoint, bezier0 = init, init

		-- Update
		if TimePassed >= Lifetime then pcall(ThisBranch.Destroy, ThisBranch) continue end
		
		local parts = {}
		local cframes = {}
		
		for i, BPart in Parts do
			local PercentAlongBolt = i / PartsN

			--Compute noisy inputs
			local input, input2 = -TimePassed*spd + freq*10*PercentAlongBolt - 0.2 + RanNum*4, 5*((-TimePassed*spd*0.01)/10 + freq*PercentAlongBolt) + RanNum*4

			local noise0 = NoiseBetween(5*input, 1.5, input2, 0, 0.2*math.pi)
				+ NoiseBetween(0.5*input, 1.5, 0.1*input2, 0, 1.8*math.pi)
			local noise1 = NoiseBetween(3.4, input2, input, MinRadius, MaxRadius)
				* RadialProfileFunction(PercentAlongBolt)
			local thicknessNoise = NoiseBetween(2.3, input2, input, MinThick, MaxThick)

			--Find next point along space curve
			local bezier1 = SpaceCurveFunction(PercentAlongBolt, p0, p1, p2, p3)

			--Find next point along bolt
			local NextPoint = i ~= PartsN
				and (CFrame.new(bezier0, bezier1) * CFrame.Angles(0, 0, noise0) * CFrame.Angles(
					math.acos(math.clamp(NoiseBetween(input2, input, 2.7, offsetAngle, 1), -1, 1)),
					0,
					0
					) * CFrame.new(0, 0, -noise1)).Position
				or bezier1
			
			local cframe = ThisBranch:_UpdateGeometry(BPart, PercentAlongBolt, TimePassed, thicknessNoise, PrevPoint, NextPoint)
			ThisBranch:_UpdateColor(BPart, PercentAlongBolt, TimePassed)
			if cframe then
				table.insert(bulkParts, BPart)
				table.insert(bulkCFrames, cframe)
			end
			PrevPoint, bezier0 = NextPoint, bezier1
		end
	end
	
	if #bulkParts > 0 then
		workspace:BulkMoveTo(bulkParts, bulkCFrames, Enum.BulkMoveMode.FireCFrameChanged)
		table.clear(bulkParts)
		table.clear(bulkCFrames)
	end
end)

return LightningBolt]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004384</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX28E8BBA0481540B8BA25FCCB1C995C88">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">1af24096c87c37d507ec96ca00005f8e</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_LightningSparks</string>
								<string name="ScriptGuid">{A7BBC471-8EEF-4016-A7FB-99B58979CC2C}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--!native
-- Adds sparks effect to a Lightning Bolt
local LightningBolt = require("./_LightningBolt")
type LightningBolt = LightningBolt.LightningBolt

local ActiveSparks = {}
local rng = Random.new()
local LightningSparks = {}
LightningSparks.__index = LightningSparks

export type LightningSparks = typeof(setmetatable({} :: {
	Enabled: boolean,
	LightningBolt: LightningBolt,
	MaxSparkCount: number,
	MinSpeed: number,
	MaxSpeed: number,
	MinDistance: number,
	MaxDistance: number,
	MinPartsPerSpark: number,
	MaxPartsPerSpark: number,
	SparksN: number,
	SlotTable: {LightningBolt},
	RefIndex: number,
}, LightningSparks))

function LightningSparks.new(LightningBolt: LightningBolt, MaxSparkCount: number?)
	local self = setmetatable({}, LightningSparks)
	
	self.Enabled = true --Stops spawning sparks when false
	self.LightningBolt = LightningBolt --Bolt which sparks fly out of
	self.MaxSparkCount = MaxSparkCount or 10 --Max number of sparks visible at any given instance
	self.MinSpeed, self.MaxSpeed = 4, 6 --Min and max PulseSpeeds of sparks
	self.MinDistance, self.MaxDistance = 3, 6 --Governs how far sparks travel away from main bolt
	self.MinPartsPerSpark, self.MaxPartsPerSpark = 8, 10 --Adjustable
	
	self.SparksN = 0
	self.SlotTable = {}
	self.RefIndex = #ActiveSparks + 1
	
	ActiveSparks[self.RefIndex] = self
	return self
end

function LightningSparks:Destroy()
	ActiveSparks[self.RefIndex] = nil
	
	for i, v in self.SlotTable do
		if v.Destroyed then
			self.SlotTable[i] = nil --Removes reference to prevent memory leak
		end
	end
end

function RandomVectorOffset(v, maxAngle) --returns uniformly-distributed random unit vector no more than maxAngle radians away from v
	return (CFrame.new(Vector3.zero, v)*CFrame.Angles(0, 0, rng:NextNumber(0, 2*math.pi))*CFrame.Angles(math.acos(rng:NextNumber(math.cos(maxAngle), 1)), 0, 0)).LookVector
end

game:GetService("RunService").Heartbeat:Connect(function()
	for _, ThisSpark in ActiveSparks do
		if ThisSpark.Enabled == true and ThisSpark.SparksN < ThisSpark.MaxSparkCount then
			local Bolt = ThisSpark.LightningBolt
			if Bolt.Destroyed then ThisSpark:Destroy() continue end
			
			local opaque_parts = {}
			for part_i = 1, #Bolt._Parts do --Fill opaque_parts table
				if Bolt._Parts[part_i].Transparency < 0.3 then -- minimum opacity required to be able to generate a spark there
					table.insert(opaque_parts, (part_i - 0.5) / #Bolt._Parts)
				end
			end
			
			local minSlot, maxSlot 
			if #opaque_parts ~= 0 then
				minSlot, maxSlot = math.ceil(opaque_parts[1]*ThisSpark.MaxSparkCount), math.ceil(opaque_parts[#opaque_parts]*ThisSpark.MaxSparkCount)
			end
			
			for _ = 1, math.floor(rng:NextNumber(1, ThisSpark.MaxSparkCount-ThisSpark.SparksN)) do
				if #opaque_parts == 0 then break end
				local available_slots = {}
				
				for slot_i = minSlot, maxSlot do --Fill available_slots table
					if ThisSpark.SlotTable[slot_i]==nil then --check slot doesn't have existing spark
						table.insert(available_slots, slot_i)
					end
				end
				
				if #available_slots <= 0 then continue end
				local ChosenSlot = available_slots[math.random(#available_slots)]
				local localTrng = rng:NextNumber(-0.5, 0.5)
				local ChosenT = (ChosenSlot - 0.5 + localTrng)/ThisSpark.MaxSparkCount

				local dist, ChosenPart = 10, 1

				for opaque_i = 1, #opaque_parts do
					local testdist = math.abs(opaque_parts[opaque_i] - ChosenT)
					if testdist < dist then
						dist, ChosenPart = testdist, math.floor((opaque_parts[opaque_i]*#Bolt._Parts + 0.5) + 0.5)
					end
				end

				local Part = Bolt._Parts[ChosenPart]

				--Make new spark--

				local A1, A2 = {}, {}
				A1.WorldPosition = Part.Position + localTrng*Part.CFrame.RightVector*Part.Size.X
				A2.WorldPosition = A1.WorldPosition + RandomVectorOffset(Part.CFrame.RightVector, math.pi/4)*rng:NextNumber(ThisSpark.MinDistance, ThisSpark.MaxDistance)
				A1.WorldAxis = (A2.WorldPosition - A1.WorldPosition).Unit
				A2.WorldAxis = A1.WorldAxis
				local NewSpark = LightningBolt.new(A1, A2, math.random(ThisSpark.MinPartsPerSpark, ThisSpark.MaxPartsPerSpark))

				--NewSpark.MaxAngleOffset = math.rad(70)
				NewSpark.MinRadius, NewSpark.MaxRadius = 0, 0.8
				NewSpark.AnimationSpeed = 0
				NewSpark.Thickness = Part.Size.Y / 2
				NewSpark.MinThicknessMultiplier, NewSpark.MaxThicknessMultiplier = 1, 1
				NewSpark.PulseLength = 0.5
				NewSpark.PulseSpeed = rng:NextNumber(ThisSpark.MinSpeed, ThisSpark.MaxSpeed)
				NewSpark.FadeLength = 0.25
				--local cH, cS, cV = Part.Color:ToHSV()
				NewSpark.Color = Part.Color -- Color3.fromHSV(cH, 0.5, cV)
				NewSpark.Destroying:Once(function()
					if ThisSpark.SlotTable[ChosenSlot] == NewSpark then ThisSpark.SlotTable[ChosenSlot] = nil end
				end)
				ThisSpark.SlotTable[ChosenSlot] = NewSpark
			end
		end
		
		--Update SparksN--
		local slotsInUse = 0
		
		for i, v: any in ThisSpark.SlotTable do
			if not v.Destroyed then
				slotsInUse += 1
			else
				ThisSpark.SlotTable[i] = nil --Removes reference to prevent memory leak
			end
		end
		
		ThisSpark.SparksN = slotsInUse
	end
end)

return LightningSparks]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004385</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXBE6E286BB5074C95ADC050B674C1D0D9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">1af24096c87c37d507ec96ca00005f8a</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_LightningExplosion</string>
								<string name="ScriptGuid">{A0BE7F07-C23B-433F-B335-8D84BF8B611E}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--!native
--Properties do not update in realtime here
--i.e. You can't change explosion properties at any time beyond the initial function execution
local LightningBolt = require("./_LightningBolt")
local LightningSparks = require("./_LightningSparks")
local rng = Random.new()

local function RandomVectorOffsetBetween(vector: Vector3, minAngle: number, maxAngle: number): Vector3 -- returns uniformly-distributed random unit vector no more than maxAngle radians away from v and no less than minAngle radians
	return (
		CFrame.new(Vector3.zero, vector)
		* CFrame.Angles(0, 0, rng:NextNumber(0, 2*math.pi))
		* CFrame.Angles(math.acos(rng:NextNumber(math.cos(maxAngle), math.cos(minAngle))), 0, 0)
	).LookVector
end

local particles = {
	ExplosionBrightspot = script:WaitForChild("ExplosionBrightspot"):Clone(),
	GlareEmitter = script:WaitForChild("GlareEmitter"):Clone(),
	PlasmaEmitter = script:WaitForChild("PlasmaEmitter"):Clone()
}
local ActiveExplosions = {}

local LightningExplosion = {}
LightningExplosion.__type = "LightningExplosion"
LightningExplosion.__index = LightningExplosion

export type LightningExplosion = typeof(setmetatable({} :: {
	Size: number,
	NumBolts: number,
	BoltPartCount: number,
	Color: (Color3 | ColorSequence),
	BoltColor: (Color3 | ColorSequence),
	UpVector: Vector3,
	Bolts: {LightningBolt.LightningBolt},
	Attachment: Attachment,
	Part: Part,
	StartT: number,
}, LightningExplosion))

local function newExplosionBolt(Explosion: LightningExplosion)
	local A1, A2 = {}, {}

	A1.WorldPosition, A1.WorldAxis = Explosion.Attachment.WorldPosition, RandomVectorOffsetBetween(Explosion.UpVector, math.rad(65), math.rad(80))
	A2.WorldPosition, A2.WorldAxis = Explosion.Attachment.WorldPosition + A1.WorldAxis*rng:NextNumber(20, 40)*1.4*Explosion.Size, RandomVectorOffsetBetween(-Explosion.UpVector, math.rad(70), math.rad(110))
	--local curve0, curve1 = rng:NextNumber(0, 10)*size, rng:NextNumber(0, 10)*size
	local NewBolt = LightningBolt.new(A1, A2, Explosion.BoltPartCount)
	NewBolt.AnimationSpeed = 0
	NewBolt.Thickness = 1 --*size
	NewBolt.Color = Explosion.BoltColor
	NewBolt.PulseLength = 0.8
	NewBolt.ColorOffsetSpeed = 20
	NewBolt.Frequency = 2
	NewBolt.MinRadius, NewBolt.MaxRadius = 0, 4*Explosion.Size
	NewBolt.FadeLength = 0.4
	NewBolt.PulseSpeed = 5
	NewBolt.MinThicknessMultiplier, NewBolt.MaxThicknessMultiplier = 0.7, 1

	local NewSparks = LightningSparks.new(NewBolt, 5)
	NewSparks.MinDistance, NewSparks.MaxDistance = 7.5, 10
	NewBolt.Velocity = (A2.WorldPosition - A1.WorldPosition).Unit*0.1*Explosion.Size
	--NewBolt.v0, NewBolt.v1 = rng:NextNumber(0, 5)*size, rng:NextNumber(0, 5)*size

	table.insert(Explosion.Bolts, NewBolt)
end

local expPart = Instance.new("Part")
expPart.Name = "LightningExplosion"
expPart.Anchored = true
expPart.CanCollide = false
expPart.Locked = true
expPart.CastShadow = false
expPart.Transparency = 1
expPart.Size = Vector3.one * 0.001
expPart.Parent = script

function LightningExplosion.new(Position: Vector3, Size: number?, NumBolts: number?, BoltPartCount: number?, Color: (Color3 | ColorSequence)?, BoltColor: (Color3 | ColorSequence)?, UpVector: Vector3?)
	local self = {}
	local color: (Color3 | ColorSequence) = Color or ColorSequence.new(Color3.new(math.random(), math.random(), math.random()), Color3.new(math.random(), math.random(), math.random()))
	self.Size = Size and math.clamp(Size, 0, 1) or 1 --Value between 0 and 1 (1 for largest)
	self.NumBolts = NumBolts or 14 --Number of lightning bolts shot out from explosion
	self.BoltPartCount = BoltPartCount or 10
	self.Color = color --Can be a Color3 or ColorSequence
	self.BoltColor = BoltColor or (if typeof(color)=="Color3" then color else color.Keypoints[1].Value:Lerp(color.Keypoints[2].Value, 0.5)) --Can be a Color3 or ColorSequence
	self.UpVector = UpVector or Vector3.yAxis --Can be used to "rotate" the explosion
	
	local parent = workspace.CurrentCamera
	local size = math.clamp(self.Size, 0, 1)
	local color = self.Color
	
	local part = expPart:Clone()
	local attach = Instance.new("Attachment", part)
	part.Name = "LightningExplosion"
	part.Anchored = true
	part.CanCollide = false
	part.Locked = true
	part.CastShadow = false
	part.Transparency = 1
	part.Size = Vector3.one * 0.001
	part.CFrame = CFrame.new(Position + (Vector3.yAxis*0.5), Position + (Vector3.yAxis*0.5) + self.UpVector)*CFrame.new(Vector3.zero, Vector3.yAxis):Inverse()
	part.Parent = parent
	
	attach.CFrame = CFrame.identity
	attach.Parent = part
	
	self.Bolts = {}
	self.Attachment = attach
	self.Part = part
	self.StartT = workspace.DistributedGameTime
	self.RefIndex = #ActiveExplosions + 1

	setmetatable(self, LightningExplosion)
	
	local partEmit1 = particles.ExplosionBrightspot:Clone()
	local partEmit2 = particles.GlareEmitter:Clone()
	local partEmit3 = particles.PlasmaEmitter:Clone()
	
	partEmit2.Size = NumberSequence.new(30*size)
	partEmit3.Size = NumberSequence.new(18*size)
	partEmit3.Speed = NumberRange.new(100*size)
	
	partEmit1.Parent = attach
	partEmit2.Parent = attach
	partEmit3.Parent = attach
	
	if typeof(color) == "Color3" then
		partEmit2.Color, partEmit3.Color = ColorSequence.new(color), ColorSequence.new(color)
		local cH, cS, cV = color:ToHSV()
		partEmit1.Color = ColorSequence.new(Color3.fromHSV(cH, 0.5, cV))
	else --ColorSequence
		partEmit2.Color, partEmit3.Color = color, color
		local keypoints = color.Keypoints 
		for i = 1, #keypoints do
			local cH, cS, cV = keypoints[i].Value:ToHSV()
			keypoints[i] = ColorSequenceKeypoint.new(keypoints[i].Time, Color3.fromHSV(cH, 0.5, cV))
		end
		partEmit1.Color = ColorSequence.new(keypoints)
	end
	
	partEmit1.Enabled, partEmit2.Enabled, partEmit3.Enabled = true, true, true
	
	for _ = 1, self.NumBolts do
		task.spawn(newExplosionBolt, self)
	end

	ActiveExplosions[self.RefIndex] = self
	return self
end

local changeHandlers: {[string]: (LightningExplosion, any, any) -> ()} = {
	["Size"] = function(Explosion, oldValue, newValue)
		newValue = tonumber(newValue)
		if not newValue then return end
		if math.clamp(newValue, 0, 1) ~= newValue then
			newValue = math.clamp(newValue, 0, 1)
			Explosion.Size = newValue
			return
		end
		for _, NewBolt in Explosion.Bolts do
			NewBolt.MaxRadius = 4 * newValue
			local A1 = NewBolt.Attachment0
			local A2 = NewBolt.Attachment1 :: Attachment
			A2.WorldPosition = (A2.WorldPosition / oldValue) * newValue
		end
		
		local partEmit2 = Explosion.Attachment:FindFirstChild("GlareEmitter")
		local partEmit3 = Explosion.Attachment:FindFirstChild("PlasmaEmitter")
		if partEmit2 and partEmit2:IsA("ParticleEmitter") then partEmit2.Size = NumberSequence.new(30*newValue) end
		if partEmit3 and partEmit3:IsA("ParticleEmitter") then
			partEmit3.Size = NumberSequence.new(18*newValue)
			partEmit3.Speed = NumberRange.new(100*newValue)
		end
	end,
	
	["NumBolts"] = function(Explosion, oldValue, newValue)
		newValue = tonumber(newValue)
		if not newValue or math.round(newValue - oldValue)==0 then return end
		local diff = math.round(newValue - oldValue)
		if diff < 0 then diff = -diff end
		if math.round(newValue) == 0 then
			for _, v in Explosion.Bolts do
				v:Destroy()
			end
			table.clear(Explosion.Bolts)
		end
		if newValue > oldValue then
			for _ = 1, diff do
				task.spawn(newExplosionBolt, Explosion)
			end
		else
			local boltcount = #Explosion.Bolts
			for i = 0, diff-1 do
				local ind = boltcount - i
				Explosion.Bolts[ind]:Destroy()
				table.remove(Explosion.Bolts, ind)
			end
		end
	end,
	
	["BoltColor"] = function(Explosion, oldValue, newValue)
		if typeof(newValue)~="Color3" and typeof(newValue)~="ColorSequence" then return end
		for _, v in Explosion.Bolts do
			v.Color = newValue
		end
	end,
	
	["Color"] = function(Explosion, oldValue, newValue)
		local partEmit1 = Explosion.Attachment:FindFirstChild("ExplosionBrightspot")
		local partEmit2 = Explosion.Attachment:FindFirstChild("GlareEmitter"):Clone()
		local partEmit3 = Explosion.Attachment:FindFirstChild("PlasmaEmitter"):Clone()
		
		if typeof(newValue) == "Color3" then
			local sequence = ColorSequence.new(newValue)
			if partEmit2 and partEmit2:IsA("ParticleEmitter") then partEmit2.Color = sequence end
			if partEmit3 and partEmit3:IsA("ParticleEmitter") then partEmit3.Color = sequence end
			local cH, cS, cV = newValue:ToHSV()
			if partEmit1 and partEmit1:IsA("ParticleEmitter") then partEmit1.Color = ColorSequence.new(Color3.fromHSV(cH, 0.5, cV)) end
		else -- ColorSequence
			if partEmit2 and partEmit2:IsA("ParticleEmitter") then partEmit2.Color = newValue end
			if partEmit3 and partEmit3:IsA("ParticleEmitter") then partEmit3.Color = newValue end
			local keypoints = newValue.Keypoints 
			for i = 1, #keypoints do
				local cH, cS, cV = keypoints[i].Value:ToHSV()
				keypoints[i] = ColorSequenceKeypoint.new(keypoints[i].Time, Color3.fromHSV(cH, 0.5, cV))
			end
			if partEmit1 and partEmit1:IsA("ParticleEmitter") then partEmit1.Color = ColorSequence.new(keypoints) end
		end
	end,
}

function LightningExplosion:__newindex(index, value)
	if getmetatable(self)~=LightningExplosion or value==nil then return end
	if changeHandlers[index] then
		local oldValue = rawget(self :: any, index) -- dies from cringe
		rawset(self :: any, index, value) -- aughhhhhh
		task.spawn(changeHandlers[index] :: any, self, oldValue, value)
	end
end

function LightningExplosion:Destroy()
	ActiveExplosions[self.RefIndex] = nil
	pcall(game.Destroy, self.Part) -- ye this is a thing you can do
	
	table.clear(self.Bolts)
end

setmetatable(ActiveExplosions, {__newindex = function(self, index, value)
	if type(value)=="table" and getmetatable(value)~=nil and getmetatable(value).__index == LightningExplosion then
		task.delay(0.2, function()
			for _, v in value.Attachment:GetDescendants() do
				if not v:IsA("ParticleEmitter") then continue end
				v.Enabled = false
			end
			task.wait(0.5)
			value:Destroy()
		end)
	end
end,})

return LightningExplosion]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004386</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX94B88CA526A1482DAB82B4BA2BD7DD2A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">7deed65f364e39630743c3f00000ff35</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_ParallaxWindows</string>
							<string name="ScriptGuid">{C8530D76-6D72-48D5-9A98-CE216F005498}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--[[
	A client-side parallax corrected image projector (what a weird name)
	Made by Fake_Bobcat (youtube.com/@Bumcat or @bumcat1 on Discord)

	HOW TO USE:
	As this is a client-side only effect, the module must be called from a local script or a script using the client run context
	To apply the effect to a part, it must be a BasePart
	
	1. To set the module up, call [var] = [module].new() in a local script.
	2. For any face you want to apply the effect to, use [var]:AddFrame(part, normalEnum, UIElements). UIElements should be a list of UI
	   elements that will get parented to the frame and have the parallax effect applied, they need to be sized and positioned using scale only
	   You can also remove a face using :RemoveFace(), and AddFrame returns the frame instance so you can access the UIElements you placed inside,
	   or just delete it, which will also delete the frame.
	3. Use :Step() to update the effect on all added parts. It's recommended to put this in RunService.RenderStepped.
	   as an argument, the module will automatically use the local player's camera position
	4. Use :UpdateSettings(GuisettingsTable, FramesettingsTable) to apply your own settings at any time. The default settings are listed below.
	   Note: If you want to reset the settings to default, call :UpdateSettings() with no arguments
	5. If you want to get rid of the effect and clean all surfaces, use :Clear()
]]

local ParallaxWindows = {}
ParallaxWindows.__index = ParallaxWindows

-- default settings, can be overriden with custom settings by using :UpdateFaceSettings() and :UpdateFrameSettings()
local DEFAULT_GUI_SETTINGS = {
	["MaxFramerate"] = 60, -- Max Frame rate that the GUI will run at
	["MinFramerate"] = 10, -- Min Frame rate that the GUI will run at (for when the GUI is out of Update Distance)
	-- Frame rates will automatically adjust between these two distances below
	["MaxUpdateDistance"] = 10, -- Distance that the GUI will cap at the max frame rate
	["MinUpdateDistance"] = 200, -- Distance that the GUI will cap at the min frame rate
	["LazyCheckingModifier"] = 10, -- If a frame is not visible, this modifier is applied so that the module checks less frequently
	-- SurfaceGui settings
	["ZOffset"] = 0,
	["AlwaysOnTop"] = false,
	["Brightness"] = 1,
	["LightInfluence"] = 1,
	["MaxDistance"] = 1000,
	["PixelsPerStud"] = 100,
	["SizingMode"] = Enum.SurfaceGuiSizingMode.PixelsPerStud,
}

local DEFAULT_FRAME_SETTINGS = {
	["UpdateRange"] = 100, -- Distance at which the Image is no longer Updated
	["ZIndex"] = 0, -- ZIndex of the frame
	["Image"] = "rbxassetid://18838056070", -- ImageId
	["Rotation"] = 0, -- rotation of the image
	["ImageTransparency"] = 0, -- Transparency of the image when in range
	["BackgroundTransparency"] = 1, -- Transparency of the image background when in range
	["ImageColor3"] = Color3.fromRGB(255, 255, 255), -- Color of the image
	["BackgroundColor3"] = Color3.fromRGB(255, 255, 255), -- Color of the image background
	["ResampleMode"] = Enum.ResamplerMode.Default, -- Resampling mode
	["ScaleType"] = Enum.ScaleType.Stretch, -- Scaling type
	["TileSize"] = UDim2.new(1,0,1,0), -- Tile Size
	["Interactable"] = false, -- Whether or not the frame is interactable
	["Active"] = false, -- Whether or not the frame is active
	["ImageSize"] = Vector3.new(8, 8, 0), -- Size of the image in studs per tile, dont use Z value, just using V3 cause its more efficient than V2
	["PosOffset"] = Vector3.new(), -- Positional offset for parallax from the face
	["ExtraOffset"] = UDim2.new(), -- Extra positional offset added onto final position
}

-- sets up folders where SurfaceParts and SurfaceGuis will be stored
local function SetUpFolders(obj: ParallaxWindow, isparallel: boolean?): boolean?
	if obj.GuiFolder ~= nil then return end
	-- search playergui for already existing folder, if none found, create a new one
	local folder = game.Players.LocalPlayer.PlayerGui:FindFirstChild("ParallaxWindows_SurfaceGuis")
	if folder ~= nil then
		obj.GuiFolder = folder
		return
	elseif not isparallel then
		obj.GuiFolder = Instance.new("Folder")
		obj.GuiFolder.Name = "ParallaxWindows_SurfaceGuis"
		if game:GetService("RunService"):IsRunning() then
			obj.GuiFolder.Parent = game.Players.LocalPlayer.PlayerGui
		else
			obj.GuiFolder.Parent = game.StarterGui --for when testing effect with StudioExecutor
		end
		return
	end
	return true
end

type FrameSettings = typeof(DEFAULT_FRAME_SETTINGS)
type GuiSettings = typeof(DEFAULT_GUI_SETTINGS)
type self = {
	Default_GuiSettings: { [any]: any },
	Default_FrameSettings: { [any]: any },
	GuiSettings: { [any]: any },
	FrameSettings: { [any]: any },
	TargetParts: { [any]: any },
	GuiFolder: any,
	LastStep: number,
	MaxUpdates: number
}
export type ParallaxWindow = typeof(setmetatable({} :: self, ParallaxWindows))

function ParallaxWindows.new(): ParallaxWindow
	local obj = {
		Default_GuiSettings = {},
		Default_FrameSettings = {},
		GuiSettings = {},
		FrameSettings = {},
		TargetParts = {},
		GuiFolder = nil,
		LastStep = os.clock(),
		MaxUpdates = 100,
	}
	setmetatable(obj, ParallaxWindows)
	obj.Default_GuiSettings = table.clone(DEFAULT_GUI_SETTINGS)
	obj.Default_FrameSettings = table.clone(DEFAULT_FRAME_SETTINGS)
	SetUpFolders(obj)

	return obj
end

-- updates settings. 'settingsTable' argument should have the same format as DEFAULT_SETTINGS. Leave arguments empty to reset settings to default
function ParallaxWindows:UpdateSettings(guiSettings: GuiSettings, frameSettings: FrameSettings)
	if self.Default_GuiSettings == nil then
		self.Default_GuiSettings = {}
	end
	if self.Default_FrameSettings == nil then
		self.Default_FrameSettings = {}
	end

	if guiSettings then
		assert(type(guiSettings) == "table", "Expected table as parameter")

		for i,v in DEFAULT_GUI_SETTINGS do
			if guiSettings[i] ~= nil then
				self.Default_GuiSettings[i] = guiSettings[i]
			elseif self.Default_GuiSettings[i] == nil then
				self.Default_GuiSettings[i] = v
			end
		end
	end

	if frameSettings then
		assert(type(frameSettings) == "table", "Expected table as parameter")

		for i,v in DEFAULT_FRAME_SETTINGS do
			if frameSettings[i] ~= nil then
				self.Default_FrameSettings[i] = frameSettings[i]
			elseif self.Default_FrameSettings[i] == nil then
				self.Default_FrameSettings[i] = v
			end
		end
	end
end

-- updates individual settings per gui (overrides global settings). Supports all default settings
function ParallaxWindows:UpdateFaceSettings(targetPart: BasePart, normal:Enum.NormalId?, settingsTable)
	local target = self.TargetParts[targetPart][normal]
	if not target then return end
	local targetGui = target.SurfaceGui
	if not targetGui then return end
	if self.GuiSettings[targetGui] == nil then
		self.GuiSettings[targetGui] = {}
	end

	if settingsTable == nil then 
		self.GuiSettings[targetGui] = nil
		return
	end
	assert(type(settingsTable) == "table", "Expected table as parameter")

	for i,v in settingsTable do
		self.GuiSettings[targetGui][i] = v
	end
end

-- updates individual settings per frame (overrides global settings). Supports all default settings
function ParallaxWindows:UpdateFrameSettings(targetFrame: Frame, settingsTable)
	if self.FrameSettings[targetFrame] == nil then
		self.FrameSettings[targetFrame] = {}
	end

	if settingsTable == nil then
		self.FrameSettings[targetFrame] = nil
		return
	end
	assert(type(settingsTable) == "table", "Expected table as parameter")

	for i,v in settingsTable do
		self.FrameSettings[targetFrame][i] = v
	end
end

---------------------- PARALLAX FUNCTIONS ----------------------

-- gets the offset of a normal from the targetPart's origin
local function GetNormalOffset(normal: Enum.NormalId, targetPart: BasePart)
	local offset = Vector3.new()
	local rotation = CFrame.new()

	if normal == Enum.NormalId.Front then
		offset = (targetPart.Size.Z / 2) * targetPart.CFrame.LookVector
		rotation = CFrame.Angles(0, 0, 0)
	elseif normal == Enum.NormalId.Back then
		offset = (targetPart.Size.Z / 2) * -targetPart.CFrame.LookVector
		rotation = CFrame.Angles(0, math.rad(180), 0)
	elseif normal == Enum.NormalId.Left then
		offset = (targetPart.Size.X / 2) * -targetPart.CFrame.RightVector
		rotation = CFrame.Angles(0, math.rad(90), 0)
	elseif normal == Enum.NormalId.Right then
		offset = (targetPart.Size.X / 2) * targetPart.CFrame.RightVector
		rotation = CFrame.Angles(0, math.rad(-90), 0)
	elseif normal == Enum.NormalId.Top then
		offset = (targetPart.Size.Y / 2) * targetPart.CFrame.UpVector
		rotation = CFrame.Angles(math.rad(90), 0, 0)
	elseif normal == Enum.NormalId.Bottom then
		offset = (targetPart.Size.Y / 2) * -targetPart.CFrame.UpVector
		rotation = CFrame.Angles(math.rad(-90), 0, 0)
	end

	return offset, rotation
end

-- Calculate the point at which a vector intersects a plane
function rayToPlaneIntersection(rayVector: Vector3, rayPoint: Vector3, planeNormal: Vector3, planePoint: Vector3)
	local diff = rayPoint - planePoint
	local prod1 = diff:Dot(planeNormal)
	local prod2 = rayVector:Dot(planeNormal)
	local prod3 = prod1/prod2
	return rayPoint - (rayVector*prod3)
end

-- calculate the stud offsets and positions for parallax
function calcParallax(camPos: Vector3, wallCF: CFrame, posOffset: Vector3)

	local wallPos = wallCF.Position

	if math.abs(posOffset.X) < 0.05 then -- For when the Offset is at the wall, lessening the need to do calculations
		return {
			["horOffset"] = -posOffset.Z,
			["verOffset"] = -posOffset.Y,
			["parimgPoint"] = Vector3.new(),  -- Empty as this is just used to calculate size, but since it's against the wall it'll always be full size
			["imgPoint"] = Vector3.new(),
			["camPos"] = camPos,
		}
	end

	local parPoint = wallPos+(wallCF.LookVector*posOffset.X)+(wallCF.UpVector*posOffset.Y)+(wallCF.RightVector*posOffset.Z)

	local imgVector = CFrame.lookAt(camPos,parPoint).LookVector

	local imgPoint = rayToPlaneIntersection(imgVector,camPos,wallCF.LookVector,wallPos)
	local parimgPoint = rayToPlaneIntersection(imgVector,camPos,wallCF.LookVector,parPoint)

	local imgdist = (imgPoint-wallPos).Magnitude
	local hordist = rayToPlaneIntersection(wallCF.UpVector*-imgdist,imgPoint,wallCF.UpVector,wallPos)
	local horOffset = (wallPos-hordist).Magnitude

	local isRight = wallCF.RightVector:Dot(CFrame.lookAt(wallPos,hordist).LookVector) -- If the horizontal point is to the right of the camera

	if isRight > 0 then horOffset *= -1 end

	local verpoint = rayToPlaneIntersection(wallCF.RightVector*-imgdist,imgPoint,wallCF.RightVector,wallPos)
	local verOffset = (wallPos-verpoint).Magnitude

	local isDown = wallCF.UpVector:Dot(CFrame.lookAt(wallPos,verpoint).LookVector) -- If the vertical point is under the camera

	if isDown > 0 then verOffset *= -1 end

	-- horizontal & vertical stud offsets, the position of what the parallax is trying to copy, the position of the frame on the part
	return {
		["horOffset"] = horOffset,
		["verOffset"] = verOffset,
		["parimgPoint"] = parimgPoint, 
		["imgPoint"] = imgPoint,
		["camPos"] = camPos,
	}
end

function getSizeAndPosition(parCalculations: any, surfaceInfo, frameSettings, surfaceGui : SurfaceGui): (UDim2, UDim2)
	local pps = surfaceGui.PixelsPerStud
	-- Get the distance from the camera to the wall and parallax position
	local wallDist, pointDist = (parCalculations.camPos-parCalculations.imgPoint).Magnitude, (parCalculations.camPos-parCalculations.parimgPoint).Magnitude

	local ImgSize = frameSettings.ImageSize :: Vector2
	local absSize = Vector2.new(ImgSize.X*pps,ImgSize.Y*pps) -- Absolute Pixel Size of the frame in pixels (studs to pixels)
	local sizeAmplifier = (wallDist/pointDist)

	local Position
	if surfaceInfo.SurfaceNormal == Enum.NormalId.Top then
		Position = UDim2.new(0.5,parCalculations.verOffset*pps,0.5,-parCalculations.horOffset*pps)
	elseif surfaceInfo.SurfaceNormal == Enum.NormalId.Bottom then
		Position = UDim2.new(0.5,-parCalculations.verOffset*pps,0.5,parCalculations.horOffset*pps)
	else
		Position = UDim2.new(0.5,parCalculations.horOffset*pps,0.5,parCalculations.verOffset*pps)
	end
	local Size = UDim2.new(0,absSize.X*sizeAmplifier,0,absSize.Y*sizeAmplifier)

	return Position, Size -- Size & Position of the parallax corrected image/frame
end

-- Calculates the size and position of the frame using all the other functions
function getParallax(surfaceInfo, frameSettings, camPos: Vector3, wallCF, posOffset: Vector3): (UDim2?, UDim2?)
	if not posOffset or not surfaceInfo then return end
	if not camPos then
		camPos = game.Workspace.CurrentCamera.CFrame.Position
	end

	local targetPart = surfaceInfo.TargetPart
	local normal = surfaceInfo.SurfaceNormal

	if not wallCF then -- If wallCF not calculated then get it
		local offset, rotation = GetNormalOffset(surfaceInfo.SurfaceNormal, targetPart)
		wallCF = targetPart.CFrame * CFrame.new(offset) * rotation
	end

	local parCalculations = calcParallax(camPos,wallCF,posOffset) -- Calculate Parallax logic
	local Position, Size = getSizeAndPosition(parCalculations, surfaceInfo, frameSettings, surfaceInfo.SurfaceGui) -- Transform the logic into udim2 position and size

	return Position, Size
end

---------------------- ADD/REMOVE PARTS ----------------------

-- sets up surface part and SurfaceGui for a targeted face
function SetUpSurface(targetPart : BasePart, normal: Enum.NormalId, obj)
	local surfaceGui = Instance.new("SurfaceGui")
	surfaceGui.ResetOnSpawn = false
	surfaceGui.ClipsDescendants = true
	surfaceGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	surfaceGui.Parent = obj.GuiFolder
	surfaceGui.Adornee = targetPart
	surfaceGui.Face = normal
	surfaceGui.SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
	surfaceGui.PixelsPerStud = 100
	surfaceGui.Enabled = true

	local canvasGroup = Instance.new("CanvasGroup")
	canvasGroup.BackgroundTransparency = 1
	canvasGroup.Size = UDim2.new(1,0,1,0)
	canvasGroup.Parent = surfaceGui

	return surfaceGui
end

function SetUpFrame(targetGui: SurfaceGui)
	local scaleFrame = Instance.new("ImageLabel") -- Actually an imagelabel but lets not talk about that
	scaleFrame.Size = UDim2.new(1, 0, 1, 0)
	scaleFrame.AnchorPoint = Vector2.new(.5, .5)
	scaleFrame.Position = UDim2.new(.5, 0, .5, 0)
	scaleFrame.BackgroundTransparency = 1
	scaleFrame.Name = "ScaleFrame"

	local canvasGroup = targetGui:FindFirstChildWhichIsA("CanvasGroup")
	scaleFrame.Parent = canvasGroup or targetGui

	return scaleFrame
end

-- adds a part's face to the target list. Used for adding the surface gui, but not the frame
function ParallaxWindows:AddFace(targetPart: BasePart, normal: Enum.NormalId?) 
	if normal == nil then
		normal = Enum.NormalId.Front
	end
	if self.TargetParts[targetPart] == nil then
		self.TargetParts[targetPart] = {}
	end
	local surfaceGui = SetUpSurface(targetPart, normal :: Enum.NormalId, self)
	self.GuiSettings[surfaceGui] = table.clone(self.Default_GuiSettings)
	local info = {
		["SurfaceNormal"] = normal,
		["SurfaceGui"] = surfaceGui,
		["TargetPart"] = targetPart,
		["Frames"] = {},
		["LastUpdate"] = 0,
		["Visible"] = false,
		["Framerate"] = 1, -- Current frame rate
	}
	if self.TargetParts[targetPart][normal] == nil then
		self.TargetParts[targetPart][normal] = {}
	end
	self.TargetParts[targetPart][normal] = info

	return surfaceGui
end

-- adds a new frame to the target list (can have multiple frames on the same part). 'targetPart' should be a BasePart and 'normal' should be an Enum.NormalId
function ParallaxWindows:AddFrame(targetPart: BasePart, normal: Enum.NormalId?, UIElements)
	if normal == nil then
		normal = Enum.NormalId.Front
	end
	if self.TargetParts[targetPart] == nil then
		self.TargetParts[targetPart] = {}
	end
	local info = self.TargetParts[targetPart][normal]
	if not info then
		self:AddFace(targetPart, normal)
		info = self.TargetParts[targetPart][normal]
	end
	local surfaceGui = info.SurfaceGui
	local frame = SetUpFrame(surfaceGui)

	self.FrameSettings[frame] = table.clone(self.Default_FrameSettings)

	if UIElements then
		for _,v in UIElements do -- Clone all UIElements to the frame
			v.Parent = frame
		end
	end

	local info = {
		["SurfaceNormal"] = normal,
		["SurfaceGui"] = surfaceGui,
		["TargetPart"] = targetPart,
		["Frame"] = frame,
	}
	table.insert(self.TargetParts[targetPart][normal].Frames,info)

	return frame -- return the frame so they can edit it if they want to
end

-- removes a face from the target list and clears the effect from workspace/gui
function ParallaxWindows:RemoveFace(targetPart: BasePart, normal: Enum.NormalId?)
	if normal == nil then
		normal = Enum.NormalId.Front
	end
	if self.TargetParts[targetPart] == nil then return end
	local info = self.TargetParts[targetPart][normal]
	if info == nil then return end
	self.GuiSettings[info.SurfaceGui] = nil
	info.SurfaceGui:Destroy()
	self.TargetParts[targetPart][normal] = nil
	if next(self.TargetParts[targetPart]) == nil then -- dictionary is empty
		self.TargetParts[targetPart] = nil
	end
end

-- clears all ParallaxWindows from the workspace 
function ParallaxWindows:Clear()
	for _,targetParts in self.TargetParts do
		for normal, info in targetParts do
			info.SurfaceGui:Destroy()
		end
	end

	table.clear(self.GuiSettings)
	table.clear(self.FrameSettings)

	table.clear(self.TargetParts)
end

---------------------- CULLING ----------------------

function GetVectorFromNormal(CF: CFrame, NormalID: Enum.NormalId)
	if NormalID == Enum.NormalId.Front then
		return CF.LookVector
	elseif NormalID == Enum.NormalId.Right then
		return CF.RightVector
	elseif NormalID == Enum.NormalId.Top then
		return CF.UpVector
	elseif NormalID == Enum.NormalId.Back then
		return -CF.LookVector
	elseif NormalID == Enum.NormalId.Left then
		return -CF.RightVector
	elseif NormalID == Enum.NormalId.Bottom then
		return -CF.UpVector
	end
	return Vector3.zero
end

function GetCorners(Part : BasePart, wallpos : Vector3, normal : Enum.NormalId)
	local size = Part.Size
	local cf = Part.CFrame
	local u, r, l = cf.UpVector, cf.RightVector, cf.LookVector
	if normal == Enum.NormalId.Front or normal == Enum.NormalId.Back then
		return {
			wallpos,
			wallpos-u*size.Y/2-r*size.X/2,
			wallpos-u*size.Y/2+r*size.X/2,
			wallpos+u*size.Y/2-r*size.X/2,
			wallpos+u*size.Y/2+r*size.X/2,
		}
	elseif normal == Enum.NormalId.Right or normal == Enum.NormalId.Left then
		return {
			wallpos,
			wallpos-u*size.Y/2-l*size.Z/2,
			wallpos-u*size.Y/2+l*size.Z/2,
			wallpos+u*size.Y/2-l*size.Z/2,
			wallpos+u*size.Y/2+l*size.Z/2,
		}
	elseif normal == Enum.NormalId.Top or normal == Enum.NormalId.Bottom then
		return {
			wallpos,
			wallpos-r*size.X/2-l*size.Z/2,
			wallpos-r*size.X/2+l*size.Z/2,
			wallpos+r*size.X/2-l*size.Z/2,
			wallpos+r*size.X/2+l*size.Z/2,
		}
	end
	return {}
end

function CanSee(Camera : Camera, Part : BasePart, wallCF : CFrame, normal : Enum.NormalId)
	-- Can the wall see the player?
	local Vector = GetVectorFromNormal(Part.CFrame,normal)

	if Vector:Dot(CFrame.lookAt(wallCF.Position,Camera.CFrame.Position).LookVector) <= 0 then
		return false
	end

	-- If the player can see any one of the corners or the centre it is considered in view
	local corners = GetCorners(Part, wallCF.Position, normal)

	for _,corner in corners do
		local _,cansee = Camera:WorldToScreenPoint(corner)
		if cansee then
			return true
		end
	end
	return false
end

---------------------- STEP ----------------------

-- main logic of the module, called every interval. Put in RunService.RenderStepped for smooth interpolation
function ParallaxWindows:Step()
	SetUpFolders(self) -- Run every step in case folder was deleted

	local dt = os.clock()-self.LastStep -- Calculate Delta time
	self.LastStep = os.clock()

	local Camera = game.Workspace.CurrentCamera
	local camCF = Camera.CFrame
	local camPos = camCF.Position

	local Default_GuiSettings = self.Default_GuiSettings -- Default Settings
	local Default_FrameSettings = self.Default_FrameSettings

	for frame,frameSetting in self.FrameSettings do -- Clean up deleted frames
		if not frame:IsDescendantOf(self.GuiFolder) then
			self.FrameSettings[frame] = nil
		end
	end

	local MaxUpdates, TotalUpdates = self.MaxUpdates, 0 -- Cap the number of surfaces that can be updated every step

	local ToUpdate = {} -- A list of surfaces to update

	for targetPart, guis in self.TargetParts do -- Get all the surfaceGuis
		if not targetPart:IsDescendantOf(game) then
			for _, info in guis do
				self.GuiSettings[info.SurfaceGui] = nil
				info.SurfaceGui:Destroy()
			end
			self.TargetParts[targetPart] = nil
		end
		for _, info in guis do

			local surfaceGui = info.SurfaceGui

			if not surfaceGui then continue end

			-- Get the cframe of the face
			local offset, rotation = GetNormalOffset(info.SurfaceNormal, targetPart)
			local wallCF = (targetPart.CFrame + offset) * rotation
			local normal = info.SurfaceNormal

			-- Is the surface in view of the player and is the face facing the player
			local canSee = CanSee(Camera,targetPart,wallCF,normal) or false

			info.Visible = canSee

			if not canSee then continue end -- If not in view just skip

			-- set unique settings for the face if applicable
			local newTable = {}
			if self.GuiSettings[surfaceGui] ~= nil then
				for i,v in Default_GuiSettings do
					newTable[i] = self.GuiSettings[surfaceGui][i] or v
				end
			end
			local GuiSettings = newTable
			if next(newTable) ~= nil then
				GuiSettings = newTable
			end

			-- Distance from wall to camera
			local Dist = (wallCF.Position-camPos).Magnitude

			if (Dist > GuiSettings.MinUpdateDistance and GuiSettings.MinFramerate <= 0) or Dist > GuiSettings.MaxDistance then continue end -- Further than the GUI will render

			local Framerate = GuiSettings.MinFramerate + (GuiSettings.MaxFramerate - GuiSettings.MinFramerate) * math.clamp(1 - (Dist-GuiSettings.MaxUpdateDistance) / GuiSettings.MinUpdateDistance,0,1)

			if not info.Visible then
				Framerate /= GuiSettings.LazyCheckingModifier
			end

			local ratetime = 1/Framerate -- Calculate the needed delta time for the surface to be updated

			if GuiSettings.MaxFramerate < 0 then -- Uncap the frame rate
				ratetime = -1
			end

			--if info.LastUpdate < ratetime then -- Not time for this surface to update yet!
			--	continue
			--end

			info.LastUpdate += dt -- Time since the surface was updated in seconds

			table.insert(ToUpdate,{targetPart,info,GuiSettings,{offset,rotation :: any,wallCF,normal,Dist},ratetime})
		end
	end

	-- Sort the surfaces by last updated to the most recently updated, used so that when the max update limit is reached
	-- it will update the oldest ones so that all of the surfaces will get updated over time
	table.sort(ToUpdate,function(a,b)
		return a[2].LastUpdate/a[5] > b[2].LastUpdate/b[5]
	end)

	for _, myinfo in ToUpdate do -- Update all the surfaces
		local targetPart = myinfo[1]
		local info = myinfo[2]
		local GuiSettings = myinfo[3]

		if TotalUpdates >= MaxUpdates and MaxUpdates >= 0 then -- If number of surfaces updated exceeds the max then end the step
			break
		end

		local surfaceGui = info.SurfaceGui

		local offset, rotation, wallCF, normal, Dist = myinfo[4][1],myinfo[4][2],myinfo[4][3],myinfo[4][4],myinfo[4][5]

		info.LastUpdate = 0

		--local instanceSettings = {}
		--instanceSettings.ZOffset = GuiSettings.ZOffset
		--instanceSettings.AlwaysOnTop = GuiSettings.AlwaysOnTop
		--instanceSettings.Brightness = GuiSettings.Brightness
		--instanceSettings.LightInfluence = GuiSettings.LightInfluence
		--instanceSettings.MaxDistance = GuiSettings.MaxDistance
		--instanceSettings.PixelsPerStud = GuiSettings.PixelsPerStud
		--instanceSettings.SizingMode = GuiSettings.SizingMode

		---- declare main variables and set surfaceGui settings
		--for setting,value in instanceSettings do
		--	if surfaceGui[setting] ~= value then
		--		surfaceGui[setting] = value
		--	end
		--end
		surfaceGui.ZOffset = GuiSettings.ZOffset
		surfaceGui.AlwaysOnTop = GuiSettings.AlwaysOnTop
		surfaceGui.Brightness = GuiSettings.Brightness
		surfaceGui.LightInfluence = GuiSettings.LightInfluence
		surfaceGui.MaxDistance = GuiSettings.MaxDistance
		surfaceGui.PixelsPerStud = GuiSettings.PixelsPerStud
		surfaceGui.SizingMode = GuiSettings.SizingMode

		if (Dist > GuiSettings.MinUpdateDistance and GuiSettings.MinFramerate <= 0) or Dist > GuiSettings.MaxDistance then print("Die") continue end -- Further than the GUI will render

		TotalUpdates += 1

		for index, frameinfo in info.Frames do
			local frame = frameinfo.Frame

			if not frame or not frame:IsDescendantOf(self.GuiFolder) then -- Clean up deleted frames
				table.remove(info.Frames,index)
				continue
			end

			-- set unique settings for the frame if applicable
			local newTable = {}
			if self.FrameSettings[frame] ~= nil then
				for i,v in Default_FrameSettings do
					newTable[i] = self.FrameSettings[frame][i] or v
				end
			end
			local frameSettings = newTable
			if next(newTable) ~= nil then
				frameSettings = newTable
			end

			if frameSettings.UpdateRange < Dist then continue end -- Frame is outside of update distance

			-- set frame settings
			--local instanceSettings = {}
			--instanceSettings.ZIndex = frameSettings.ZIndex
			--instanceSettings.Image = frameSettings.Image
			--instanceSettings.Rotation = frameSettings.Rotation
			--instanceSettings.ImageTransparency = frameSettings.ImageTransparency
			--instanceSettings.BackgroundTransparency = frameSettings.BackgroundTransparency
			--instanceSettings.ImageColor3 = frameSettings.ImageColor3
			--instanceSettings.BackgroundColor3 = frameSettings.BackgroundColor3
			--instanceSettings.ResampleMode = frameSettings.ResampleMode
			--instanceSettings.ScaleType = frameSettings.ScaleType
			--instanceSettings.TileSize = frameSettings.TileSize
			--instanceSettings.Interactable = frameSettings.Interactable
			--instanceSettings.Active = frameSettings.Active

			--for setting,value in instanceSettings do
			--	if frame[setting] ~= value then
			--		frame[setting] = value
			--	end
			--end
			frame.ZIndex = frameSettings.ZIndex
			frame.Image = frameSettings.Image
			frame.Rotation = frameSettings.Rotation
			frame.ImageTransparency = frameSettings.ImageTransparency
			frame.BackgroundTransparency = frameSettings.BackgroundTransparency
			frame.ImageColor3 = frameSettings.ImageColor3
			frame.BackgroundColor3 = frameSettings.BackgroundColor3
			frame.ResampleMode = frameSettings.ResampleMode
			frame.ScaleType = frameSettings.ScaleType
			frame.TileSize = frameSettings.TileSize
			frame.Interactable = frameSettings.Interactable
			frame.Active = frameSettings.Active

			-- Get the parallax corrected size and position in udim2 for the frame
			local Position, Size = getParallax(info,frameSettings,camPos,wallCF,frameSettings.PosOffset)

			-- Apply the position and size
			frame.Position = Position + frameSettings.ExtraOffset or UDim2.new(0.5,0,0.5,0) + frameSettings.ExtraOffset
			frame.Size = Size or UDim2.new(1,0,1,0)
		end
	end
end

-- For parallel luau, for computing the step, but not applying changes
function ParallaxWindows:ComputeStep()
	local cancelStep = SetUpFolders(self, true) -- Run every step in case folder was deleted
	if cancelStep then return end -- No Folder exists, and you cannot write in parallel

	local updateData = {} -- Data to return to the executor for when the task is synchronised

	local dt = os.clock()-self.LastStep -- Calculate Delta time
	self.LastStep = os.clock()

	local Camera = game.Workspace.CurrentCamera
	local camCF = Camera.CFrame
	local camPos = camCF.Position

	local Default_GuiSettings = self.Default_GuiSettings -- Default Settings
	local Default_FrameSettings = self.Default_FrameSettings

	for frame,frameSetting in self.FrameSettings do -- Clean up deleted frames
		if not frame:IsDescendantOf(self.GuiFolder) then
			self.FrameSettings[frame] = nil
		end
	end

	local MaxUpdates, TotalUpdates = self.MaxUpdates, 0 -- Cap the number of surfaces that can be updated every step

	local ToUpdate = {} -- A list of surfaces to update

	for targetPart, guis in self.TargetParts do -- Get all the surfaceGuis
		if not targetPart:IsDescendantOf(game) then
			for _, info in guis do
				self.GuiSettings[info.SurfaceGui] = nil
				info.SurfaceGui:Destroy()
			end
			self.TargetParts[targetPart] = nil
		end
		for _, info in guis do

			local surfaceGui = info.SurfaceGui

			if not surfaceGui then continue end

			-- Get the cframe of the face
			local offset, rotation = GetNormalOffset(info.SurfaceNormal, targetPart)
			local wallCF = (targetPart.CFrame + offset) * rotation
			local normal = info.SurfaceNormal

			-- Is the surface in view of the player and is the face facing the player
			local canSee = CanSee(Camera,targetPart,wallCF,normal) or false

			info.Visible = canSee

			if not canSee then continue end -- If not in view just skip

			-- set unique settings for the face if applicable
			local newTable = {}
			if self.GuiSettings[surfaceGui] ~= nil then
				for i,v in Default_GuiSettings do
					newTable[i] = self.GuiSettings[surfaceGui][i] or v
				end
			end
			local GuiSettings = newTable
			if next(newTable) ~= nil then
				GuiSettings = newTable
			end

			-- Distance from wall to camera
			local Dist = (wallCF.Position-camPos).Magnitude

			if (Dist > GuiSettings.MinUpdateDistance and GuiSettings.MinFramerate <= 0) or Dist > GuiSettings.MaxDistance then continue end -- Further than the GUI will render

			local Framerate = GuiSettings.MinFramerate + (GuiSettings.MaxFramerate - GuiSettings.MinFramerate) * math.clamp(1 - (Dist-GuiSettings.MaxUpdateDistance) / GuiSettings.MinUpdateDistance,0,1)

			if not info.Visible then
				Framerate /= GuiSettings.LazyCheckingModifier
			end

			local ratetime = 1/Framerate -- Calculate the needed delta time for the surface to be updated

			if GuiSettings.MaxFramerate < 0 then -- Uncap the frame rate
				ratetime = -1
			end

			--if info.LastUpdate < ratetime then -- Not time for this surface to update yet!
			--	continue
			--end

			info.LastUpdate += dt -- Time since the surface was updated in seconds

			table.insert(ToUpdate,{targetPart,info,GuiSettings,{offset,rotation :: any,wallCF,normal,Dist},ratetime})
		end
	end

	-- Sort the surfaces by last updated to the most recently updated, used so that when the max update limit is reached
	-- it will update the oldest ones so that all of the surfaces will get updated over time
	table.sort(ToUpdate,function(a,b)
		return a[2].LastUpdate/a[5] > b[2].LastUpdate/b[5]
	end)

	for _, myinfo in ToUpdate do -- Update all the surfaces
		local targetPart = myinfo[1]
		local info = myinfo[2]
		local GuiSettings = myinfo[3]

		if TotalUpdates >= MaxUpdates and MaxUpdates >= 0 then -- If number of surfaces updated exceeds the max then end the step
			break
		end

		local surfaceGui = info.SurfaceGui

		local offset, rotation, wallCF, normal, Dist = myinfo[4][1],myinfo[4][2],myinfo[4][3],myinfo[4][4],myinfo[4][5]

		table.insert(updateData,{
			istype = "surface",
			surfaceGui = surfaceGui,
			GuiSettings = GuiSettings,
		})

		info.LastUpdate = 0

		if (Dist > GuiSettings.MinUpdateDistance and GuiSettings.MinFramerate <= 0) or Dist > GuiSettings.MaxDistance then continue end -- Further than the GUI will render

		TotalUpdates += 1

		for index, frameinfo in info.Frames do
			local frame = frameinfo.Frame

			if not frame or not frame:IsDescendantOf(self.GuiFolder) then -- Clean up deleted frames
				table.remove(info.Frames,index)
				continue
			end

			-- set unique settings for the frame if applicable
			local newTable = {}
			if self.FrameSettings[frame] ~= nil then
				for i,v in Default_FrameSettings do
					newTable[i] = self.FrameSettings[frame][i] or v
				end
			end
			local frameSettings = newTable
			if next(newTable) ~= nil then
				frameSettings = newTable
			end

			if frameSettings.UpdateRange < Dist then continue end -- Frame is outside of update distance

			-- Get the parallax corrected size and position in udim2 for the frame
			local Position, Size = getParallax(info,frameSettings,camPos,wallCF,frameSettings.PosOffset)

			-- Insert the position and size

			table.insert(updateData,{
				istype = "frame",
				frame = frame,
				Position = Position + frameSettings.ExtraOffset or UDim2.new(0.5,0,0.5,0) + frameSettings.ExtraOffset,
				Size = Size or UDim2.new(1,0,1,0),
				frameSettings = frameSettings,
			})
		end
	end

	return updateData -- Return computed data
end

-- For parallel luau, for applying the step after computing changes in parallel
function ParallaxWindows:ApplyStep(stepData)
	if stepData == nil or #stepData <= 0 then return end -- Nothing to Update
	SetUpFolders(self) -- Run every step in case folder was deleted

	local Default_GuiSettings = self.Default_GuiSettings -- Default Settings
	local Default_FrameSettings = self.Default_FrameSettings

	for index,data: any in stepData do
		if data.istype == "frame" then
			local frame = data.frame
			if not frame or not frame:IsDescendantOf(self.GuiFolder) then -- Ignore deleted frames
				continue
			end

			local frameSettings = data.frameSettings

			-- set frame settings
			frame.ZIndex = frameSettings.ZIndex
			frame.Image = frameSettings.Image
			frame.Rotation = frameSettings.Rotation
			frame.ImageTransparency = frameSettings.ImageTransparency
			frame.BackgroundTransparency = frameSettings.BackgroundTransparency
			frame.ImageColor3 = frameSettings.ImageColor3
			frame.BackgroundColor3 = frameSettings.BackgroundColor3
			frame.ResampleMode = frameSettings.ResampleMode
			frame.ScaleType = frameSettings.ScaleType
			frame.TileSize = frameSettings.TileSize
			frame.Interactable = frameSettings.Interactable
			frame.Active = false--frameSettings.Active

			-- Set computed size and position
			frame.Position = data.Position
			frame.Size = data.Size
		elseif data.istype == "surface" then
			local surfaceGui = data.surfaceGui
			local GuiSettings = data.GuiSettings

			-- set surfaceGui settings
			surfaceGui.ZOffset = GuiSettings.ZOffset
			surfaceGui.AlwaysOnTop = GuiSettings.AlwaysOnTop
			surfaceGui.Brightness = GuiSettings.Brightness
			surfaceGui.LightInfluence = GuiSettings.LightInfluence
			surfaceGui.MaxDistance = GuiSettings.MaxDistance
			surfaceGui.PixelsPerStud = GuiSettings.PixelsPerStud
			surfaceGui.SizingMode = GuiSettings.SizingMode
		end
	end
end

return ParallaxWindows
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000438a</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX44640EB2267A4285A2B41CCD175CA9FB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009679</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Streamable</string>
							<string name="ScriptGuid">{15231B2C-6EFB-4F4E-853E-CCFB07CF2B3D}</string>
							<ProtectedString name="Source"><![CDATA[--!strict

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Streamable
-- Stephen Leitnick
-- March 03, 2021

type StreamableWithInstance = {
	Instance: Instance?,
	[any]: any,
}

local Trove = require("../ModuleUtils/_Trove")
local Signal = require("../ModuleUtils/_Signal")

--[=[
	@within Streamable
	@prop Instance Instance
	The current instance represented by the Streamable. If this
	is being observed, it will always exist. If not currently
	being observed, this will be `nil`.
]=]

--[=[
	@class Streamable
	@client
	Because parts in StreamingEnabled games can stream in and out of existence at
	any point in time, it is hard to write code to interact with them. This is
	where Streamables come into play. Streamables will observe the existence of
	a given instance, and will signal when the instance exists and does not
	exist.

	The API is very simple. Create a Streamable that points to a certain parent
	and looks for a specific child instance (typically a BasePart). Then, call
	the `Observe` method to observe when the instance streams in and out.

	```lua
	local Streamable = require(packages.Streamable).Streamable

	-- Models might take a bit to load, but the model instance
	-- is never removed, thus we can use WaitForChild.
	local model = workspace:WaitForChild("MyModel")

	-- Watch for a specific part in the model:
	local partStreamable = Streamable.new(model, "SomePart")

	partStreamable:Observe(function(part, trove)
		print(part:GetFullName() .. " added")
		-- Run code on the part here.
		-- Use the trove to manage cleanup when the part goes away.
		trove:Add(function()
			-- General cleanup stuff
			print(part.Name .. " removed")
		end)
	end)

	-- Watch for the PrimaryPart of a model to exist:
	local primaryStreamable = Streamable.primary(model)
	primaryStreamable:Observe(function(primary, trove)
		print("Model now has a PrimaryPart:", primary.Name)
		trove:Add(function()
			print("Model's PrimaryPart has been removed")
		end)
	end)

	-- At any given point, accessing the Instance field will
	-- reference the observed part, if it exists:
	if partStreamable.Instance then
		print("Streamable has its instance:", partStreamable.Instance)
	end

	-- When/if done, call Destroy on the streamable, which will
	-- also clean up any observers:
	partStreamable:Destroy()
	primaryStreamable:Destroy()
	```

	For more information on the mechanics of how StreamingEnabled works
	and what sort of behavior to expect, see the
	[Content Streaming](https://developer.roblox.com/en-us/articles/content-streaming#technical-behavior)
	page. It is important to understand that only BaseParts and their descendants are streamed in/out,
	whereas other instances are loaded during the initial client load. It is also important to understand
	that streaming only occurs on the client. The server has immediate access to everything right away.
]=]
local Streamable = {}
Streamable.__index = Streamable
type self = {
	_trove: Trove.TroveType,
	_shown: Signal.SignalType<(instance: Instance, trove: Trove.TroveType) -> (), (Instance, Trove.TroveType)>,
	_shownTrove: Trove.TroveType,
	Instance: Instance
}
export type StreamableType = typeof(setmetatable({}, Streamable))

--[=[
	@return Streamable
	@param parent Instance
	@param childName string

	Constructs a Streamable that watches for a direct child of name `childName`
	within the `parent` Instance. Call `Observe` to observe the existence of
	the child within the parent.
]=]
function Streamable.new(parent: Instance, childName: string): StreamableType
	local self: StreamableWithInstance = {}
	setmetatable(self, Streamable)

	self._trove = Trove.new()
	self._shown = self._trove:Construct(Signal)
	self._shownTrove = Trove.new()
	self._trove:Add(self._shownTrove)

	self.Instance = parent:FindFirstChild(childName)

	local function OnInstanceSet()
		local instance = self.Instance
		if typeof(instance) == "Instance" then
			self._shown:Fire(instance, self._shownTrove)
			self._shownTrove:Connect(instance:GetPropertyChangedSignal("Parent"), function()
				if not instance.Parent then
					self._shownTrove:Clean()
				end
			end)
			self._shownTrove:Add(function()
				if self.Instance == instance then
					self.Instance = nil
				end
			end)
		end
	end

	local function OnChildAdded(child: Instance)
		if child.Name == childName and not self.Instance then
			self.Instance = child
			OnInstanceSet()
		end
	end

	self._trove:Connect(parent.ChildAdded, OnChildAdded)
	if self.Instance then
		OnInstanceSet()
	end

	return self
end

--[=[
	@return Streamable
	@param parent Model

	Constructs a streamable that watches for the PrimaryPart of the
	given `parent` Model.
]=]
function Streamable.primary(parent: Model)
	local self: StreamableWithInstance = {}
	setmetatable(self, Streamable)

	self._trove = Trove.new()
	self._shown = self._trove:Construct(Signal)
	self._shownTrove = Trove.new()
	self._trove:Add(self._shownTrove)

	self.Instance = parent.PrimaryPart

	local function OnPrimaryPartChanged()
		local primaryPart = parent.PrimaryPart
		self._shownTrove:Clean()
		self.Instance = primaryPart
		if primaryPart then
			self._shown:Fire(primaryPart, self._shownTrove)
		end
	end

	self._trove:Connect(parent:GetPropertyChangedSignal("PrimaryPart"), OnPrimaryPartChanged)
	if self.Instance then
		OnPrimaryPartChanged()
	end

	return self
end

--[=[
	@param handler (instance: Instance, trove: Trove) -> nil
	@return Connection

	Observes the instance. The handler is called anytime the
	instance comes into existence, and the trove given is
	cleaned up when the instance goes away.

	To stop observing, disconnect the returned connection.
]=]
function Streamable:Observe(handler)
	if self.Instance then
		task.spawn(handler, self.Instance, self._shownTrove)
	end
	return self._shown:Connect(handler)
end

--[=[
	Destroys the Streamable. Any observers will be disconnected,
	which also means that troves within observers will be cleaned
	up. This should be called when a streamable is no longer needed.
]=]
function Streamable:Destroy()
	self._trove:Destroy()
end

return Streamable]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000438b</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB9DC9182F41B4E60AA5EAADEB636E9D3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009396</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_SurfaceGuiClass</string>
							<string name="ScriptGuid">{F0DCE9DC-B3B2-4FD2-9173-7B95DAFD7C79}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 1/18/25
--[[@description:
	Wrapper class for SurfaceGuis that adds extra features.
	
	Features:
	- Ability to convert a SurfaceGui into a rotating SurfaceGui.
		- It will rotate to follow and look at the camera.
		- You can define rotation limits.
	
	Due to how this module works, changing the Enabled property of the SurfaceGui will no longer work.
	You must set an attribute 'IsEnabled' to toggle whether or not the SurfaceGui should render.
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local FunctionUtils = require("../FunctionUtils")
local ModuleUtils = require("../ModuleUtils")
local RunService = game:GetService("RunService")
local t = FunctionUtils.t

-----------------------------
-- TYPES --
-----------------------------
-- For all of the properties/fields of an object made from this class.
type fields = {
	_trove: ModuleUtils.TroveType,
	_visibleTrove: ModuleUtils.TroveType,
	Signals: {
		GuiShown: ModuleUtils.SignalType<() -> (), ()>,
		GuiHidden: ModuleUtils.SignalType<() -> (), ()>
	},
	_gui: SurfaceGui,
	_adorneeOrigCFrame: CFrame,
	
	_onHidingCallback: HidingCallback?,
	_maxDistance: number,
	_inRange: boolean,
	_rotationEnabled: boolean,
	_rotationLimits: RotationLimits?,
	_rotationSpring: ModuleUtils.Spring<Vector3>,
}

type RotationLimits = { X: NumberRange?, Y: NumberRange? }
type HidingCallback = (obj: WrappedSurfaceGui) -> ()

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}
local MT = {}
MT.__index = MT
export type WrappedSurfaceGui = typeof(setmetatable({} :: fields, MT))

local heartbeatConnection: RBXScriptConnection?
local objectCache = {}

-- CONSTANTS --
local DEFAULT_DAMPING = 0.85
local DEFAULT_SPEED = 16

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

local function onHeartbeat()
	for _, obj in ipairs(objectCache) do
		obj:_Step()
	end
end

local function getAdornee(gui: SurfaceGui): BasePart?
	local adornee = gui.Adornee or gui.Parent
	if not t.instanceIsA("BasePart")(adornee) then
		return
	end
	return adornee :: BasePart
end

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Creates a new WrappedSurfaceGui. The gui must have an adornee.
function Module.new(gui: SurfaceGui): WrappedSurfaceGui
	local adornee = getAdornee(gui)
	if not adornee then
		error(`surface gui: {gui} is missing adornee`, 2)
	end
	local self = setmetatable({} :: fields, MT)
	
	self._trove = ModuleUtils.Trove.new()
	self._visibleTrove = self._trove:Construct(ModuleUtils.Trove)
	self.Signals = {
		GuiShown = self._trove:Construct(ModuleUtils.Signal),
		GuiHidden = self._trove:Construct(ModuleUtils.Signal)
	}
	self._gui = gui
	self._maxDistance = gui.MaxDistance
	self._rotationEnabled = false
	self._inRange = false
	self._adorneeOrigCFrame = adornee.CFrame
	self._rotationSpring = ModuleUtils.Spring.new(Vector3.zero, DEFAULT_DAMPING, DEFAULT_SPEED)
	
	gui.MaxDistance = 0
	gui:SetAttribute("IsEnabled", gui.Enabled)
	gui.Enabled = false
	
	if not heartbeatConnection then
		heartbeatConnection = RunService.Heartbeat:Connect(onHeartbeat)
	end
	self._trove:Connect(gui:GetPropertyChangedSignal("MaxDistance"), function()
		if gui.MaxDistance == 0 then
			return
		end
		self._maxDistance = gui.MaxDistance
		gui.MaxDistance = 0
	end)
	self._trove:Connect(gui.Destroying, function()
		self:Destroy()
	end)
	
	table.insert(objectCache, self)
	return self
end

function Module:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")

	local mt = getmetatable(object)
	return mt ~= nil and mt.__index == MT
end

-- Enables the SurfaceGui to start rotating and looking at the player's camera.
-- Note: This will manipulate the CFrame of the adornee of the SurfaceGui.
-- <strong>rotationLimits</strong>: Optional limits for the rotation of the adornee (in radians). This limit is based on the adornee's starting orientation.
-- <strong>speed</strong>: Modify the speed of the spring responsible for rotation.
-- <strong>damping</strong>: Modify the damper of the spring responsible for rotation.
function MT.ToggleRotation(
	self: WrappedSurfaceGui,
	enable: boolean,
	rotationLimits: RotationLimits?,
	speed: number?,
	damping: number?
): WrappedSurfaceGui
	self._rotationEnabled = enable
	self._rotationLimits = rotationLimits
	
	if speed then
		self._rotationSpring.Speed = speed
	end
	if damping then
		self._rotationSpring.Damping = damping
	end
	
	return self
end

-- Allows you to set a function that will be called before the GUI is hidden. This callback may yield and the GUI will not hide
-- until the callback stops yielding. This is useful if you want to tween out the SurfaceGUI before it stops rendering.
-- If the GUI comes back into view/rendering before the callback finishes, the yielding thread will be cancelled.
-- Only one callback may be set!
function MT.SetOnHiding(self: WrappedSurfaceGui, callback: HidingCallback): WrappedSurfaceGui
	self._onHidingCallback = callback
	return self
end

function MT.GetGui(self: WrappedSurfaceGui): SurfaceGui
	return self._gui
end

function MT.GetAdornee(self: WrappedSurfaceGui): BasePart?
	return getAdornee(self._gui)
end

-- Is this SurfaceGui within range of the player's camera to be rendered?
function MT.InRange(self: WrappedSurfaceGui)
	return self._inRange
end

-- Returns if this GUI is rotating to look at the camera.
function MT.IsRotating(self: WrappedSurfaceGui)
	return self._rotationEnabled
end

function MT._Step(self: WrappedSurfaceGui)
	local gui = self:GetGui()
	local adornee = self:GetAdornee()
	if not adornee then
		return
	end
	if not gui:GetAttribute("IsEnabled") then
		return
	end
	local camera = workspace.CurrentCamera
	local cameraPosition = camera.CFrame.Position

	local checkPosition = adornee.Position
	local maxDistance = if self._maxDistance <= 0 then math.huge else self._maxDistance
	local magnitude = (cameraPosition - checkPosition).Magnitude

	if self:InRange() and magnitude > maxDistance then
		self._visibleTrove:Clean()
		self._visibleTrove:Add(task.spawn(function()
			self._inRange = false
			if self._onHidingCallback then
				self._onHidingCallback(self)
			end
			gui.Enabled = false
			self.Signals.GuiHidden:Fire()
		end))
	elseif not self:InRange() and magnitude <= maxDistance then
		self._visibleTrove:Clean()
		self._inRange = true
		gui.Enabled = true
		self.Signals.GuiShown:Fire()
	end
	
	if self:InRange() and self:IsRotating() then
		local lookCFrame = CFrame.lookAt(adornee.Position, camera.CFrame.Position)
		local targetX, targetY = lookCFrame:ToOrientation()
		local origX, origY, origZ = self._adorneeOrigCFrame:ToOrientation()

		local limits = self._rotationLimits
		local finalX = if limits and limits.X then FunctionUtils.Math.clampAngle(targetX, limits.X.Min, limits.X.Max, origX) else targetX
		local finalY = if limits and limits.Y then FunctionUtils.Math.clampAngle(targetY, limits.Y.Min, limits.Y.Max, origY) else targetY
		local finalZ = origZ

		self._rotationSpring.Target = Vector3.new(finalX, finalY, finalZ)
		local rot = self._rotationSpring.Position
		adornee.CFrame = CFrame.new(adornee.Position) * CFrame.fromOrientation(rot.X, rot.Y, rot.Z)
	end
end

function MT.Destroy(self: WrappedSurfaceGui)
	table.remove(objectCache, table.find(objectCache, self))
	self._trove:Clean()
	setmetatable(self :: any, nil)
	table.clear(self :: any)
end

-----------------------------
-- MAIN --
-----------------------------
return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000438c</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX70EB61A3BBDD43E68895F50071F4A9C7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">2d572042b95aecbf06c6b2ca00006f4c</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_GuiTextClass</string>
							<string name="ScriptGuid">{181A64C5-0DEA-4641-892C-2A681650CF38}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: C0DERACTU4L @CoderActual & crusherfire
--@date: 8/8/2024
--[[@description:
	
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local ModuleUtils = require("../ModuleUtils")
local FunctionUtils = require("../FunctionUtils")
local Trove = ModuleUtils.Trove

-----------------------------
-- TYPES --
-----------------------------
-- This is for all of the properties of an object made from this class for type annotation purposes.
type self = {
	_trove: ModuleUtils.TroveType,
	_label: TextLabel,
	_dropShadow: ExampleDropShadow?,
}

export type ExampleDropShadow = typeof(script.ExampleDropShadow)

-----------------------------
-- VARIABLES --
-----------------------------
local GuiTextClass = {}

local MT = {}
MT.__index = MT
export type WrappedTextLabel = typeof(setmetatable({} :: self, MT))

-- CONSTANTS --
local COPY_PROPERTIES = {
	"FontFace",
	"LineHeight",
	"MaxVisibleGraphemes",
	"RichText",
	"Text",
	"TextDirection",
	"TextScaled",
	"TextSize",
	"TextTruncate",
	"TextWrapped",
	"TextXAlignment",
	"TextYAlignment",
}
local IGNORE_CONSTRAINTS = {
	UIStroke = true
}
local UDIM2_SCALE_ONE = UDim2.fromScale(1, 1)
local UDIM2_IDENTITY = UDim2.fromScale(0, 0)

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

local function createDropShadow(self: WrappedTextLabel): ExampleDropShadow
	local label = self:GetLabel()
	do
		-- Destroy placeholders
		local other = label:FindFirstChild("_DropShadow")
		if other then
			other:Destroy()
		end
	end
	local origParent = label.Parent
	local frame = script.ExampleDropShadow:Clone()
	frame.Name = "_DropShadow"
	frame.Size = label.Size
	frame.Position = label.Position
	frame.AnchorPoint = label.AnchorPoint
	frame.LayoutOrder = label.LayoutOrder
	frame.ZIndex = label.ZIndex
	frame.BackgroundTransparency = 1

	label.Parent = frame
	label.Size = UDIM2_SCALE_ONE
	label.Position = UDIM2_IDENTITY
	label.AnchorPoint = Vector2.zero

	local shadowLabel = frame._ShadowLabel
	for _, property in ipairs(COPY_PROPERTIES) do
		(shadowLabel :: any)[property] = (label :: any)[property]
	end
	shadowLabel.BackgroundTransparency = 1
	shadowLabel.AnchorPoint = Vector2.zero
	shadowLabel.Position = UDIM2_IDENTITY
	shadowLabel.Size = UDIM2_SCALE_ONE
	shadowLabel.ZIndex = label.ZIndex - 1
	shadowLabel.Parent = frame
	
	frame.Parent = origParent
	
	return frame
end

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Creates a new WrappedTextLabel.
function GuiTextClass.new(textObject: TextLabel): WrappedTextLabel
	assert(textObject:IsA("TextLabel"), "GuiTextClass: Inputted param must be a TextLabel.")
	local self = setmetatable({} :: self, MT)
	
	self._trove = Trove.new()
	self._label = textObject
	
	self._trove:Add(textObject.Destroying:Once(function()
		self:Destroy()
	end))
	
	return self
end

function GuiTextClass:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")

	return getmetatable(object).__index == MT
end

-- Creates a drop shadow on the text label.
-- <strong>WARNING!</strong> This will change the parent hierarchy for the text label.
-- <strong>color</strong>: Optional color override for the dropshadow (default is black)
-- <strong>offset</strong>: Optional offset override (default offset is (2, 2))
-- <strong>transparency</strong>: Optional transparency override (default is 0.4)
function MT.CreateDropShadow(self: WrappedTextLabel, color: Color3?, offset: Vector2?, transparency: number?): WrappedTextLabel
	local label = self._label :: TextLabel
	local dropShadow = createDropShadow(self)
	self._dropShadow = dropShadow
	local shadowLabel = dropShadow._ShadowLabel
	
	local offset = offset or Vector2.new(2, 2)
	shadowLabel.Position = UDIM2_IDENTITY + UDim2.fromOffset(offset.X, offset.Y)
	shadowLabel.TextTransparency = transparency or 0.4
	
	for _, property in ipairs(COPY_PROPERTIES) do
		self._trove:Connect(label:GetPropertyChangedSignal(property), function()
			if property == "Text" then
				-- Removes custom text color, strokes, and highlights (since a dropshadow doesn't need those)
				local newText = label.Text:gsub("(<font[^>]*>)", function(tag)
					-- Remove the font color attribute, whether it's hex, rgb(), etc.
					return tag:gsub('%s*color%s*=%s*["\'][^"\']*["\']', "")
				end):gsub("</?stroke%s*[^>]*>", "")
					:gsub("</?mark%s*[^>]*>", "")

				shadowLabel.Text = newText
			else
				pcall(function()
					shadowLabel[property] = (label :: any)[property]
				end)
			end
		end)
	end
	
	-- UI constraint copying/listening
	do
		local function onNewConstraint(constraint: UIBase)
			local clone = constraint:Clone()
			clone.Parent = shadowLabel
			self._trove:Add(constraint.Destroying:Once(function()
				clone:Destroy()
			end))
			self._trove:Connect(constraint.Changed, function(property)
				(clone :: any)[property] = (constraint :: any)[property]
			end)
		end
		
		for _, item in ipairs(label:GetChildren()) do
			if not item:IsA("UIBase") then
				continue
			end
			if IGNORE_CONSTRAINTS[item.ClassName] then
				continue
			end
			onNewConstraint(item)
		end
		
		self._trove:Connect(label.ChildAdded, function(child)
			if not child:IsA("UIBase") then
				return
			end
			if IGNORE_CONSTRAINTS[child.ClassName] then
				return
			end
			onNewConstraint(child)
		end)
	end
	
	
	return self
end

-- Returns the drop shadow frame (if present).
-- It's' not recommended to attempt to modify anything on the drop shadow. Use it for read-only values.
function MT.GetDropShadow(self: WrappedTextLabel): ExampleDropShadow?
	return self._dropShadow
end

function MT.GetLabel(self: WrappedTextLabel): TextLabel
	return self._label
end

function MT.Destroy(self: WrappedTextLabel)
	self._trove:Clean()
	setmetatable(self :: any, nil)
	table.clear(self :: any)
end

-----------------------------
-- MAIN --
-----------------------------
return GuiTextClass]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a513440000438d</UniqueId>
						</Properties>
						<Item class="Folder" referent="RBX78B22232E23C447AB7F43402A938D998">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">ExampleDropShadow</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b8e</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX983F6DA4F47B43EEB78A17DF53D63155">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009377</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_GuiObjectClass</string>
							<string name="ScriptGuid">{6C231B2A-7DD8-49F5-AB40-A7FE9BFE6BDC}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 10/7/24
--[[@description:
	Wrapper class that applies generic effects across all UI objects
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local ModuleUtils = require("../ModuleUtils")
local FunctionUtils = require("../FunctionUtils")
local Trove = ModuleUtils.Trove
local Input = require("./_Input")

-----------------------------
-- TYPES --
-----------------------------
-- This is for all of the properties of an object made from this class for type annotation purposes.
type self = {
	_trove: ModuleUtils.TroveType,
	_toolTipTrove: ModuleUtils.TroveType, -- Cleaned when tool tip is disabled.
	_notifTrove: ModuleUtils.TroveType, -- Cleaned when notifications are cleared.
	_object: GuiObject,
	_currentNotices: number,
	
	_shimmerEnabled: boolean?,
	_shimmerTrove: ModuleUtils.TroveType,
	_shimmer: GuiObject?
}
export type ToolTipStyles = "INFO" | "WARNING"

export type ToolTipParams = {
	CustomToolTip: { -- for your own custom toolt tip (if provided, all other params are ignored except MouseOffset)
		ToolTip: GuiObject, -- template to clone from
		OnCreate: (tooltip: GuiObject) -> (), -- to customzie the custom tooltip
		OnEnterHover: (tooltip: GuiObject) -> (), 
		OnExitHover: (tooltip: GuiObject) -> (), -- this function can yield to prevent immediate destruction of tooltip (if tooltip gets disabled)
	}?,
	MouseOffset: Vector2?, -- how the tooltip should be offset from the mouse or element (if locked) in pixels
	LockedToElement: boolean?, -- tool tip appears over element and doesn't follow mouse
	AnchorPoint: Vector2?,
	DescriptionText: string?,
	TitleText: string?,
	-- If both are provided, Style is applied first and then CustomizeTooltip is called.
	CustomizeTooltip: ( (frame: ExampleToolTip) -> () )?, -- for your own custom tool tip styles for the default tooltip
	Style: ToolTipStyles?, -- built-in tool tip styles
}

type NotificationCorner = "UpperLeft" | "UpperRight" | "BottomLeft" | "BottomRight"

export type NotificationOptions = {
	Corner: NotificationCorner?,
	Color: Color3?,
	ClearSignal: ModuleUtils.GenericSignal? -- For clearing this specific notice.
}

export type ShimmerParams = {
	Color: ColorSequence?,
	Rotation: number?,
}

-----------------------------
-- VARIABLES --
-----------------------------
local GuiObjectClass = {}
local MT = {}
MT.__index = MT
export type WrappedGuiObject = typeof(setmetatable({} :: self, MT))

local mouse = Input.Mouse.new()
local toolTipGui = script.ToolTipGui
local exampleToolTip = toolTipGui.ExampleToolTip
local exampleNotification = script.ExampleNotification
export type ExampleNotif = typeof(exampleNotification)
export type ExampleToolTip = typeof(exampleToolTip)

local objectCache = {}

-- CONSTANTS --
local PLAYER = Players.LocalPlayer

local TOP_NO_SIZE = UDim2.fromScale(0, 0.3)
local BOTTOM_NO_SIZE = UDim2.fromScale(1, 0)
local TOP_SIZE = exampleToolTip.TopFrame.Size
local BOTTOM_SIZE = exampleToolTip.BottomFrame.Size
local TEXT_TWEEN_INFO = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
local SIZE_TWEEN_INFO = TweenInfo.new(0.25, Enum.EasingStyle.Cubic, Enum.EasingDirection.InOut)
local ANCHOR_POINT_IDENTITY = Vector2.zero
local CAMERA = workspace.CurrentCamera

local CORNER_TO_UDIM2 = {
	UpperLeft = UDim2.fromScale(0, 0),
	UpperRight = UDim2.fromScale(1, 0),
	BottomLeft = UDim2.fromScale(0, 1),
	BottomRight = UDim2.fromScale(1, 1)
}
local CORNER_TO_ANCHOR_POINT = {
	UpperLeft = Vector2.new(0.2, 0.2),
	UpperRight = Vector2.new(0.8, 0.2),
	BottomLeft = Vector2.new(0.2, 0.8),
	BottomRight = Vector2.new(0.8, 0.8)
}

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------
local customizeTooltip = {
	INFO = function(frame: ExampleToolTip)
		local color = Color3.fromRGB(87, 120, 140)
		local h, s, v = color:ToHSV()
		local darkerColor = Color3.fromHSV(h, s, v * 0.7)
		frame.TopFrame.Icon.Image = "rbxassetid://13868179798"
		frame.TopFrame.BackgroundColor3 = color
		frame.BottomFrame.BackgroundColor3 = darkerColor
	end,
	WARNING = function(frame: ExampleToolTip)
		local color = Color3.fromRGB(144, 81, 26)
		local h, s, v = color:ToHSV()
		local darkerColor = Color3.fromHSV(h, s, v * 0.7)
		frame.TopFrame.Icon.Image = "rbxassetid://14939539960"
		frame.TopFrame.BackgroundColor3 = color
		frame.BottomFrame.BackgroundColor3 = darkerColor
	end,
} :: { [ToolTipStyles]: (frame: ExampleToolTip) -> () }

local function createToolTip(params: ToolTipParams): ExampleToolTip
	local clone = exampleToolTip:Clone()
	clone.TopFrame.TitleLabel.Text = params.TitleText or ""
	clone.BottomFrame.DescriptionLabel.Text = params.DescriptionText or ""
	clone.Visible = false
	
	clone.TopFrame.Size = TOP_NO_SIZE
	clone.BottomFrame.Size = BOTTOM_NO_SIZE
	clone.TopFrame.TitleLabel.TextTransparency = 1
	clone.BottomFrame.DescriptionLabel.TextTransparency = 1
	clone.TopFrame.UICorner.CornerRadius = if not params.DescriptionText then clone.UICorner.CornerRadius else UDim.new()
	
	clone.AnchorPoint = params.AnchorPoint or ANCHOR_POINT_IDENTITY
	
	if params.Style then
		customizeTooltip[params.Style](clone)
	end
	if params.CustomizeTooltip then
		local success, err = pcall(function()
			params.CustomizeTooltip(clone)
		end)
		if not success then
			warn(err)
		end
	end
	
	clone.Parent = toolTipGui
	return clone
end

local function createShimmerEffect(self: WrappedGuiObject, params: ShimmerParams?): (GuiObject, UIGradient)
	local shimmerEffect: GuiObject = if self:GetObject():IsA("ImageButton") then Instance.new("ImageLabel") else Instance.new("Frame")
	if shimmerEffect:IsA("ImageLabel") then
		local button = self:GetObject() :: ImageButton
		shimmerEffect.Image = button.Image
		shimmerEffect.ImageColor3 = Color3.new(1, 1, 1)
		shimmerEffect.ScaleType = button.ScaleType
		shimmerEffect.SliceCenter = button.SliceCenter
	else
		local uiCorner = self:GetObject():FindFirstChildWhichIsA("UICorner")
		if uiCorner then
			local uiCornerClone = uiCorner:Clone()
			uiCornerClone.Parent = shimmerEffect
		end
	end

	FunctionUtils.Interface.center(shimmerEffect)
	shimmerEffect.Size = UDim2.fromScale(1, 1)
	shimmerEffect.BackgroundTransparency = 0
	shimmerEffect.ZIndex = 1000

	local uiGradient = Instance.new("UIGradient")
	local whiteColorSequence = ColorSequence.new(Color3.new(1, 1, 1))
	uiGradient.Color = if params and params.Color then params.Color else whiteColorSequence
	uiGradient.Rotation = if params and params.Rotation then params.Rotation else 0
	uiGradient.Parent = shimmerEffect
	uiGradient.Offset = Vector2.new(-1, 0)
	uiGradient.Transparency = NumberSequence.new{
		NumberSequenceKeypoint.new(0, 1),
		NumberSequenceKeypoint.new(0.3, 1),
		NumberSequenceKeypoint.new(0.5, .4),
		NumberSequenceKeypoint.new(0.7, 1),
		NumberSequenceKeypoint.new(1, 1),
	}

	shimmerEffect.Parent = self:GetObject()

	return shimmerEffect, uiGradient
end

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Creates a new WrappedGuiObject
function GuiObjectClass.new(guiObject: GuiObject): WrappedGuiObject
	local obj = GuiObjectClass:GetObjectByObject(guiObject)
	if obj then
		return obj
	end
	
	local self = setmetatable({} :: self, MT)
	
	self._trove = Trove.new()
	self._shimmerTrove = self._trove:Construct(Trove)
	self._toolTipTrove = self._trove:Construct(Trove)
	self._notifTrove = self._trove:Construct(Trove)
	self._object = guiObject
	self._currentNotices = 0
	
	self._trove:Add(guiObject.Destroying:Once(function()
		self:Destroy()
	end))
	
	table.insert(objectCache, self)
	return self
end

function GuiObjectClass:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")

	return getmetatable(object).__index == MT
end

function GuiObjectClass:GetObjectByObject(object: GuiObject): WrappedGuiObject?
	for _, classObj in ipairs(objectCache) do
		if classObj:GetObject() == object then
			return classObj
		end
	end
	return nil
end

-- Adds a notification icon/number to the corner of the GuiObject.
function MT.Notify(self: WrappedGuiObject, notifyOptions: NotificationOptions?): WrappedGuiObject
	self._currentNotices += 1
	local frame = self:GetObject():FindFirstChild("_activeNotification") :: ExampleNotif
	
	local position = if notifyOptions and notifyOptions.Corner then CORNER_TO_UDIM2[notifyOptions.Corner] else CORNER_TO_UDIM2.UpperRight
	local anchorPoint = if notifyOptions and notifyOptions.Corner then CORNER_TO_ANCHOR_POINT[notifyOptions.Corner] else CORNER_TO_ANCHOR_POINT.UpperRight
	
	if not frame then
		frame = exampleNotification:Clone()
		self._notifTrove:Add(frame)
	end
	frame.Position = position
	frame.AnchorPoint = anchorPoint
	frame.Icon.Visible = if self._currentNotices <= 1 then true else false
	frame.CountLabel.Visible = not frame.Icon.Visible
	frame.CountLabel.Text = self:GetNotices()
	frame.Visible = true
	frame.Parent = self:GetObject()
	
	if notifyOptions and notifyOptions.ClearSignal then
		self._notifTrove:Add(notifyOptions.ClearSignal:Once(function()
			self._currentNotices -= 1
			frame.Icon.Visible = if self._currentNotices <= 1 then true else false
			frame.CountLabel.Visible = not frame.Icon.Visible
			frame.CountLabel.Text = self:GetNotices()
			if self._currentNotices <= 0 then
				self:ClearNotices()
			end
		end))
	end
	
	return self
end

function MT.ToggleShimmer(self: WrappedGuiObject, enable: boolean?, params: ShimmerParams?): WrappedGuiObject
	if enable and self:IsShimmerEnabled() then
		return self
	elseif not enable and not self:IsShimmerEnabled() then
		return self
	end

	self._shimmerEnabled = if enable ~= nil then enable else false

	if self:IsShimmerEnabled() then
		local shimmer, gradient = createShimmerEffect(self, params)
		self._shimmerTrove:Add(shimmer)
		local tween = TweenService:Create(gradient, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, -1, false, 1), {Offset = Vector2.new(1, 0)})
		tween:Play()
		self._shimmerTrove:Add(tween)
		self._shimmer = shimmer
	else
		self._shimmerTrove:Clean()
		self._shimmer = nil
	end

	return self
end

function MT.IsShimmerEnabled(self: WrappedGuiObject)
	return self._shimmerEnabled
end

-- Clears ALL notices.
function MT.ClearNotices(self: WrappedGuiObject): WrappedGuiObject
	self._notifTrove:Clean()
	self._currentNotices = 0
	return self
end

function MT.GetNotices(self: WrappedGuiObject): number
	return self._currentNotices
end

function MT.GetObject(self: WrappedGuiObject): GuiObject
	return self._object
end

-- Displays a tool tip when hovering over the GuiObject.
function MT.ToggleToolTip(self: WrappedGuiObject, enable: boolean?, params: ToolTipParams?): WrappedGuiObject
	if enable and not params then
		warn("Expected tool tip params when enabling tool tip!")
		return self
	end
	
	if enable and toolTipGui.Parent ~= PLAYER.PlayerGui then
		toolTipGui.Parent = PLAYER.PlayerGui
	end
	
	if not enable then
		self._toolTipTrove:Clean()
		return self
	end
	local params = params :: ToolTipParams
	
	-- Enabling tool tip
	if params.CustomToolTip then
		local toolTip = params.CustomToolTip.ToolTip:Clone()
		if params.CustomToolTip.OnCreate then
			params.CustomToolTip.OnCreate(toolTip)
		end
		toolTip.Visible = false
		toolTip.Parent = toolTipGui
		local offset: Vector2 do
			if params.MouseOffset then
				offset = params.MouseOffset
			elseif toolTip.AnchorPoint.X == 1 then
				offset = Vector2.new(-5, -5)
			elseif toolTip.AnchorPoint.X == 0 then
				offset = Vector2.new(15, -5)
			elseif toolTip.AnchorPoint.X == 0.5 then
				offset = Vector2.new(0, 5)
			end
		end
		self._toolTipTrove:Add(function()
			if toolTip.Visible then
				params.CustomToolTip.OnExitHover(toolTip)
			end
			toolTip:Destroy()
		end)
		self._toolTipTrove:Connect(self._object.MouseEnter, function()
			params.CustomToolTip.OnEnterHover(toolTip)
		end)
		self._toolTipTrove:Connect(self._object.MouseLeave, function()
			params.CustomToolTip.OnExitHover(toolTip)
		end)
		local function onVisiblityChanged()
			local visible = FunctionUtils.Interface.trulyVisible(self._object)
			if not visible then
				params.CustomToolTip.OnExitHover(toolTip)
			end
		end
		for _, ancestor in ipairs(FunctionUtils.Object.getAncestors(self._object)) do
			if ancestor:IsA("LayerCollector") then
				self._toolTipTrove:Connect(ancestor:GetPropertyChangedSignal("Enabled"), onVisiblityChanged)
			elseif ancestor:IsA("GuiObject") then
				self._toolTipTrove:Connect(ancestor:GetPropertyChangedSignal("Visible"), onVisiblityChanged)
			end
		end
		self._toolTipTrove:Connect(self._object:GetPropertyChangedSignal("Visible"), onVisiblityChanged)
		if params.LockedToElement then
			local function evaluateToolTipPosition()
				local absolutePos = self._object.AbsolutePosition
				local absoluteSize = self._object.AbsoluteSize
				local isTopHalf = absolutePos.Y < (CAMERA.ViewportSize / 2).Y
				
				local newPosition
				if isTopHalf then
					toolTip.AnchorPoint = Vector2.new(0.5, 0)
					newPosition = absolutePos + Vector2.new(absoluteSize.X / 2, absoluteSize.Y)
				else
					toolTip.AnchorPoint = Vector2.new(0.5, 1)
					newPosition = absolutePos + Vector2.new(absoluteSize.X / 2, 0)
				end
				newPosition += if isTopHalf then offset else -offset
				toolTip.Position = UDim2.fromOffset(newPosition.X, newPosition.Y)
			end
			
			self._toolTipTrove:Connect(self._object:GetPropertyChangedSignal("AbsolutePosition"), evaluateToolTipPosition)
			self._toolTipTrove:Connect(self._object:GetPropertyChangedSignal("AbsoluteSize"), evaluateToolTipPosition)
			evaluateToolTipPosition()
		else
			self._toolTipTrove:Connect(mouse.Moved, function(position: Vector2)
				if not toolTip.Visible then
					return
				end
				toolTip.Position = UDim2.fromOffset(position.X + offset.X, position.Y + offset.Y)
			end)
		end
	else
		local toolTip = createToolTip(params :: ToolTipParams)
		local offset: Vector2 = if params.MouseOffset then params.MouseOffset elseif toolTip.AnchorPoint.X == 1 then Vector2.new(-5, -5) else Vector2.new(15, -5)
		local tweenTrove = Trove.new()

		local function displayToolTip(frame: ExampleToolTip)
			tweenTrove:Clean()

			tweenTrove:Add(task.spawn(function()
				frame.Visible = true
				local tween
				if toolTip.TopFrame.Size ~= TOP_SIZE then
					tween = TweenService:Create(toolTip.TopFrame, SIZE_TWEEN_INFO, {Size = TOP_SIZE})
					tween:Play()
					tween.Completed:Wait()
				end
				TweenService:Create(toolTip.TopFrame.TitleLabel, TEXT_TWEEN_INFO, {TextTransparency = 0}):Play()
				if toolTip.BottomFrame.DescriptionLabel.Text ~= "" then
					if toolTip.BottomFrame.Size ~= BOTTOM_SIZE then
						tween = TweenService:Create(toolTip.BottomFrame, SIZE_TWEEN_INFO, {Size = BOTTOM_SIZE})
						tween:Play()
						tween.Completed:Wait()
					end
					TweenService:Create(toolTip.BottomFrame.DescriptionLabel, TEXT_TWEEN_INFO, {TextTransparency = 0}):Play()
				end
			end))
		end

		local function hideToolTip(frame: ExampleToolTip)
			tweenTrove:Clean()

			tweenTrove:Add(task.spawn(function()
				local tween
				if toolTip.BottomFrame.Size.Y.Scale > 0 then
					tween = TweenService:Create(toolTip.BottomFrame, SIZE_TWEEN_INFO, {Size = BOTTOM_NO_SIZE})
					tween:Play()
					TweenService:Create(toolTip.BottomFrame.DescriptionLabel, TEXT_TWEEN_INFO, {TextTransparency = 1}):Play()
					tween.Completed:Wait()
				end
				tween = TweenService:Create(toolTip.TopFrame, SIZE_TWEEN_INFO, {Size = TOP_NO_SIZE})
				TweenService:Create(toolTip.TopFrame.TitleLabel, TEXT_TWEEN_INFO, {TextTransparency = 1}):Play()
				tween:Play()
				tween.Completed:Wait()
				frame.Visible = false
			end))
		end

		self._toolTipTrove:Add(function()
			if toolTip.Visible then
				hideToolTip(toolTip)
				toolTip:GetPropertyChangedSignal("Visible"):Wait()
			end
			tweenTrove:Clean()
			toolTip:Destroy()
		end)
		self._toolTipTrove:Connect(self._object.MouseEnter, function()
			displayToolTip(toolTip)
		end)
		self._toolTipTrove:Connect(self._object.MouseLeave, function()
			hideToolTip(toolTip)
		end)
		if params.LockedToElement then
			local function evaluateToolTipPosition()
				local absolutePos = self._object.AbsolutePosition
				local absoluteSize = self._object.AbsoluteSize
				local isTopHalf = absolutePos.Y >= (CAMERA.ViewportSize / 2).Y

				local newPosition
				if isTopHalf then
					toolTip.AnchorPoint = Vector2.new(0.5, 0)
					newPosition = absolutePos + Vector2.new(absoluteSize.X / 2, absoluteSize.Y)
				else
					toolTip.AnchorPoint = Vector2.new(0.5, 1)
					newPosition = absolutePos + Vector2.new(absoluteSize.X / 2, 0)
				end
				toolTip.Position = UDim2.fromOffset(newPosition.X, newPosition.Y)
			end
			self._toolTipTrove:Connect(self._object:GetPropertyChangedSignal("AbsolutePosition"), evaluateToolTipPosition)
			self._toolTipTrove:Connect(self._object:GetPropertyChangedSignal("AbsoluteSize"), evaluateToolTipPosition)
		else
			self._toolTipTrove:Connect(mouse.Moved, function(position: Vector2)
				if not toolTip.Visible then
					return
				end
				toolTip.Position = UDim2.fromOffset(position.X + offset.X, position.Y + offset.Y)
			end)
		end
	end
	
	return self
end

function MT.Destroy(self: WrappedGuiObject)
	self._trove:Clean()
	local i = table.find(objectCache, self)
	if i then
		table.remove(objectCache, i)
	end
end

-----------------------------
-- MAIN --
-----------------------------
return GuiObjectClass]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a5134400004390</UniqueId>
						</Properties>
						<Item class="Folder" referent="RBX6A26E26FC0AB46EA8620BFF93308B0EC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">ToolTipGui</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b73</UniqueId>
							</Properties>
							<Item class="Folder" referent="RBXA1F30632EE824A6091974745EA522FCE">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">ExampleToolTip</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b74</UniqueId>
								</Properties>
								<Item class="Folder" referent="RBX4AB9F30E239F42E4BE6545823D961EC9">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">BottomFrame</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b75</UniqueId>
									</Properties>
									<Item class="Folder" referent="RBXAFB08601A1564C4DB0581DEE9B224574">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<string name="Name">DescriptionLabel</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b76</UniqueId>
										</Properties>
									</Item>
								</Item>
								<Item class="Folder" referent="RBXEF3FF04F2A064F19A6DABDB03A5C8E7E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">TopFrame</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b77</UniqueId>
									</Properties>
									<Item class="Folder" referent="RBX7DAB85A8526E479595603843A5980826">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<string name="Name">Icon</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b78</UniqueId>
										</Properties>
									</Item>
								</Item>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXF56D5BB053334F64AA9802C018F0E3E1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">ExampleNotification</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b86</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX2EBB67923B534230A20E7022A555CD4A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009398</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_GuiImageClass</string>
							<string name="ScriptGuid">{3D85154A-89F9-4F69-9518-0ACEFD2B4E07}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 3/20/25
--[[@description:

]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local ModuleUtils = require("../ModuleUtils")
local FunctionUtils = require("../FunctionUtils")
local t = FunctionUtils.t

-----------------------------
-- TYPES --
-----------------------------
-- For all of the properties/fields of an object made from this class.
type fields = {
	_trove: ModuleUtils.TroveType,
	_flipbookTrove: ModuleUtils.TroveType,
	
	Signals: {
		FlipbookPaused: ModuleUtils.GenericSignal,
		FlipbookUnpaused: ModuleUtils.GenericSignal,
		FlipbookEnded: ModuleUtils.SignalType<(finished: boolean) -> (), (boolean)>
	},
	
	_activeFlipbook: FlipbookParams?,
	_userData: { [any]: any },
	_imageLabel: ImageButton | ImageLabel,
	
	-- flags
	_flipbookPaused: boolean,
}

export type FlipbookParams = {
	ImageId: string,
	ImageResolution: number, -- 8x8, 16x16, 32x32, 64x64, 128x128, 256x256, 512x512, or 1024x1024
	Layout: Enum.ParticleFlipbookLayout,
	Mode: Enum.ParticleFlipbookMode,
	Framerate: number, -- FPS
	RepeatCount: number, -- -1 is infinite
	Direction: number?, -- -1 is backwards, 1 is forwards (default is 1)
	Reset: boolean?, -- should the frame reset back to default position when flipbook is over?
}
-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}
local MT = {}
MT.__index = MT
export type WrappedGuiImage = typeof(setmetatable({} :: fields, MT))

local rng = Random.new(tick())

-- CONSTANTS --

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- CLASS FUNCTIONS --
-----------------------------

function Module.new(image: ImageButton | ImageLabel): WrappedGuiImage
	local self = setmetatable({} :: fields, MT) :: WrappedGuiImage
	self._trove = ModuleUtils.Trove.new()
	self._flipbookTrove = self._trove:Construct(ModuleUtils.Trove)
	self.Signals = {
		FlipbookPaused = self._trove:Construct(ModuleUtils.Signal),
		FlipbookUnpaused = self._trove:Construct(ModuleUtils.Signal),
		FlipbookEnded = self._trove:Construct(ModuleUtils.Signal)
	}
	self._userData = {}
	
	self._imageLabel = image
	
	self._flipbookPaused = false
	
	self._trove:Connect(self._imageLabel.Destroying, function()
		self:Destroy()
	end)
	
	return self
end

function Module:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")

	local mt = getmetatable(object)
	return mt ~= nil and mt.__index == MT
end

-----------------------------
-- METHODS --
-----------------------------

-- Performs a flipbook animation on the image.
function MT.Flipbook(self: WrappedGuiImage, params: FlipbookParams): WrappedGuiImage
	-- Cleanup any previous flipbook tasks.
	self:CancelFlipbook()
	
	self._activeFlipbook = params
	local paramsDirection = params.Direction or 1
	local imageLabel = self._imageLabel :: ImageLabel
	imageLabel.Image = params.ImageId

	local gridSize do
		if params.Layout == Enum.ParticleFlipbookLayout.Grid2x2 then
			gridSize = 2
		elseif params.Layout == Enum.ParticleFlipbookLayout.Grid4x4 then
			gridSize = 4
		elseif params.Layout == Enum.ParticleFlipbookLayout.Grid8x8 then
			gridSize = 8
		else
			warn(`Invalid layout: {params.Layout}`)
			return self
		end
	end

	local gridResolution = params.ImageResolution / gridSize
	imageLabel.ImageRectSize = Vector2.new(gridResolution, gridResolution)
	local totalFrames = gridSize * gridSize
	local waitDuration = 1 / params.Framerate

	local currentIteration = 0
	local frameCount = 0

	local direction = paramsDirection
	local currentFrame = if direction == 1 then 1 else totalFrames
	local finished = false
	
	self._flipbookTrove:Add(task.spawn(function()
		while true do
			local column = ((currentFrame - 1) % gridSize) + 1
			local row = math.floor((currentFrame - 1) / gridSize) + 1
			imageLabel.ImageRectOffset = Vector2.new((column - 1) * gridResolution, (row - 1) * gridResolution)

			if params.Mode == Enum.ParticleFlipbookMode.Random then
				currentFrame = rng:NextInteger(1, totalFrames)
				if frameCount % totalFrames == 0 then
					currentIteration += 1
				end
			elseif params.Mode == Enum.ParticleFlipbookMode.PingPong then
				-- For PingPong, use the current direction (which may have been flipped)
				currentFrame = currentFrame + direction
				if currentFrame > totalFrames then
					-- Overshot the last frame, so reverse (and avoid a duplicate)
					currentFrame = totalFrames - 1
					direction = -direction
				elseif currentFrame < 1 then
					-- Overshot before the first frame; reverse and count an iteration.
					currentFrame = 2
					direction = -direction
					currentIteration += 1
				end
			elseif params.Mode == Enum.ParticleFlipbookMode.Loop then
				-- Move sequentially based on the provided Direction.
				currentFrame = currentFrame + paramsDirection
				if currentFrame > totalFrames then
					currentIteration += 1
					currentFrame = 1
				elseif currentFrame < 1 then
					currentIteration += 1
					currentFrame = totalFrames
				end
			else
				-- OneShot
				currentFrame = currentFrame + paramsDirection
				if currentFrame > totalFrames then
					currentIteration += 1
					currentFrame = if params.RepeatCount ~= -1 and currentIteration >= params.RepeatCount then totalFrames else 1
				elseif currentFrame < 1 then
					currentIteration += 1
					currentFrame = if params.RepeatCount ~= -1 and currentIteration >= params.RepeatCount then 1 else totalFrames
				end
			end

			frameCount += 1

			task.wait(waitDuration)
			if self._flipbookPaused then
				self.Signals.FlipbookUnpaused:Wait()
			end
			
			if params.RepeatCount ~= -1 and currentIteration >= params.RepeatCount then
				if params.Reset then
					local currentFrame = 1
					local column = ((currentFrame - 1) % gridSize) + 1
					local row = math.floor((currentFrame - 1) / gridSize) + 1
					imageLabel.ImageRectOffset = Vector2.new((column - 1) * gridResolution, (row - 1) * gridResolution)
				end
				break
			end
		end
		finished = true
		self.Signals.FlipbookEnded:Fire(finished)
	end))
	
	self._flipbookTrove:Add(function()
		if not finished then
			self.Signals.FlipbookEnded:Fire(finished)
		end
	end)
	
	return self
end

-- Pauses any active flipbook animations.
function MT.PauseFlipbook(self: WrappedGuiImage)
	self._flipbookPaused = true
	self.Signals.FlipbookPaused:FireDefer()
end

-- Resumes any active flipbook animations.
function MT.UnpauseFlipbook(self: WrappedGuiImage)
	self._flipbookPaused = false
	self.Signals.FlipbookUnpaused:FireDefer()
end

-- Cancels any active flipbook.
-- <strong>reset</strong>: Resets offset back to starting position (0, 0).
function MT.CancelFlipbook(self: WrappedGuiImage, reset: boolean?)
	if not self._activeFlipbook then
		return
	end
	if reset then
		(self._imageLabel :: any).ImageRectOffset = Vector2.zero
	end
	self._flipbookTrove:Clean()
	self._activeFlipbook = nil
end

-----------------------------
-- SETTERS --
-----------------------------

-----------------------------
-- GETTERS --
-----------------------------

function MT.GetImage(self: WrappedGuiImage): ImageLabel | ImageButton
	return self._imageLabel
end

function MT.GetTrove(self: WrappedGuiImage): ModuleUtils.TroveType
	return self._trove
end

function MT.GetUserData(self: WrappedGuiImage): { [any]: any }
	return self._userData
end

-----------------------------
-- CLEANUP --
-----------------------------

function MT.Destroy(self: WrappedGuiImage)
	self._trove:Clean()
end

-----------------------------
-- MAIN --
-----------------------------
return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043a6</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX54A88B18C97B41F28176CF79C1182231">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025cf6</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_GuiButtonClass</string>
							<string name="ScriptGuid">{64FC8CC3-B456-4A43-AA7B-2561D2E4AE09}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire & CoderActual
--@date: 8/9/24
--[[@description:
	Wrapper class for GuiButtons. Chainable functions for GuiButtons!
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local ModuleUtils = require("../ModuleUtils")
local FunctionUtils = require("../FunctionUtils")
local Signal = ModuleUtils.Signal
local Trove = ModuleUtils.Trove
local Input = require("./_Input")

-----------------------------
-- TYPES --
-----------------------------
export type ButtonTweenInfo = {
	BackgroundColor3: TweenInfo?,
	Size: TweenInfo?,
	Position: TweenInfo?,
	Rotation: TweenInfo?
}
type TweenableProperties = {
	BackgroundColor3: Color3?,
	Size: UDim2?,
	Position: UDim2?,
	Rotation: number?,
}
export type ButtonTheme = {
	Properties: {
		Enter: TweenableProperties,
		Exit: TweenableProperties,
	},

	EnterTweenInfo: ButtonTweenInfo,
	ExitTweenInfo: ButtonTweenInfo
}
export type ButtonThemeModification = {
	Properties: {
		Enter: TweenableProperties?,
		Exit: TweenableProperties?
	}?,

	EnterTweenInfo: ButtonTweenInfo?,
	ExitTweenInfo: ButtonTweenInfo?
}

-- This is for all of the properties of an object made from this class for type annotation purposes.

type self = {
	-- Private members
	_trove: ModuleUtils.TroveType,
	_shadowTrove: ModuleUtils.TroveType, -- cleaned each hover
	_shadowLifetimeTrove: ModuleUtils.TroveType, -- cleaned when dropshadow is removed
	_button: GuiButton,
	_originalPosition: UDim2, -- capture the button's original position
	_buttonProperties: ButtonProperties,
	_shadowProperties: ShadowProperties,
	_activeTweens: {
		Enter: { [string]: Tween },
		Exit: { [string]: Tween }
	},
	_deselectGroup: string,
	_shimmerTrove: ModuleUtils.TroveType, -- cleaned when shimmer is removed
	_shimmer: GuiObject?,
	_shadow: GuiObject?,
	
	-- Conditions
	_debounce: boolean,
	_isLocked: boolean, -- Stops any user input.
	_isSelected: boolean,
	_shimmerEnabled: boolean,
	_shadowEnabled: boolean,
	_isHovering: boolean,
	_doClickSound: boolean,
	_doHoverSound: boolean,
	_hasActiveInput: boolean, -- boolean is true if input begins on button and has not ended yet
	
	-- Public members
	Signals: {
		Selected: ModuleUtils.SignalType<(user: "Player" | "Script", inputObj: InputObject?) -> (), ("Player" | "Script", InputObject?)>,
		Deselected: ModuleUtils.SignalType<(user: "Player" | "Script", inputObj: InputObject?) -> (), ("Player" | "Script", InputObject?)>,
		Activated: ModuleUtils.SignalType<(user: "Player" | "Script", inputObj: InputObject?, clickCount: number) -> (), ("Player" | "Script", InputObject?, number)>,
		InputBegan: ModuleUtils.SignalType<(input: InputObject) -> (), (InputObject)>,
		InputEnded: ModuleUtils.SignalType<(input: InputObject) -> (), (InputObject)>,
		InputChanged: ModuleUtils.SignalType<(input: InputObject) -> (), (InputObject)>,
		MouseEnter: ModuleUtils.SignalType<(x: number, y: number) -> (), (number, number)>,
		MouseLeave: ModuleUtils.SignalType<(x: number, y: number) -> (), (number, number)>,
	}
}
type Signals = "Selected" | "Deselected" | "Activated" | "MouseEnter" | "MouseLeave"

type ButtonProperties = {
	HoverTheme: ButtonTheme,
	SelectionTheme: ButtonTheme,
	AutoDeselect: boolean,
	OneClick: boolean,
	
	ClickSound: Sound,
	HoverSound: Sound
}
export type ButtonParams = {
	AutoDeselect: boolean?,
	OneClick: boolean?,
	
	ClickSound: Sound?,
	HoverSound: Sound?

	--HoverColor: Color3?,
	--HoverBorderColor: Color3?,
	--HoverBorderLineJoinMode: Enum.LineJoinMode?,
	----HoverInfoPanel: MouseHoverPanelProperties?,
	--HoverBorderThickness: number?,
}

type ShadowProperties = {
	XOffset: number,
	YOffset: number,
}

export type ShadowParams = {
	BackgroundColor3: Color3?,
	XOffset: number,
	YOffset: number,
	BackgroundTransparency: number?,
	Parent: Instance?,
}

export type ShimmerParams = {
	Color: ColorSequence?,
	Rotation: number?,
}
-----------------------------
-- VARIABLES --
-----------------------------
local GuiButtonClass = {}
local MT = {}
MT.__index = MT
export type WrappedGuiButton = typeof(setmetatable({} :: self, MT))

local logger = ModuleUtils.Logger.new(script.Name)
local buttonCache = {} :: { WrappedGuiButton }
local deselectGroups = {
	DEFAULT = {}
}
local touch = Input.Touch.new()

-- CONSTANTS --
local DEFAULT_SOUNDS = {
	HOVER = FunctionUtils.Game.createSound({SoundId = "rbxassetid://9126031928", Volume = 1}),
	CLICK = FunctionUtils.Game.createSound({SoundId = "rbxassetid://9125418953", Volume = 2}),
}

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------
local applyInputEnterTheme, applyMouseLeaveTheme, applySelectedTheme, applyDeselectedTheme

function applyInputEnterTheme(self: WrappedGuiButton)
	local hoverTheme = self._buttonProperties.HoverTheme
	local selectionTheme = self._buttonProperties.SelectionTheme
	local enterTweenInfo = hoverTheme.EnterTweenInfo

	do
		-- cancel any tweens!
		local names = { "HoverColor", "HoverSize", "HoverPosition", "HoverRotation" }

		for _, name in ipairs(names) do
			if self._activeTweens.Exit[name] then
				self._activeTweens.Exit[name]:Cancel()
				self._activeTweens.Exit[name] = nil
			end
		end
	end

	for name, value in pairs(hoverTheme.Properties.Enter) do
		if self:IsSelected() and selectionTheme.Properties.Enter[name] then
			-- Selection theme takes priority for this property!
			warn(`Property: {name} is overriden by selection theme.`)
			continue
		elseif not self:IsSelected() and selectionTheme.Properties.Exit[name] then
			-- Selection theme takes priority for this property!
			warn(`Property: {name} is overriden by selection theme.`)
			continue
		end

		if enterTweenInfo[name] then
			local goal = {}
			if name == "BackgroundColor3" then
				goal[name] = value
			else
				-- add original value + new offset
				goal[name] = hoverTheme.Properties.Exit[name] + value
			end

			local tween = TweenService:Create(self._button, enterTweenInfo[name], goal)
			self._activeTweens.Enter[`Hover{name}`] = tween
			tween:Play()
		else
			local button = self._button :: any -- resolves a type annotation issue
			if name == "BackgroundColor3" then
				button[name] = value
			else
				-- add original value + new offset
				button[name] = hoverTheme.Properties.Exit[name] + value
			end
		end
	end
end

function applyMouseLeaveTheme(self: WrappedGuiButton)
	local hoverTheme = self._buttonProperties.HoverTheme
	local selectionTheme = self._buttonProperties.SelectionTheme
	local exitTweenInfo = hoverTheme.ExitTweenInfo

	do
		-- cancel any tweens!
		local names = { "HoverColor", "HoverSize", "HoverPosition", "HoverRotation" }

		for _, name in ipairs(names) do
			if self._activeTweens.Enter[name] then
				self._activeTweens.Enter[name]:Cancel()
				self._activeTweens.Enter[name] = nil
			end
		end
	end

	for name, value in pairs(hoverTheme.Properties.Exit) do
		if self:IsSelected() and selectionTheme.Properties.Enter[name] then
			-- Selection theme takes priority for this property!
			warn(`Property: {name} is overriden by selection theme.`)
			continue
		elseif not self:IsSelected() and selectionTheme.Properties.Exit[name] then
			-- Selection theme takes priority for this property!
			warn(`Property: {name} is overriden by selection theme.`)
			continue
		end

		if exitTweenInfo[name] then
			local goal = {}
			if name == "BackgroundColor3" then
				goal[name] = value
			else
				goal[name] = value
			end

			local tween = TweenService:Create(self._button, exitTweenInfo[name], goal)
			self._activeTweens.Enter[`Hover{name}`] = tween
			tween:Play()
		else
			local button = self._button :: any -- resolves a type annotation issue
			if name == "BackgroundColor3" then
				button[name] = value
			else
				button[name] = value
			end
		end
	end
end

function applySelectedTheme(self: WrappedGuiButton)
	local selectionTheme = self._buttonProperties.SelectionTheme
	local enterTweenInfo = selectionTheme.EnterTweenInfo

	do
		-- cancel any tweens!
		local names = { "SelectionColor", "SelectionSize", "SelectionPosition", "SelectionRotation" }

		for _, name in ipairs(names) do
			if self._activeTweens.Exit[name] then
				self._activeTweens.Exit[name]:Cancel()
				self._activeTweens.Exit[name] = nil
			end
		end
	end

	for name, value in pairs(selectionTheme.Properties.Enter) do
		if enterTweenInfo[name] then
			local goal = {}
			if name == "BackgroundColor3" then
				goal[name] = value
			else
				-- add original value + new offset
				goal[name] = selectionTheme.Properties.Exit[name] + value
			end

			local tween = TweenService:Create(self._button, enterTweenInfo[name], goal)
			self._activeTweens.Enter[`Selection{name}`] = tween
			tween:Play()
		else
			local button = self._button :: any -- resolves a type annotation issue
			if name == "BackgroundColor3" then
				button[name] = value
			else
				-- add original value + new offset
				button[name] = selectionTheme.Properties.Exit[name] + value
			end
		end
	end
end

function applyDeselectedTheme(self: WrappedGuiButton)
	local selectionTheme = self._buttonProperties.SelectionTheme
	local exitTweenInfo = selectionTheme.ExitTweenInfo

	do
		-- cancel any tweens!
		local names = { "SelectionColor", "SelectionSize", "SelectionPosition", "SelectionRotation" }

		for _, name in ipairs(names) do
			if self._activeTweens.Enter[name] then
				self._activeTweens.Enter[name]:Cancel()
				self._activeTweens.Enter[name] = nil
			end
		end
	end

	for name, value in pairs(selectionTheme.Properties.Exit) do
		if exitTweenInfo[name] then
			local goal = {}
			if name == "BackgroundColor3" then
				goal[name] = value
			else
				goal[name] = value
			end

			local tween = TweenService:Create(self._button, exitTweenInfo[name], goal)
			self._activeTweens.Enter[`Hover{name}`] = tween
			tween:Play()
		else
			local button = self._button :: any -- resolves a type annotation issue
			if name == "BackgroundColor3" then
				button[name] = value
			else
				button[name] = value
			end
		end
	end
end

local function updateDeselectGroup(groupName: string)
	for _, button in ipairs(GuiButtonClass:GetDeselectGroupByName(groupName)) do
		if button:IsSelected() and button:IsAutoDeselect() then
			button:Deselect()
		end
	end
end

local function onButtonActivated(self: WrappedGuiButton, inputObj: InputObject?, clickCount: number)
	if self:OnDebounce() then
		return
	end
	if self:CanDoClickSound() then
		FunctionUtils.Game.playSoundClone(self._buttonProperties.ClickSound, game:GetService("SoundService"))
	end
	local userOverride: any = if inputObj then "Player" else "Script"
	
	if self:IsSelected() then
		self:Deselect(userOverride, inputObj)
	else
		self:Select(userOverride, inputObj)
		if self:IsOneClick() then
			self:Deselect(userOverride, inputObj)
		end
	end
	self.Signals.Activated:FireDefer("Player", inputObj, clickCount)
end

local function getDefaultTheme(): ButtonTheme
	local theme: ButtonTheme = {
		Properties = {
			Enter = {},
			Exit = {},
		},
		EnterTweenInfo = {},
		ExitTweenInfo = {}
	}
	return theme
end

local function getDefaultShadowParams(): ShadowParams
	return {
		BackgroundTransparency = 0.5,
		XOffset = 5,
		YOffset = 5,
		BackgroundColor3 = Color3.new(0, 0, 0),
	}
end

local function createShimmerEffect(self: WrappedGuiButton, params: ShimmerParams?): (GuiObject, UIGradient)
	local shimmerEffect: GuiObject = if self._button:IsA("ImageButton") then Instance.new("ImageLabel") else Instance.new("Frame")
	if shimmerEffect:IsA("ImageLabel") then
		local button = self._button :: ImageButton
		shimmerEffect.Image = button.Image
		shimmerEffect.ImageColor3 = Color3.new(1, 1, 1)
		shimmerEffect.ScaleType = button.ScaleType
		shimmerEffect.SliceCenter = button.SliceCenter
	else
		local uiCorner = self._button:FindFirstChildWhichIsA("UICorner")
		if uiCorner then
			local uiCornerClone = uiCorner:Clone()
			uiCornerClone.Parent = shimmerEffect
		end
	end
	
	FunctionUtils.Interface.center(shimmerEffect)
	shimmerEffect.Size = UDim2.fromScale(1, 1)
	shimmerEffect.BackgroundTransparency = 0
	shimmerEffect.ZIndex = 1000
	
	local uiGradient = Instance.new("UIGradient")
	local whiteColorSequence = ColorSequence.new(Color3.new(1, 1, 1))
	uiGradient.Color = if params and params.Color then params.Color else whiteColorSequence
	uiGradient.Rotation = if params and params.Rotation then params.Rotation else 25
	uiGradient.Parent = shimmerEffect
	uiGradient.Offset = Vector2.new(-1, 0)
	uiGradient.Transparency = NumberSequence.new{
		NumberSequenceKeypoint.new(0, 1),
		NumberSequenceKeypoint.new(0.3, 1),
		NumberSequenceKeypoint.new(0.5, .2),
		NumberSequenceKeypoint.new(0.7, 1),
		NumberSequenceKeypoint.new(1, 1),
	}
	
	shimmerEffect.Parent = self._button
	
	return shimmerEffect, uiGradient
end

local function createDropShadow(self: WrappedGuiButton, params: ShadowParams) : GuiObject
	local screenGui = self._button:FindFirstAncestorWhichIsA("ScreenGui") :: ScreenGui
	if not screenGui then
		warn("Failed to get ScreenGui")
	end
	
	local dropShadow = Instance.new("Frame")
	local buttonPos = if screenGui.ZIndexBehavior == Enum.ZIndexBehavior.Sibling then UDim2.fromScale(.5,.5) else self._button.Position
	dropShadow.Size = if screenGui.ZIndexBehavior == Enum.ZIndexBehavior.Sibling then UDim2.fromScale(1, 1) else self._button.Size
	dropShadow.AnchorPoint = self._button.AnchorPoint
	dropShadow.Position = UDim2.new(buttonPos.X.Scale, buttonPos.X.Offset + params.XOffset, buttonPos.Y.Scale, buttonPos.Y.Offset + params.YOffset)
	dropShadow.BackgroundColor3 = params.BackgroundColor3 or Color3.new(0, 0, 0)
	dropShadow.BackgroundTransparency = params.BackgroundTransparency or 0.5
	dropShadow.ZIndex = self._button.ZIndex - 1
	
	local uiCorner = self._button:FindFirstChildWhichIsA("UICorner")
	if uiCorner then
		local uiCornerClone = uiCorner:Clone()
		uiCornerClone.Parent = dropShadow
	end
	
	local uiAspectRatio = self._button:FindFirstChildWhichIsA("UIAspectRatioConstraint")
	if uiAspectRatio then
		local uiAspectRatioClone = uiAspectRatio:Clone()
		uiAspectRatioClone.Parent = dropShadow
	end
	
	dropShadow.Visible = self._button.Visible
	dropShadow.Parent = params.Parent or self._button.Parent
	self._shadowLifetimeTrove:Connect(self._button:GetPropertyChangedSignal("Visible"), function()
		dropShadow.Visible = self._button.Visible
	end)
	self._shadowLifetimeTrove:Connect(self._button:GetPropertyChangedSignal("Rotation"), function()
		dropShadow.Rotation = self._button.Rotation
	end)
	self._shadowLifetimeTrove:Connect(self._button:GetPropertyChangedSignal("Size"), function()
		dropShadow.Size = self._button.Size
	end)
	
	return dropShadow
end
-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

function GuiButtonClass.new(button: GuiButton, params: ButtonParams?): WrappedGuiButton
	assert(button:IsA("GuiButton"), "Must be a GuiButton!")
	local obj =  GuiButtonClass:GetObjectByButton(button)
	if obj then
		return obj
	end
	local self = setmetatable({} :: self, MT)

	self._trove = Trove.new()
	self._shadowTrove = self._trove:Construct(Trove)
	self._shadowLifetimeTrove = self._trove:Construct(Trove)
	self._shimmerTrove = self._trove:Construct(Trove)
	self._button = button
	self._originalPosition = button.Position
	self._buttonProperties = {
		HoverTheme = getDefaultTheme(),
		SelectionTheme = getDefaultTheme(),
		AutoDeselect = if params and params.AutoDeselect ~= nil then params.AutoDeselect else false,
		OneClick = if params and params.OneClick ~= nil then params.OneClick else false,
		HoverSound = if params and params.HoverSound then params.HoverSound else DEFAULT_SOUNDS.HOVER,
		ClickSound = if params and params.ClickSound then params.ClickSound else DEFAULT_SOUNDS.CLICK,
	}
	self._shadowProperties = {
		XOffset = 0,
		YOffset = 0
	}
	self._activeTweens = {
		Enter = {},
		Exit = {}
	}
	self._deselectGroup = "DEFAULT"

	-- conditions
	self._shimmerEnabled = false
	self._shadowEnabled = false
	self._isLocked = false
	self._isSelected = false
	self._isHovering = false
	self._debounce = false
	self._doClickSound = false
	self._doHoverSound = false
	self._hasActiveInput = false

	self.Signals = {
		Selected = self._trove:Add(Signal.new()),
		Deselected = self._trove:Add(Signal.new()),
		Activated = self._trove:Add(Signal.new()),
		MouseEnter = self._trove:Add(Signal.wrap(button.MouseEnter)),
		MouseLeave = self._trove:Add(Signal.wrap(button.MouseLeave)),
		InputBegan = self._trove:Add(Signal.wrap(button.InputBegan)),
		InputEnded = self._trove:Add(Signal.wrap(button.InputEnded)),
		InputChanged = self._trove:Add(Signal.wrap(button.InputChanged))
	}

	self._trove:Connect(button.Activated, function(inputObj, clickCount)
		if self:IsLocked() then
			return
		end
		onButtonActivated(self, inputObj, clickCount)
	end)
	local shadowTweenMouseEnter, shadowTweenMouseLeave
	function shadowTweenMouseEnter()
		if not self._shadow or not self:IsShadowEnabled() then
			return
		end
		self._shadowTrove:Clean()
		
		local origPos = self._originalPosition
		local tween = TweenService:Create(self._button, TweenInfo.new(0.1), {Position = self._originalPosition + UDim2.fromOffset(self._shadowProperties.XOffset, self._shadowProperties.YOffset)})
		self._shadowTrove:Add(function()
			if tween.PlaybackState == Enum.PlaybackState.Playing then
				tween:Cancel()
			end
		end)
		tween:Play()
		self._shadowTrove:Add(tween.Completed:Once(function(state)
			if state ~= Enum.PlaybackState.Completed then
				return
			end
			self._shadow.Visible = false
			if not self:HasActiveInput() then
				shadowTweenMouseLeave()
			end
		end))
	end
	
	function shadowTweenMouseLeave()
		if not self._shadow or not self:IsShadowEnabled() then
			return
		end
		self._shadowTrove:Clean()
		local tween = TweenService:Create(self._button, TweenInfo.new(0.1), {Position = self._originalPosition})
		self._shadowTrove:Add(function()
			if tween.PlaybackState == Enum.PlaybackState.Playing then
				tween:Cancel()
			end
		end)
		tween:Play()
		self._shadow.Visible = true
		self._shadowTrove:Add(tween.Completed:Once(function(state)
			if state ~= Enum.PlaybackState.Completed then
				return
			end
			if self:HasActiveInput() then
				shadowTweenMouseEnter()
			end
		end))
	end
	
	self._trove:Connect(button.InputBegan, function(input: InputObject)
		if 
			input.UserInputType ~= Enum.UserInputType.MouseMovement
			and input.UserInputType ~= Enum.UserInputType.Touch
			and input.UserInputType ~= Enum.UserInputType.Gamepad1
		then
			return
		end
		local usingTouch, touchObj = touch:IsUsingThumbstickControls()
		if usingTouch and touchObj then
			-- avoid if this input is actively interacting with thumbstick
			if input == touchObj then
				return
			end
		end
		if self:IsLocked() then
			return
		end
		if self:HasActiveInput() then
			-- This could likely be a second finger attempting to interact with the button, so ignore.
			logger:print("Ignoring other input on button.")
			return
		end
		self._hasActiveInput = true
		applyInputEnterTheme(self)
		
		if self:CanDoHoverSound() then
			FunctionUtils.Game.playSoundClone(self._buttonProperties.HoverSound, game:GetService("SoundService"))
		end
		
		if self._shadow and self:IsShadowEnabled() then
			shadowTweenMouseEnter()
		end
		
		if self._shimmer and self:IsShimmerEnabled() then
			self._shimmer.Visible = false
		end
	end)
	self._trove:Connect(button.InputEnded, function(input)
		if 
			input.UserInputType ~= Enum.UserInputType.MouseMovement
			and input.UserInputType ~= Enum.UserInputType.Touch
			and input.UserInputType ~= Enum.UserInputType.Gamepad1
		then
			return
		end
		if not self:HasActiveInput() then
			return
		end
		self._hasActiveInput = false
		applyMouseLeaveTheme(self)
		if self._shadow and self:IsShadowEnabled() then
			shadowTweenMouseLeave()
		end
		
		if self._shimmer and self:IsShimmerEnabled() then
			self._shimmer.Visible = true
		end
	end)
	self._trove:Connect(button.Destroying, function()
		self:Destroy()
	end)

	table.insert(deselectGroups.DEFAULT, self)
	table.insert(buttonCache, self)
	
	return self
end

function GuiButtonClass:GetObjectByButton(button: GuiButton): WrappedGuiButton?
	for _, buttonObj in ipairs(buttonCache) do
		if buttonObj._button == button then
			return buttonObj
		end
	end
	return nil
end

function GuiButtonClass:GetDeselectGroupByName(name: string): { WrappedGuiButton }
	return if deselectGroups[name] then deselectGroups[name] else {}
end

function GuiButtonClass:GetSelectedButtons(): { WrappedGuiButton }
	local result = {}
	for _, button in ipairs(buttonCache) do
		if button:IsSelected() then
			table.insert(result, button)
		end
	end
	return result
end

function GuiButtonClass:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")
	return getmetatable(object).__index == MT
end

-----------------------------
-- CHAINABLE METHODS --
-----------------------------

-- Call a function within the method chain that is given the button object as an argument.
function MT.Call(self: WrappedGuiButton, callback: (buttonObj: WrappedGuiButton) -> ()): WrappedGuiButton
	task.spawn(callback, self)
	return self
end

function MT.ModifyTheme(self: WrappedGuiButton, which: "Hover" | "Selection", themeModification: ButtonThemeModification): WrappedGuiButton
	local themeName = `{which}Theme`
	local currentTheme = self._buttonProperties[themeName] :: ButtonTheme
	local newTheme = FunctionUtils.Table.reconcile(themeModification, currentTheme) :: ButtonTheme
	
	for name, info in pairs(newTheme.EnterTweenInfo) do
		if not newTheme.ExitTweenInfo[name] then
			newTheme.ExitTweenInfo[name] = info
		end
	end
	for propertyName, _ in pairs(newTheme.Properties.Enter) do
		local button = self._button :: any -- fixes type annotation issue
		if not newTheme.Properties.Exit[propertyName] then
			newTheme.Properties.Exit[propertyName] = button[propertyName]
		end
	end
	
	self._buttonProperties[themeName] = newTheme
	return self
end

-- Places the button in a debounce state.
-- Prevents the button from being interacted with, including client and scripts.
function MT.Debounce(self: WrappedGuiButton, debounce: boolean?): WrappedGuiButton
	self._debounce = if debounce then debounce else false
	return self
end

-- <strong><code>!YIELDS!</code></strong>
-- Prevents the button from being interacted with (client and scripts) for the given <strong>duration</strong>.
function MT.DebounceYield(self: WrappedGuiButton, duration: number): WrappedGuiButton
	self._debounce = true
	task.wait(duration)
	self._debounce = false
	return self
end

function MT.ToggleShimmer(self: WrappedGuiButton, enable: boolean?, params: ShimmerParams?): WrappedGuiButton
	if enable and self:IsShimmerEnabled() then
		return self
	elseif not enable and not self:IsShimmerEnabled() then
		return self
	end
	
	self._shimmerEnabled = if enable ~= nil then enable else false
	
	if self:IsShimmerEnabled() then
		local shimmer, gradient = createShimmerEffect(self, params)
		self._shimmerTrove:Add(shimmer)
		local tween = TweenService:Create(gradient, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, -1, false, 1), {Offset = Vector2.new(1, 0)})
		tween:Play()
		self._shimmerTrove:Add(tween)
		self._shimmer = shimmer
	else
		self._shimmerTrove:Clean()
		self._shimmer = nil
	end

	return self
end

function MT.ToggleDropShadow(self: WrappedGuiButton, enable: boolean?, params: ShadowParams?): WrappedGuiButton
	if enable and self:IsShadowEnabled() then
		return self
	elseif not enable and not self:IsShadowEnabled() then
		return self
	end
	
	local params = params or getDefaultShadowParams()
	self._shadowProperties.XOffset = params.XOffset
	self._shadowProperties.YOffset = params.YOffset
	
	self._shadowEnabled = if enable ~= nil then enable else false
	
	if self:IsShadowEnabled() then
		self._shadow = createDropShadow(self, params)
		self._shadowLifetimeTrove:Add(self._shadow)
	elseif self._shadow then
		self._shadowLifetimeTrove:Clean()
		self._shadow = nil
	end

	return self
end

-- Sound when the button is clicked?
function MT.ToggleClickSound(self: WrappedGuiButton, enable: boolean?): WrappedGuiButton
	self._doClickSound = if enable then true else false
	return self
end

-- Sound when the mouse hovers over the button?
function MT.ToggleHoverSound(self: WrappedGuiButton, enable: boolean?): WrappedGuiButton
	self._doHoverSound = if enable then true else false
	return self
end

function MT.ToggleAutoDeselect(self: WrappedGuiButton, enable: boolean?): WrappedGuiButton
	self._buttonProperties.AutoDeselect = if enable ~= nil then enable else false
	local numOfSelected = #GuiButtonClass:GetSelectedButtons()
	if enable and numOfSelected > 1 and self:IsSelected() then
		self:Deselect()
	end
	return self
end

-- Mark the button in a specific group for auto-deselect purposes
function MT.SetAutoDeselectGroup(self: WrappedGuiButton, groupName: string?): WrappedGuiButton
	local groupName = groupName or "DEFAULT"
	if not deselectGroups[groupName] then
		deselectGroups[groupName] = {}
	end
	
	for _, group in deselectGroups do
		local i = table.find(group, self)
		if i then
			table.remove(group, i)
		end
	end
	
	if self:IsSelected() then
		updateDeselectGroup(groupName)
	end
	self._deselectGroup = groupName
	table.insert(deselectGroups[groupName], self)
	return self
end

-- Makes the button immediately deselect when selected (acts as one click button)
function MT.ToggleOneClick(self: WrappedGuiButton, enable: boolean?): WrappedGuiButton
	self._buttonProperties.OneClick = if enable ~= nil then enable else false
	if enable and self:IsSelected() then
		self:Deselect()
	end
	return self
end

-- Stops user input from interacting with the button, but not scripts.
function MT.Lock(self: WrappedGuiButton): WrappedGuiButton
	self._isLocked = true
	return self
end

function MT.Unlock(self: WrappedGuiButton): WrappedGuiButton
	self._isLocked = false
	return self
end

function MT.Hide(self: WrappedGuiButton): WrappedGuiButton
	self._button.Visible = false
	return self
end

function MT.Unhide(self: WrappedGuiButton): WrappedGuiButton
	self._button.Visible = true
	return self
end

function MT.Select(self: WrappedGuiButton, userOverride: ("Player" | "Script")?, inputObj: InputObject?): WrappedGuiButton
	if self:OnDebounce() then
		return self
	end
	if not self:IsOneClick() then
		-- Deselect others only when this button is not a one-click button.
		updateDeselectGroup(self._deselectGroup)
	end
	self._isSelected = true
	applySelectedTheme(self)
	self.Signals.Selected:FireDefer(userOverride or "Script", inputObj)
	return self
end

function MT.Deselect(self: WrappedGuiButton, userOverride: ("Player" | "Script")?, inputObj: InputObject?): WrappedGuiButton
	if self:OnDebounce() then
		return self
	end
	self._isSelected = false
	applyDeselectedTheme(self)
	self.Signals.Deselected:FireDefer(userOverride or "Script", inputObj)
	return self
end

-- Manually activate the button through scripts. This bypasses input lock if the button is locked via <code>:Lock()</code>
-- You can optionally provide an <code>InputObject</code> if the button is being activated by client-input but needs to bypass the :Lock()
-- This does NOT bypass debounces.
function MT.Activate(self: WrappedGuiButton, inputObj: InputObject?): WrappedGuiButton
	onButtonActivated(self, nil, 1)
	return self
end

-- Shorthand for <code>:GetButton().Visible</code>
function MT.SetVisible(self: WrappedGuiButton, visible: boolean?): WrappedGuiButton
	self._button.Visible = visible or false
	return self
end

-- Shorthand for <code>:GetButton().AutoButtonColor</code>
function MT.SetAutoColor(self: WrappedGuiButton, auto: boolean?): WrappedGuiButton
	self._button.AutoButtonColor = auto or false
	return self
end

-----------------------------
-- REGULAR METHODS --
-----------------------------

function MT.GetButton(self: WrappedGuiButton): GuiButton
	return self._button
end

function MT.CanDoClickSound(self: WrappedGuiButton): boolean
	return self._doClickSound
end

function MT.CanDoHoverSound(self: WrappedGuiButton): boolean
	return self._doHoverSound
end

function MT.IsLocked(self: WrappedGuiButton): boolean
	return self._isLocked
end

function MT.IsHidden(self: WrappedGuiButton): boolean
	return self._button.Visible
end

function MT.IsMouseHovering(self: WrappedGuiButton): boolean
	return self._isHovering
end

function MT.IsAutoDeselect(self: WrappedGuiButton): boolean
	return self._buttonProperties.AutoDeselect
end

function MT.IsOneClick(self: WrappedGuiButton): boolean
	return self._buttonProperties.OneClick
end

-- Returns a boolean signifying if the button has an active input from the client.
function MT.HasActiveInput(self: WrappedGuiButton): boolean
	return self._hasActiveInput
end

function MT.IsShimmerEnabled(self: WrappedGuiButton): boolean
	return self._shimmerEnabled
end

function MT.IsShadowEnabled(self: WrappedGuiButton) : boolean
	return self._shadowEnabled
end

function MT.IsSelected(self: WrappedGuiButton): boolean
	return self._isSelected
end

function MT.OnDebounce(self: WrappedGuiButton): boolean
	return self._debounce
end

function MT.Destroy(self: WrappedGuiButton)
	self._trove:Clean()
	table.remove(buttonCache, table.find(buttonCache, self))
	table.remove(deselectGroups[self._deselectGroup], table.find(deselectGroups[self._deselectGroup], self))
end

-----------------------------
-- MAIN --
-----------------------------
return GuiButtonClass]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043a7</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5C0E625DCD34421081A559683DD6FD9B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc082180130000967b</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_StreamableUtil</string>
							<string name="ScriptGuid">{B7361131-5041-4C8E-9396-9A8335A828C0}</string>
							<ProtectedString name="Source"><![CDATA[--!strict

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- StreamableUtil
-- Stephen Leitnick
-- March 03, 2021

local Trove = require("../ModuleUtils/_Trove")
local Streamable = require(script.Parent._Streamable)

type Streamables = { Streamable.StreamableType }
type CompoundHandler = (Streamables, any) -> nil

--[=[
	@class StreamableUtil
	@client
	A utility library for the Streamable class.

	```lua
	local StreamableUtil = require(packages.Streamable).StreamableUtil
	```
]=]
local StreamableUtil = {}

--[=[
	@param streamables {Streamable}
	@param handler ({[child: string]: Instance}, trove: Trove) -> nil
	@return Trove

	Creates a compound streamable around all the given streamables. The compound
	streamable's observer handler will be fired once _all_ the given streamables
	are in existence, and will be cleaned up when _any_ of the streamables
	disappear.

	```lua
	local s1 = Streamable.new(workspace, "Part1")
	local s2 = Streamable.new(workspace, "Part2")

	local compoundTrove = StreamableUtil.Compound({S1 = s1, S2 = s2}, function(streamables, trove)
		local part1 = streamables.S1.Instance
		local part2 = streamables.S2.Instance
		trove:Add(function()
			print("Cleanup")
		end)
	end)
	```
]=]
function StreamableUtil.Compound(streamables: Streamables, handler: CompoundHandler)
	local compoundTrove = Trove.new()
	local observeAllTrove = Trove.new()
	local allAvailable = false
	local function Check()
		if allAvailable then
			return
		end
		for _, streamable in pairs(streamables) do
			if not streamable.Instance then
				return
			end
		end
		allAvailable = true
		handler(streamables, observeAllTrove)
	end
	local function Cleanup()
		if not allAvailable then
			return
		end
		allAvailable = false
		observeAllTrove:Clean()
	end
	for _, streamable in pairs(streamables) do
		compoundTrove:Add(streamable:Observe(function(_child, trove)
			Check()
			trove:Add(Cleanup)
		end))
	end
	compoundTrove:Add(Cleanup)
	return compoundTrove
end

return StreamableUtil]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043a8</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX01E5D46850E7428BB9FAF66D35CA536C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025cf8</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_WindLineCreator</string>
							<string name="ScriptGuid">{8BE89422-50F4-46D9-A727-7E781BD3CFF5}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 6/17/25
--[[@description:
	An object that creates wind-like streams around the player's character.
	
	Improved & type annotation version of onses' WindService:
	https://devforum.roblox.com/t/wind-effect-customizable-module/1024867
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local FunctionUtils = require("../FunctionUtils")
local Trove = require("../ModuleUtils/_Trove")
local Future = require("../ModuleUtils/_Future")
local t = FunctionUtils.t

-----------------------------
-- TYPES --
-----------------------------
-- For all of the properties/fields of an object made from this class.
type fields = {
	_trove: Trove.TroveType,
	_userData: { [any]: any },
	_startTrove: Trove.TroveType,
	
	_container: any,
	_randomized: boolean,
	_velocity: Vector3,
	_matchGlobalWind: boolean,
	_maxCount: number,
	_lifetimeInSeconds: number,
	_frequency: number,
	_amplitude: number,
	_cameraRange: number,
	_spawnDelay: number,
	_color: ColorSequence,
	_widthScale: NumberSequence,
	
	_activeWind: { { Part: WindPart, CreationTimestamp: number } },
	_active: boolean,
	
	_count: number
}

type WindPart = typeof(script.Wind)

export type WindLineCreatorParams = {
	Container: Instance?, -- where wind instances are stored
	Randomized: boolean?, -- false by default
	Velocity: Vector3?, -- direction & speed of the wind (if randomzied, the random range will be within Velocity)
	MatchGlobalWind: boolean?, -- false by default
	MaxCount: number?, -- how many wind lines should exist at any given point (default is 5)
	LifetimeInSeconds: number?, -- how long the wind lines live for (default is 2 seconds)
	Frequency: number?, -- for sine wave (default is 0.25)
	Amplitude: number?, -- for sine wave (default is 0.05)
	CameraRange: number?, -- up to how far away wind is generated around the player's camera (default is 50 studs)
	SpawnDelay: number?, -- delay between creating wind objects (default is 0)
	Color: ColorSequence?, -- change the color of the wind lines
	WidthScale: NumberSequence?, -- change the WidthScale of the wind trail
}

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}
local MT = {}
MT.__index = MT
export type WindLineCreator = typeof(setmetatable({} :: fields, MT))

local rng = Random.new(tick())

-- CONSTANTS --
local CAMERA = workspace.CurrentCamera

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-- Returns a future that resolves once the fade is complete.
local function fadeWind(trail: Trail): Future.Future<>
	return Future.new(function(trail: Trail)
		local thread = coroutine.running()
		local start = workspace:GetServerTimeNow()
		local fadeDuration = 2
		local connection
		connection = RunService.PreRender:Connect(function(dt)
			local elapsed = workspace:GetServerTimeNow() - start
			local alpha = math.clamp(elapsed / fadeDuration, 0, 1)
			trail.Transparency = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 1),
				NumberSequenceKeypoint.new(0.3, alpha),
				NumberSequenceKeypoint.new(0.6, alpha),
				NumberSequenceKeypoint.new(1, 1),
			})
			if alpha >= 1 then
				connection:Disconnect()
				task.spawn(thread)
			end
		end)
		coroutine.yield()
	end, trail)
end

-----------------------------
-- CLASS FUNCTIONS --
-----------------------------

--[[
	Creates a new WindLineCreator.
	Will automatically return an already existing creator.
]]
function Module.new(params: WindLineCreatorParams): WindLineCreator
	local self = setmetatable({} :: fields, MT) :: WindLineCreator
	self._trove = Trove.new()
	self._userData = {}
	
	self._startTrove = self._trove:Construct(Trove)
	
	self._container = params.Container or CAMERA
	self._randomized = params.Randomized or false
	self._velocity = (params.Velocity or Vector3.xAxis) / 50
	self._matchGlobalWind = params.MatchGlobalWind or false
	self._maxCount = params.MaxCount or 5
	self._lifetimeInSeconds = params.LifetimeInSeconds or 2
	self._frequency = params.Frequency or 0.25
	self._amplitude = params.Amplitude or 0.05
	self._cameraRange = params.CameraRange or 50
	self._spawnDelay = params.SpawnDelay or 0
	self._color = params.Color or ColorSequence.new(Color3.new(1, 1, 1))
	self._widthScale = params.WidthScale or NumberSequence.new(1, 0)
	
	self._activeWind = {}
	self._active = false
	self._count = 0
	
	self._trove:Connect(RunService.PreRender, function()
		if not self._active then
			return
		end
		if self._velocity.Magnitude == 0 then
			return
		end
		debug.profilebegin("WIND_CREATOR_UPDATE")
		local parts = {}
		local cframes = {}

		for _, info in self._activeWind do
			local elapsedTime = workspace:GetServerTimeNow() - info.CreationTimestamp
			local maxVelocity = self._velocity
			local velocity =
				if self._randomized
				then Vector3.new(
					rng:NextNumber(-maxVelocity.X, maxVelocity.X),
					rng:NextNumber(-maxVelocity.Y, maxVelocity.Y),
					rng:NextNumber(-maxVelocity.Z, maxVelocity.Z)
				)
				else maxVelocity
			local zOffset = self:_CalculateSineWave(self._amplitude, elapsedTime, self._frequency, 0)
			local newCFrame = info.Part.CFrame * CFrame.new(0, 0, zOffset) + velocity

			table.insert(parts, info.Part)
			table.insert(cframes, newCFrame)
		end

		if #parts > 0 then
			workspace:BulkMoveTo(parts, cframes, Enum.BulkMoveMode.FireCFrameChanged)
		end
		debug.profileend()
	end)
	
	if self._matchGlobalWind then
		self._trove:Add(FunctionUtils.Observers.observeProperty(workspace, "GlobalWind", function(globalWind)
			self._velocity = globalWind / 50
			return
		end))
	end
	
	return self
end

function Module:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")

	return getmetatable(object) == MT
end

-----------------------------
-- METHODS --
-----------------------------

--[[
	Creates a new wind line, ignoring any max count limits.
	This is automatically called internally when the creator is started.
]]
function MT.CreateWind(self: WindLineCreator)
	local part = script.Wind:Clone()
	local trail = part.Trail
	trail.Color = self._color
	trail.WidthScale = self._widthScale
	part.Position = self:_GetRandomPosition()
	part.Parent = self._container
	self._count += 1
	local info = {
		Part = part,
		CreationTimestamp = workspace:GetServerTimeNow()
	}
	table.insert(self._activeWind, info)
	task.delay(self._lifetimeInSeconds, function(info, trail)
		fadeWind(trail):After(function()
			local i = table.find(self._activeWind, info)
			if i then
				table.remove(self._activeWind, i)
				self._count -= 1
			end
			info.Part:Destroy()
		end)
	end, info, trail)
end

--[[
	Begins a loop that spawns wind around the player's camera.
]]
function MT.Start(self: WindLineCreator)
	if self:IsActive() then
		return
	end
	self._active = true
	self._startTrove:Add(task.spawn(function()
		while true do
			if self._count < self._maxCount then
				self:CreateWind()
			end
			task.wait(self._spawnDelay)
		end
	end))
end

--[[
	Stops the loop that spawns wind around the player's camera. Any remaining wind will fade out.
]]
function MT.Stop(self: WindLineCreator)
	self._active = false
	self._startTrove:Clean()
end

-----------------------------
-- SETTERS --
-----------------------------

-----------------------------
-- GETTERS --
-----------------------------

function MT.GetTrove(self: WindLineCreator): Trove.TroveType
	return self._trove
end

function MT.GetUserData(self: WindLineCreator): { [any]: any }
	return self._userData
end

function MT.IsActive(self: WindLineCreator): boolean
	return self._active
end

function MT._GetRandomPosition(self: WindLineCreator): Vector3
	local cameraCFrame = CAMERA.CFrame
	return Vector3.new(
		cameraCFrame.Position.X + rng:NextInteger(-self._cameraRange, self._cameraRange),
		cameraCFrame.Position.Y + rng:NextInteger(-5, self._cameraRange / 1.5),
		cameraCFrame.Position.Z + rng:NextInteger(-self._cameraRange, self._cameraRange)
	)
end

@native
function MT._CalculateSineWave(self: WindLineCreator, amp: number, x: number, freq: number, phase: number): number
	return amp * math.sin((x / freq) + phase)
end

-----------------------------
-- CLEANUP --
-----------------------------

function MT.Destroy(self: WindLineCreator)
	self._trove:Clean()
end

-----------------------------
-- MAIN --
-----------------------------
return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043a9</UniqueId>
						</Properties>
						<Item class="Folder" referent="RBXAF6D5D19533E457CAFBC2A9E34A75475">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Wind</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00001b79</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXE3443CA894B04A029D56B11D7F436599">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">77744aa360d6d33c062a35620000735c</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_WindShake</string>
							<string name="ScriptGuid">{AE517E4F-14F6-4953-B97D-8DCD5EFB925D}</string>
							<ProtectedString name="Source"><![CDATA[--[=[

WindShake- High performance wind effect for leaves and foliage
by: boatbomber, CloneTrooper1019

Docs: https://devforum.roblox.com/t/wind-shake-high-performance-wind-effect-for-leaves-and-foliage/1039806/1

--]=]

local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local Settings = require(script.Settings)
local VectorMap = require(script.VectorMap)

local COLLECTION_TAG = "WindShake" -- The CollectionService tag to be watched and mounted automatically

-- Use the script's attributes as the default settings.
-- The table provided is a fallback if the attributes
-- are undefined or using the wrong value types.

local FALLBACK_SETTINGS = {
	WindDirection = Vector3.new(0.5, 0, 0.5),
	WindSpeed = 20,
	WindPower = 0.5,
}

-----------------------------------------------------------------------------------------------------------------

local ObjectShakeAddedEvent = Instance.new("BindableEvent")
local ObjectShakeRemovedEvent = Instance.new("BindableEvent")
local ObjectShakeUpdatedEvent = Instance.new("BindableEvent")
local PausedEvent = Instance.new("BindableEvent")
local ResumedEvent = Instance.new("BindableEvent")

local WindShake = {
	RenderDistance = 150,
	MaxRefreshRate = 1 / 60,
	SharedSettings = Settings.new(script),

	ObjectMetadata = {},
	VectorMap = VectorMap.new(),

	Handled = 0,
	Active = 0,

	_partList = table.create(500),
	_cframeList = table.create(500),

	ObjectShakeAdded = ObjectShakeAddedEvent.Event,
	ObjectShakeRemoved = ObjectShakeRemovedEvent.Event,
	ObjectShakeUpdated = ObjectShakeUpdatedEvent.Event,
	Paused = PausedEvent.Event,
	Resumed = ResumedEvent.Event,
}

export type WindShakeSettings = {
	WindDirection: Vector3?,
	WindSpeed: number?,
	WindPower: number?,
}

function WindShake:Connect(funcName: string, event: RBXScriptSignal): RBXScriptConnection
	local callback = self[funcName]
	assert(typeof(callback) == "function", "Unknown function: " .. funcName)

	return event:Connect(function(...)
		return callback(self, ...)
	end)
end

function WindShake:AddObjectShake(object: BasePart | Bone, settingsTable: WindShakeSettings?)
	if typeof(object) ~= "Instance" then
		return
	end

	if not (object:IsA("BasePart") or object:IsA("Bone")) then
		return
	end

	local metadata = self.ObjectMetadata

	if metadata[object] then
		return
	else
		self.Handled += 1
	end

	metadata[object] = {
		ChunkKey = self.VectorMap:AddObject(
			if object:IsA("Bone") then object.WorldPosition else object.Position,
			object
		),
		Settings = Settings.new(object),

		Seed = math.random(5000) * 0.32,
		Origin = if object:IsA("Bone") then object.WorldCFrame else object.CFrame,
		LastUpdate = os.clock(),
	}

	if settingsTable then
		self:UpdateObjectSettings(object, settingsTable)
	end

	ObjectShakeAddedEvent:Fire(object)
end

function WindShake:RemoveObjectShake(object: BasePart | Bone)
	if typeof(object) ~= "Instance" then
		return
	end

	local metadata = self.ObjectMetadata
	local objMeta = metadata[object]

	if objMeta then
		self.Handled -= 1
		metadata[object] = nil
		objMeta.Settings:Destroy()
		self.VectorMap:RemoveObject(objMeta.ChunkKey, object)

		if object:IsA("BasePart") then
			object.CFrame = objMeta.Origin
		elseif object:IsA("Bone") then
			object.WorldCFrame = objMeta.Origin
		end
	end

	ObjectShakeRemovedEvent:Fire(object)
end

function WindShake:Update(deltaTime: number)
	debug.profilebegin("WindShake")

	local active = 0

	debug.profilebegin("Update")

	local now = os.clock()
	local slowerDeltaTime = deltaTime * 3
	local step = math.min(1, deltaTime * 5)

	-- Reuse tables to avoid garbage collection
	local bulkMoveIndex = 0
	local partList = self._partList
	local cframeList = self._cframeList
	table.clear(partList)
	table.clear(cframeList)

	-- Cache hot values
	local objectMetadata = self.ObjectMetadata
	local camera = workspace.CurrentCamera
	local cameraPos = camera.CFrame.Position
	local renderDistance = self.RenderDistance
	local maxRefreshRate = self.MaxRefreshRate
	local sharedSettings = self.SharedSettings
	local sharedWindPower = sharedSettings.WindPower
	local sharedWindSpeed = sharedSettings.WindSpeed
	local sharedWindDirection = sharedSettings.WindDirection

	-- Update objects in view at their respective refresh rates
	self.VectorMap:ForEachObjectInView(camera, renderDistance, function(className: string, object: BasePart | Bone)
		local objMeta = objectMetadata[object]
		local lastUpdate = objMeta.LastUpdate or 0
		local isBone = className == "Bone"

		-- Determine if the object refresh rate
		local objectCFrame = if isBone then (object :: Bone).WorldCFrame else object.CFrame
		local distanceAlpha = ((cameraPos - objectCFrame.Position).Magnitude / renderDistance)
		local distanceAlphaSq = distanceAlpha * distanceAlpha
		local jitter = (1 / math.random(60, 120))
		local refreshRate = (slowerDeltaTime * distanceAlphaSq) + maxRefreshRate

		if (now - lastUpdate) + jitter <= refreshRate then
			-- It is not yet time to update
			return
		end

		objMeta.LastUpdate = now
		active += 1

		local objSettings = objMeta.Settings

		local windDirection = (objSettings.WindDirection or sharedWindDirection)
		if windDirection.Magnitude < 1e-5 then
			return
		end

		local amp = (objSettings.WindPower or sharedWindPower) * 0.2
		if amp < 1e-5 then
			return
		end

		local freq = now * ((objSettings.WindSpeed or sharedWindSpeed) * 0.08)
		if freq < 1e-5 then
			return
		end

		local seed = objMeta.Seed
		local animValue = (math.noise(freq, 0, seed) + 0.4) * amp
		local lerpAlpha = math.clamp(step + distanceAlphaSq, 0.1, 0.5)
		local lowAmp = amp / 3

		local origin = objMeta.Origin * (objSettings.PivotOffset or CFrame.identity)
		local localWindDirection = origin:VectorToObjectSpace(windDirection)

		if isBone then
			local bone: Bone = object :: Bone
			bone.Transform = bone.Transform:Lerp(
				(
					CFrame.fromAxisAngle(localWindDirection:Cross(Vector3.yAxis), -animValue)
					* CFrame.Angles(
						math.noise(seed, 0, freq) * lowAmp,
						math.noise(seed, freq, 0) * lowAmp,
						math.noise(freq, seed, 0) * lowAmp
					)
				) + (localWindDirection * animValue * amp),
				lerpAlpha
			)
		else
			bulkMoveIndex += 1
			partList[bulkMoveIndex] = object
			cframeList[bulkMoveIndex] = objectCFrame:Lerp(
				(
					origin
					* CFrame.fromAxisAngle(localWindDirection:Cross(Vector3.yAxis), -animValue)
					* CFrame.Angles(
						math.noise(seed, 0, freq) * lowAmp,
						math.noise(seed, freq, 0) * lowAmp,
						math.noise(freq, seed, 0) * lowAmp
					)
					* (objSettings.PivotOffsetInverse or CFrame.identity)
				) + (windDirection * animValue * (amp * 2)),
				lerpAlpha
			)
		end
	end)

	self.Active = active

	debug.profileend()

	workspace:BulkMoveTo(partList, cframeList, Enum.BulkMoveMode.FireCFrameChanged)

	debug.profileend()
end

function WindShake:Pause()
	if self.UpdateConnection then
		self.UpdateConnection:Disconnect()
		self.UpdateConnection = nil
	end

	self.Active = 0
	self.Running = false

	PausedEvent:Fire()
end

function WindShake:Resume()
	if self.Running then
		return
	else
		self.Running = true
	end

	-- Connect updater
	self.UpdateConnection = self:Connect("Update", RunService.Heartbeat)

	ResumedEvent:Fire()
end

function WindShake:Init(config: { MatchWorkspaceWind: boolean? }?)
	if self.Initialized then
		return
	end

	-- Define attributes if they're undefined.
	local power = script:GetAttribute("WindPower")
	local speed = script:GetAttribute("WindSpeed")
	local direction = script:GetAttribute("WindDirection")

	if typeof(power) ~= "number" then
		script:SetAttribute("WindPower", FALLBACK_SETTINGS.WindPower)
	end

	if typeof(speed) ~= "number" then
		script:SetAttribute("WindSpeed", FALLBACK_SETTINGS.WindSpeed)
	end

	if typeof(direction) ~= "Vector3" then
		script:SetAttribute("WindDirection", FALLBACK_SETTINGS.WindDirection)
	end

	-- Clear any old stuff.
	self:Cleanup()
	self.Initialized = true

	-- Wire up tag listeners.
	local windShakeAdded = CollectionService:GetInstanceAddedSignal(COLLECTION_TAG)
	self.AddedConnection = self:Connect("AddObjectShake", windShakeAdded)

	local windShakeRemoved = CollectionService:GetInstanceRemovedSignal(COLLECTION_TAG)
	self.RemovedConnection = self:Connect("RemoveObjectShake", windShakeRemoved)

	for _, object in CollectionService:GetTagged(COLLECTION_TAG) do
		self:AddObjectShake(object)
	end

	-- Wire up workspace wind.
	if config and config.MatchWorkspaceWind then
		self:MatchWorkspaceWind()
		self.WorkspaceWindConnection = workspace:GetPropertyChangedSignal("GlobalWind"):Connect(function()
			self:MatchWorkspaceWind()
		end)
	end

	-- Automatically start.
	self:Resume()
end

function WindShake:Cleanup()
	if not self.Initialized then
		return
	end

	self:Pause()

	if self.AddedConnection then
		self.AddedConnection:Disconnect()
		self.AddedConnection = nil
	end

	if self.RemovedConnection then
		self.RemovedConnection:Disconnect()
		self.RemovedConnection = nil
	end

	if self.WorkspaceWindConnection then
		self.WorkspaceWindConnection:Disconnect()
		self.WorkspaceWindConnection = nil
	end

	table.clear(self.ObjectMetadata)
	self.VectorMap:ClearAll()

	self.Handled = 0
	self.Active = 0
	self.Initialized = false
end

function WindShake:UpdateObjectSettings(object: Instance, settingsTable: WindShakeSettings)
	if typeof(object) ~= "Instance" then
		return
	end

	if typeof(settingsTable) ~= "table" then
		return
	end

	if not self.ObjectMetadata[object] and (object ~= script) then
		return
	end

	for key, value in settingsTable do
		object:SetAttribute(key, value)
	end

	ObjectShakeUpdatedEvent:Fire(object)
end

function WindShake:UpdateAllObjectSettings(settingsTable: WindShakeSettings)
	if typeof(settingsTable) ~= "table" then
		return
	end

	for obj, _objMeta in self.ObjectMetadata do
		for key, value in settingsTable do
			obj:SetAttribute(key, value)
		end
		ObjectShakeUpdatedEvent:Fire(obj)
	end
end

function WindShake:SetDefaultSettings(settingsTable: WindShakeSettings)
	self:UpdateObjectSettings(script, settingsTable)
end

function WindShake:MatchWorkspaceWind()
	local workspaceWind = workspace.GlobalWind
	local windDirection = workspaceWind.Unit
	local windSpeed, windPower = 0, 0

	local windMagnitude = workspaceWind.Magnitude
	if windMagnitude > 0 then
		windPower = if windMagnitude > 1 then math.log10(windMagnitude) + 0.2 else 0.3
		windSpeed = if windMagnitude < 100 then (windMagnitude * 1.2) + 5 else 125
	end

	self:SetDefaultSettings({
		WindDirection = windDirection,
		WindSpeed = windSpeed,
		WindPower = windPower,
	})
end

return WindShake
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043ae</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX3C9D06C1508D458C9B857B3D395F14B2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">77744aa360d6d33c062a35620000735e</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">VectorMap</string>
								<string name="ScriptGuid">{96A3F580-05FF-444E-A394-2E3332392932}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

local VectorMap = {}
VectorMap.__index = VectorMap

function VectorMap.new(voxelSize: number?)
	return setmetatable({
		_voxelSize = voxelSize or 50,
		_voxels = {},
	}, VectorMap)
end

function VectorMap:_debugDrawVoxel(voxelKey: Vector3)
	local box = Instance.new("Part")
	box.Name = tostring(voxelKey)
	box.Anchored = true
	box.CanCollide = false
	box.Transparency = 1
	box.Size = Vector3.one * self._voxelSize
	box.Position = (voxelKey * self._voxelSize) + (Vector3.one * (self._voxelSize / 2))
	box.Parent = workspace

	local selection = Instance.new("SelectionBox")
	selection.Color3 = Color3.new(0, 0, 1)
	selection.Adornee = box
	selection.Parent = box

	task.delay(1 / 30, box.Destroy, box)
end

function VectorMap:AddObject(position: Vector3, object: any)
	local className = object.ClassName

	local voxelSize = self._voxelSize
	local voxelKey = Vector3.new(
		math.floor(position.X / voxelSize),
		math.floor(position.Y / voxelSize),
		math.floor(position.Z / voxelSize)
	)

	local voxel = self._voxels[voxelKey]

	if voxel == nil then
		self._voxels[voxelKey] = {
			[className] = { object },
		}
	elseif voxel[className] == nil then
		voxel[className] = { object }
	else
		table.insert(voxel[className], object)
	end

	return voxelKey
end

function VectorMap:RemoveObject(voxelKey: Vector3, object: any)
	local voxel = self._voxels[voxelKey]

	if voxel == nil then
		return
	end

	local className = object.ClassName
	if voxel[className] == nil then
		return
	end

	local classBucket = voxel[className]
	for index, storedObject in classBucket do
		if storedObject == object then
			-- Swap remove to avoid shifting
			local n = #classBucket
			classBucket[index] = classBucket[n]
			classBucket[n] = nil
			break
		end
	end

	-- Remove empty class bucket
	if #classBucket == 0 then
		voxel[className] = nil

		-- Remove empty voxel
		if next(voxel) == nil then
			self._voxels[voxelKey] = nil
		end
	end
end

function VectorMap:GetVoxel(voxelKey: Vector3)
	return self._voxels[voxelKey]
end

function VectorMap:ForEachObjectInRegion(top: Vector3, bottom: Vector3, callback: (string, any) -> ())
	local voxelSize = self._voxelSize
	local xMin, yMin, zMin = math.min(bottom.X, top.X), math.min(bottom.Y, top.Y), math.min(bottom.Z, top.Z)
	local xMax, yMax, zMax = math.max(bottom.X, top.X), math.max(bottom.Y, top.Y), math.max(bottom.Z, top.Z)

	for x = math.floor(xMin / voxelSize), math.floor(xMax / voxelSize) do
		for z = math.floor(zMin / voxelSize), math.floor(zMax / voxelSize) do
			for y = math.floor(yMin / voxelSize), math.floor(yMax / voxelSize) do
				local voxel = self._voxels[Vector3.new(x, y, z)]
				if not voxel then
					continue
				end

				for className, objects in voxel do
					for _, object in objects do
						callback(className, object)
					end
				end
			end
		end
	end
end

function VectorMap:ForEachObjectInView(camera: Camera, distance: number, callback: (string, any) -> ())
	local voxelSize = self._voxelSize
	local cameraCFrame = camera.CFrame
	local cameraPos = cameraCFrame.Position
	local rightVec, upVec = cameraCFrame.RightVector, cameraCFrame.UpVector

	local distance2 = distance / 2
	local farPlaneHeight2 = math.tan(math.rad((camera.FieldOfView + 5) / 2)) * distance
	local farPlaneWidth2 = farPlaneHeight2 * (camera.ViewportSize.X / camera.ViewportSize.Y)
	local farPlaneCFrame = cameraCFrame * CFrame.new(0, 0, -distance)
	local farPlaneTopLeft = farPlaneCFrame * Vector3.new(-farPlaneWidth2, farPlaneHeight2, 0)
	local farPlaneTopRight = farPlaneCFrame * Vector3.new(farPlaneWidth2, farPlaneHeight2, 0)
	local farPlaneBottomLeft = farPlaneCFrame * Vector3.new(-farPlaneWidth2, -farPlaneHeight2, 0)
	local farPlaneBottomRight = farPlaneCFrame * Vector3.new(farPlaneWidth2, -farPlaneHeight2, 0)

	local frustumCFrameInverse = (cameraCFrame * CFrame.new(0, 0, -distance2)):Inverse()

	local rightNormal = upVec:Cross(farPlaneBottomRight - cameraPos).Unit
	local leftNormal = upVec:Cross(farPlaneBottomLeft - cameraPos).Unit
	local topNormal = rightVec:Cross(cameraPos - farPlaneTopRight).Unit
	local bottomNormal = rightVec:Cross(cameraPos - farPlaneBottomRight).Unit

	local minBound =
		cameraPos:Min(farPlaneTopLeft):Min(farPlaneTopRight):Min(farPlaneBottomLeft):Min(farPlaneBottomRight)
	local maxBound =
		cameraPos:Max(farPlaneTopLeft):Max(farPlaneTopRight):Max(farPlaneBottomLeft):Max(farPlaneBottomRight)

	minBound = Vector3.new(
		math.floor(minBound.X / voxelSize),
		math.floor(minBound.Y / voxelSize),
		math.floor(minBound.Z / voxelSize)
	)
	maxBound = Vector3.new(
		math.floor(maxBound.X / voxelSize),
		math.floor(maxBound.Y / voxelSize),
		math.floor(maxBound.Z / voxelSize)
	)

	local function isPointInView(point: Vector3): boolean
		-- Check if point lies outside frustum OBB
		local relativeToOBB = frustumCFrameInverse * point
		if
			relativeToOBB.X > farPlaneWidth2
			or relativeToOBB.X < -farPlaneWidth2
			or relativeToOBB.Y > farPlaneHeight2
			or relativeToOBB.Y < -farPlaneHeight2
			or relativeToOBB.Z > distance2
			or relativeToOBB.Z < -distance2
		then
			return false
		end

		-- Check if point lies outside a frustum plane
		local lookToCell = point - cameraPos
		if
			rightNormal:Dot(lookToCell) < 0
			or leftNormal:Dot(lookToCell) > 0
			or topNormal:Dot(lookToCell) < 0
			or bottomNormal:Dot(lookToCell) > 0
		then
			return false
		end

		return true
	end

	for x = minBound.X, maxBound.X do
		local xMin = x * voxelSize
		local xMax = xMin + voxelSize
		local xPos = math.clamp(farPlaneCFrame.X, xMin, xMax)

		for y = minBound.Y, maxBound.Y do
			local yMin = y * voxelSize
			local yMax = yMin + voxelSize
			local yPos = math.clamp(farPlaneCFrame.Y, yMin, yMax)

			for z = minBound.Z, maxBound.Z do
				local zMin = z * voxelSize
				local zMax = zMin + voxelSize

				local voxelNearestPoint = Vector3.new(xPos, yPos, math.clamp(farPlaneCFrame.Z, zMin, zMax))
				if isPointInView(voxelNearestPoint) then
					-- Found the first in frustum, now binary search for the last
					local entry, exit = z, minBound.Z - 1
					local left = z
					local right = maxBound.Z

					while left <= right do
						local mid = math.floor((left + right) / 2)
						local midPos = Vector3.new(
							xPos,
							yPos,
							math.clamp(farPlaneCFrame.Z, mid * voxelSize, mid * voxelSize + voxelSize)
						)

						if isPointInView(midPos) then
							exit = mid
							left = mid + 1
						else
							right = mid - 1
						end
					end

					for fillZ = entry, exit do
						local voxel = self._voxels[Vector3.new(x, y, fillZ)]
						if voxel then
							for className, objects in voxel do
								for _, object in objects do
									callback(className, object)
								end
							end
						end
					end

					break
				end
			end
		end
	end
end

function VectorMap:ClearAll()
	self._voxels = {}
end

return VectorMap
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043af</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXB909A83EC5244BF6ADE56464817B899B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">77744aa360d6d33c062a35620000735d</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Settings</string>
								<string name="ScriptGuid">{4EC86366-BF5A-47FE-A8D2-D0EC1536A454}</string>
								<ProtectedString name="Source"><![CDATA[local Settings = {}

local SettingTypes = {
	WindPower = "number",
	WindSpeed = "number",
	WindDirection = "Vector3",
	PivotOffset = "CFrame",
}

function Settings.new(object: BasePart | Bone | ModuleScript)
	local objectSettings = {}

	-- Initial settings
	local WindPower = object:GetAttribute("WindPower")
	local WindSpeed = object:GetAttribute("WindSpeed")
	local WindDirection = object:GetAttribute("WindDirection")

	objectSettings.WindPower = if typeof(WindPower) == SettingTypes.WindPower then WindPower else nil
	objectSettings.WindSpeed = if typeof(WindSpeed) == SettingTypes.WindSpeed then WindSpeed else nil
	objectSettings.WindDirection = if typeof(WindDirection) == SettingTypes.WindDirection
		then (if WindDirection.Magnitude > 0 then WindDirection.Unit else Vector3.zero)
		else nil
	objectSettings.PivotOffset = if object:IsA("BasePart") then object.PivotOffset else nil
	objectSettings.PivotOffsetInverse = if typeof(objectSettings.PivotOffset) == "CFrame"
		then objectSettings.PivotOffset:Inverse()
		else nil

	-- Update settings on event

	local PowerConnection = object:GetAttributeChangedSignal("WindPower"):Connect(function()
		WindPower = object:GetAttribute("WindPower")
		objectSettings.WindPower = if typeof(WindPower) == SettingTypes.WindPower then WindPower else nil
	end)

	local SpeedConnection = object:GetAttributeChangedSignal("WindSpeed"):Connect(function()
		WindSpeed = object:GetAttribute("WindSpeed")
		objectSettings.WindSpeed = if typeof(WindSpeed) == SettingTypes.WindSpeed then WindSpeed else nil
	end)

	local DirectionConnection = object:GetAttributeChangedSignal("WindDirection"):Connect(function()
		WindDirection = object:GetAttribute("WindDirection")
		objectSettings.WindDirection = if typeof(WindDirection) == SettingTypes.WindDirection
			then (if WindDirection.Magnitude > 0 then WindDirection.Unit else Vector3.zero)
			else nil
	end)

	local PivotConnection
	if object:IsA("BasePart") then
		PivotConnection = object:GetPropertyChangedSignal("PivotOffset"):Connect(function()
			objectSettings.PivotOffset = object.PivotOffset
			objectSettings.PivotOffsetInverse = objectSettings.PivotOffset:Inverse()
		end)
	end

	-- Cleanup function for when shake is removed or object is unloaded

	function objectSettings:Destroy()
		PowerConnection:Disconnect()
		SpeedConnection:Disconnect()
		DirectionConnection:Disconnect()
		if PivotConnection then
			PivotConnection:Disconnect()
		end

		table.clear(objectSettings)
	end

	return objectSettings
end

return Settings
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043b0</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXE8AB32740D3549CC8866677740638A54">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d00</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Icon</string>
							<string name="ScriptGuid">{154452BB-F53A-483A-800A-4B0CA0BBC86A}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	
	The majority of this code is an interface designed to make it easy for you to
	work with TopbarPlus (most methods for instance reference :modifyTheme()).
	The processing overhead mainly consists of applying themes and calculating 
	appearance (such as size and width of labels) which is handled in about
	200 lines of code here and the Widget UI module. This has been achieved
	in v3 by outsourcing a majority of previous calculations to inbuilt Roblox
	features like UIListLayouts.


	v3 provides inbuilt support for Replicas (simply press DPadUp),
	touch devices (phones, tablets , etc), localization (automatic resizing
	of widgets, autolocalize for relevant labels), backwards compatability
	with the old topbar, and more.


	My primary goals for the v3 re-write have been to:
		
	1. Improve code readability and organisation (reduced lines of code within
	   Icon+IconReplica from 3200 to ~950, separated UI elements, etc)
		
	2. Improve ease-of-use (themes now actually make sense and can account
	   for any modifications you want, converted to a package for
	   quick installation and easy-comparisons of new updates, etc)
	
	3. Provide support for all key features of the new Roblox topbar
	   while improving performance of the module (deferring and collecting
	   changes then calling as a singular, utilizing inbuilt Roblox features
	   such as UILIstLayouts, etc)

--]]



-- SERVICES
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local Types = require(script.Types)



-- TYPES
export type Icon = Types.Icon



-- REFERENCE HANDLER
-- Multiple Icons packages may exist at runtime (for instance if the developer additionally uses HD Admin)
-- therefore this ensures that the first required package becomes the dominant and only functioning module
local iconModule = script
local Reference = require(iconModule.Reference)
local referenceObject = Reference.getObject()
local leadPackage = referenceObject and referenceObject.Value
if leadPackage and leadPackage ~= iconModule then
	return require(leadPackage) :: Types.StaticIcon
end
if not referenceObject then
	Reference.addToReplicatedStorage()
end



-- MODULES
local Signal = require(iconModule.Packages.GoodSignal)
local Janitor = require(iconModule.Packages.Janitor)
local Utility = require(iconModule.Utility)
local Themes = require(iconModule.Features.Themes)
local Gamepad = require(iconModule.Features.Gamepad)
local Overflow = require(iconModule.Features.Overflow)
local Icon = {}
Icon.__index = Icon



--- LOCAL
local localPlayer = Players.LocalPlayer
local themes = iconModule.Features.Themes
local iconsDict = {}
local anyIconSelected = Signal.new()
local elements = iconModule.Elements
local totalCreatedIcons = 0



-- PUBLIC VARIABLES
Icon.baseDisplayOrderChanged = Signal.new()
Icon.baseDisplayOrder = 10
Icon.baseTheme = require(themes.Default)
Icon.isOldTopbar = false -- Logic has been moved to Container
Icon.iconsDictionary = iconsDict
Icon.insetHeightChanged = Signal.new()
Icon.container = require(elements.Container)(Icon)
Icon.topbarEnabled = true
Icon.iconAdded = Signal.new()
Icon.iconRemoved = Signal.new()
Icon.iconChanged = Signal.new()



-- PUBLIC FUNCTIONS
function Icon.getIcons()
	return Icon.iconsDictionary
end

function Icon.getIconByUID(UID)
	local match = Icon.iconsDictionary[UID]
	if match then
		return match
	end
	return nil
end

function Icon.getIcon(nameOrUID)
	local match = Icon.getIconByUID(nameOrUID)
	if match then
		return match
	end
	for _, icon in pairs(iconsDict) do
		if icon.name == nameOrUID then
			return icon
		end
	end
	return nil
end

function Icon.setTopbarEnabled(bool, isInternal)
	if typeof(bool) ~= "boolean" then
		bool = Icon.topbarEnabled
	end
	if not isInternal then
		Icon.topbarEnabled = bool
	end
	for _, screenGui in pairs(Icon.container) do
		screenGui.Enabled = bool
	end
end

function Icon.modifyBaseTheme(modifications)
	modifications = Themes.getModifications(modifications)
	for _, modification in pairs(modifications) do
		for _, detail in pairs(Icon.baseTheme) do
			Themes.merge(detail, modification)
		end
	end
	for _, icon in pairs(iconsDict) do
		icon:setTheme(Icon.baseTheme)
	end
end

function Icon.setDisplayOrder(int)
	Icon.baseDisplayOrder = int
	Icon.baseDisplayOrderChanged:Fire(int)
end



-- SETUP
task.defer(Gamepad.start, Icon)
task.defer(Overflow.start, Icon)
task.defer(function()
	local playerGui = localPlayer:WaitForChild("PlayerGui")
	for _, screenGui in pairs(Icon.container) do
		screenGui.Parent = playerGui
	end
	require(iconModule.Attribute)
end)



-- CONSTRUCTOR
function Icon.new()
	local self = {}
	setmetatable(self, Icon)

	--- Janitors (for cleanup)
	local janitor = Janitor.new()
	self.janitor = janitor
	self.themesJanitor = janitor:add(Janitor.new())
	self.singleClickJanitor = janitor:add(Janitor.new())
	self.captionJanitor = janitor:add(Janitor.new())
	self.joinJanitor = janitor:add(Janitor.new())
	self.menuJanitor = janitor:add(Janitor.new())
	self.dropdownJanitor = janitor:add(Janitor.new())

	-- Register
	local iconUID = Utility.generateUID()
	iconsDict[iconUID] = self
	janitor:add(function()
		iconsDict[iconUID] = nil
	end)

	-- Signals (events)
	self.selected = janitor:add(Signal.new())
	self.deselected = janitor:add(Signal.new())
	self.toggled = janitor:add(Signal.new())
	self.viewingStarted = janitor:add(Signal.new())
	self.viewingEnded = janitor:add(Signal.new())
	self.stateChanged = janitor:add(Signal.new())
	self.notified = janitor:add(Signal.new())
	self.noticeStarted = janitor:add(Signal.new())
	self.noticeChanged = janitor:add(Signal.new())
	self.endNotices = janitor:add(Signal.new())
	self.toggleKeyAdded = janitor:add(Signal.new())
	self.fakeToggleKeyChanged = janitor:add(Signal.new())
	self.alignmentChanged = janitor:add(Signal.new())
	self.updateSize = janitor:add(Signal.new())
	self.resizingComplete = janitor:add(Signal.new())
	self.joinedParent = janitor:add(Signal.new())
	self.menuSet = janitor:add(Signal.new())
	self.dropdownSet = janitor:add(Signal.new())
	self.updateMenu = janitor:add(Signal.new())
	self.startMenuUpdate = janitor:add(Signal.new())
	self.childThemeModified = janitor:add(Signal.new())
	self.indicatorSet = janitor:add(Signal.new())
	self.dropdownChildAdded = janitor:add(Signal.new())
	self.menuChildAdded = janitor:add(Signal.new())

	-- Properties
	self.iconModule = iconModule
	self.UID = iconUID
	self.isEnabled = true
	self.enabled = self.isEnabled -- Backwards compatability
	self.isSelected = false
	self.isViewing = false
	self.joinedFrame = false
	self.parentIconUID = false
	self.deselectWhenOtherIconSelected = true
	self.totalNotices = 0
	self.activeState = "Deselected"
	self.alignment = ""
	self.originalAlignment = ""
	self.appliedTheme = {}
	self.appearance = {}
	self.cachedInstances = {}
	self.cachedNamesToInstances = {}
	self.cachedCollectives = {}
	self.bindedToggleKeys = {}
	self.customBehaviours = {}
	self.toggleItems = {}
	self.bindedEvents = {}
	self.notices = {}
	self.menuIcons = {}
	self.dropdownIcons = {}
	self.childIconsDict = {}
	self.creationTime = os.clock()

	-- Widget is the new name for an icon
	local widget = janitor:add(require(elements.Widget)(self, Icon))
	self.widget = widget
	self:setAlignment()
	
	-- It's important we set an order otherwise icons will not align
	-- correctly within menus
	totalCreatedIcons += 1
	local ourOrder = 1+(totalCreatedIcons*0.01)
	self:setOrder(ourOrder, "deselected")
	self:setOrder(ourOrder, "selected")

	-- This applies the default them
	self:setTheme(Icon.baseTheme)

	-- Button Clicked (for states "Selected" and "Deselected")
	local clickRegion = self:getInstance("ClickRegion")
	local function handleToggle()
		if self.locked then
			return
		end
		if self.isSelected then
			self:deselect("User", self)
		else
			self:select("User", self)
		end
	end
	local isTouchTapping = false
	local isClicking = false
	clickRegion.MouseButton1Click:Connect(function()
		if isTouchTapping then
			return
		end
		isClicking = true
		task.delay(0.01, function()
			isClicking = false
		end)
		handleToggle()
	end)
	clickRegion.TouchTap:Connect(function()
		-- This resolves the bug report by @28Pixels:
		-- https://devforum.roblox.com/t/topbarplus/1017485/1104
		if isClicking then
			return
		end
		isTouchTapping = true
		task.delay(0.01, function()
			isTouchTapping = false
		end)
		handleToggle()
	end)

	-- Keys can be bound to toggle between Selected and Deselected
	janitor:add(UserInputService.InputBegan:Connect(function(input, touchingAnObject)
		if self.locked then
			return
		end
		if self.bindedToggleKeys[input.KeyCode] and not touchingAnObject then
			handleToggle()
		end
	end))

	-- Button Hovering (for state "Viewing")
	-- Hovering is a state only for devices with keyboards
	-- and Replicas (not touchpads)
	local function viewingStarted(dontSetState)
		if self.locked then
			return
		end
		self.isViewing = true
		self.viewingStarted:Fire(true)
		if not dontSetState then
			self:setState("Viewing", "User", self)
		end
	end
	local function viewingEnded()
		if self.locked then
			return
		end
		self.isViewing = false
		self.viewingEnded:Fire(true)
		self:setState(nil, "User", self)
	end
	self.joinedParent:Connect(function()
		if self.isViewing then
			viewingEnded()
		end
	end)
	clickRegion.MouseEnter:Connect(function()
		local dontSetState = not UserInputService.KeyboardEnabled
		viewingStarted(dontSetState)
	end)
	local touchCount = 0
	janitor:add(UserInputService.TouchEnded:Connect(viewingEnded))
	clickRegion.MouseLeave:Connect(viewingEnded)
	clickRegion.SelectionGained:Connect(viewingStarted)
	clickRegion.SelectionLost:Connect(viewingEnded)
	clickRegion.MouseButton1Down:Connect(function()
		if not self.locked and UserInputService.TouchEnabled then
			touchCount += 1
			local myTouchCount = touchCount
			task.delay(0.2, function()
				if myTouchCount == touchCount then
					viewingStarted()
				end
			end)
		end
	end)
	clickRegion.MouseButton1Up:Connect(function()
		touchCount += 1
	end)

	-- Handle overlay on viewing
	local iconOverlay = self:getInstance("IconOverlay")
	self.viewingStarted:Connect(function()
		iconOverlay.Visible = not self.overlayDisabled
	end)
	self.viewingEnded:Connect(function()
		iconOverlay.Visible = false
	end)

	-- Deselect when another icon is selected
	janitor:add(anyIconSelected:Connect(function(incomingIcon)
		if incomingIcon ~= self and self.deselectWhenOtherIconSelected and incomingIcon.deselectWhenOtherIconSelected then
			self:deselect("AutoDeselect", incomingIcon)
		end
	end))

	-- This checks if the script calling this module is a descendant of a ScreenGui
	-- with 'ResetOnSpawn' set to true. If it is, then we destroy the icon the
	-- client respawns. This solves one of the most asked about questions on the post
	-- The only caveat this may not work if the player doesn't uniquely name their ScreenGui and the frames
	-- the LocalScript rests within
	local source =  debug.info(2, "s")
	local sourcePath = string.split(source, ".")
	local origin = game
	local originsScreenGui
	for i, sourceName in pairs(sourcePath) do
		origin = origin:FindFirstChild(sourceName)
		if not origin then
			break
		end
		if origin:IsA("ScreenGui") then
			originsScreenGui = origin
		end
	end
	if origin and originsScreenGui and originsScreenGui.ResetOnSpawn == true then
		Utility.localPlayerRespawned(function()
			self:destroy()
		end)
	end

	-- Additional children behaviour when toggled (mostly notices)
	self.toggled:Connect(function(isSelected)
		self.noticeChanged:Fire(self.totalNotices)
		for childIconUID, _ in pairs(self.childIconsDict) do
			local childIcon = Icon.getIconByUID(childIconUID)
			childIcon.noticeChanged:Fire(childIcon.totalNotices)
			if not isSelected and childIcon.isSelected then
				-- If an icon within a menu or dropdown is also
				-- a dropdown or menu, then close it
				for _, _ in pairs(childIcon.childIconsDict) do
					childIcon:deselect("HideParentFeature", self)
				end
			end
		end
	end)
	
	-- This closes/reopens the chat or playerlist if the icon is a dropdown
	-- In the future I'd prefer to use the position+size of the chat
	-- to determine whether to close dropdown (instead of non-right-set)
	-- but for reasons mentioned here it's unreliable at the time of
	-- writing this: https://devforum.roblox.com/t/here/2794915
	-- I could also make this better by accounting for multiple
	-- dropdowns being open (not just this one) but this will work
	-- fine for almost every use case for now.
	self.selected:Connect(function()
		local isDropdown = #self.dropdownIcons > 0
		if isDropdown then
			if StarterGui:GetCore("ChatActive") and self.alignment ~= "Right" then
				self.chatWasPreviouslyActive = true
				StarterGui:SetCore("ChatActive", false)
			end
			if StarterGui:GetCoreGuiEnabled("PlayerList") and self.alignment ~= "Left" then
				self.playerlistWasPreviouslyActive = true
				StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
			end
		end
	end)
	self.deselected:Connect(function()
		if self.chatWasPreviouslyActive then
			self.chatWasPreviouslyActive = nil
			StarterGui:SetCore("ChatActive", true)
		end
		if self.playerlistWasPreviouslyActive then
			self.playerlistWasPreviouslyActive = nil
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
		end
	end)
	
	-- There's a rare occassion where the appearance is not
	-- fully set to deselected so this ensures the icons
	-- appearance is fully as it should be
	task.delay(0.1, function()
		if self.activeState == "Deselected" then
			self.stateChanged:Fire("Deselected")
			self:refresh()
		end
	end)
	
	-- Call icon added
	Icon.iconAdded:Fire(self)

	return self
end



-- METHODS
function Icon:setName(name)
	self.widget.Name = name
	self.name = name
	return self
end

function Icon:setState(incomingStateName, fromSource, sourceIcon)
	-- This is responsible for acknowleding a change in stage (such as from "Deselected" to "Viewing" when
	-- a users mouse enters the widget), then informing other systems of this state change to then act upon
	-- (such as the theme handler applying the theme which corresponds to that state).
	if not incomingStateName then
		incomingStateName = (self.isSelected and "Selected") or "Deselected"
	end
	local stateName = Utility.formatStateName(incomingStateName)
	local previousStateName = self.activeState
	if previousStateName == stateName then
		return
	end
	local currentIsSelected = self.isSelected
	self.activeState = stateName
	if stateName == "Deselected" then
		self.isSelected = false
		if currentIsSelected then
			self.toggled:Fire(false, fromSource, sourceIcon)
			self.deselected:Fire(fromSource, sourceIcon)
		end
		self:_setToggleItemsVisible(false, fromSource, sourceIcon)
	elseif stateName == "Selected" then
		self.isSelected = true
		if not currentIsSelected then
			self.toggled:Fire(true, fromSource, sourceIcon)
			self.selected:Fire(fromSource, sourceIcon)
			anyIconSelected:Fire(self, fromSource, sourceIcon)
		end
		self:_setToggleItemsVisible(true, fromSource, sourceIcon)
	end
	self.stateChanged:Fire(stateName, fromSource, sourceIcon)
end

function Icon:getInstance(name)
	-- This enables us to easily retrieve instances located within the icon simply by passing its name.
	-- Every important/significant instance is named uniquely therefore this is no worry of overlap.
	-- We cache the result for more performant retrieval in the future.
	local instance = self.cachedNamesToInstances[name]
	if instance then
		return instance
	end
	local function cacheInstance(childName, child)
		local currentCache = self.cachedInstances[child]
		if not currentCache then
			local collectiveName = child:GetAttribute("Collective")
			local cachedCollective = collectiveName and self.cachedCollectives[collectiveName]
			if cachedCollective then
				table.insert(cachedCollective, child)
			end
			self.cachedNamesToInstances[childName] = child
			self.cachedInstances[child] = true
			child.Destroying:Once(function()
				self.cachedNamesToInstances[childName] = nil
				self.cachedInstances[child] = nil
			end)
		end
	end
	local widget = self.widget
	cacheInstance("Widget", widget)
	if name == "Widget" then
		return widget
	end

	local returnChild
	local function scanChildren(parentInstance)
		for _, child in pairs(parentInstance:GetChildren()) do
			local widgetUID = child:GetAttribute("WidgetUID")
			if widgetUID and widgetUID ~= self.UID then
				-- This prevents instances within other icons from being recorded
				-- (for instance when other icons are added to this icons menu)
				continue
			end
			-- If the child is a fake placeholder instance (such as dropdowns, notices, etc)
			-- then its important we scan the real original instance instead of this clone
			local realChild = Themes.getRealInstance(child)
			if realChild then
				child = realChild
			end
			-- Finally scan its children
			scanChildren(child)
			if child:IsA("GuiBase") or child:IsA("UIBase") or child:IsA("ValueBase") then
				local childName = child.Name
				cacheInstance(childName, child)
				if childName == name then
					returnChild = child
				end
			end
		end
	end
	scanChildren(widget)
	return returnChild
end

function Icon:getCollective(name)
	-- A collective is an array of instances within the Widget that have been
	-- grouped together based on a given name. This just makes it easy
	-- to act on multiple instances at once which share similar behaviours.
	-- For instance, if we want to change the icons corner size, all corner instances
	-- with the attribute "Collective" and value "WidgetCorner" could be updated
	-- instantly by doing Themes.apply(icon, "WidgetCorner", newSize)
	local collective = self.cachedCollectives[name]
	if collective then
		return collective
	end
	collective = {}
	for instance, _ in pairs(self.cachedInstances) do
		if instance:GetAttribute("Collective") == name then
			table.insert(collective, instance)
		end
	end
	self.cachedCollectives[name] = collective
	return collective
end

function Icon:getInstanceOrCollective(collectiveOrInstanceName)
	-- Similar to :getInstance but also accounts for 'Collectives', such as UICorners and returns
	-- an array of instances instead of a single instance
	local instances = {}
	local instance = self:getInstance(collectiveOrInstanceName)
	if instance then
		table.insert(instances, instance)
	end
	if #instances == 0 then
		instances = self:getCollective(collectiveOrInstanceName)
	end
	return instances
end

function Icon:getStateGroup(iconState)
	local chosenState = iconState or self.activeState
	local stateGroup = self.appearance[chosenState]
	if not stateGroup then
		stateGroup = {}
		self.appearance[chosenState] = stateGroup
	end
	return stateGroup
end

function Icon:refreshAppearance(instance, specificProperty)
	Themes.refresh(self, instance, specificProperty)
	return self
end

function Icon:refresh()
	self:refreshAppearance(self.widget)
	self.updateSize:Fire()
	return self
end

function Icon:updateParent()
	local parentIcon = Icon.getIconByUID(self.parentIconUID)
	if parentIcon then
		parentIcon.updateSize:Fire()
	end
end

function Icon:setBehaviour(collectiveOrInstanceName, property, callback, refreshAppearance)
	-- You can specify your own custom callback to handle custom logic just before
	-- an instances property is changed by using :setBehaviour()
	local key = collectiveOrInstanceName.."-"..property
	self.customBehaviours[key] = callback
	if refreshAppearance then
		local instances = self:getInstanceOrCollective(collectiveOrInstanceName)
		for _, instance in pairs(instances) do
			self:refreshAppearance(instance, property)
		end
	end
end

function Icon:modifyTheme(modifications, customModificationUID)
	local modificationUID = Themes.modify(self, modifications, customModificationUID)
	return self, modificationUID
end

function Icon:modifyChildTheme(modifications, modificationUID)
	-- Same as modifyTheme except for its children (i.e. icons
	-- within its dropdown or menu)
	self.childModifications = modifications
	self.childModificationsUID = modificationUID
	for childIconUID, _ in pairs(self.childIconsDict) do
		local childIcon = Icon.getIconByUID(childIconUID)
		childIcon:modifyTheme(modifications, modificationUID)
	end
	self.childThemeModified:Fire()
	return self
end

function Icon:removeModification(modificationUID)
	Themes.remove(self, modificationUID)
	return self
end

function Icon:removeModificationWith(instanceName, property, state)
	Themes.removeWith(self, instanceName, property, state)
	return self
end

function Icon:setTheme(theme)
	Themes.set(self, theme)
	return self
end

function Icon:setEnabled(bool)
	self.isEnabled = bool
	self.enabled = self.isEnabled
	self.widget.Visible = bool
	self:updateParent()
	return self
end

function Icon:select(fromSource, sourceIcon)
	self:setState("Selected", fromSource, sourceIcon)
	return self
end

function Icon:deselect(fromSource, sourceIcon)
	self:setState("Deselected", fromSource, sourceIcon)
	return self
end

function Icon:notify(customClearSignal, noticeId)
	-- Generates a notification which appears in the top right of the icon. Useful for example for prompting
	-- users of changes/updates within your UI such as a Catalog
	-- 'customClearSignal' is a signal object (e.g. icon.deselected) or
	-- Roblox event (e.g. Instance.new("BindableEvent").Event)
	local notice = self.notice
	if not notice then
		notice = require(elements.Notice)(self, Icon)
		self.notice = notice
	end
	self.noticeStarted:Fire(customClearSignal, noticeId)
	return self
end

function Icon:clearNotices()
	self.endNotices:Fire()
	return self
end

function Icon:disableOverlay(bool)
	self.overlayDisabled = bool
	return self
end
Icon.disableStateOverlay = Icon.disableOverlay

function Icon:setImage(imageId, iconState)
	self:modifyTheme({"IconImage", "Image", imageId, iconState})
	return self
end

function Icon:setLabel(text, iconState)
	self:modifyTheme({"IconLabel", "Text", text, iconState})
	return self
end

function Icon:setOrder(int, iconState)
	-- We multiply by 100 to allow for custom increments inbetween
	-- (.01, .02, etc) as LayoutOrders only support integers
	local newInt = int*100
	self:modifyTheme({"IconSpot", "LayoutOrder", newInt, iconState})
	self:modifyTheme({"Widget", "LayoutOrder", newInt, iconState})
	return self
end

function Icon:setCornerRadius(udim, iconState)
	self:modifyTheme({"IconCorners", "CornerRadius", udim, iconState})
	return self
end

function Icon:align(leftCenterOrRight, isFromParentIcon)
	-- Determines the side of the screen the icon will be ordered
	local direction = tostring(leftCenterOrRight):lower()
	if direction == "mid" or direction == "centre" then
		direction = "center"
	end
	if direction ~= "left" and direction ~= "center" and direction ~= "right" then
		direction = "left"
	end
	local screenGui = (direction == "center" and Icon.container.TopbarCentered) or Icon.container.TopbarStandard
	local holders = screenGui.Holders
	local finalDirection = string.upper(string.sub(direction, 1, 1))..string.sub(direction, 2)
	if not isFromParentIcon then
		self.originalAlignment = finalDirection
	end
	local joinedFrame = self.joinedFrame
	local alignmentHolder = holders[finalDirection]
	self.screenGui = screenGui
	self.alignmentHolder = alignmentHolder
	if not self.isDestroyed then
		self.widget.Parent = joinedFrame or alignmentHolder
	end
	self.alignment = finalDirection
	self.alignmentChanged:Fire(finalDirection)
	Icon.iconChanged:Fire(self)
	return self
end
Icon.setAlignment = Icon.align

function Icon:setLeft()
	self:setAlignment("Left")
	return self
end

function Icon:setMid()
	self:setAlignment("Center")
	return self
end

function Icon:setRight()
	self:setAlignment("Right")
	return self
end

function Icon:setWidth(offsetMinimum, iconState)
	-- This sets a minimum X offset size for the widget, useful
	-- for example if you're constantly changing the label
	-- but don't want the icon to resize every time
	self:modifyTheme({"Widget", "DesiredWidth", offsetMinimum, iconState})
	return self
end

function Icon:setImageScale(number, iconState)
	self:modifyTheme({"IconImageScale", "Value", number, iconState})
	return self
end

function Icon:setImageRatio(number, iconState)
	self:modifyTheme({"IconImageRatio", "AspectRatio", number, iconState})
	return self
end

function Icon:setTextSize(number, iconState)
	self:modifyTheme({"IconLabel", "TextSize", number, iconState})
	return self
end

function Icon:setTextFont(font, fontWeight, fontStyle, iconState)
	fontWeight = fontWeight or Enum.FontWeight.Regular
	fontStyle = fontStyle or Enum.FontStyle.Normal
	local fontFace
	local fontType = typeof(font)
	if fontType == "number" then
		fontFace = Font.fromId(font, fontWeight, fontStyle)
	elseif fontType == "EnumItem" then
		fontFace = Font.fromEnum(font)
	elseif fontType == "string" then
		if not font:match("rbxasset") then
			fontFace = Font.fromName(font, fontWeight, fontStyle)
		end
	end
	if not fontFace then
		fontFace = Font.new(font, fontWeight, fontStyle)
	end
	self:modifyTheme({"IconLabel", "FontFace", fontFace, iconState})
	return self
end

function Icon:bindToggleItem(guiObjectOrLayerCollector)
	if not guiObjectOrLayerCollector:IsA("GuiObject") and not guiObjectOrLayerCollector:IsA("LayerCollector") then
		error("Toggle item must be a GuiObject or LayerCollector!")
	end
	self.toggleItems[guiObjectOrLayerCollector] = true
	self:_updateSelectionInstances()
	return self
end

function Icon:unbindToggleItem(guiObjectOrLayerCollector)
	self.toggleItems[guiObjectOrLayerCollector] = nil
	self:_updateSelectionInstances()
	return self
end

function Icon:_updateSelectionInstances()
	-- This is to assist with Replica navigation and selection
	-- It converts the value true to an array
	for guiObjectOrLayerCollector, _ in pairs(self.toggleItems) do
		local buttonInstancesArray = {}
		for _, instance in pairs(guiObjectOrLayerCollector:GetDescendants()) do
			if (instance:IsA("TextButton") or instance:IsA("ImageButton")) and instance.Active then
				table.insert(buttonInstancesArray, instance)
			end
		end
		self.toggleItems[guiObjectOrLayerCollector] = buttonInstancesArray
	end
end

function Icon:_setToggleItemsVisible(bool, fromSource, sourceIcon)
	for toggleItem, _ in pairs(self.toggleItems) do
		if not sourceIcon or sourceIcon == self or sourceIcon.toggleItems[toggleItem] == nil then
			local property = "Visible"
			if toggleItem:IsA("LayerCollector") then
				property = "Enabled"
			end
			toggleItem[property] = bool
		end
	end
end

function Icon:bindEvent(iconEventName, eventFunction)
	local event = self[iconEventName]
	assert(event and typeof(event) == "table" and event.Connect, "argument[1] must be a valid topbarplus icon event name!")
	assert(typeof(eventFunction) == "function", "argument[2] must be a function!")
	self.bindedEvents[iconEventName] = event:Connect(function(...)
		eventFunction(self, ...)
	end)
	return self
end

function Icon:unbindEvent(iconEventName)
	local eventConnection = self.bindedEvents[iconEventName]
	if eventConnection then
		eventConnection:Disconnect()
		self.bindedEvents[iconEventName] = nil
	end
	return self
end

function Icon:bindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.bindedToggleKeys[keyCodeEnum] = true
	self.toggleKeyAdded:Fire(keyCodeEnum)
	self:setCaption("_hotkey_")
	return self
end

function Icon:unbindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.bindedToggleKeys[keyCodeEnum] = nil
	return self
end

function Icon:call(callback, ...)
	local packedArgs = table.pack(...)
	task.spawn(function()
		callback(self, table.unpack(packedArgs))
	end)
	return self
end

function Icon:addToJanitor(callback, methodName, index)
	self.janitor:add(callback, methodName, index)
	return self
end

function Icon:lock()
	-- This disables all user inputs related to the icon (such as clicking buttons, pressing keys, etc)
	local clickRegion = self:getInstance("ClickRegion")
	clickRegion.Visible = false
	self.locked = true
	return self
end

function Icon:unlock()
	local clickRegion = self:getInstance("ClickRegion")
	clickRegion.Visible = true
	self.locked = false
	return self
end

function Icon:debounce(seconds)
	self:lock()
	task.wait(seconds)
	self:unlock()
	return self
end

function Icon:autoDeselect(bool)
	-- When set to true the icon will deselect itself automatically whenever
	-- another icon is selected
	if bool == nil then
		bool = true
	end
	self.deselectWhenOtherIconSelected = bool
	return self
end

function Icon:oneClick(bool)
	-- When set to true the icon will automatically deselect when selected, this creates
	-- the effect of a single click button
	local singleClickJanitor = self.singleClickJanitor
	singleClickJanitor:clean()
	if bool or bool == nil then
		singleClickJanitor:add(self.selected:Connect(function()
			self:deselect("OneClick", self)
		end))
	end
	self.oneClickEnabled = true
	return self
end

function Icon:setCaption(text)
	if text == "_hotkey_" and (self.captionText) then
		return self
	end
	local captionJanitor = self.captionJanitor
	self.captionJanitor:clean()
	if not text or text == "" then
		self.caption = nil
		self.captionText = nil
		return self
	end
	local caption = captionJanitor:add(require(elements.Caption)(self))
	caption:SetAttribute("CaptionText", text)
	self.caption = caption
	self.captionText = text
	return self
end

function Icon:setCaptionHint(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.fakeToggleKey = keyCodeEnum
	self.fakeToggleKeyChanged:Fire(keyCodeEnum)
	self:setCaption("_hotkey_")
	return self
end

function Icon:leave()
	local joinJanitor = self.joinJanitor
	joinJanitor:clean()
	return self
end

function Icon:joinMenu(parentIcon)
	Utility.joinFeature(self, parentIcon, parentIcon.menuIcons, parentIcon:getInstance("Menu"))
	parentIcon.menuChildAdded:Fire(self)
	return self
end

function Icon:setMenu(arrayOfIcons)
	self.menuSet:Fire(arrayOfIcons)
	return self
end

function Icon:setFrozenMenu(arrayOfIcons)
	self:freezeMenu(arrayOfIcons)
	self:setMenu(arrayOfIcons)
end

function Icon:freezeMenu()
	-- A frozen menu is a menu which is permanently locked in the
	-- the selected state (with its toggle hidden)
	self:select("FrozenMenu", self)
	self:bindEvent("deselected", function(icon)
		icon:select("FrozenMenu", self)
	end)
	self:modifyTheme({"IconSpot", "Visible", false})
end

function Icon:joinDropdown(parentIcon)
	parentIcon:getDropdown()
	Utility.joinFeature(self, parentIcon, parentIcon.dropdownIcons, parentIcon:getInstance("DropdownScroller"))
	parentIcon.dropdownChildAdded:Fire(self)
	return self
end

function Icon:getDropdown()
	local dropdown = self.dropdown
	if not dropdown then
		dropdown = require(elements.Dropdown)(self)
		self.dropdown = dropdown
		self:clipOutside(dropdown)
	end
	return dropdown
end

function Icon:setDropdown(arrayOfIcons)
	self:getDropdown()
	self.dropdownSet:Fire(arrayOfIcons)
	return self
end

function Icon:clipOutside(instance)
	-- This is essential for items such as notices and dropdowns which will exceed the bounds of the widget. This is an issue
	-- because the widget must have ClipsDescendents enabled to hide items for instance when the menu is closing or opening.
	-- This creates an invisible frame which matches the size and position of the instance, then the instance is parented outside of
	-- the widget and tracks the clone to match its size and position. In order for themes, etc to work the applying system checks
	-- to see if an instance is a clone, then if it is, it applies it to the original instance instead of the clone.
	local instanceClone = Utility.clipOutside(self, instance)
	self:refreshAppearance(instance)
	return self, instanceClone
end

function Icon:setIndicator(keyCode)
	-- An indicator is a direction button prompt with an image of the given keycode. This is useful for instance
	-- with Replicas to show the user what button to press to highlight the topbar. You don't need
	-- to set an indicator for Replicas as this is handled internally within the Gamepad module
	local indicator = self.indicator
	if not indicator then
		indicator = self.janitor:add(require(elements.Indicator)(self, Icon))
		self.indicator = indicator
	end
	self.indicatorSet:Fire(keyCode)
end

function Icon:convertLabelToNumberSpinner(numberSpinner)
	local label = self:getInstance("IconLabel")
	label.Transparency = 1
	numberSpinner.Parent = label.Parent
	numberSpinner.Size = UDim2.fromScale(1, 1)
	numberSpinner.AnchorPoint = Vector2.new(0.5, 0.5)
	numberSpinner.Position = UDim2.new(0.5, 0, 0.5, 0)
	numberSpinner.TextXAlignment = Enum.TextXAlignment.Center
	numberSpinner.ClipsDescendants = false

	local propertiesToChangeLabel = {
		"FontFace",
		"BorderSizePixel",
		"BorderColor3",
		"Rotation",
		"TextStrokeTransparency",
		"TextStrokeColor3",
		"TextStrokeTransparency",
		"TextColor3",
	}
	for _, property in ipairs(propertiesToChangeLabel) do
		numberSpinner[property] = label[property]
		self:addToJanitor(label:GetPropertyChangedSignal(property):Connect(function()
			numberSpinner[property] = label[property]
		end))
	end

	local minDigits = 0
	local maxDigits = 8
	local function getSpinnerSizeAndDigitCount()
		local TotalSize = 0
		local numOfDigits = 0
		for i, child in numberSpinner.Frame:GetChildren() do
			local name = string.lower(child.Name)
			if name == "digit" then
				TotalSize += child.AbsoluteSize.X
				numOfDigits += 1
			elseif name == "prefix" or name == "suffix" or name == "comma" then
				if child.Text ~= "" then
					TotalSize += child.AbsoluteSize.X
					numOfDigits += 1
				end
			end
		end
		return TotalSize, numOfDigits
	end

	local function getLabelParentContainerXSize()
		local nextParent = label.Parent.Parent
		if nextParent == nil then
			return 0
		end
		if nextParent.IconImage.Visible == true then
			return numberSpinner.Frame.AbsoluteSize.X + label.Parent.Parent.IconImage.AbsoluteSize.X
		else
			return nextParent.AbsoluteSize.X
		end
	end
	local function getNumberSpinnerXSize()
		return numberSpinner.Frame.AbsoluteSize.X
	end

	local function adjustSize()
		local totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
		if numOfDigits < 18 then
			self:setLabel(numberSpinner.Value)
		end

		local NumberSpinnerXSize = getNumberSpinnerXSize()

		while totalDigitXSize < NumberSpinnerXSize and self.isDestroyed ~= true do
			task.wait(0.05)
			if numOfDigits > minDigits and numOfDigits < maxDigits then
				numberSpinner.TextSize = label.TextSize
				break
			else
				numberSpinner.TextSize += 1
			end

			NumberSpinnerXSize = getNumberSpinnerXSize()
			totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
		end

		local labelParentContainerXSize = getLabelParentContainerXSize()
		while totalDigitXSize > labelParentContainerXSize and self.isDestroyed ~= true do
			task.wait(0.05)
			if numOfDigits < maxDigits and numOfDigits > minDigits then
				numberSpinner.TextSize = label.TextSize
				break
			else
				numberSpinner.TextSize -= 1
			end

			labelParentContainerXSize = getLabelParentContainerXSize()
			totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
		end
	end

	self:addToJanitor(numberSpinner.Frame.ChildAdded:Connect(adjustSize))
	self:addToJanitor(numberSpinner.Frame.ChildRemoved:Connect(adjustSize))
	self:addToJanitor(self.iconAdded:Connect(function()
		task.wait(1)
		adjustSize()
	end))

	self:updateParent()

	-- This corrects text to the size of a normal label
	numberSpinner.Name = "LabelSpinner"
	numberSpinner.Prefix = "$"
	numberSpinner.Commas = true
	numberSpinner.Decimals = 0
	numberSpinner.Duration = 0.25
	numberSpinner.Value = 10
	task.wait(0.2)

	return self
end



-- DESTROY/CLEANUP
function Icon:destroy()
	if self.isDestroyed then
		return
	end
	self:clearNotices()
	if self.parentIconUID then
		self:leave()
	end
	self.isDestroyed = true
	self.janitor:clean()
	Icon.iconRemoved:Fire(self)
end
Icon.Destroy = Icon.destroy

return Icon :: Types.StaticIcon]]></ProtectedString>
							<int64 name="SourceAssetId">16049574146</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043b1</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXA0376B1A7592423ABDF7BF54467F574A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d01</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Types</string>
								<string name="ScriptGuid">{82D2DA05-E2EF-4290-91A9-B629EB8524AD}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

-- GoodSignal Types (...but simpler!)

--- Connection

type Connection<Variant... = ...any> = {
	Disconnect: (self: Connection<Variant...>) -> (),
}

--- Signal

type Signal<Variant... = ...any> = {
	Connect: (self: Signal<Variant...>, func: (Variant...) -> ()) -> Connection<Variant...>,
    Once: (self: Signal<Variant...>, func: (Variant...) -> ()) -> Connection<Variant...>,
	Wait: (self: Signal<Variant...>) -> Variant...,
}

----------------------

export type IconState = "Deselected" | "Selected" | "Viewing"
export type Events = "selected" | "deselected" | "toggled" | "viewingStarted" | "viewingEnded" | "notified"
export type Alignment = "Left" | "Center" | "Right"
export type EventSource = "User" | "OneClick" | "AutoDeselect" | "HideParentFeature" | "Overflow"
export type Modification = { any }


type StaticFunctions = {
	getIcons: typeof(
		--[[
			Returns a dictionary of icons where the key is the icon's UID and value the icon.
		]]
		function(): { Icon }
			return (nil :: any) :: { Icon }
		end
	),
	getIcon: typeof(
		--[[
			Returns an icon of the given name or UID.
		]]
		function(nameOrUID: string): Icon?
			return nil :: any
		end
	),
	setTopbarEnabled: typeof(
		--[[
			When set to <code>false</code> all TopbarPlus ScreenGuis are hidden.
			This does not impact Roblox's Topbar.
		]]
		function(enabled: boolean)

		end
	),
	modifyBaseTheme: typeof(
		--[[
			Updates the appearance of all icons.
		]]
		function(modifications: { Modification })

		end
	),
	setDisplayOrder: typeof(
		--[[
			Sets the base DisplayOrder of all TopbarPlus ScreenGuis.
		]]
		function(order: number)

		end
	),
}

local MT = {} :: Methods
type Methods = {
	__index: typeof(MT),
	
	-- CLASS FUNCTIONS
	setName: typeof(
		--[[
			Sets the name of the Widget instance. This can be used in conjunction with <code>Icon.getIcon(name)</code>
		]]
		function(self: Icon, name: string): Icon
			return nil :: any
		end
	),
	getInstance: typeof(
		--[[
			Returns the first descendant found within the widget of name <code>instanceName</code>.
		]]
		function(self: Icon, instanceName: string): Instance?
			return (nil :: any) :: Instance?
		end
	),
	modifyTheme: typeof(
		--[[
			Updates the appearance of the icon.
		]]
		function(self: Icon, modifications: { Modification }): Icon
			return nil :: any
		end
	),
	modifyChildTheme: typeof(
		--[[
			Updates the appearance of all icons that are parented to this icon (for example when a menu or dropdown).
		]]
		function(self: Icon, modifications: { Modification }): Icon
			return nil :: any
		end
	),
	setEnabled: typeof(
		--[[
			When set to <code>false</code> the icon will be disabled and hidden.
		]]
		function(self: Icon, enabled: boolean): Icon
			return nil :: any
		end
	),
	select: typeof(
		--[[
			Selects the icon (as if it were clicked once).
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	deselect: typeof(
		--[[
			Deselects the icon (as if it were clicked, then clicked again).
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	notify: typeof(
		--[[
			Prompts a notice bubble which accumulates the further it is prompted.
			If the icon belongs to a dropdown or menu, then the notice will appear on the parent icon when the parent icon is deselected.
		]]
		function(self: Icon, clearNoticeEvent: Signal?): Icon
			return nil :: any
		end
	),
	clearNotices: typeof(
		--[[
			
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	disableOverlay: typeof(
		--[[
			When set to <code>true</code>, disables the shade effect which appears when the icon is pressed and released.
		]]
		function(self: Icon, disabled: boolean): Icon
			return nil :: any
		end
	),
	setImage: typeof(
		--[[
			Applies an image to the icon based on the given <code>imageId</code>. <code>imageId</code> can be an assetId or a complete asset string.
		]]
		function(self: Icon, imageId: string | number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setLabel: typeof(
		--[[
			
		]]
		function(self: Icon, text: string, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setOrder: typeof(
		--[[
			
		]]
		function(self: Icon, order: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setCornerRadius: typeof(
		--[[
			
		]]
		function(self: Icon, udim: UDim2, iconState: IconState?): Icon
			return nil :: any
		end
	),
	align: typeof(
		--[[
			This enables you to set the icon to the <code>"Left"</code> (default), <code>"Center"</code> or <code>"Right"</code> side of the screen.
		]]
		function(self: Icon, alignment: Alignment?): Icon
			return nil :: any
		end
	),
	setWidth: typeof(
		--[[
			This sets the minimum width the icon can be (it can be larger for instance when setting a long label). The default width is <code>44</code>.
		]]
		function(self: Icon, minimumSize: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setImageScale: typeof(
		--[[
			How large the image is relative to the icon. The default value is <code>0.5</code>.
		]]
		function(self: Icon, scale: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setImageRatio: typeof(
		--[[
			How stretched the image will appear. The default value is <code>1</code> (a perfect square).
		]]
		function(self: Icon, ratio: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setTextSize: typeof(
		--[[
			The size of the icon labels' text. The default value is <code>16</code>.
		]]
		function(self: Icon, textSize: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setTextFont: typeof(
		--[[
			Sets the labels FontFace.
			<code>font</code> can be a font family name (such as <code>"Creepster"</code>),
			a font enum (such as <code>Enum.Font.Bangers</code>),
			a font ID (such as <code>12187370928</code>),
			or font family link (such as <code>"rbxasset://fonts/families/Sarpanch.json"</code>).
		]]
		function(self: Icon, font: string | Enum.Font, fontWeight: Enum.FontWeight?, fontStyle: Enum.FontSize?, iconState: IconState?): Icon
			return nil :: any
		end
	),
	bindToggleItem: typeof(
		--[[
			Binds a GuiObject or LayerCollector to appear and disappeared when the icon is toggled.
		]]
		function(self: Icon, guiObjectOrLayerCollector: GuiObject | LayerCollector): Icon
			return nil :: any
		end
	),
	unbindToggleItem: typeof(
		--[[
			Unbinds the given GuiObject or LayerCollector from the toggle.
		]]
		function(self: Icon, guiObjectOrLayerCollector: GuiObject | LayerCollector): Icon
			return nil :: any
		end
	),
	bindEvent: typeof(
		--[[
			Connects to an icon event with <code>iconEventName</code>.
			It's important to remember all event names are in <code>camelCase</code>.
			<code>callback</code> is called with arguments <code>(self, ...)</code> when the event is triggered.
		]]
		function(self: Icon, event: Events, callback: (...any) -> ()): Icon
			return nil :: any
		end
	),
	unbindEvent: typeof(
		--[[
			Unbinds the connection of the associated <code>iconEventName</code>.
		]]
		function(self: Icon, event: Events): Icon
			return nil :: any
		end
	),
	bindToggleKey: typeof(
		--[[
			Binds a keycode which toggles the icon when pressed.
		]]
		function(self: Icon, keycode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	unbindToggleKey: typeof(
		--[[
			Unbinds the given keycode.
		]]
		function(self: Icon, keycode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	call: typeof(
		--[[
			Calls the function immediately via <code>task.spawn</code>.
			The first argument passed is the icon itself.
			This is useful when needing to extend the behaviour of an icon while remaining in the chain.
		]]
		function(self: Icon, func: (self: Icon) -> (...any)): Icon
			return nil :: any
		end
	),
	addToJanitor: typeof(
		--[[
			Passes the given userdata to the icons janitor to be destroyed/disconnected on the icons destruction.
			If a function is passed, it will be called when the icon is destroyed.
		]]
		function(self: Icon, userdata: unknown): Icon
			return nil :: any
		end
	),
	lock: typeof(
		--[[
			Prevents the icon being toggled by user-input (such as clicking), however, the icon can still be toggled via localscript using methods such as <code>icon:select()</code>.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	unlock: typeof(
		--[[
			Re-enables user-input to toggle the icon again.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	debounce: typeof(
		--[[
			Locks the icon, yields for the given time, then unlocks the icon, effectively shorthand for <code>icon:lock() task.wait(seconds) icon:unlock()</code>.
			This is useful for applying cooldowns (to prevent an icon from being pressed again) after an icon has been selected or deselected.
		]]
		function(self: Icon, seconds: number): Icon
			return nil :: any
		end
	),
	autoDeselect: typeof(
		--[[
			When set to <code>true</code> (the default) the icon is deselected when another icon (with autoDeselect enabled) is pressed.
			Set to <code>false</code> to prevent the icon being deselected when another icon is selected (a useful behaviour in dropdowns).
		]]
		function(self: Icon, enabled: boolean?): Icon
			return nil :: any
		end
	),
	oneClick: typeof(
		--[[
			When set to true the icon will automatically deselect when selected.
			This creates the effect of a single click button.
		]]
		function(self: Icon, enabled: boolean?): Icon
			return nil :: any
		end
	),
	setCaption: typeof(
		--[[
			Sets a caption. To remove, pass <code>nil</code> as <code>text</code>.
		]]
		function(self: Icon, text: string?): Icon
			return nil :: any
		end
	),
	setCaptionHint: typeof(
		--[[
			This customizes the appearance of the caption's hint without having to use <code>icon:bindToggleKey</code>.
		]]
		function(self: Icon, keyCode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	setDropdown: typeof(
		--[[
			Creates a vertical dropdown based upon the given table array of icons.
			Pass an empty table <code>{}</code> to remove the dropdown.
		]]
		function(self: Icon, icons: { Icon }): Icon
			return nil :: any
		end
	),
	joinDropdown: typeof(
		--[[
			Joins the dropdown of <code>parentIcon</code>.
			This is what <code>icon:setDropdown</code> calls internally on the icons within its array.
		]]
		function(self: Icon, parent: Icon): Icon
			return nil :: any
		end
	),
	setMenu: typeof(
		--[[
			Creates a horizontal menu based upon the given array of icons.
			Pass an empty table <code>{}</code> to remove the menu.
		]]
		function(self: Icon, icons: { Icon }): Icon
			return nil :: any
		end
	),
	joinMenu: typeof(
		--[[
			Joins the menu of <code>parentIcon</code>.
			This is what <code>icon:setMenu</code> calls internally on the icons within its array.
		]]
		function(self: Icon, parentIcon: Icon): Icon
			return nil :: any
		end
	),
	leave: typeof(
		--[[
			Unparents an icon from a parentIcon if it belongs to a dropdown or menu.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	convertLabelToNumberSpinner: typeof(
		--[[
			Unparents an icon from a parentIcon if it belongs to a dropdown or menu.
		]]
		function(self: Icon, numberSpinner: any): Icon
			return nil :: any
		end
	),
	destroy: typeof(
		--[[
			Clears all connections and destroys all instances associated with the icon.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
} & StaticFunctions

type Fields = {
	-- CLASS PROPERTIES
	name: string,
	isSelected: boolean,
	isEnabled: boolean,
	totalNotices: number,
	locked: boolean,

	-- CLASS EVENTS
	selected: Signal<EventSource>,
	deselected: Signal<EventSource>,
	toggled: Signal<boolean, EventSource>,
	viewingStarted: Signal,
	viewingEnded: Signal,
	notified: Signal,
}

export type Icon = typeof(setmetatable({} :: Fields, MT))

export type StaticIcon = {
	new: typeof(
		--[[
			Constructs an empty <code>32x32</code> icon on the topbar.
		]]
		function(): Icon
			return nil :: any
		end
	),
} & StaticFunctions

return {}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043b2</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXB0D45DEB4CE24A1180922853C2185AA2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d14</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">VERSION</string>
								<string name="ScriptGuid">{0652B30C-25EA-4B12-968C-B1F969910872}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- LOCAL
local VERSION = {}



-- SHARED
VERSION.appVersion = "v3.2.5"
VERSION.latestVersion = nil :: string?



-- FUNCTIONS
function VERSION.getLatestVersion(): string?
	local DEVELOPMENT_PLACE_ID = 117501901079852
	local latestVersion = VERSION.latestVersion
	if latestVersion then
		return latestVersion
	end
	local placeName = ""
	while true do
		local success, hdDevelopmentDetails = pcall(function()
			return game:GetService("MarketplaceService"):GetProductInfo(DEVELOPMENT_PLACE_ID)
		end)
		if success and hdDevelopmentDetails then
			placeName = hdDevelopmentDetails.Name
			break
		end
		task.wait(1)
	end
	latestVersion = string.match(placeName, "^TopbarPlus (.*)$")
	if latestVersion then
		latestVersion = latestVersion:gsub("%s+", "") -- Remove all whitespace (spaces, tabs, newlines)
	end
	VERSION.latestVersion = latestVersion
	return latestVersion
end

function VERSION.getAppVersion()
	return VERSION.appVersion
end

function VERSION.isUpToDate()
	local latestVersion = VERSION.getLatestVersion()
	local appVersion = VERSION.getAppVersion()
	return latestVersion ~= nil and latestVersion == appVersion
end



return VERSION]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043b3</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC0E5153A5592426BB21B1863389D1DF4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d15</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Reference</string>
								<string name="ScriptGuid">{A2BDA7A1-B62C-4619-9987-B859C08E5F44}</string>
								<ProtectedString name="Source"><![CDATA[-- This module enables you to place Icon wherever you like within the data model while
-- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it
-- This is necessary to prevent two TopbarPlus applications initiating at runtime which would
-- cause icons to overlap with each other

local replicatedStorage = game:GetService("ReplicatedStorage")
local Reference = {}
Reference.objectName = "TopbarPlusReference"

function Reference.addToReplicatedStorage()
	local existingItem = replicatedStorage:FindFirstChild(Reference.objectName)
    if existingItem then
        return false
    end
    local objectValue = Instance.new("ObjectValue")
	objectValue.Name = Reference.objectName
    objectValue.Value = script.Parent
    objectValue.Parent = replicatedStorage
    return objectValue
end

function Reference.getObject()
	local objectValue = replicatedStorage:FindFirstChild(Reference.objectName)
    if objectValue then
        return objectValue
    end
    return false
end

return Reference]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043b4</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC7EFA80343494236A2851A74F8555B6A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d16</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Attribute</string>
								<string name="ScriptGuid">{6F6A279D-5657-43E0-A9CD-D053DF6344D1}</string>
								<ProtectedString name="Source"><![CDATA[--[[

	TopbarPlus was developed by ForeverHD and is possible thanks to HD Admin.

	By using TopbarPlus in your experience or application, you agree to either:
		1. Keep Attribute unchanged, or
		2. If an experience, to credit TopbarPlus in your description, or in a
		   devforum post linked from your experience's description.

	v3 has involved over 350 hours of work to develop, so please consider supporting
	its development by reporting any issues or feedback you have at its repository:
	https://github.com/1ForeverHD/TopbarPlus

	You can get in touch with me on Discord via the social link here:
	https://create.roblox.com/store/asset/92368439343389/TopbarPlus

	Many thanks! ~Ben, June 10th 2025
	
]]

task.defer(function()
	local RunService = game:GetService("RunService")
	local VERSION = require(script.Parent.VERSION)
	local appVersion = VERSION.getAppVersion()
	local latestVersion = VERSION.getLatestVersion()
	local isOutdated = not VERSION.isUpToDate()
	if not RunService:IsStudio() then
		print(`🍍 Running TopbarPlus {appVersion} by @ForeverHD & HD Admin`)
	end
	if isOutdated then
		--warn(`A new version of TopbarPlus ({latestVersion}) is available: https://devforum.roblox.com/t/topbarplus/1017485`)
	end
end)

return {}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043b5</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2015E12531FC4CA4BC27347A671A6AA1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d17</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Utility</string>
								<string name="ScriptGuid">{5E82D946-5FB8-4B2D-9441-3886E9BD2BC4}</string>
								<ProtectedString name="Source"><![CDATA[-- Just generic utility functions which I use and repeat across all my projects



-- LOCAL
local Utility = {}
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer



-- FUNCTIONS
function Utility.createStagger(delayTime, callback, delayInitially)
	-- This creates and returns a function which when called
	-- acts identically to callback, however will only be called
	-- for a maximum of once per delayTime. If the returned function
	-- is called more than once during the delayTime, then it will
	-- wait until the expiryTime then perform another recall.
	-- This is useful for visual interfaces and effects which may be
	-- triggered multiple times within a frame or short period, but which
	-- we don't necessary need to (for performance reasons).
	local staggerActive = false
	local multipleCalls = false
	if not delayTime or delayTime == 0 then
		-- We make 0.01 instead of 0 because devices can now run at
		-- different frame rates
		delayTime = 0.01
	end
	local function staggeredCallback(...)
		if staggerActive then
			multipleCalls = true
			return
		end
		local packedArgs = table.pack(...)
		staggerActive = true
		multipleCalls = false
		task.spawn(function()
			if delayInitially then
				task.wait(delayTime)
			end
			callback(table.unpack(packedArgs))
		end)
		task.delay(delayTime, function()
			staggerActive = false
			if multipleCalls then
				-- This means it has been called at least once during
				-- the stagger period, so call again
				staggeredCallback(table.unpack(packedArgs))
			end
		end)
	end
	return staggeredCallback
end

function Utility.round(n)
	-- Credit to Darkmist101 for this
	return math.floor(n + 0.5)
end

function Utility.reverseTable(t)
	for i = 1, math.floor(#t/2) do
		local j = #t - i + 1
		t[i], t[j] = t[j], t[i]
	end
end

function Utility.copyTable(t)
	-- Credit to Stephen Leitnick (September 13, 2017) for this function from TableUtil
	assert(type(t) == "table", "First argument must be a table")
	local tCopy = table.create(#t)
	for k,v in pairs(t) do
		if (type(v) == "table") then
			tCopy[k] = Utility.copyTable(v)
		else
			tCopy[k] = v
		end
	end
	return tCopy
end

local validCharacters = {"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","1","2","3","4","5","6","7","8","9","0","<",">","?","@","{","}","[","]","!","(",")","=","+","~","#"}
function Utility.generateUID(length)
	length = length or 8
	local UID = ""
	local list = validCharacters
	local total = #list
	for i = 1, length do
		local randomCharacter = list[math.random(1, total)]
		UID = UID..randomCharacter
	end
	return UID
end

local instanceTrackers = {}
function Utility.setVisible(instance, bool, sourceUID)
	-- This effectively works like a buff object but
	-- incredibly simplified. It stacks false values
	-- so that if there is more than more than, the 
	-- instance remains hidden even if set visible true
	local tracker = instanceTrackers[instance]
	if not tracker then
		tracker = {}
		instanceTrackers[instance] = tracker
		instance.Destroying:Once(function()
			instanceTrackers[instance] = nil
		end)
	end
	if not bool then
		tracker[sourceUID] = true
	else
		tracker[sourceUID] = nil
	end
	local isVisible = bool
	if bool then
		for sourceUID, _ in pairs(tracker) do
			isVisible = false
			break
		end
	end
	instance.Visible = isVisible
end

function Utility.formatStateName(incomingStateName)
	return string.upper(string.sub(incomingStateName, 1, 1))..string.lower(string.sub(incomingStateName, 2))
end

function Utility.localPlayerRespawned(callback)
	-- The client localscript may be located under a ScreenGui with ResetOnSpawn set to true
	-- In these scenarios, traditional methods like CharacterAdded won't be called by the
	-- time the localscript has been destroyed, therefore we listen for removing instead
	-- If humanoid and health == 0, then reset/died normally, else was
	-- forcefully reset via a method such as LoadCharacter
	-- We wrap this behaviour in case any additional quirks need to be accounted for
	localPlayer.CharacterRemoving:Connect(callback)
end

function Utility.getClippedContainer(screenGui)
	-- We always want clipped items to display in front hence
	-- why we have this
	local clippedContainer = screenGui:FindFirstChild("ClippedContainer")
	if not clippedContainer then
		clippedContainer = Instance.new("Folder")
		clippedContainer.Name = "ClippedContainer"
		clippedContainer.Parent = screenGui
	end
	return clippedContainer
end

local Janitor = require(script.Parent.Packages.Janitor)
local GuiService = game:GetService("GuiService")
function Utility.clipOutside(icon, instance)
	local cloneJanitor = icon.janitor:add(Janitor.new())
	instance.Destroying:Once(function()
		cloneJanitor:Destroy()
	end)
	icon.janitor:add(instance)

	local originalParent = instance.Parent
	local clone = cloneJanitor:add(Instance.new("Frame"))
	clone:SetAttribute("IsAClippedClone", true)
	clone.Name = instance.Name
	clone.AnchorPoint = instance.AnchorPoint
	clone.Size = instance.Size
	clone.Position = instance.Position
	clone.BackgroundTransparency = 1
	clone.LayoutOrder = instance.LayoutOrder
	clone.Parent = originalParent

	local valueInstance = Instance.new("ObjectValue")
	valueInstance.Name = "OriginalInstance"
	valueInstance.Value = instance
	valueInstance.Parent = clone

	local valueInstanceCopy = valueInstance:Clone()
	instance:SetAttribute("HasAClippedClone", true)
	valueInstanceCopy.Name = "ClippedClone"
	valueInstanceCopy.Value = clone
	valueInstanceCopy.Parent = instance

	local screenGui
	local Icon = require(icon.iconModule)
	local container = Icon.container
	local function updateScreenGui()
		local originalScreenGui = originalParent:FindFirstAncestorWhichIsA("ScreenGui")
		screenGui = if string.match(originalScreenGui.Name, "Clipped") then originalScreenGui else container[originalScreenGui.Name.."Clipped"]
		instance.AnchorPoint = Vector2.new(0, 0)
		instance.Parent = Utility.getClippedContainer(screenGui)
	end
	cloneJanitor:add(icon.alignmentChanged:Connect(updateScreenGui))
	updateScreenGui()

	-- Lets copy over children that modify size
	for _, child in pairs(instance:GetChildren()) do
		if child:IsA("UIAspectRatioConstraint") then
			child:Clone().Parent = clone
		end
	end

	-- If the icon is hidden, its important we are too (as
	-- setting a parent to visible = false no longer makes
	-- this hidden)
	local widget = icon.widget
	local isOutsideParent = false
	local ignoreVisibilityUpdater = instance:GetAttribute("IgnoreVisibilityUpdater")
	local function updateVisibility()
		if ignoreVisibilityUpdater then
			return
		end
		local isVisible = widget.Visible
		if isOutsideParent then
			isVisible = false
		end
		Utility.setVisible(instance, isVisible, "ClipHandler")
	end
	cloneJanitor:add(widget:GetPropertyChangedSignal("Visible"):Connect(updateVisibility))

	local previousScroller
	local function checkIfOutsideParentXBounds()
		-- Defer so that roblox's properties reflect their true values
		task.defer(function()
			-- If the instance is within a parent item (such as a dropdown or menu)
			-- then we hide it if it exceeds the bounds of that parent
			local parentInstance
			local ourUID = icon.UID
			local nextIconUID = ourUID
			local shouldClipToParent = instance:GetAttribute("ClipToJoinedParent")
			if shouldClipToParent then
				for i = 1, 10 do -- This is safer than while true do and should never be > 4 parents
					local nextIcon = Icon.getIconByUID(nextIconUID)
					if not nextIcon then
						break
					end
					local nextParentInstance = nextIcon.joinedFrame
					nextIconUID = nextIcon.parentIconUID
					if not nextParentInstance then
						break
					end
					parentInstance = nextParentInstance
					if parentInstance and parentInstance.Name == "DropdownScroller" then
						break
					end
				end
			end
			if not parentInstance then
				isOutsideParent = false
				updateVisibility()
				return
			end
			local pos = instance.AbsolutePosition
			local halfSize = instance.AbsoluteSize/2
			local parentPos = parentInstance.AbsolutePosition
			local parentSize = parentInstance.AbsoluteSize
			local posHalf = (pos + halfSize)
			local exceededLeft = posHalf.X < parentPos.X
			local exceededRight = posHalf.X > (parentPos.X + parentSize.X)
			local exceededTop = posHalf.Y < parentPos.Y
			local exceededBottom = posHalf.Y > (parentPos.Y + parentSize.Y)
			local hasExceeded = exceededLeft or exceededRight or exceededTop or exceededBottom
			if hasExceeded ~= isOutsideParent then
				isOutsideParent = hasExceeded
				updateVisibility()
			end
			if parentInstance:IsA("ScrollingFrame") and previousScroller ~= parentInstance then
				previousScroller = parentInstance
				local connection = parentInstance:GetPropertyChangedSignal("AbsoluteWindowSize"):Connect(function()
					checkIfOutsideParentXBounds()
				end)
				cloneJanitor:add(connection, "Disconnect", "TrackUtilityScroller-"..ourUID)
			end
		end)
	end

	local camera = workspace.CurrentCamera
	local additionalOffsetX = instance:GetAttribute("AdditionalOffsetX") or 0
	local function trackProperty(property)
		local absoluteProperty = "Absolute"..property
		local function updateProperty()
			local cloneValue = clone[absoluteProperty]
			local absoluteValue = UDim2.fromOffset(cloneValue.X, cloneValue.Y)
			if property == "Position" then

				-- This binds the instances within the bounds of the screen
				local SIDE_PADDING = 4
				local limitX = camera.ViewportSize.X - instance.AbsoluteSize.X - SIDE_PADDING
				local inputX = absoluteValue.X.Offset
				if inputX < SIDE_PADDING then
					inputX = SIDE_PADDING
				elseif inputX > limitX then
					inputX = limitX
				end
				absoluteValue = UDim2.fromOffset(inputX, absoluteValue.Y.Offset)

				-- AbsolutePosition does not perfectly match with TopbarInsets enabled
				-- This corrects this
				local topbarInset = GuiService.TopbarInset
				local viewportWidth = workspace.CurrentCamera.ViewportSize.X
				local guiWidth = screenGui.AbsoluteSize.X
				local guiOffset = screenGui.AbsolutePosition.X
				--local widthDifference = guiOffset - topbarInset.Min.X
				local oldTopbarCenterOffset = 0--widthDifference/30
				local offsetX = if Icon.isOldTopbar then guiOffset else viewportWidth - guiWidth - oldTopbarCenterOffset
				
				-- Also add additionalOffset
				offsetX -= additionalOffsetX
				absoluteValue += UDim2.fromOffset(-offsetX, topbarInset.Height)

				-- Finally check if within its direct parents bounds
				checkIfOutsideParentXBounds()

			end
			instance[property] = absoluteValue
		end
		
		-- This defer is essential as the listener may be in a different screenGui to the actor
		local updatePropertyStaggered = Utility.createStagger(0.01, updateProperty)
		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyStaggered))
		cloneJanitor:add(clone:GetAttributeChangedSignal("ForceUpdate"):Connect(function()
			updatePropertyStaggered()
		end))

		-- This is to patch a weirddddd bug with ScreenGuis with SreenInsets set to
		-- 'TopbarSafeInsets'. For some reason the absolute position of gui instances
		-- within this type of screenGui DO NOT accurately update to match their new
		-- real world position; instead they jump around almost randomly for a few frames.
		-- I have spent way too many hours trying to solve this bug, I think the only way
		-- for the time being is to not use ScreenGuis with TopbarSafeInsets, but I don't
		-- have time to redesign the entire system around that at the moment.
		-- Here's a GIF of this bug: https://i.imgur.com/VitHdC1.gif
		local updatePropertyPatch = Utility.createStagger(0.5, updateProperty, true)
		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyPatch))
		
		-- When the screenGui is resized (such as when chat is hidden/shown), we need
		-- to update the position of the clone. Ths especially fixes the following:
		-- https://devforum.roblox.com/t/bug/1017485/1732
		if property == "Position" then
			cloneJanitor:add(screenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				updatePropertyStaggered()
			end))
		end

	end
	task.delay(0.1, checkIfOutsideParentXBounds)
	checkIfOutsideParentXBounds()
	updateVisibility()
	trackProperty("Position")
	
	-- Track visiblity changes
	cloneJanitor:add(instance:GetPropertyChangedSignal("Visible"):Connect(function()
		--print("Visiblity changed:", instance, clone, instance.Visible)
		--clone.Visible = instance.Visible
	end))

	-- To ensure accurate positioning, it's important the clone also remains the same size as the instance
	local shouldTrackCloneSize = instance:GetAttribute("TrackCloneSize")
	if shouldTrackCloneSize then
		trackProperty("Size")
	else
		cloneJanitor:add(instance:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			local absolute = instance.AbsoluteSize
			clone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
		end))
	end

	return clone
end

function Utility.joinFeature(originalIcon, parentIcon, iconsArray, scrollingFrameOrFrame)

	-- This is resonsible for moving the icon under a feature like a dropdown
	local joinJanitor = originalIcon.joinJanitor
	joinJanitor:clean()
	if not scrollingFrameOrFrame then
		originalIcon:leave()
		return
	end
	originalIcon.parentIconUID = parentIcon.UID
	originalIcon.joinedFrame = scrollingFrameOrFrame
	local function updateAlignent()
		local parentAlignment = parentIcon.alignment
		if parentAlignment == "Center" then
			parentAlignment = "Left"
		end
		originalIcon:setAlignment(parentAlignment, true)
	end
	joinJanitor:add(parentIcon.alignmentChanged:Connect(updateAlignent))
	updateAlignent()
	originalIcon:modifyTheme({"IconButton", "BackgroundTransparency", 1}, "JoinModification")
	originalIcon:modifyTheme({"ClickRegion", "Active", false}, "JoinModification")
	if parentIcon.childModifications then
		-- We defer so that the default values (such as dropdown
		-- minimum width can be applied before any custom
		-- child modifications from the user)
		task.defer(function()
			originalIcon:modifyTheme(parentIcon.childModifications, parentIcon.childModificationsUID)
		end)
	end
	--
	local clickRegion = originalIcon:getInstance("ClickRegion")
	local function makeSelectable()
		clickRegion.Selectable = parentIcon.isSelected
	end
	joinJanitor:add(parentIcon.toggled:Connect(makeSelectable))
	task.defer(makeSelectable)
	joinJanitor:add(function()
		clickRegion.Selectable = true
	end)
	--

	-- We track icons in arrays and dictionaries using their UID instead of the icon
	-- itself to prevent heavy cyclical tables when printing the icons
	local originalIconUID = originalIcon.UID
	table.insert(iconsArray, originalIconUID)
	parentIcon:autoDeselect(false)
	parentIcon.childIconsDict[originalIconUID] = true
	if not parentIcon.isEnabled then
		parentIcon:setEnabled(true)
	end
	originalIcon.joinedParent:Fire(parentIcon)

	-- This is responsible for removing it from that feature and updating
	-- their parent icon so its informed of the icon leaving it
	joinJanitor:add(function()
		local joinedFrame = originalIcon.joinedFrame
		if not joinedFrame then
			return
		end
		for i, iconUID in pairs(iconsArray) do
			if iconUID == originalIconUID then
				table.remove(iconsArray, i)
				break
			end
		end
		local Icon = require(originalIcon.iconModule)
		local parentIcon = Icon.getIconByUID(originalIcon.parentIconUID)
		if not parentIcon then
			return
		end
		originalIcon:setAlignment(originalIcon.originalAlignment)
		originalIcon.parentIconUID = false
		originalIcon.joinedFrame = false
		--originalIcon:setBehaviour("IconButton", "BackgroundTransparency", nil, true)
		originalIcon:removeModification("JoinModification")
		
		local parentHasNoChildren = true
		local parentChildIcons = parentIcon.childIconsDict
		parentChildIcons[originalIconUID] = nil
		for childIconUID, _ in pairs(parentChildIcons) do
			parentHasNoChildren = false
			break
		end
		if parentHasNoChildren and not parentIcon.isAnOverflow then
			parentIcon:setEnabled(false)
		end
		updateAlignent()

	end)

end



return Utility]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043b6</UniqueId>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXD329074D5976404093D655AFD802774B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d02</UniqueId>
								<string name="Name">Elements</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043b7</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX9E234AC92028402B85C6569F6286438A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d03</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Caption</string>
									<string name="ScriptGuid">{8973E956-D9DE-4A15-A53F-FF34AD59AB06}</string>
									<ProtectedString name="Source"><![CDATA[local CAPTION_COLOR = Color3.fromRGB(39, 41, 48)
local TEXT_SIZE = 15
return function(icon)

	-- Credit to lolmansReturn and Canary Software for
	-- retrieving these values
	local clickRegion = icon:getInstance("ClickRegion")
	local caption = Instance.new("CanvasGroup")
	caption.Name = "Caption"
	caption.AnchorPoint = Vector2.new(0.5, 0)
	caption.BackgroundTransparency = 1
	caption.BorderSizePixel = 0
	caption.GroupTransparency = 1
	caption.Position = UDim2.fromOffset(0, 0)
	caption.Visible = true
	caption.ZIndex = 30
	caption.Parent = clickRegion

	local box = Instance.new("Frame")
	box.Name = "Box"
	box.AutomaticSize = Enum.AutomaticSize.XY
	box.BackgroundColor3 = CAPTION_COLOR
	box.Position = UDim2.fromOffset(4, 7)
	box.ZIndex = 12
	box.Parent = caption

	local header = Instance.new("TextLabel")
	header.Name = "Header"
	header.FontFace = Font.new(
		"rbxasset://fonts/families/BuilderSans.json",
		Enum.FontWeight.Medium,
		Enum.FontStyle.Normal
	)
	header.Text = "Caption"
	header.TextColor3 = Color3.fromRGB(255, 255, 255)
	header.TextSize = TEXT_SIZE
	header.TextTruncate = Enum.TextTruncate.None
	header.TextWrapped = false
	header.TextXAlignment = Enum.TextXAlignment.Left
	header.AutomaticSize = Enum.AutomaticSize.X
	header.BackgroundTransparency = 1
	header.LayoutOrder = 1
	header.Size = UDim2.fromOffset(0, 16)
	header.ZIndex = 18
	header.Parent = box

	local layout = Instance.new("UIListLayout")
	layout.Name = "Layout"
	layout.Padding = UDim.new(0, 8)
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Parent = box

	local UICorner = Instance.new("UICorner")
	UICorner.Name = "CaptionCorner"
	UICorner.Parent = box

	local padding = Instance.new("UIPadding")
	padding.Name = "Padding"
	padding.PaddingBottom = UDim.new(0, 12)
	padding.PaddingLeft = UDim.new(0, 12)
	padding.PaddingRight = UDim.new(0, 12)
	padding.PaddingTop = UDim.new(0, 12)
	padding.Parent = box

	local hotkeys = Instance.new("Frame")
	hotkeys.Name = "Hotkeys"
	hotkeys.AutomaticSize = Enum.AutomaticSize.Y
	hotkeys.BackgroundTransparency = 1
	hotkeys.LayoutOrder = 3
	hotkeys.Size = UDim2.fromScale(1, 0)
	hotkeys.Visible = false
	hotkeys.Parent = box

	local layout1 = Instance.new("UIListLayout")
	layout1.Name = "Layout1"
	layout1.Padding = UDim.new(0, 6)
	layout1.FillDirection = Enum.FillDirection.Vertical
	layout1.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout1.HorizontalFlex = Enum.UIFlexAlignment.None
	layout1.ItemLineAlignment = Enum.ItemLineAlignment.Automatic
	layout1.VerticalFlex = Enum.UIFlexAlignment.None
	layout1.SortOrder = Enum.SortOrder.LayoutOrder
	layout1.Parent = hotkeys

	local keyTag1 = Instance.new("ImageLabel")
	keyTag1.Name = "Key1"
	keyTag1.Image = "rbxasset://textures/ui/Controls/key_single.png"
	keyTag1.ImageTransparency = 0.7
	keyTag1.ScaleType = Enum.ScaleType.Slice
	keyTag1.SliceCenter = Rect.new(5, 5, 23, 24)
	keyTag1.AutomaticSize = Enum.AutomaticSize.X
	keyTag1.BackgroundTransparency = 1
	keyTag1.LayoutOrder = 1
	keyTag1.Size = UDim2.fromOffset(0, 30)
	keyTag1.ZIndex = 15
	keyTag1.Parent = hotkeys

	local inset = Instance.new("UIPadding")
	inset.Name = "Inset"
	inset.PaddingLeft = UDim.new(0, 8)
	inset.PaddingRight = UDim.new(0, 8)
	inset.Parent = keyTag1

	local labelContent = Instance.new("TextLabel")
	labelContent.AutoLocalize = false
	labelContent.Name = "LabelContent"
	labelContent.FontFace = Font.new(
		"rbxasset://fonts/families/GothamSSm.json",
		Enum.FontWeight.Medium,
		Enum.FontStyle.Normal
	)
	labelContent.Text = ""
	labelContent.TextColor3 = Color3.fromRGB(189, 190, 190)
	labelContent.TextSize = TEXT_SIZE
	labelContent.AutomaticSize = Enum.AutomaticSize.X
	labelContent.BackgroundTransparency = 1
	labelContent.Position = UDim2.fromOffset(0, -1)
	labelContent.Size = UDim2.fromScale(1, 1)
	labelContent.ZIndex = 16
	labelContent.Parent = keyTag1
	
	local caret = Instance.new("ImageLabel")
	caret.Name = "Caret"
	caret.Image = "rbxasset://LuaPackages/Packages/_Index/FoundationImages/FoundationImages/SpriteSheets/img_set_2x_1.png"
	caret.ImageColor3 = CAPTION_COLOR
	caret.ImageRectOffset = Vector2.new(0, 494)
	caret.ImageRectSize = Vector2.new(32, 16)
	caret.AnchorPoint = Vector2.new(0, 0.5)
	caret.BackgroundTransparency = 1
	caret.Position = UDim2.new(0, 0, 0, 4)
	caret.Rotation = 180
	caret.Size = UDim2.fromOffset(16, 8)
	caret.ZIndex = 12
	caret.Parent = caption

	local dropShadow = Instance.new("ImageLabel")
	dropShadow.Name = "DropShadow"
	dropShadow.Image = "rbxasset://LuaPackages/Packages/_Index/FoundationImages/FoundationImages/SpriteSheets/img_set_2x_5.png"
	dropShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
	dropShadow.ImageRectOffset = Vector2.new(52, 460)
	dropShadow.ImageRectSize = Vector2.new(50, 50)
	dropShadow.ImageTransparency = 0.45
	dropShadow.ScaleType = Enum.ScaleType.Slice
	dropShadow.SliceCenter = Rect.new(12, 12, 13, 13)
	dropShadow.BackgroundTransparency = 1
	dropShadow.Position = UDim2.fromOffset(0, 5)
	dropShadow.Size = UDim2.new(1, 0, 0, 48)
	dropShadow.Parent = caption
	box:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		dropShadow.Size = UDim2.new(1, 0, 0, box.AbsoluteSize.Y + 8)
	end)
	
	-- It's important we match the sizes as this is not
	-- handles within clipOutside (as it assumes the sizes
	-- are already the same)
	local captionJanitor = icon.captionJanitor
	local _, captionClone = icon:clipOutside(caption)
	captionClone.AutomaticSize = Enum.AutomaticSize.None
	local function matchSize()
		local absolute = caption.AbsoluteSize
		captionClone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
	end
	captionJanitor:add(caption:GetPropertyChangedSignal("AbsoluteSize"):Connect(matchSize))
	matchSize()
	
	
	
	-- This handles the appearing/disappearing/positioning of the caption
	local isCompletelyEnabled = false
	local captionHeader = caption.Box.Header
	local UserInputService = game:GetService("UserInputService")
	local function updateHotkey(keyCodeEnum)
		local hasKeyboard = UserInputService.KeyboardEnabled
		local text = caption:GetAttribute("CaptionText") or ""
		local hideHeader = text == "_hotkey_"
		if not hasKeyboard and hideHeader then
			icon:setCaption()
			return
		end
		captionHeader.Text = text
		captionHeader.Visible = not hideHeader
		if keyCodeEnum then
			labelContent.Text = keyCodeEnum.Name
			hotkeys.Visible = true
		end
		if not hasKeyboard then
			hotkeys.Visible = false
		end
	end
	caption:GetAttributeChangedSignal("CaptionText"):Connect(updateHotkey)

	local EASING_STYLE = Enum.EasingStyle.Quad
	local TWEEN_SPEED = 0.2
	local TWEEN_INFO_IN = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.In)
	local TWEEN_INFO_OUT = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.Out)
	local TweenService = game:GetService("TweenService")
	local RunService = game:GetService("RunService")
	local function getCaptionPosition(customEnabled)
		local enabled = if customEnabled ~= nil then customEnabled else isCompletelyEnabled
		local yOut = 2
		local yIn = yOut + 8
		local yOffset = if enabled then yIn else yOut
		return UDim2.new(0.5, 0, 1, yOffset)
	end
	local function updatePosition(forcedEnabled)
		
		-- Ignore changes if not enabled to reduce redundant calls
		if not isCompletelyEnabled then
			return
		end
		
		-- Currently the one thing which isn't accounted for are the bounds of the screen
		-- This would be an issue if someone sets a long caption text for the left or
		-- right most icon
		local enabled = if forcedEnabled ~= nil then forcedEnabled else isCompletelyEnabled
		local startPosition = getCaptionPosition(not enabled)
		local endPosition = getCaptionPosition(enabled)
		
		-- It's essential we reset the carets position to prevent the x sizing bounds
		-- of the caption from infinitely scaling up
		if enabled then
			local caretY = caret.Position.Y.Offset
			caret.Position = UDim2.fromOffset(0, caretY)
			caption.AutomaticSize = Enum.AutomaticSize.XY
			caption.Size = UDim2.fromOffset(32, 53)
		else
			local absolute = caption.AbsoluteSize
			caption.AutomaticSize = Enum.AutomaticSize.Y
			caption.Size = UDim2.fromOffset(absolute.X, absolute.Y)
		end
		
		-- We initially default to the opposite state
		local previousCaretX
		local function updateCaret()
			local caretX = clickRegion.AbsolutePosition.X - caption.AbsolutePosition.X + clickRegion.AbsoluteSize.X/2 - caret.AbsoluteSize.X/2
			local caretY = caret.Position.Y.Offset
			local newCaretPosition = UDim2.fromOffset(caretX, caretY)
			if previousCaretX ~= caretX then
				-- Again, it's essential we reset the caret if
				-- a difference in X position is detected otherwise
				-- a slight quirk with AutomaticCanvas can cause
				-- the caption to infinitely scale
				previousCaretX = caretX
				caret.Position = UDim2.fromOffset(0, caretY)
				task.wait()
			end
			caret.Position = newCaretPosition
		end
		captionClone.Position = startPosition
		updateCaret()
		
		-- Now we tween into the new state
		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
		local tween = TweenService:Create(captionClone, tweenInfo, {Position = endPosition})
		local updateCaretConnection = RunService.Heartbeat:Connect(updateCaret)
		tween:Play()
		tween.Completed:Once(function()
			updateCaretConnection:Disconnect()
		end)
		
	end
	captionJanitor:add(clickRegion:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		updatePosition()
	end))
	updatePosition(false)
	
	captionJanitor:add(icon.toggleKeyAdded:Connect(updateHotkey))
	for keyCodeEnum, _ in pairs(icon.bindedToggleKeys) do
		updateHotkey(keyCodeEnum)
		break
	end
	captionJanitor:add(icon.fakeToggleKeyChanged:Connect(updateHotkey))
	local fakeToggleKey = icon.fakeToggleKey
	if fakeToggleKey then
		updateHotkey(fakeToggleKey)
	end

	local function setCaptionEnabled(enabled)
		if isCompletelyEnabled == enabled then
			return
		end
		local joinedFrame = icon.joinedFrame
		if joinedFrame and string.match(joinedFrame.Name, "Dropdown") then
			enabled = false
		end
		isCompletelyEnabled = enabled
		local newTransparency = (enabled and 0) or 1
		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
		local tweenTransparency = TweenService:Create(caption, tweenInfo, {
			GroupTransparency = newTransparency
		})
		tweenTransparency:Play()
		if enabled then
			captionClone:SetAttribute("ForceUpdate", true)
		end
		updatePosition()
		updateHotkey()
	end
	
	local WAIT_DURATION = 0.5
	local RECOVER_PERIOD = 0.3
	local Icon = require(icon.iconModule)
	captionJanitor:add(icon.stateChanged:Connect(function(stateName)
		if stateName == "Viewing" then
			local lastClock = Icon.captionLastClosedClock
			local clockDifference = (lastClock and os.clock() - lastClock) or 999
			local waitDuration = (clockDifference < RECOVER_PERIOD and 0) or WAIT_DURATION
			task.delay(waitDuration, function()
				if icon.activeState == "Viewing" then
					setCaptionEnabled(true)
				end
			end)
		else
			Icon.captionLastClosedClock = os.clock()
			setCaptionEnabled(false)
		end
	end))
	
	return caption
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043b8</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXABF964C964524CD79117603533670112">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d04</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Container</string>
									<string name="ScriptGuid">{CB5600B5-D9CC-4737-8FAD-E21D20512592}</string>
									<ProtectedString name="Source"><![CDATA[local hasBecomeOldTheme = false
local previousInsetHeight = 0
return function(Icon)
	
	-- Has to be included for the time being due to this bug mentioned here:
	-- https://devforum.roblox.com/t/bug/2973508/7
	local GuiService = game:GetService("GuiService")
	local container = {}
	local Signal = require(script.Parent.Parent.Packages.GoodSignal)
	local insetChanged = Signal.new()
	local guiInset = GuiService:GetGuiInset()
	local startInset = 0
	local yDownOffset = 0
	local ySizeOffset = 0
	local checkCount = 0
	local function checkInset(status)
		local currentHeight = GuiService.TopbarInset.Height
		local isOldTopbar = currentHeight <= 36
		local isConsoleScreen = GuiService:IsTenFootInterface()

		-- These additional checks are needed to ensure *it is actually* the old topbar
		-- and not a client which takes a really long time to load
		-- There's unfortunately no APIs to do this a prettier way
		Icon.isOldTopbar = isOldTopbar
		checkCount += 1
		if currentHeight == 0 and status == nil then
			task.delay(5,function()
				checkInset("ForceConvertToOld")
			end)
		elseif checkCount == 1 then
			task.delay(5, function()
				if checkCount == 1 then
					checkInset()
				end
			end)
		end

		-- Conver to old theme if verified
		if Icon.isOldTopbar and not isConsoleScreen and hasBecomeOldTheme == false and (currentHeight ~= 0 or status == "ForceConvertToOld") then
			hasBecomeOldTheme = true
			task.defer(function()
				-- If oldtopbar, apply the Classic theme
				local themes = script.Parent.Parent.Features.Themes
				local Classic = require(themes.Classic)
				Icon.modifyBaseTheme(Classic)

				-- Also configure the oldtopbar correctly
				local function decideToHideTopbar()
					if GuiService.MenuIsOpen then
						Icon.setTopbarEnabled(false, true)
					else
						Icon.setTopbarEnabled()
					end
				end
				GuiService:GetPropertyChangedSignal("MenuIsOpen"):Connect(decideToHideTopbar)
				decideToHideTopbar()
			end)
		end

		-- Modify the offsets slightly depending on device type
		guiInset = GuiService:GetGuiInset()
		startInset = if isOldTopbar then 12 else guiInset.Y - 50
		yDownOffset = if isOldTopbar then 2 else 0 --if isOldTopbar then 2 else 0 
		ySizeOffset = -2
		if isConsoleScreen then
			startInset = 10
			yDownOffset = -9
		end
		if GuiService.TopbarInset.Height == 0 and not hasBecomeOldTheme then
			yDownOffset += 13
			ySizeOffset = 50
		end

		-- Now inform other areas of the change
		insetChanged:Fire(guiInset)
		local insetHeight = guiInset.Y
		if insetHeight ~= previousInsetHeight then
			previousInsetHeight = insetHeight
			task.defer(function()
				Icon.insetHeightChanged:Fire(insetHeight)
			end)
		end
		
	end
	GuiService:GetPropertyChangedSignal("TopbarInset"):Connect(checkInset)
	checkInset("FirstTime")

	local screenGui = Instance.new("ScreenGui")
	insetChanged:Connect(function()
		screenGui:SetAttribute("StartInset", startInset)
	end)
	screenGui.Name = "TopbarStandard"
	screenGui.Enabled = true
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.IgnoreGuiInset = true
	screenGui.ResetOnSpawn = false
	screenGui.ScreenInsets = Enum.ScreenInsets.TopbarSafeInsets
	container[screenGui.Name] = screenGui
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGui.DisplayOrder = Icon.baseDisplayOrder
	end)

	local holders = Instance.new("Frame")
	holders.Name = "Holders"
	holders.BackgroundTransparency = 1
	insetChanged:Connect(function()
		holders.Position = UDim2.new(0, 0, 0, yDownOffset)
		holders.Size = UDim2.new(1, 0, 1, ySizeOffset)
	end)
	holders.Visible = true
	holders.ZIndex = 1
	holders.Parent = screenGui
	
	local screenGuiCenter = screenGui:Clone()
	local holdersCenter = screenGuiCenter.Holders
	local function updateCenteredHoldersHeight()
		holdersCenter.Size = UDim2.new(1, 0, 0, GuiService.TopbarInset.Height+ySizeOffset)
	end
	screenGuiCenter.Name = "TopbarCentered"
	screenGuiCenter.ScreenInsets = Enum.ScreenInsets.None
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiCenter.DisplayOrder = Icon.baseDisplayOrder
	end)
	container[screenGuiCenter.Name] = screenGuiCenter
	
	insetChanged:Connect(updateCenteredHoldersHeight)
	updateCenteredHoldersHeight()
	
	local screenGuiClipped = screenGui:Clone()
	screenGuiClipped.Name = screenGuiClipped.Name.."Clipped"
	screenGuiClipped.DisplayOrder += 1
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiClipped.DisplayOrder = Icon.baseDisplayOrder + 1
	end)
	container[screenGuiClipped.Name] = screenGuiClipped
	
	local screenGuiCenterClipped = screenGuiCenter:Clone()
	screenGuiCenterClipped.Name = screenGuiCenterClipped.Name.."Clipped"
	screenGuiCenterClipped.DisplayOrder += 1
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiCenterClipped.DisplayOrder = Icon.baseDisplayOrder + 1
	end)
	container[screenGuiCenterClipped.Name] = screenGuiCenterClipped
	
	local holderReduction = -24
	local left = Instance.new("ScrollingFrame")
	left:SetAttribute("IsAHolder", true)
	left.Name = "Left"
	insetChanged:Connect(function()
		left.Position = UDim2.fromOffset(startInset, 0)
	end)
	left.Size = UDim2.new(1, holderReduction, 1, 0)
	left.BackgroundTransparency = 1
	left.Visible = true
	left.ZIndex = 1
	left.Active = false
	left.ClipsDescendants = true
	left.HorizontalScrollBarInset = Enum.ScrollBarInset.None
	left.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
	left.AutomaticCanvasSize = Enum.AutomaticSize.X
	left.ScrollingDirection = Enum.ScrollingDirection.X
	left.ScrollBarThickness = 0
	left.BorderSizePixel = 0
	left.Selectable = false
	left.ScrollingEnabled = false--true
	left.ElasticBehavior = Enum.ElasticBehavior.Never
	left.Parent = holders
	
	local UIListLayout = Instance.new("UIListLayout")
	insetChanged:Connect(function()
		UIListLayout.Padding = UDim.new(0, startInset)
	end)
	UIListLayout.FillDirection = Enum.FillDirection.Horizontal
	UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
	UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	UIListLayout.Parent = left
	
	local center = left:Clone()
	insetChanged:Connect(function()
		center.UIListLayout.Padding = UDim.new(0, startInset)
	end)
	center.ScrollingEnabled = false
	center.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	center.Name = "Center"
	center.Parent = holdersCenter
	
	local right = left:Clone()
	insetChanged:Connect(function()
		right.UIListLayout.Padding = UDim.new(0, startInset)
	end)
	right.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
	right.Name = "Right"
	right.AnchorPoint = Vector2.new(1, 0)
	right.Position = UDim2.new(1, -12, 0, 0)
	right.Parent = holders

	-- This is important so that all elements update instantly
	insetChanged:Fire(guiInset)

	return container
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043b9</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5B801D920D984E72B083A34511FFFA72">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d05</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Dropdown</string>
									<string name="ScriptGuid">{531E1CE3-C4AF-43B3-8D65-286BCA4D01DB}</string>
									<ProtectedString name="Source"><![CDATA[local PADDING = 0 -- used to be 8
return function(icon)
	
	local dropdown = Instance.new("Frame") -- Instance.new("CanvasGroup")
	dropdown.Name = "Dropdown"
	dropdown.AutomaticSize = Enum.AutomaticSize.XY
	dropdown.BackgroundTransparency = 1
	dropdown.BorderSizePixel = 0
	dropdown.AnchorPoint = Vector2.new(0.5, 0)
	dropdown.Position = UDim2.new(0.5, 0, 1, 10)
	dropdown.ZIndex = -2
	dropdown.ClipsDescendants = true
	dropdown.Parent = icon.widget

	-- Account for PreferredTransparency which can be set by every player
	local GuiService = game:GetService("GuiService")
	icon:setBehaviour("Dropdown", "BackgroundTransparency", function(value)
		local preference = GuiService.PreferredTransparency
		local newValue = value * preference
		if value == 1 then
			return value
		end
		return newValue
	end)
	icon.janitor:add(GuiService:GetPropertyChangedSignal("PreferredTransparency"):Connect(function()
		icon:refreshAppearance(dropdown, "BackgroundTransparency")
	end))

	local UICorner = Instance.new("UICorner")
	UICorner.Name = "DropdownCorner"
	UICorner.CornerRadius = UDim.new(0, 10)
	UICorner.Parent = dropdown

	local dropdownScroller = Instance.new("ScrollingFrame")
	dropdownScroller.Name = "DropdownScroller"
	dropdownScroller.AutomaticSize = Enum.AutomaticSize.X
	dropdownScroller.BackgroundTransparency = 1
	dropdownScroller.BorderSizePixel = 0
	dropdownScroller.AnchorPoint = Vector2.new(0, 0)
	dropdownScroller.Position = UDim2.new(0, 0, 0, 0)
	dropdownScroller.ZIndex = -1
	dropdownScroller.ClipsDescendants = true
	dropdownScroller.Visible = true
	dropdownScroller.VerticalScrollBarInset = Enum.ScrollBarInset.None --ScrollBar
	dropdownScroller.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right
	dropdownScroller.Active = false
	dropdownScroller.ScrollingEnabled = true
	dropdownScroller.AutomaticCanvasSize = Enum.AutomaticSize.Y
	dropdownScroller.ScrollBarThickness = 5
	dropdownScroller.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
	dropdownScroller.ScrollBarImageTransparency = 0.8
	dropdownScroller.CanvasSize = UDim2.new(0, 0, 0, 0)
	dropdownScroller.Selectable = false
	dropdownScroller.Active = true
	dropdownScroller.Parent = dropdown
	
	local dropdownPadding = Instance.new("UIPadding")
	dropdownPadding.Name = "DropdownPadding"
	dropdownPadding.PaddingTop = UDim.new(0, PADDING)
	dropdownPadding.PaddingBottom = UDim.new(0, PADDING)
	dropdownPadding.Parent = dropdownScroller

	local dropdownList = Instance.new("UIListLayout")
	dropdownList.Name = "DropdownList"
	dropdownList.FillDirection = Enum.FillDirection.Vertical
	dropdownList.SortOrder = Enum.SortOrder.LayoutOrder
	dropdownList.HorizontalAlignment = Enum.HorizontalAlignment.Center
	dropdownList.HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly
	dropdownList.Parent = dropdownScroller
	
	local dropdownJanitor = icon.dropdownJanitor
	local Icon = require(icon.iconModule)
	icon.dropdownChildAdded:Connect(function(childIcon)
		-- Modify appearance of child when joined
		local _, modificationUID = childIcon:modifyTheme({
			{"Widget", "BorderSize", 0},
			{"IconCorners", "CornerRadius", UDim.new(0, 10)},
			{"Widget", "MinimumWidth", 190},
			{"Widget", "MinimumHeight", 58},
			{"IconLabel", "TextSize", 20},
			{"IconOverlay", "Size", UDim2.new(1, 0, 1, 0)},
			{"PaddingLeft", "Size", UDim2.fromOffset(25, 0)},
			{"Notice", "Position", UDim2.new(1, -24, 0, 5)},
			{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Left},
			{"Selection", "Size", UDim2.new(1, -PADDING, 1, -PADDING)},
			{"Selection", "Position", UDim2.new(0, PADDING/2, 0, PADDING/2)},
		})
		task.defer(function()
			childIcon.joinJanitor:add(function()
				childIcon:removeModification(modificationUID)
			end)
		end)
	end)
	icon.dropdownSet:Connect(function(arrayOfIcons)
		-- Destroy any previous icons
		for i, otherIconUID in pairs(icon.dropdownIcons) do
			local otherIcon = Icon.getIconByUID(otherIconUID)
			otherIcon:destroy()
		end
		-- Add new icons
		if type(arrayOfIcons) == "table" then
			for i, otherIcon in pairs(arrayOfIcons) do
				otherIcon:joinDropdown(icon)
			end
		end
	end)

	-- Update visibiliy of dropdown
	local Utility = require(script.Parent.Parent.Utility)
	local function updateVisibility()
		--icon:modifyTheme({"Dropdown", "Visible", icon.isSelected})
		Utility.setVisible(dropdown, icon.isSelected, "InternalDropdown")
	end
	dropdownJanitor:add(icon.toggled:Connect(updateVisibility))
	updateVisibility()
	--task.delay(0.2, updateVisibility)
	
	-- This updates the scrolling frame to only display a scroll
	-- length equal to the distance produced by its MaxIcons
	local updateCount = 0
	local isUpdating = false
	local function updateMaxIcons()
		
		-- This prevents more than 1 update occurring every frame
		updateCount += 1
		if isUpdating then
			return
		end
		local myUpdateCount = updateCount
		isUpdating = true
		task.defer(function()
			isUpdating = false
			if updateCount ~= myUpdateCount then
				updateMaxIcons()
			end
		end)
			
		local maxIcons = dropdown:GetAttribute("MaxIcons")
		if not maxIcons then
			return
		end
		local orderedInstances = {}
		for _, child in pairs(dropdownScroller:GetChildren()) do
			if child:IsA("GuiObject") then
				table.insert(orderedInstances, {child, child.AbsolutePosition.Y})
			end
		end
		table.sort(orderedInstances, function(groupA, groupB)
			return groupA[2] < groupB[2]
		end)
		local totalHeight = 0
		local hasSetNextSelection = false
		local maxIconsRoundedUp = math.ceil(maxIcons)
		for i = 1, maxIconsRoundedUp do
			local group = orderedInstances[i]
			if not group then
				break
			end
			local child = group[1]
			local height = child.AbsoluteSize.Y
			local isReduced = i == maxIconsRoundedUp and maxIconsRoundedUp ~= maxIcons
			if isReduced then
				height = height * (maxIcons - maxIconsRoundedUp + 1)
			end
			totalHeight += height
			if isReduced then
				continue
			end
			local iconUID = child:GetAttribute("WidgetUID")
			local childIcon = iconUID and Icon.getIconByUID(iconUID)
			if childIcon then
				local nextSelection = nil
				if not hasSetNextSelection then
					hasSetNextSelection = true
					nextSelection = icon:getInstance("ClickRegion")
				end
				childIcon:getInstance("ClickRegion").NextSelectionUp = nextSelection
			end
		end
		totalHeight += dropdownPadding.PaddingTop.Offset
		totalHeight += dropdownPadding.PaddingBottom.Offset
		dropdownScroller.Size = UDim2.fromOffset(0, totalHeight)
	end
	dropdownJanitor:add(dropdownScroller:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(updateMaxIcons))
	dropdownJanitor:add(dropdownScroller.ChildAdded:Connect(updateMaxIcons))
	dropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateMaxIcons))
	dropdownJanitor:add(dropdown:GetAttributeChangedSignal("MaxIcons"):Connect(updateMaxIcons))
	dropdownJanitor:add(icon.childThemeModified:Connect(updateMaxIcons))
	updateMaxIcons()
	
	return dropdown
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043ba</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX83CE0EFFECA74DF68EB2198BDD8D76BF">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d06</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Indicator</string>
									<string name="ScriptGuid">{4855335A-54CC-4E97-A9B2-C271C39DA7B9}</string>
									<ProtectedString name="Source"><![CDATA[return function(icon, Icon)

	local widget = icon.widget
	local contents = icon:getInstance("Contents")
	local indicator = Instance.new("Frame")
	indicator.Name = "Indicator"
	indicator.LayoutOrder = 9999999
	indicator.ZIndex = 6
	indicator.Size = UDim2.new(0, 42, 0, 42)
	indicator.BorderColor3 = Color3.fromRGB(0, 0, 0)
	indicator.BackgroundTransparency = 1
	indicator.Position = UDim2.new(1, 0, 0.5, 0)
	indicator.BorderSizePixel = 0
	indicator.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	indicator.Parent = contents

	local indicatorButton = Instance.new("Frame")
	indicatorButton.Name = "IndicatorButton"
	indicatorButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
	indicatorButton.AnchorPoint = Vector2.new(0.5, 0.5)
	indicatorButton.BorderSizePixel = 0
	indicatorButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	indicatorButton.Parent = indicator
	
	local GuiService = game:GetService("GuiService")
	local GamepadService = game:GetService("GamepadService")
	local ourClickRegion = icon:getInstance("ClickRegion")
	local function selectionChanged()
		local selectedClickRegion = GuiService.SelectedObject
		if selectedClickRegion == ourClickRegion then
			indicatorButton.BackgroundTransparency = 1
			indicatorButton.Position = UDim2.new(0.5, -2, 0.5, 0)
			indicatorButton.Size = UDim2.fromScale(1.2, 1.2)
		else
			indicatorButton.BackgroundTransparency = 0.75
			indicatorButton.Position = UDim2.new(0.5, 2, 0.5, 0)
			indicatorButton.Size = UDim2.fromScale(1, 1)
		end
	end
	icon.janitor:add(GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(selectionChanged))
	selectionChanged()

	local imageLabel = Instance.new("ImageLabel")
	imageLabel.LayoutOrder = 2
	imageLabel.ZIndex = 15
	imageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	imageLabel.Size = UDim2.new(0.5, 0, 0.5, 0)
	imageLabel.BackgroundTransparency = 1
	imageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
	imageLabel.Image = "rbxasset://textures/ui/Controls/XboxReplica/DPadUp@2x.png"
	imageLabel.Parent = indicatorButton

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = indicatorButton

	local UserInputService = game:GetService("UserInputService")
	local function setIndicatorVisible(visibility)
		if visibility == nil then
			visibility = indicator.Visible
		end
		if GamepadService.GamepadCursorEnabled then
			visibility = false
		end
		if visibility then
			icon:modifyTheme({"PaddingRight", "Size", UDim2.new(0, 0, 1, 0)}, "IndicatorPadding")
		elseif indicator.Visible then
			icon:removeModification("IndicatorPadding")
		end
		icon:modifyTheme({"Indicator", "Visible", visibility})
		icon.updateSize:Fire()
	end
	icon.janitor:add(GamepadService:GetPropertyChangedSignal("GamepadCursorEnabled"):Connect(setIndicatorVisible))
	icon.indicatorSet:Connect(function(keyCode)
		local visibility = false
		if keyCode then
			imageLabel.Image = UserInputService:GetImageForKeyCode(keyCode)
			visibility = true
		end
		setIndicatorVisible(visibility)
	end)

	local function updateSize()
		local ySize = widget.AbsoluteSize.Y*0.96
		indicator.Size = UDim2.new(0, ySize, 0, ySize)
	end
	widget:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateSize)
	updateSize()

	return indicator
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043bb</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB5099426BDFF4A0CBDE9CABBCF9314F1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d07</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Menu</string>
									<string name="ScriptGuid">{371D5F97-497F-4DEE-A615-DF6E1374580F}</string>
									<ProtectedString name="Source"><![CDATA[return function(icon)

	local menu = Instance.new("ScrollingFrame")
	menu.Name = "Menu"
	menu.BackgroundTransparency = 1
	menu.Visible = true
	menu.ZIndex = 1
	menu.Size = UDim2.fromScale(1, 1)
	menu.ClipsDescendants = true
	menu.TopImage = ""
	menu.BottomImage = ""
	menu.HorizontalScrollBarInset = Enum.ScrollBarInset.Always
	menu.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
	menu.ScrollingEnabled = true
	menu.ScrollingDirection = Enum.ScrollingDirection.X
	menu.ZIndex = 20
	menu.ScrollBarThickness = 3
	menu.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
	menu.ScrollBarImageTransparency = 0.8
	menu.BorderSizePixel = 0
	menu.Selectable = false
	
	local Icon = require(icon.iconModule)
	local menuUIListLayout = Icon.container.TopbarStandard:FindFirstChild("UIListLayout", true):Clone()
	menuUIListLayout.Name = "MenuUIListLayout"
	menuUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	menuUIListLayout.Parent = menu

	local menuGap = Instance.new("Frame")
	menuGap.Name = "MenuGap"
	menuGap.BackgroundTransparency = 1
	menuGap.Visible = false
	menuGap.AnchorPoint = Vector2.new(0, 0.5)
	menuGap.ZIndex = 5
	menuGap.Parent = menu
	
	local hasStartedMenu = false
	local Themes = require(script.Parent.Parent.Features.Themes)
	local function totalChildrenChanged()
		
		local menuJanitor = icon.menuJanitor
		local totalIcons = #icon.menuIcons
		if hasStartedMenu then
			if totalIcons <= 0 then
				menuJanitor:clean()
				hasStartedMenu = false
			end
			return
		end
		hasStartedMenu = true
		
		-- Listen for changes
		menuJanitor:add(icon.toggled:Connect(function()
			if #icon.menuIcons > 0 then
				icon.updateSize:Fire()
			end
		end))
		
		-- Modify appearance of menu icon when joined
		local _, modificationUID = icon:modifyTheme({
			{"Menu", "Active", true},
		})
		task.defer(function()
			menuJanitor:add(function()
				icon:removeModification(modificationUID)
			end)
		end)
		
		-- For right-aligned icons, this ensures their menus
		-- close button appear instantly when selected (instead
		-- of partially hidden from view)
		local previousCanvasX = menu.AbsoluteCanvasSize.X
		local function rightAlignCanvas()
			if icon.alignment == "Right" then
				local newCanvasX = menu.AbsoluteCanvasSize.X
				local difference = previousCanvasX - newCanvasX
				previousCanvasX = newCanvasX
				menu.CanvasPosition = Vector2.new(menu.CanvasPosition.X - difference, 0)
			end
		end
		menuJanitor:add(icon.selected:Connect(rightAlignCanvas))
		menuJanitor:add(menu:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(rightAlignCanvas))
		
		-- Apply a close selected image if the user hasn't applied thier own
		local stateGroup = icon:getStateGroup()
		local imageDeselected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Deselected")
		local imageSelected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Selected")
		if imageDeselected == imageSelected then
			local fontLink = "rbxasset://fonts/families/FredokaOne.json"
			local fontFace = Font.new(fontLink, Enum.FontWeight.Light, Enum.FontStyle.Normal)
			icon:removeModificationWith("IconLabel", "Text", "Viewing")
			icon:removeModificationWith("IconLabel", "Image", "Viewing")
			icon:modifyTheme({
				{"IconLabel", "FontFace", fontFace, "Selected"},
				{"IconLabel", "Text", "X", "Selected"},
				{"IconLabel", "TextSize", 20, "Selected"},
				{"IconLabel", "TextStrokeTransparency", 0.8, "Selected"},
				{"IconImage", "Image", "", "Selected"},
			})
		end

		-- Change order of spot when alignment changes
		local menuGap = icon:getInstance("MenuGap")
		local function updateAlignent()
			local alignment = icon.alignment
			local spotIndex = -99999
			local gapIndex = -99998
			if alignment == "Right" then
				spotIndex = 99999
				gapIndex = 99998
			end
			icon:modifyTheme({"IconSpot", "LayoutOrder", spotIndex})
			menuGap.LayoutOrder = gapIndex
		end
		menuJanitor:add(icon.alignmentChanged:Connect(updateAlignent))
		updateAlignent()
		
		-- This updates the scrolling frame to only display a scroll
		-- length equal to the distance produced by its MaxIcons
		menu:GetAttributeChangedSignal("MenuCanvasWidth"):Connect(function()
			local canvasWidth = menu:GetAttribute("MenuCanvasWidth")
			local canvasY = menu.CanvasSize.Y
			menu.CanvasSize = UDim2.new(0, canvasWidth, canvasY.Scale, canvasY.Offset)
		end)
		menuJanitor:add(icon.updateMenu:Connect(function()
			local maxIcons = menu:GetAttribute("MaxIcons")
			if not maxIcons then
				return
			end
			local orderedInstances = {}
			for _, child in pairs(menu:GetChildren()) do
				local widgetUID = child:GetAttribute("WidgetUID")
				if widgetUID and child.Visible then
					table.insert(orderedInstances, {child, child.AbsolutePosition.X})
				end
			end
			table.sort(orderedInstances, function(groupA, groupB)
				return groupA[2] < groupB[2]
			end)
			local totalWidth = 0
			for i = 1, maxIcons do
				local group = orderedInstances[i]
				if not group then
					break
				end
				local child = group[1]
				local width = child.AbsoluteSize.X + menuUIListLayout.Padding.Offset
				totalWidth += width
			end
			menu:SetAttribute("MenuWidth", totalWidth)
		end))
		local function startMenuUpdate()
			task.delay(0.1, function()
				icon.startMenuUpdate:Fire()
			end)
		end
		menuJanitor:add(menu.ChildAdded:Connect(startMenuUpdate))
		menuJanitor:add(menu.ChildRemoved:Connect(startMenuUpdate))
		menuJanitor:add(menu:GetAttributeChangedSignal("MaxIcons"):Connect(startMenuUpdate))
		menuJanitor:add(menu:GetAttributeChangedSignal("MaxWidth"):Connect(startMenuUpdate))
		startMenuUpdate()
	end
	
	icon.menuChildAdded:Connect(totalChildrenChanged)
	icon.menuSet:Connect(function(arrayOfIcons)
		-- Reset any previous icons
		for i, otherIconUID in pairs(icon.menuIcons) do
			local otherIcon = Icon.getIconByUID(otherIconUID)
			otherIcon:destroy()
		end
		-- Apply new icons
		if type(arrayOfIcons) == "table" then
			for i, otherIcon in pairs(arrayOfIcons) do
				otherIcon:joinMenu(icon)
			end
		end
	end)
	
	return menu
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043bc</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX54BBC8B01EF64DD9B07D82F3BB38E1A0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d08</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Notice</string>
									<string name="ScriptGuid">{8BADC4ED-0528-44D2-AB9D-8DA15507C57D}</string>
									<ProtectedString name="Source"><![CDATA[return function(icon, Icon)

	local notice = Instance.new("Frame")
	notice.Name = "Notice"
	notice.ZIndex = 25
	notice.AutomaticSize = Enum.AutomaticSize.X
	notice.BorderColor3 = Color3.fromRGB(0, 0, 0)
	notice.BorderSizePixel = 0
	notice.BackgroundTransparency = 0.1
	notice.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	notice.Visible = false
	notice.Parent = icon.widget

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = notice

	local UIStroke = Instance.new("UIStroke")
	UIStroke.Parent = notice

	local noticeLabel = Instance.new("TextLabel")
	noticeLabel.Name = "NoticeLabel"
	noticeLabel.ZIndex = 26
	noticeLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	noticeLabel.AutomaticSize = Enum.AutomaticSize.X
	noticeLabel.Size = UDim2.new(1, 0, 1, 0)
	noticeLabel.BackgroundTransparency = 1
	noticeLabel.Position = UDim2.new(0.5, 0, 0.515, 0)
	noticeLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	noticeLabel.FontSize = Enum.FontSize.Size14
	noticeLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
	noticeLabel.Text = "1"
	noticeLabel.TextWrapped = true
	noticeLabel.TextWrap = true
	noticeLabel.Font = Enum.Font.Arial
	noticeLabel.Parent = notice
	
	local iconModule = script.Parent.Parent
	local packages = iconModule.Packages
	local Janitor = require(packages.Janitor)
	local Signal = require(packages.GoodSignal)
	local Utility = require(iconModule.Utility)
	icon.noticeChanged:Connect(function(totalNotices)

		-- Notice amount
		if not totalNotices then
			return
		end
		local exceeded99 = totalNotices > 99
		local noticeDisplay = (exceeded99 and "99+") or totalNotices
		noticeLabel.Text = noticeDisplay
		if exceeded99 then
			noticeLabel.TextSize = 11
		end

		-- Should enable
		local enabled = true
		if totalNotices < 1 then
			enabled = false
		end
		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
		local dropdownOrMenuActive = #icon.dropdownIcons > 0 or #icon.menuIcons > 0
		if icon.isSelected and dropdownOrMenuActive then
			enabled = false
		elseif parentIcon and not parentIcon.isSelected then
			enabled = false
		end
		Utility.setVisible(notice, enabled, "NoticeHandler")

	end)
	icon.noticeStarted:Connect(function(customClearSignal, noticeId)
	
		if not customClearSignal then
			customClearSignal = icon.deselected
		end
		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
		if parentIcon then
			parentIcon:notify(customClearSignal)
		end
		
		local noticeJanitor = icon.janitor:add(Janitor.new())
		local noticeComplete = noticeJanitor:add(Signal.new())
		noticeJanitor:add(icon.endNotices:Connect(function()
			noticeComplete:Fire()
		end))
		noticeJanitor:add(customClearSignal:Connect(function()
			noticeComplete:Fire()
		end))
		noticeId = noticeId or Utility.generateUID()
		icon.notices[noticeId] = {
			completeSignal = noticeComplete,
			clearNoticeEvent = customClearSignal,
		}
		local function updateNotice()
			icon.noticeChanged:Fire(icon.totalNotices)
		end
		icon.notified:Fire(noticeId)
		icon.totalNotices += 1
		updateNotice()
		noticeComplete:Once(function()
			noticeJanitor:destroy()
			icon.totalNotices -= 1
			icon.notices[noticeId] = nil
			updateNotice()
		end)
	end)
	
	-- Establish the notice
	notice:SetAttribute("ClipToJoinedParent", true)
	icon:clipOutside(notice)
	
	return notice
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043bd</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX98575986E40C4A42AFA4D099203C43A9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d09</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Selection</string>
									<string name="ScriptGuid">{5D421DF9-67C6-4153-BA53-2D41D2F21289}</string>
									<ProtectedString name="Source"><![CDATA[return function(Icon)

	-- Credit to lolmansReturn and Canary Software for
	-- retrieving these values
	local selectionContainer = Instance.new("Frame")
	selectionContainer.Name = "SelectionContainer"
	selectionContainer.Visible = false
	
	local selection = Instance.new("Frame")
	selection.Name = "Selection"
	selection.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	selection.BackgroundTransparency = 1
	selection.BorderColor3 = Color3.fromRGB(0, 0, 0)
	selection.BorderSizePixel = 0
	selection.Parent = selectionContainer

	local UIStroke = Instance.new("UIStroke")
	UIStroke.Name = "UIStroke"
	UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	UIStroke.Color = Color3.fromRGB(255, 255, 255)
	UIStroke.Thickness = 3
	UIStroke.Parent = selection

	local selectionGradient = Instance.new("UIGradient")
	selectionGradient.Name = "SelectionGradient"
	selectionGradient.Parent = UIStroke

	local UICorner = Instance.new("UICorner")
	UICorner:SetAttribute("Collective", "IconCorners")
	UICorner.Name = "UICorner"
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = selection
	
	local RunService = game:GetService("RunService")
	local GuiService = game:GetService("GuiService")
	local rotationSpeed = 1
	selection:GetAttributeChangedSignal("RotationSpeed"):Connect(function()
		rotationSpeed = selection:GetAttribute("RotationSpeed")
	end)
	RunService.Heartbeat:Connect(function()
		if not GuiService.SelectedObject then
			return
		end
		selectionGradient.Rotation = (os.clock() * rotationSpeed * 100) % 360
	end)

	return selectionContainer
	
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043be</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX7303F2CDF3A441E593312AF0C4BB9F79">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d0a</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Widget</string>
									<string name="ScriptGuid">{4EA453CC-F450-4477-8AA8-70C9BE52C875}</string>
									<ProtectedString name="Source"><![CDATA[-- I named this 'Widget' instead of 'Icon' to make a clear difference between the icon *object* and
-- the icon (aka Widget) instance.
-- This contains the core components of the icon such as the button, image, label and notice. It's
-- also responsible for handling the automatic resizing of the widget (based upon image visibility and text length)

return function(icon, Icon)

	local widget = Instance.new("Frame")
	widget:SetAttribute("WidgetUID", icon.UID)
	widget.Name = "Widget"
	widget.BackgroundTransparency = 1
	widget.Visible = true
	widget.ZIndex = 20
	widget.Active = false
	widget.ClipsDescendants = true

	local button = Instance.new("Frame")
	button.Name = "IconButton"
	button.Visible = true
	button.ZIndex = 2
	button.BorderSizePixel = 0
	button.Parent = widget
	button.ClipsDescendants = true
	button.Active = false -- This is essential for mobile scrollers to work when dragging
	icon.deselected:Connect(function()
		button.ClipsDescendants = true
		task.delay(0.2, function()
			if icon.isSelected then
				button.ClipsDescendants = false
			end
		end)
	end)

	-- Account for PreferredTransparency which can be set by every player
	local GuiService = game:GetService("GuiService")
	icon:setBehaviour("IconButton", "BackgroundTransparency", function(value)
		local preference = GuiService.PreferredTransparency
		local newValue = value * preference
		if value == 1 then
			return value
		end
		return newValue
	end)
	icon.janitor:add(GuiService:GetPropertyChangedSignal("PreferredTransparency"):Connect(function()
		icon:refreshAppearance(button, "BackgroundTransparency")
	end))

	local iconCorner = Instance.new("UICorner")
	iconCorner:SetAttribute("Collective", "IconCorners")
	iconCorner.Name = "UICorner"
	iconCorner.Parent = button

	local menu = require(script.Parent.Menu)(icon)
	local menuUIListLayout = menu.MenuUIListLayout
	local menuGap = menu.MenuGap
	menu.Parent = button

	local iconSpot = Instance.new("Frame")
	iconSpot.Name = "IconSpot"
	iconSpot.BackgroundColor3 = Color3.fromRGB(225, 225, 225)
	iconSpot.BackgroundTransparency = 0.9
	iconSpot.Visible = true
	iconSpot.AnchorPoint = Vector2.new(0, 0.5)
	iconSpot.ZIndex = 5
	iconSpot.Parent = menu

	local iconSpotCorner = iconCorner:Clone()
	iconSpotCorner.Parent = iconSpot

	local overlay = iconSpot:Clone()
	overlay.UICorner.Name = "OverlayUICorner"
	overlay.Name = "IconOverlay"
	overlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	overlay.ZIndex = iconSpot.ZIndex + 1
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.Position = UDim2.new(0, 0, 0, 0)
	overlay.AnchorPoint = Vector2.new(0, 0)
	overlay.Visible = false
	overlay.Parent = iconSpot

	local clickRegion = Instance.new("TextButton")
	clickRegion:SetAttribute("CorrespondingIconUID", icon.UID)
	clickRegion.Name = "ClickRegion"
	clickRegion.BackgroundTransparency = 1
	clickRegion.Visible = true
	clickRegion.Text = ""
	clickRegion.ZIndex = 20
	clickRegion.Selectable = true
	clickRegion.SelectionGroup = true
	clickRegion.Parent = iconSpot
	
	local Gamepad = require(script.Parent.Parent.Features.Gamepad)
	Gamepad.registerButton(clickRegion)

	local clickRegionCorner = iconCorner:Clone()
	clickRegionCorner.Parent = clickRegion

	local contents = Instance.new("Frame")
	contents.Name = "Contents"
	contents.BackgroundTransparency = 1
	contents.Size = UDim2.fromScale(1, 1)
	contents.Parent = iconSpot

	local contentsList = Instance.new("UIListLayout")
	contentsList.Name = "ContentsList"
	contentsList.FillDirection = Enum.FillDirection.Horizontal
	contentsList.VerticalAlignment = Enum.VerticalAlignment.Center
	contentsList.SortOrder = Enum.SortOrder.LayoutOrder
	contentsList.VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly
	contentsList.Padding = UDim.new(0, 3)
	contentsList.Parent = contents

	local paddingLeft = Instance.new("Frame")
	paddingLeft.Name = "PaddingLeft"
	paddingLeft.LayoutOrder = 1
	paddingLeft.ZIndex = 5
	paddingLeft.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingLeft.BackgroundTransparency = 1
	paddingLeft.BorderSizePixel = 0
	paddingLeft.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingLeft.Parent = contents

	local paddingCenter = Instance.new("Frame")
	paddingCenter.Name = "PaddingCenter"
	paddingCenter.LayoutOrder = 3
	paddingCenter.ZIndex = 5
	paddingCenter.Size = UDim2.new(0, 0, 1, 0)
	paddingCenter.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingCenter.BackgroundTransparency = 1
	paddingCenter.BorderSizePixel = 0
	paddingCenter.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingCenter.Parent = contents

	local paddingRight = Instance.new("Frame")
	paddingRight.Name = "PaddingRight"
	paddingRight.LayoutOrder = 5
	paddingRight.ZIndex = 5
	paddingRight.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingRight.BackgroundTransparency = 1
	paddingRight.BorderSizePixel = 0
	paddingRight.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingRight.Parent = contents

	local iconLabelContainer = Instance.new("Frame")
	iconLabelContainer.Name = "IconLabelContainer"
	iconLabelContainer.LayoutOrder = 4
	iconLabelContainer.ZIndex = 3
	iconLabelContainer.AnchorPoint = Vector2.new(0, 0.5)
	iconLabelContainer.Size = UDim2.new(0, 0, 0.5, 0)
	iconLabelContainer.BackgroundTransparency = 1
	iconLabelContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
	iconLabelContainer.Parent = contents

	local iconLabel = Instance.new("TextLabel")
	local viewportX = workspace.CurrentCamera.ViewportSize.X+200
	iconLabel.Name = "IconLabel"
	iconLabel.LayoutOrder = 4
	iconLabel.ZIndex = 15
	iconLabel.AnchorPoint = Vector2.new(0, 0)
	iconLabel.Size = UDim2.new(0, viewportX, 1, 0)
	iconLabel.ClipsDescendants = false
	iconLabel.BackgroundTransparency = 1
	iconLabel.Position = UDim2.fromScale(0, 0)
	iconLabel.RichText = true
	iconLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	iconLabel.TextXAlignment = Enum.TextXAlignment.Left
	iconLabel.Text = ""
	iconLabel.TextWrapped = true
	iconLabel.TextWrap = true
	iconLabel.TextScaled = false
	iconLabel.Active = false
	iconLabel.AutoLocalize = true
	iconLabel.Parent = iconLabelContainer

	local iconImage = Instance.new("ImageLabel")
	iconImage.Name = "IconImage"
	iconImage.LayoutOrder = 2
	iconImage.ZIndex = 15
	iconImage.AnchorPoint = Vector2.new(0, 0.5)
	iconImage.Size = UDim2.new(0, 0, 0.5, 0)
	iconImage.BackgroundTransparency = 1
	iconImage.Position = UDim2.new(0, 11, 0.5, 0)
	iconImage.ScaleType = Enum.ScaleType.Stretch
	iconImage.Active = false
	iconImage.Parent = contents

	local iconImageCorner = iconCorner:Clone()
	iconImageCorner:SetAttribute("Collective", nil)
	iconImageCorner.CornerRadius = UDim.new(0, 0)
	iconImageCorner.Name = "IconImageCorner"
	iconImageCorner.Parent = iconImage

	local TweenService = game:GetService("TweenService")
	local resizingCount = 0
	local function handleLabelAndImageChangesUnstaggered(forceUpdateString)

		-- We defer changes by a frame to eliminate all but 1 requests which
		-- could otherwise stack up to 20+ requests in a single frame
		-- We then repeat again once to account for any final changes
		-- Deferring is also essential because properties are set immediately
		-- afterwards (therefore calculations will use the correct values)
		task.defer(function()
			local indicator = icon.indicator
			local usingIndicator = indicator and indicator.Visible
			local usingText = usingIndicator or iconLabel.Text ~= ""
			local usingImage = iconImage.Image ~= "" and iconImage.Image ~= nil
			local _alignment = Enum.HorizontalAlignment.Center
			local NORMAL_BUTTON_SIZE = UDim2.fromScale(1, 1)
			local buttonSize = NORMAL_BUTTON_SIZE
			if usingImage and not usingText then
				iconLabelContainer.Visible = false
				iconImage.Visible = true
				paddingLeft.Visible = false
				paddingCenter.Visible = false
				paddingRight.Visible = false
			elseif not usingImage and usingText then
				iconLabelContainer.Visible = true
				iconImage.Visible = false
				paddingLeft.Visible = true
				paddingCenter.Visible = false
				paddingRight.Visible = true
			elseif usingImage and usingText then
				iconLabelContainer.Visible = true
				iconImage.Visible = true
				paddingLeft.Visible = true
				paddingCenter.Visible = not usingIndicator
				paddingRight.Visible = not usingIndicator
				_alignment = Enum.HorizontalAlignment.Left
			end
			button.Size = buttonSize

			local function getItemWidth(item)
				local targetWidth = item:GetAttribute("TargetWidth") or item.AbsoluteSize.X
				return targetWidth
			end
			local contentsPadding = contentsList.Padding.Offset
			local initialWidgetWidth = contentsPadding --0
			local textWidth = iconLabel.TextBounds.X
			iconLabelContainer.Size = UDim2.new(0, textWidth, iconLabel.Size.Y.Scale, 0)
			for _, child in pairs(contents:GetChildren()) do
				if child:IsA("GuiObject") and child.Visible == true then
					local itemWidth = getItemWidth(child)
					initialWidgetWidth += itemWidth + contentsPadding
				end
			end
			local widgetMinimumWidth = widget:GetAttribute("MinimumWidth")
			local widgetMinimumHeight = widget:GetAttribute("MinimumHeight")
			local widgetBorderSize = widget:GetAttribute("BorderSize")
			local widgetWidth = math.clamp(initialWidgetWidth, widgetMinimumWidth, viewportX)
			local menuIcons = icon.menuIcons
			local additionalWidth = 0
			local hasMenu = #menuIcons > 0
			local showMenu = hasMenu and icon.isSelected
			if showMenu then
				for _, frame in pairs(menu:GetChildren()) do
					if frame ~= iconSpot and frame:IsA("GuiObject") and frame.Visible then
						additionalWidth += getItemWidth(frame) + menuUIListLayout.Padding.Offset
					end
				end
				if not iconSpot.Visible then
					widgetWidth -= (getItemWidth(iconSpot) + menuUIListLayout.Padding.Offset*2 + widgetBorderSize)
				end
				additionalWidth -= (widgetBorderSize*0.5)
				widgetWidth += additionalWidth - (widgetBorderSize*0.75)
			end
			menuGap.Visible = showMenu and iconSpot.Visible
			local desiredWidth = widget:GetAttribute("DesiredWidth")
			if desiredWidth and widgetWidth < desiredWidth then
				widgetWidth = desiredWidth
			end

			icon.updateMenu:Fire()
			local preWidth = math.max(widgetWidth-additionalWidth, widgetMinimumWidth)
			local spotWidth = preWidth-(widgetBorderSize*2)
			local menuWidth = menu:GetAttribute("MenuWidth")
			local totalMenuWidth = menuWidth and menuWidth + spotWidth + menuUIListLayout.Padding.Offset + 10
			if totalMenuWidth then
				local maxWidth = menu:GetAttribute("MaxWidth")
				if maxWidth then
					totalMenuWidth = math.max(maxWidth, widgetMinimumWidth)
				end
				menu:SetAttribute("MenuCanvasWidth", widgetWidth)
				if totalMenuWidth < widgetWidth then
					widgetWidth = totalMenuWidth
				end
			end

			local style = Enum.EasingStyle.Quint
			local direction = Enum.EasingDirection.Out
			local spotWidthMax = math.max(spotWidth, getItemWidth(iconSpot), iconSpot.AbsoluteSize.X)
			local widgetWidthMax = math.max(widgetWidth, getItemWidth(widget), widget.AbsoluteSize.X)
			local SPEED = 750
			local spotTweenInfo = TweenInfo.new(spotWidthMax/SPEED, style, direction)
			local widgetTweenInfo = TweenInfo.new(widgetWidthMax/SPEED, style, direction)
			TweenService:Create(iconSpot, spotTweenInfo, {
				Position = UDim2.new(0, widgetBorderSize, 0.5, 0),
				Size = UDim2.new(0, spotWidth, 1, -widgetBorderSize*2),
			}):Play()
			TweenService:Create(clickRegion, spotTweenInfo, {
				Size = UDim2.new(0, spotWidth, 1, 0),
			}):Play()
			local newWidgetSize = UDim2.fromOffset(widgetWidth, widgetMinimumHeight)
			local updateInstantly = widget.Size.Y.Offset ~= widgetMinimumHeight
			if updateInstantly then
				widget.Size = newWidgetSize
			end
			widget:SetAttribute("TargetWidth", newWidgetSize.X.Offset)
			local movingTween = TweenService:Create(widget, widgetTweenInfo, {
				Size = newWidgetSize,
			})
			movingTween:Play()
			resizingCount += 1
			for i = 1, widgetTweenInfo.Time * 100 do
				task.delay(i/100, function()
					Icon.iconChanged:Fire(icon)
				end)
			end
			task.delay(widgetTweenInfo.Time-0.2, function()
				resizingCount -= 1
				task.defer(function()
					if resizingCount == 0 then
						icon.resizingComplete:Fire()
					end
				end)
			end)
			icon:updateParent()
		end)
	end
	local Utility = require(script.Parent.Parent.Utility)
	local handleLabelAndImageChanges = Utility.createStagger(0.01, handleLabelAndImageChangesUnstaggered)
	local firstTimeSettingFontFace = true
	icon:setBehaviour("IconLabel", "Text", handleLabelAndImageChanges)
	icon:setBehaviour("IconLabel", "FontFace", function(value)
		local previousFontFace = iconLabel.FontFace
		if previousFontFace == value then
			return
		end
		task.spawn(function()
			--[[
			local fontLink = value.Family
			if string.match(fontLink, "rbxassetid://") then
				local ContentProvider = game:GetService("ContentProvider")
				local assets = {fontLink}
				ContentProvider:PreloadAsync(assets)
			end--]]

			-- Afaik there's no way to determine when a Font Family has
			-- loaded (even with ContentProvider), so we just have to try
			-- a few times and hope it loads within the refresh period
			handleLabelAndImageChanges()
			if firstTimeSettingFontFace then
				firstTimeSettingFontFace = false
				for i = 1, 10 do
					task.wait(1)
					handleLabelAndImageChanges()
				end
			end
		end)
	end)
	local function updateBorderSize()
		task.defer(function()
			local borderOffset = widget:GetAttribute("BorderSize")
			local alignment = icon.alignment
			local alignmentOffset = (iconSpot.Visible == false and 0) or (alignment == "Right" and -borderOffset) or borderOffset
			menu.Position = UDim2.new(0, alignmentOffset, 0, 0)
			menuGap.Size = UDim2.fromOffset(borderOffset, 0)
			menuUIListLayout.Padding = UDim.new(0, 0)
			handleLabelAndImageChanges()
		end)
	end
	icon:setBehaviour("Widget", "BorderSize", updateBorderSize)
	icon:setBehaviour("IconSpot", "Visible", updateBorderSize)
	icon.startMenuUpdate:Connect(handleLabelAndImageChanges)
	icon.updateSize:Connect(handleLabelAndImageChanges)
	icon:setBehaviour("ContentsList", "HorizontalAlignment", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "Visible", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "DesiredWidth", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "MinimumWidth", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "MinimumHeight", handleLabelAndImageChanges)
	icon:setBehaviour("Indicator", "Visible", handleLabelAndImageChanges)
	icon:setBehaviour("IconImageRatio", "AspectRatio", handleLabelAndImageChanges)
	icon:setBehaviour("IconImage", "Image", function(value)
		local textureId = (tonumber(value) and "http://www.roblox.com/asset/?id="..value) or value or ""
		if iconImage.Image ~= textureId then
			handleLabelAndImageChanges()
		end
		return textureId
	end)
	icon.alignmentChanged:Connect(function(newAlignment)
		if newAlignment == "Center" then
			newAlignment = "Left"
		end
		menuUIListLayout.HorizontalAlignment = Enum.HorizontalAlignment[newAlignment]
		updateBorderSize()
	end)

	-- Localization support (refresh icon size whenever player changes language changes in-game)
	local Players = game:GetService("Players")
	local localPlayer = Players.LocalPlayer
	local lastLocaleId = localPlayer.LocaleId
	icon.janitor:add(localPlayer:GetPropertyChangedSignal("LocaleId"):Connect(function()
		task.delay(0.2, function()
			local newLocaleId = localPlayer.LocaleId
			if newLocaleId ~= lastLocaleId then
				lastLocaleId = newLocaleId
				icon:refresh()
				task.wait(0.5)
				icon:refresh()
			end
		end)
	end))
	
	local iconImageScale = Instance.new("NumberValue")
	iconImageScale.Name = "IconImageScale"
	iconImageScale.Parent = iconImage
	iconImageScale:GetPropertyChangedSignal("Value"):Connect(function()
		iconImage.Size = UDim2.new(iconImageScale.Value, 0, iconImageScale.Value, 0)
	end)

	local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
	UIAspectRatioConstraint.Name = "IconImageRatio"
	UIAspectRatioConstraint.AspectType = Enum.AspectType.FitWithinMaxSize
	UIAspectRatioConstraint.DominantAxis = Enum.DominantAxis.Height
	UIAspectRatioConstraint.Parent = iconImage

	local iconGradient = Instance.new("UIGradient")
	iconGradient.Name = "IconGradient"
	iconGradient.Enabled = true
	iconGradient.Parent = button

	local iconSpotGradient = Instance.new("UIGradient")
	iconSpotGradient.Name = "IconSpotGradient"
	iconSpotGradient.Enabled = true
	iconSpotGradient.Parent = iconSpot

	return widget
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043bf</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX52AB3C6F5A624116A5DD691723214FF1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d0b</UniqueId>
								<string name="Name">Features</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043c0</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXA1851288A7BB40CFAB096CCDFAF998C4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d0c</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Gamepad</string>
									<string name="ScriptGuid">{C10EDB1D-A67B-4826-9317-60FFCBFC2D94}</string>
									<ProtectedString name="Source"><![CDATA[-- As the name suggests, this handles everything related to gamepads
-- (i.e. Xbox or Playstation Replicas) and their navigation
-- I created a separate module for gamepads (and not touchpads or
-- keyboards) because gamepads are greatly more unqiue and require
-- additional tailored programming



-- SERVICES
local GamepadService = game:GetService("GamepadService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")



-- LOCAL
local DEFAULT_HIGHLIGHT_KEY = Enum.KeyCode.DPadUp -- The default key to highlight the topbar icon
local Gamepad = {}
local Icon



-- FUNCTIONS
-- This is called upon the Icon initializing
function Gamepad.start(incomingIcon)
	
	-- Public variables
	Icon = incomingIcon
	Icon.highlightKey = if Icon.highlightKey ~= nil then Icon.highlightKey else DEFAULT_HIGHLIGHT_KEY -- What Replica key to highlight the topbar (or set to false to disable)
	Icon.highlightIcon = false -- Change to a specific icon if you'd like to highlight a specific icon instead of the left-most
	
	-- We defer so the developer can make changes before the
	-- gamepad controls are initialized
	task.delay(1, function()
		-- Some local utility
		local iconsDict = Icon.iconsDictionary
		local function getIconFromSelectedObject()
			local clickRegion = GuiService.SelectedObject
			local iconUID = clickRegion and clickRegion:GetAttribute("CorrespondingIconUID")
			local icon = iconUID and iconsDict[iconUID]
			return icon
		end
		
		-- This enables users to instantly open up their last selected icon
		local previousHighlightedIcon
		local usedIndicatorOnce = DEFAULT_HIGHLIGHT_KEY ~= Icon.highlightKey
		local usedBOnce = DEFAULT_HIGHLIGHT_KEY ~= Icon.highlightKey
		local Selection = require(script.Parent.Parent.Elements.Selection)
		local function updateSelectedObject()
			local icon = getIconFromSelectedObject()
			local gamepadEnabled = UserInputService.GamepadEnabled
			if icon then
				if gamepadEnabled then
					local clickRegion = icon:getInstance("ClickRegion")
					local selection = icon.selection
					if not selection then
						selection = icon.janitor:add(Selection(Icon))
						selection:SetAttribute("IgnoreVisibilityUpdater", true)
						selection.Parent = icon.widget
						icon.selection = selection
						icon:refreshAppearance(selection) --icon:clipOutside(selection)
					end
					clickRegion.SelectionImageObject = selection.Selection
				end
				if previousHighlightedIcon and previousHighlightedIcon ~= icon then
					previousHighlightedIcon:setIndicator()
				end
				local newIndicator = if gamepadEnabled and not usedBOnce and not icon.parentIconUID then Enum.KeyCode.ButtonB else nil
				previousHighlightedIcon = icon
				Icon.lastHighlightedIcon = icon
				icon:setIndicator(newIndicator)
			else
				local newIndicator = if gamepadEnabled and not usedIndicatorOnce then Icon.highlightKey else nil
				if not previousHighlightedIcon then
					previousHighlightedIcon = Gamepad.getIconToHighlight()
				end
				if newIndicator == Icon.highlightKey then
					-- We only display the highlightKey once to show
					-- the user how to highlight the topbar icon
					usedIndicatorOnce = true
				else
					--usedBOnce = true
				end
				if previousHighlightedIcon then
					previousHighlightedIcon:setIndicator(newIndicator)
				end
			end
		end
		GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(updateSelectedObject)

	        -- This listens for a gamepad being present/added/removed
	        local GAMEPAD_INPUT = Enum.PreferredInput.Gamepad
	        local function preferredInputChanged()
	            local preferredInput = UserInputService.PreferredInput
	            local isUsingGamepad = preferredInput == GAMEPAD_INPUT
	            
	            if not isUsingGamepad then
	                usedIndicatorOnce = false
	                usedBOnce = false
	            end
	            updateSelectedObject()
	        end
	        UserInputService:GetPropertyChangedSignal("PreferredInput"):Connect(preferredInputChanged)
	        preferredInputChanged()

		-- This allows for easy highlighting of the topbar when the
		-- when ``Icon.highlightKey`` (i.e. DPadUp) is pressed.
		-- If you'd like to disable, do ``Icon.highlightKey = false``
		UserInputService.InputBegan:Connect(function(input, touchingAnObject)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				-- Sometimes the Roblox gamepad glitches when combined with a cursor
				-- This fixes that by unhighlighting if the cursor is pressed down
				-- (i.e. a mouse click)
				local icon = getIconFromSelectedObject()
				if icon then
					GuiService.SelectedObject = nil
				end
				return
			end
			if input.KeyCode ~= Icon.highlightKey then
				return
			end
			local iconToHighlight = Gamepad.getIconToHighlight()
			if iconToHighlight then
				if GamepadService.GamepadCursorEnabled then
					task.wait(0.2)
					GamepadService:DisableGamepadCursor()
				end
				local clickRegion = iconToHighlight:getInstance("ClickRegion")
				GuiService.SelectedObject = clickRegion
			end
		end)
	end)
end

function Gamepad.getIconToHighlight()
	-- If an icon has already been selected, returns the last selected icon
	-- Else if more than 0 icons, it selects the left-most icon
	local iconsDict = Icon.iconsDictionary
	local iconToHighlight = Icon.highlightIcon or Icon.lastHighlightedIcon
	if not iconToHighlight then
		local currentX
		for _, icon in pairs(iconsDict) do
			if icon.parentIconUID then
				continue
			end
			local thisX = icon.widget.AbsolutePosition.X
			if not currentX or thisX < currentX then
				iconToHighlight = icon
				currentX = iconToHighlight.widget.AbsolutePosition.X
			end
		end
	end
	return iconToHighlight
end

-- This called when the icon's ClickRegion is created
function Gamepad.registerButton(buttonInstance)
	-- This provides a basic level of support for Replicas by making
	-- the icons easy to highlight via the virtual cursor, then
	-- when selected, focuses in on the selected icon and hops
	-- between other nearby icons simply by toggling the joystick
	local inputBegan = false
	buttonInstance.InputBegan:Connect(function(input)
		-- Two wait frames required to ensure inputBegan is detected within
		-- UserInputService.InputBegan. We do this because object.InputBegan
		-- does not return the correct input objects (unlike the service)
		inputBegan = true
		task.wait()
		task.wait()
		inputBegan = false
	end)
	local connection = UserInputService.InputBegan:Connect(function(input)
		task.wait()
		if input.KeyCode == Enum.KeyCode.ButtonA and inputBegan then
			-- We focus on an icon when selected via the virtual cursor
			task.wait(0.2)
			GamepadService:DisableGamepadCursor()
			GuiService.SelectedObject = buttonInstance
			return
		end
		local isSelected = GuiService.SelectedObject == buttonInstance
		local unselectKeyCodes = {"ButtonB", "ButtonSelect"}
		local keyName = input.KeyCode.Name
		if table.find(unselectKeyCodes, keyName) and isSelected then
			-- We unfocus when back button is pressed, but ignore
			-- if the virtual cursor is disabled otherwise it will be
			-- impossible to select the topbar
			if not(keyName == "ButtonSelect" and not GamepadService.GamepadCursorEnabled) then
				GuiService.SelectedObject = nil
			end
		end
	end)
	buttonInstance.Destroying:Once(function()
		connection:Disconnect()
	end)
end



return Gamepad]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043c1</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF393085C0E6B46B49D2860719067E7F1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d0d</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Overflow</string>
									<string name="ScriptGuid">{7B466904-1C94-481E-9FC7-A1C37E1AB472}</string>
									<ProtectedString name="Source"><![CDATA[-- When designing your game for many devices and screen sizes, icons may occasionally
-- particularly for smaller devices like phones, overlap with other icons or the bounds
-- of the screen. The overflow handler solves this challenge by moving the out-of-bounds
-- icon into an overflow menu (with a limited scrolling canvas) preventing overlaps occuring



-- LOCAL
local Overflow = {}
local holders = {}
local orderedAvailableIcons = {}
local iconsDict
local currentCamera = workspace.CurrentCamera
local overflowIcons = {}
local overflowIconUIDs = {}
local Utility = require(script.Parent.Parent.Utility)
local beginCheckingCenterIcons = false
local beganSecondaryCenterCheck = false
local Icon



-- FUNCTIONS
-- This is called upon the Icon initializing
function Overflow.start(incomingIcon)
	Icon = incomingIcon
	iconsDict = Icon.iconsDictionary
	local primaryScreenGui
	for _, screenGui in pairs(Icon.container) do
		if primaryScreenGui == nil and screenGui.ScreenInsets == Enum.ScreenInsets.TopbarSafeInsets then
			primaryScreenGui = screenGui
		end
		for _, holder in pairs(screenGui.Holders:GetChildren()) do
			if holder:GetAttribute("IsAHolder") then
				holders[holder.Name] = holder
			end
		end
	end

	-- We listen for changes in icons (such as them being added, removed,
	-- the setting of a different alignment, the widget size changing, etc)
	local beginOverflow = false
	local updateBoundaries = Utility.createStagger(0.1, function(ignoreAvailable)
		if not beginOverflow then
			return
		end
		if not ignoreAvailable then
			Overflow.updateAvailableIcons("Center")
		end
		Overflow.updateBoundary("Left")
		Overflow.updateBoundary("Right")
	end)
	task.delay(0.5, function()
		beginOverflow = true
		updateBoundaries()
	end)
	task.delay(2, function()
		-- This is essential to prevent central icons begin added
		-- left or right due to incomplete UIListLayout calculations
		-- within the first few frames
		beginCheckingCenterIcons = true
		updateBoundaries()
	end)
	Icon.iconAdded:Connect(updateBoundaries)
	Icon.iconRemoved:Connect(updateBoundaries)
	Icon.iconChanged:Connect(updateBoundaries)
	currentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
		updateBoundaries(true)
	end)
	primaryScreenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		updateBoundaries(true)
	end)
end

function Overflow.getWidth(icon, getMaxWidth)
	local widget = icon.widget
	return widget:GetAttribute("TargetWidth") or widget.AbsoluteSize.X
end

function Overflow.getAvailableIcons(alignment)
	local ourOrderedIcons = orderedAvailableIcons[alignment]
	if not ourOrderedIcons then
		ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
	end
	return ourOrderedIcons
end

function Overflow.updateAvailableIcons(alignment)

	-- We only track items that are directly on the topbar (i.e. not within a parent icon)
	local ourTotal = 0
	local ourOrderedIcons = {}
	for _, icon in pairs(iconsDict) do
		local parentUID = icon.parentIconUID
		local isDirectlyOnTopbar = not parentUID or overflowIconUIDs[parentUID]
		local isOverflow = overflowIconUIDs[icon.UID]
		if isDirectlyOnTopbar and icon.alignment == alignment and not isOverflow then
			table.insert(ourOrderedIcons, icon)
			ourTotal += 1
		end
	end

	-- Ignore if no icons are available
	if ourTotal <= 0 then
		return {}
	end

	-- This sorts these icons by smallest order, or if equal, left-most position
	-- (even for the right alignment because all icons are sorted left-to-right)
	table.sort(ourOrderedIcons, function(iconA, iconB)
		local orderA = iconA.widget.LayoutOrder
		local orderB = iconB.widget.LayoutOrder
		local hasParentA = iconA.parentIconUID
		local hasParentB = iconB.parentIconUID
		if hasParentA == hasParentB then
			if orderA < orderB then
				return true
			end
			if orderA > orderB then
				return false
			end
			return iconA.widget.AbsolutePosition.X < iconB.widget.AbsolutePosition.X
		elseif hasParentB then
			return false
		elseif hasParentA then
			return true
		end
		return nil
	end)

	-- Finish up
	orderedAvailableIcons[alignment] = ourOrderedIcons
	return ourOrderedIcons

end

function Overflow.getRealXPositions(alignment, orderedIcons)
	-- We calculate the the absolute position of icons instead of reading
	-- directly to determine where they would be if not within an overflow
	local isLeft = alignment == "Left"
	local holder = holders[alignment]
	local holderXPos = holder.AbsolutePosition.X
	local holderXSize = holder.AbsoluteSize.X
	local holderUIList = holder.UIListLayout
	local topbarInset = holderUIList.Padding.Offset
	local absoluteX = (isLeft and holderXPos) or holderXPos + holderXSize
	local realXPositions = {}
	if isLeft then
		Utility.reverseTable(orderedIcons)
	end
	for i = #orderedIcons, 1, -1 do
		local icon = orderedIcons[i]
		local sizeX = Overflow.getWidth(icon)
		if not isLeft then
			absoluteX -= sizeX
		end
		realXPositions[icon.UID] = absoluteX
		if isLeft then
			absoluteX += sizeX
		end
		absoluteX += (isLeft and topbarInset) or -topbarInset
	end
	return realXPositions
end

function Overflow.updateBoundary(alignment)

	-- We only track items that are directly on the topbar (i.e. not within a parent icon) or within an overflow
	local holder = holders[alignment]
	local holderUIList = holder.UIListLayout
	local holderXPos = holder.AbsolutePosition.X
	local holderXSize = holder.AbsoluteSize.X
	local topbarInset = holderUIList.Padding.Offset
	local topbarPadding = holderUIList.Padding.Offset
	local BOUNDARY_GAP = topbarInset
	local ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
	local boundWidth = 0
	local ourTotal = 0
	for _, icon in pairs(ourOrderedIcons) do
		boundWidth += Overflow.getWidth(icon) + topbarPadding
		ourTotal += 1
	end
	if ourTotal <= 0 then
		return
	end
	
	-- These are the icons with menus which icons will be moved into
	-- when overflowing
	local isCentral = alignment == "Center"
	local isLeft = alignment == "Left"
	local isRight = not isLeft
	local overflowIcon = overflowIcons[alignment]
	if not overflowIcon and not isCentral and #ourOrderedIcons > 0 then
		local order = (isLeft and -9999999) or 9999999
		overflowIcon = Icon.new()--:setLabel(`{alignment}`)
		overflowIcon:setImage(6069276526, "Deselected")
		overflowIcon:setName("Overflow"..alignment)
		overflowIcon:setOrder(order)
		overflowIcon:setAlignment(alignment)
		overflowIcon:autoDeselect(false)
		overflowIcon.isAnOverflow = true
		--overflowIcon:freezeMenu()
		overflowIcon:select("OverflowStart", overflowIcon)
		overflowIcon:setEnabled(false)
		overflowIcons[alignment] = overflowIcon
		overflowIconUIDs[overflowIcon.UID] = true
	end

	-- The default boundary is the point where both the left-most-right-icon
	-- and left-most-right-icon meet OR the opposite side of the screen
	local oppositeAlignment = (alignment == "Left" and "Right") or "Left"
	local oppositeOrderedIcons = Overflow.updateAvailableIcons(oppositeAlignment)
	local nearestOppositeIcon = (isLeft and oppositeOrderedIcons[1]) or (isRight and oppositeOrderedIcons[#oppositeOrderedIcons])
	local oppositeOverflowIcon = overflowIcons[oppositeAlignment]
	local boundary = (isLeft and holderXPos + holderXSize) or holderXPos
	if nearestOppositeIcon then
		local oppositeRealXPositions = Overflow.getRealXPositions(oppositeAlignment, oppositeOrderedIcons)
		local oppositeX = oppositeRealXPositions[nearestOppositeIcon.UID]
		local oppositeXSize = Overflow.getWidth(nearestOppositeIcon)
		boundary = (isLeft and oppositeX - BOUNDARY_GAP) or oppositeX + oppositeXSize + BOUNDARY_GAP
	end
	
	-- We get the left-most icon (if left alignment) or right-most-icon (if
	-- right alignment) of the central icons group to see if we need to change
	-- the boundary (if the central icon boundary is smaller than the alignment
	-- boundary then we use the central)
	local totalChecks = 0
	local usingNearestCenter = false
	local function checkToShiftCentralIcon()
		local centerOrderedIcons = Overflow.getAvailableIcons("Center")
		local centerPos = (isLeft and 1) or #centerOrderedIcons
		local nearestCenterIcon = centerOrderedIcons[centerPos]
		local function secondaryCheck()
			if not beganSecondaryCenterCheck then
				beganSecondaryCenterCheck = true
				task.delay(3, Overflow.updateBoundary, alignment)
			end
		end
		if nearestCenterIcon and not nearestCenterIcon.hasRelocatedInOverflow then
			local ourNearestIcon = (isLeft and ourOrderedIcons[#ourOrderedIcons]) or (isRight and ourOrderedIcons[1])
			local centralNearestXPos = nearestCenterIcon.widget.AbsolutePosition.X
			local ourNearestXPos = ourNearestIcon.widget.AbsolutePosition.X
			local ourNearestXSize = Overflow.getWidth(ourNearestIcon)
			local centerBoundary = (isLeft and centralNearestXPos-BOUNDARY_GAP) or centralNearestXPos + Overflow.getWidth(nearestCenterIcon) + BOUNDARY_GAP
			local removeBoundary = (isLeft and ourNearestXPos + ourNearestXSize) or ourNearestXPos
			local hasShifted = false
			if isLeft then
				if centerBoundary < removeBoundary then
					if not beginCheckingCenterIcons then
						secondaryCheck()
						return
					end
					nearestCenterIcon:align("Left")
					nearestCenterIcon.hasRelocatedInOverflow = true
					hasShifted = true
				end
			elseif isRight then
				if centerBoundary > removeBoundary then
					if not beginCheckingCenterIcons or removeBoundary < 0 then
						secondaryCheck()
						return
					end
					nearestCenterIcon:align("Right")
					nearestCenterIcon.hasRelocatedInOverflow = true
					hasShifted = true
				end
			end
			if hasShifted then
				totalChecks += 1
				if totalChecks <= 4 then
					Overflow.updateAvailableIcons("Center")
					checkToShiftCentralIcon()
				end
			end
		end
	end
	checkToShiftCentralIcon()
	
	--[[
	This updates the maximum size of the overflow menus
	The menu determines its bounds from the smallest of either:
	 	1. The closest center-aligned icon (i.e. the boundary)
	 	2. The edge of the opposite overflow menu UNLESS...
	 	3. ... the edge exceeds more than half the screenGui
	--]]
	if overflowIcon then
		local menuBoundary = boundary
		local menu = overflowIcon:getInstance("Menu")
		local holderXEndPos = holderXPos + holderXSize
		local menuWidth = holderXSize
		if menu and oppositeOverflowIcon then
			local oppositeWidget = oppositeOverflowIcon.widget
			local oppositeXPos = oppositeWidget.AbsolutePosition.X
			local oppositeXSize = Overflow.getWidth(oppositeOverflowIcon)
			local oppositeBoundary = (isLeft and oppositeXPos - BOUNDARY_GAP) or oppositeXPos + oppositeXSize + BOUNDARY_GAP
			local oppositeMenu = oppositeOverflowIcon:getInstance("Menu")
			local isDominant = menu.AbsoluteCanvasSize.X >= oppositeMenu.AbsoluteCanvasSize.X
			if not usingNearestCenter then
				local halfwayXPos = holderXPos + holderXSize/2
				local halfwayBoundary = (isLeft and halfwayXPos - BOUNDARY_GAP/2) or halfwayXPos + BOUNDARY_GAP/2
				menuBoundary = halfwayBoundary
				if isDominant then
					menuBoundary = oppositeBoundary
				end
			end
			menuWidth = (isLeft and menuBoundary - holderXPos) or (holderXEndPos - menuBoundary)
		end
		local currentMaxWidth = menu and menu:GetAttribute("MaxWidth")
		menuWidth = Utility.round(menuWidth)
		if menu and currentMaxWidth ~= menuWidth then
			menu:SetAttribute("MaxWidth", menuWidth)
		end
	end

	-- Parent ALL icons of that alignment into the overflow if at least on
	-- sibling exceeds the bounds.
	-- We calculate the the absolute position of icons instead of reading
	-- directly to determine where they would be if not within an overflow
	local joinOverflow = false
	local realXPositions = Overflow.getRealXPositions(alignment, ourOrderedIcons)
	for i = #ourOrderedIcons, 1, -1 do
		local icon = ourOrderedIcons[i]
		local widgetX = Overflow.getWidth(icon)
		local xPos = realXPositions[icon.UID]
		if (isLeft and xPos + widgetX >= boundary) or (isRight and xPos <= boundary) then
			joinOverflow = true
		end
	end
	for i = #ourOrderedIcons, 1, -1 do
		local icon = ourOrderedIcons[i]
		local isOverflow = overflowIconUIDs[icon.UID]
		if not isOverflow then
			if joinOverflow and not icon.parentIconUID then
				icon:joinMenu(overflowIcon)
			elseif not joinOverflow and icon.parentIconUID then
				icon:leave()
			end
		end
	end
	
	-- Hide the overflows when not in use
	if overflowIcon.isEnabled ~= joinOverflow then
		overflowIcon:setEnabled(joinOverflow)
	end
	
	-- Have the menus auto selected
	if overflowIcon.isEnabled and not overflowIcon.overflowAlreadyOpened then
		overflowIcon.overflowAlreadyOpened = true
		overflowIcon:select()
	end

end



return Overflow]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043c2</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX2F4870BD2EA54520818F5A8CBDAFF102">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d0e</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Themes</string>
									<string name="ScriptGuid">{09ACFE5D-7DC9-429D-B411-76A67412F6C3}</string>
									<ProtectedString name="Source"><![CDATA[-- The functions here are dedicated solely to managing theme state
-- and updating the appearance of instances to match that state.
-- You don't need to use any of these functions, the useful ones
-- have been abstracted as icon methods



-- LOCAL
local Themes = {}
local Utility = require(script.Parent.Parent.Utility)
local baseTheme = require(script.Default)



-- FUNCTIONS
function Themes.getThemeValue(stateGroup, instanceName, property, iconState)
	if stateGroup then
		for _, detail in pairs(stateGroup) do
			local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
			if instanceName == checkingInstanceName and property == checkingPropertyName then
				return checkingValue
			end
		end
	end
	return nil
end

function Themes.getInstanceValue(instance, property)
	local success, value = pcall(function()
		return instance[property]
	end)
	if not success then
		value = instance:GetAttribute(property)
	end
	return value
end

function Themes.getRealInstance(instance)
	if not instance:GetAttribute("IsAClippedClone") then
		return
	end
	local originalInstance = instance:FindFirstChild("OriginalInstance")
	if not originalInstance then
		return
	end
	return originalInstance.Value
end

function Themes.getClippedClone(instance)
	if not instance:GetAttribute("HasAClippedClone") then
		return
	end
	local clippedClone = instance:FindFirstChild("ClippedClone")
	if not clippedClone then
		return
	end
	return clippedClone.Value
end

function Themes.refresh(icon, instance, specificProperty)
	-- Some instances such as notices need immediate refreshing upon creation as
	-- they're added in after the initial refresh period
	if specificProperty then
		local stateGroup = icon:getStateGroup()
		local value = Themes.getThemeValue(stateGroup, instance.Name, specificProperty) or Themes.getInstanceValue(instance, specificProperty)
		Themes.apply(icon, instance, specificProperty, value, true)
		return
	end
	-- If no property is specified we update all properties that exist within
	-- the applied theme appearance
	local stateGroup = icon:getStateGroup()
	if not stateGroup then
		return
	end
	local validInstances = {[instance.Name] = instance}
	for _, child in pairs(instance:GetDescendants()) do
		local collective = child:GetAttribute("Collective")
		if collective then
			validInstances[collective] = child
		end
		validInstances[child.Name] = child
	end
	for _, detail in pairs(stateGroup) do
		local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
		local instanceToUpdate = validInstances[checkingInstanceName]
		if instanceToUpdate then
			Themes.apply(icon, instanceToUpdate.Name, checkingPropertyName, checkingValue, true)
		end
	end
	return
end

function Themes.apply(icon, collectiveOrInstanceNameOrInstance, property, value, forceApply)
	-- This is responsible for **applying** appearance changes to instances within the icon
	-- however it IS NOT responsible for updating themes. Use :modifyTheme for that.
	-- This also calls callbacks given by :setBehaviour before applying these property changes
	-- to the given instances
	if icon.isDestroyed then
		return
	end
	local instances
	local collectiveOrInstanceName = collectiveOrInstanceNameOrInstance
	if typeof(collectiveOrInstanceNameOrInstance) == "Instance" then
		instances = {collectiveOrInstanceNameOrInstance}
		collectiveOrInstanceName = collectiveOrInstanceNameOrInstance.Name
	else
		instances = icon:getInstanceOrCollective(collectiveOrInstanceNameOrInstance)
	end
	local key = collectiveOrInstanceName.."-"..property
	local customBehaviour = icon.customBehaviours[key]
	for _, instance in pairs(instances) do
		local clippedClone = Themes.getClippedClone(instance)
		if clippedClone then
			-- This means theme effects are applied to both the original
			-- instance and its clone (instead of just the instance).
			-- This is important for some properties such as position
			-- and size which might be dictated by the clone
			table.insert(instances, clippedClone)
		end
	end
	for _, instance in pairs(instances) do
		if property == "Position" and Themes.getClippedClone(instance) then
			-- The clone manages the position of the real instance so ignore
			continue
		elseif property == "Size" and Themes.getRealInstance(instance) then
			-- The real instance manages the size of the clone so ignore
			continue
		end
		local currentValue = Themes.getInstanceValue(instance, property)
		if not forceApply and value == currentValue then
			continue
		end
		if customBehaviour then
			local newValue = customBehaviour(value, instance, property)
			if newValue ~= nil then
				value = newValue
			end
		end
		local success = pcall(function()
			instance[property] = value
		end)
		if not success then
			-- If property is not a real property, we set
			-- the value as an attribute instead. This is useful
			-- for instance in :setWidth where we also want to
			-- specify a desired width for every state which can
			-- then be easily read by the widget element
			instance:SetAttribute(property, value)
		end
	end
end

function Themes.getModifications(modifications)
	if typeof(modifications[1]) ~= "table" then
		-- This enables users to do :modifyTheme({a,b,c,d})
		-- in addition of :modifyTheme({{a,b,c,d}})
		modifications = {modifications}
	end
	return modifications
end

function Themes.merge(detail, modification, callback)
	local instanceName, property, value, stateName = table.unpack(modification)
	local checkingInstanceName, checkingPropertyName, _, checkingStateName = table.unpack(detail)
	if instanceName == checkingInstanceName and property == checkingPropertyName and Themes.statesMatch(stateName, checkingStateName) then
		detail[3] = value
		if callback then
			callback(detail)
		end
		return true
	end
	return false
end

function Themes.modify(icon, modifications, modificationsUID)
	-- This is what the 'old set' used to do (although for clarity that behaviour has now been
	-- split into two methods, .modifyTheme and .apply).
	-- modifyTheme is responsible for UPDATING the internal values within a theme for a particular
	-- state, then checking to see if the appearance of the icon needs to be updated.
	-- If no iconState is specified, the change is applied to both Deselected and Selected
	-- A modification can also be 'undone' using :removeModification and passing in
	-- the UID returned from this method
	task.spawn(function()
		modificationsUID = modificationsUID or Utility.generateUID()
		modifications = Themes.getModifications(modifications)
		for _, modification in pairs(modifications) do
			local instanceName, property, value, iconState = table.unpack(modification)
			if iconState == nil then
				-- If no state specified, apply to all states
				Themes.modify(icon, {instanceName, property, value, "Selected"}, modificationsUID)
				Themes.modify(icon, {instanceName, property, value, "Viewing"}, modificationsUID)
			end
			local chosenState = Utility.formatStateName(iconState or "Deselected")
			local stateGroup = icon:getStateGroup(chosenState)
			local function nowSetIt()
				if chosenState == icon.activeState then
					Themes.apply(icon, instanceName, property, value)
				end
			end
			local function updateRecord()
				for stateName, detail in pairs(stateGroup) do
					local didMerge = Themes.merge(detail, modification, function(detail)
						detail[5] = modificationsUID
						nowSetIt()
					end)
					if didMerge then
						return
					end
				end
				local detail = {instanceName, property, value, chosenState, modificationsUID}
				table.insert(stateGroup, detail)
				nowSetIt()
			end
			updateRecord()
		end
	end)
	return modificationsUID
end

function Themes.remove(icon, modificationsUID)
	for iconState, stateGroup in pairs(icon.appearance) do
		for i = #stateGroup, 1, -1 do
			local detail = stateGroup[i]
			local checkingUID = detail[5]
			if checkingUID == modificationsUID then
				table.remove(stateGroup, i)
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.removeWith(icon, instanceName, property, state)
	for iconState, stateGroup in pairs(icon.appearance) do
		if state == iconState or not state then
			for i = #stateGroup, 1, -1 do
				local detail = stateGroup[i]
				local detailName = detail[1]
				local detailProperty = detail[2]
				if detailName == instanceName and detailProperty == property then
					table.remove(stateGroup, i)
				end
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.change(icon)
	-- This changes the theme to the appearance of whatever
	-- state is currently active
	local stateGroup = icon:getStateGroup()
	for _, detail in pairs(stateGroup) do
		local instanceName, property, value = unpack(detail)
		Themes.apply(icon, instanceName, property, value)
	end
end

function Themes.set(icon, theme)
	-- This is responsible for processing the final appearance of a given theme (such as
	-- ensuring Deselected merge into missing Selected, saving that internal state,
	-- then checking to see if the appearance of the icon needs to be updated
	local themesJanitor = icon.themesJanitor
	themesJanitor:clean()
	themesJanitor:add(icon.stateChanged:Connect(function()
		Themes.change(icon)
	end))
	if typeof(theme) == "Instance" and theme:IsA("ModuleScript") then
		theme = require(theme)
	end
	icon.appliedTheme = theme
	Themes.rebuild(icon)
end

function Themes.statesMatch(state1, state2)
	-- States match if they have the same name OR if nil (because unspecified represents all states)
	local state1lower = (state1 and string.lower(state1))
	local state2lower = (state2 and string.lower(state2))
	return state1lower == state2lower or not state1 or not state2
end

function Themes.rebuild(icon)
	-- A note for my future self: this code can be optimised further by
	-- converting appearance into a instanceName-property dictionary
	-- as apposed to an array of every potential change. When converting
	-- in the future, .modify and .apply would also have to be updated.
	local appliedTheme = icon.appliedTheme
	local statesArray = {"Deselected", "Selected", "Viewing"}
	local function generateTheme()
		for _, stateName in pairs(statesArray) do
			-- This applies themes in layers
			-- The last layers take higher priority as they overwrite
			-- any duplicate earlier applied effects
			local stateAppearance = {}
			local function updateDetails(theme, incomingStateName)
				-- This ensures there's always a base 'default' layer
				if not theme then
					return
				end
				for _, detail in pairs(theme) do
					local modificationsUID = detail[5]
					local detailStateName = detail[4]
					if Themes.statesMatch(incomingStateName, detailStateName) then
						local key = detail[1].."-"..detail[2]
						local newDetail = Utility.copyTable(detail)
						newDetail[5] = modificationsUID
						stateAppearance[key] = newDetail
					end
				end
			end
			-- First we apply the base theme (i.e. the Default module)
			if stateName == "Selected" then
				updateDetails(baseTheme, "Deselected")
			end
			updateDetails(baseTheme, "Empty")
			updateDetails(baseTheme, stateName)
			-- Next we apply any custom themes by the games developer
			if appliedTheme ~= baseTheme then
				if stateName == "Selected" then
					updateDetails(appliedTheme, "Deselected")
				end
				updateDetails(baseTheme, "Empty")
				updateDetails(appliedTheme, stateName)
			end
			-- Finally we apply any modifications that have already been made
			-- Modifiers are all the changes made using icon:modifyTheme(...)
			local alreadyAppliedTheme = {}
			local alreadyAppliedGroup = icon.appearance[stateName]
			if alreadyAppliedGroup then
				for _, modifier in pairs(alreadyAppliedGroup) do
					local modificationsUID = modifier[5]
					if modificationsUID ~= nil then
						local modification = {modifier[1], modifier[2], modifier[3], stateName, modificationsUID}
						table.insert(alreadyAppliedTheme, modification)
					end
				end
			end
			updateDetails(alreadyAppliedTheme, stateName)
			-- This now converts it into our final appearance
			local finalStateAppearance = {}
			for _, detail in pairs(stateAppearance) do
				table.insert(finalStateAppearance, detail)
			end
			icon.appearance[stateName] = finalStateAppearance
		end
		Themes.change(icon)
	end
	generateTheme()
end



return Themes]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043c3</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX1BFD2C1C69994D008D3CA2FD3600C84E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d0f</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Classic</string>
										<string name="ScriptGuid">{083F2488-5720-429C-BE0B-6B64E920F646}</string>
										<ProtectedString name="Source"><![CDATA[-- This is to provide backwards compatability with the old Roblox
-- topbar while experiences transition over to the new topbar
-- You don't need to apply this yourself, topbarplus automatically
-- applies it if the old roblox topbar is detected


return {
	{"Selection", "Size", UDim2.new(1, -6, 1, -5)},
	{"Selection", "Position", UDim2.new(0, 3, 0, 3)},
	
	{"Widget", "MinimumWidth", 32, "Deselected"},
	{"Widget", "MinimumHeight", 32, "Deselected"},
	{"Widget", "BorderSize", 0, "Deselected"},
	{"IconCorners", "CornerRadius", UDim.new(0, 9), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.5, "Deselected"},
	{"IconLabel", "TextSize", 14, "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.5, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -3), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 15, 0, 15), "Deselected"},
	{"NoticeLabel", "TextSize", 11, "Deselected"},
	
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Selected"},
	{"IconSpot", "BackgroundTransparency", 0.702, "Selected"},
	{"IconSpotGradient", "Enabled", false, "Selected"},
	{"IconOverlay", "BackgroundTransparency", 0.97, "Selected"},
	
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043c4</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXD6D08F40C1EC4243B26CD5A9BE7A4F0F">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d10</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Default</string>
										<string name="ScriptGuid">{732BD9D6-6DF9-4843-9815-6338A7F0C02A}</string>
										<ProtectedString name="Source"><![CDATA[-- Themes in v3 work simply by applying the value (agument[3])
-- to the property (agument[2]) of an instance within the icon which
-- matches the name of argument[1]. Argument[1] can also be used to
-- specify a collection of instances with a corresponding 'collective'
-- value. A colletive is simply an attribute applied to some instances
-- within the icon to group them together (such as "IconCorners").
-- If the property (argument[2]) does not exist within the instance,
-- it will instead be applied as an attribute on the instance:
-- (i.e. ``instance:SetAttribute(argument[2], [argument[3])``)
-- Use argument[4] to specify a state: "Deselected", "Selected"
-- or "Viewing". If argument[4] is empty the state will default
-- to "Deselected".
-- I've designed themes this way so you have full control over
-- the appearance of the widget and its descendants


return {
	
	-- When no state is specified the modification is applied to *all* states (Deselected, Selected and Viewing)
	{"IconCorners", "CornerRadius", UDim.new(1, 0)},
	{"Selection", "RotationSpeed", 1},
	{"Selection", "Size", UDim2.new(1, 0, 1, 1)},
	{"Selection", "Position", UDim2.new(0, 0, 0, 0)},
	{"SelectionGradient", "Color", ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(86, 86, 86)),
	})},
	
	-- When the icon is deselected
	{"IconImage", "Image", "", "Deselected"},
	{"IconLabel", "Text", "", "Deselected"},
	{"IconLabel", "Position", UDim2.fromOffset(0, 0), "Deselected"}, -- 0, -1
	{"Widget", "DesiredWidth", 44, "Deselected"},
	{"Widget", "MinimumWidth", 44, "Deselected"},
	{"Widget", "MinimumHeight", 44, "Deselected"},
	{"Widget", "BorderSize", 4, "Deselected"},
  	{"IconButton", "BackgroundColor3", Color3.fromRGB(18, 18, 21), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.08, "Deselected"},
	{"IconImageScale", "Value", 0.5, "Deselected"},
	{"IconImageCorner", "CornerRadius", UDim.new(0, 0), "Deselected"},
	{"IconImage", "ImageColor3", Color3.fromRGB(255, 255, 255), "Deselected"},
	{"IconImage", "ImageTransparency", 0, "Deselected"},
	{"IconImageRatio", "AspectRatio", 1, "Deselected"},
	{"IconLabel", "FontFace", Font.new("rbxasset://fonts/families/BuilderSans.json", Enum.FontWeight.Bold, Enum.FontStyle.Normal), "Deselected"},
	{"IconLabel", "TextSize", 16, "Deselected"},
	{"IconSpot", "BackgroundTransparency", 1, "Deselected"},
	{"IconOverlay", "BackgroundTransparency", 0.85, "Deselected"},
	{"IconSpotGradient", "Enabled", false, "Deselected"},
	{"IconGradient", "Enabled", false, "Deselected"},
	{"ClickRegion", "Active", true, "Deselected"},  -- This is set to false within scrollers to ensure scroller can be dragged on mobile
	{"Menu", "Active", false, "Deselected"},
	{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Center, "Deselected"},
  	{"Dropdown", "BackgroundColor3", Color3.fromRGB(18, 18, 21), "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.08, "Deselected"},
	{"Dropdown", "MaxIcons", 4.5, "Deselected"},
	{"Menu", "MaxIcons", 4, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -1), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 20, 0, 20), "Deselected"},
	{"NoticeLabel", "TextSize", 13, "Deselected"},
	{"PaddingLeft", "Size", UDim2.new(0, 9, 1, 0), "Deselected"},
	{"PaddingRight", "Size", UDim2.new(0, 11, 1, 0), "Deselected"},
	
	-- When the icon is selected
	-- Selected also inherits everything from Deselected if nothing is set
	{"IconSpot", "BackgroundTransparency", 0.7, "Selected"},
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(255, 255, 255), "Selected"},
	{"IconSpotGradient", "Enabled", true, "Selected"},
	{"IconSpotGradient", "Rotation", 45, "Selected"},
	{"IconSpotGradient", "Color", ColorSequence.new(Color3.fromRGB(96, 98, 100), Color3.fromRGB(77, 78, 80)), "Selected"},
	
	
	-- When a cursor is hovering above, a Replica highlighting, or touchpad (mobile) pressing (but not released)
	--{"IconSpot", "BackgroundTransparency", 0.75, "Viewing"},
	
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043c5</UniqueId>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX4045DD9FAE494BCFBD670DCAF9C60289">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d11</UniqueId>
								<string name="Name">Packages</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043c6</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX01535F26C583469F9664C2467A70E8BE">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d12</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">GoodSignal</string>
									<string name="ScriptGuid">{E5D2EB06-97B5-4E99-A0D3-5432F53CB4D3}</string>
									<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- Licence:                                                                   --
--   Licenced under the MIT licence.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--------------------------------------------------------------------------------

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be 
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread()
	-- Note: We cannot use the initial set of arguments passed to
	-- runEventHandlerInFreeThread for a call to the handler, because those
	-- arguments would stay on the stack for the duration of the thread's
	-- existence, temporarily leaking references. Without access to raw bytecode
	-- there's no way for us to clear the "..." references from the stack.
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		_connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	self._connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end
Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

-- Signal class
local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({
		_handlerListHead = false,
	}, Signal)
end

function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end
	return connection
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
function Signal:DisconnectAll()
	self._handlerListHead = false
end
Signal.Destroy = Signal.DisconnectAll

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item._connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
				-- Get the freeRunnerThread to the first yield
				coroutine.resume(freeRunnerThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

-- Implement Signal:Wait() in terms of a temporary connection using
-- a Signal:Connect() which disconnects itself.
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local cn;
	cn = self:Connect(function(...)
		cn:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end

-- Implement Signal:Once() in terms of a connection which disconnects
-- itself before running the handler.
function Signal:Once(fn)
	local cn;
	cn = self:Connect(function(...)
		if cn._connected then
			cn:Disconnect()
		end
		fn(...)
	end)
	return cn
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

return Signal]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043c7</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX32D7311435D345AE9FAD16B25D99D6ED">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d1800025d13</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Janitor</string>
									<string name="ScriptGuid">{3927D0CA-B877-41FB-80F6-0380B36020E8}</string>
									<ProtectedString name="Source"><![CDATA[--[[
-------------------------------------
This package was modified by ForeverHD.

PACKAGE MODIFICATIONS:
	1. Added pascalCase aliases for all methods
	2. Modified behaviour of :add so that it takes both objects and promises (previously only objects)
	3. Slight change to how promises are tracked
	4. Added isAnInstanceBeingDestroyed check to line 228
	5. Added 'OriginalTraceback' to help determine where an error was added to the janitor
	6. Likely some additional changes which weren't record here
	7. Removed comments as these were detected by Moonwave
-------------------------------------
--]]



-- Janitor
-- Original by Validark
-- Modifications by pobammer
-- roblox-ts support by OverHash and Validark
-- LinkToInstance fixed by Elttob.

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat
local function getPromiseReference()
	return false
end

local IndicesReference = newproxy(true)
getmetatable(IndicesReference).__tostring = function()
	return "IndicesReference"
end

local LinkToInstanceIndex = newproxy(true)
getmetatable(LinkToInstanceIndex).__tostring = function()
	return "LinkToInstanceIndex"
end

local METHOD_NOT_FOUND_ERROR = "Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s"
local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))"

local Janitor = {
	IGNORE_MEMORY_DEBUG = true,
	ClassName = "Janitor";
	__index = {
		CurrentlyCleaning = true;
		[IndicesReference] = nil;
	};
}

local TypeDefaults = {
	["function"] = true;
	["Promise"] = "cancel";
	RBXScriptConnection = "Disconnect";
}

function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false;
		[IndicesReference] = nil;
	}, Janitor)
end

function Janitor.Is(Object)
	return type(Object) == "table" and getmetatable(Object) == Janitor
end

Janitor.is = Janitor.Is

function Janitor.__index:Add(Object, MethodName, Index)
	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]
		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end

	local objectType = typeof(Object)
	if objectType == "table" and string.match(tostring(Object), "Promise") then
		objectType = "Promise"
		--local status = Object:getStatus()
		--print("status =", status, status == "Rejected")
	end
	MethodName = MethodName or TypeDefaults[objectType] or "Destroy"
	if type(Object) ~= "function" and not Object[MethodName] then
		warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil :: any, 2)))
	end

	local OriginalTraceback = debug.traceback("")
	self[Object] = {MethodName, OriginalTraceback}
	return Object
end
Janitor.__index.Give = Janitor.__index.Add

-- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.

function Janitor.__index:AddPromise(PromiseObject)
	local Promise = getPromiseReference()
	if Promise then
		if not Promise.is(PromiseObject) then
			error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
		end
		if PromiseObject:getStatus() == Promise.Status.Started then
			local Id = newproxy(false)
			local NewPromise = self:Add(Promise.new(function(Resolve, _, OnCancel)
				if OnCancel(function()
						PromiseObject:cancel()
					end) then
					return
				end

				Resolve(PromiseObject)
			end), "cancel", Id)

			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise
		else
			return PromiseObject
		end
	else
		return PromiseObject
	end
end
Janitor.__index.GivePromise = Janitor.__index.AddPromise

-- This will assume whether or not the object is a Promise or a regular object.
function Janitor.__index:AddObject(Object)
	local Id = newproxy(false)
	local Promise = getPromiseReference()
	if Promise and Promise.is(Object) then
		if Object:getStatus() == Promise.Status.Started then
			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise, Id
		else
			return Object
		end
	else
		return self:Add(Object, false, Id), Id
	end
end

Janitor.__index.GiveObject = Janitor.__index.AddObject

function Janitor.__index:Remove(Index)
	local This = self[IndicesReference]
	if This then
		local Object = This[Index]

		if Object then
			local ObjectDetail = self[Object]
			local MethodName = ObjectDetail and ObjectDetail[1]

			if MethodName then
				if MethodName == true then
					Object()
				else
					local ObjectMethod = Object[MethodName]
					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end

function Janitor.__index:Get(Index)
	local This = self[IndicesReference]
	if This then
		return This[Index]
	end
	return nil
end

function Janitor.__index:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil
		for Object, ObjectDetail in next, self do
			if Object == IndicesReference then
				continue
			end

			-- Weird decision to rawset directly to the janitor in Agent. This should protect against it though.
			local TypeOf = type(Object)
			if TypeOf == "string" or TypeOf == "number" then
				self[Object] = nil
				continue
			end

			local MethodName = ObjectDetail[1]
			local OriginalTraceback = ObjectDetail[2]
			local function warnUser(warning)
				local cleanupLine = debug.traceback("", 3)--string.gsub(debug.traceback("", 3), "%c", "")
				local addedLine = OriginalTraceback
				warn("-------- Janitor Error --------".."\n"..tostring(warning).."\n"..cleanupLine..""..addedLine)
			end
			if MethodName == true then
				local success, warning = pcall(Object)
				if not success then
					warnUser(warning)
				end
			else
				local ObjectMethod = Object[MethodName]
				if ObjectMethod then
					local success, warning = pcall(ObjectMethod, Object)
					local isAnInstanceBeingDestroyed = typeof(Object) == "Instance" and ObjectMethod == "Destroy"
					if not success and not isAnInstanceBeingDestroyed then
						warnUser(warning)
					end
				end
			end

			self[Object] = nil
		end

		local This = self[IndicesReference]
		if This then
			for Index in next, This do
				This[Index] = nil
			end

			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end

Janitor.__index.Clean = Janitor.__index.Cleanup

function Janitor.__index:Destroy()
	self:Cleanup()
	--table.clear(self)
	--setmetatable(self, nil)
end

Janitor.__call = Janitor.__index.Cleanup

local Disconnect = {Connected = true}
Disconnect.__index = Disconnect
function Disconnect:Disconnect()
	if self.Connected then
		self.Connected = false
		self.Connection:Disconnect()
	end
end

function Disconnect:__tostring()
	return "Disconnect<" .. tostring(self.Connected) .. ">"
end

function Janitor.__index:LinkToInstance(Object, AllowMultiple)
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, Disconnect)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				coroutine.wrap(function()
					Heartbeat:Wait()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							Heartbeat:Wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)()
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil
	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end

function Janitor.__index:LinkToInstances(...)
	local ManualCleanup = Janitor.new()
	for _, Object in ipairs({...}) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end

for FunctionName, Function in next, Janitor.__index do
	local NewFunctionName = string.sub(string.lower(FunctionName), 1, 1) .. string.sub(FunctionName, 2)
	Janitor.__index[NewFunctionName] = Function
end

return Janitor]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043c8</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXC28EBECC804445AD9E2284E3D14D22E1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc0821801300009372</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_BillboardGuiClass</string>
							<string name="ScriptGuid">{DD60B878-C68D-4136-AC8C-C48456CC9C17}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 1/15/24
--[[@description:
	Wrapper class for Billboard GUIs that adds extra features.
	
	Features:
	- Ability to have billboard GUIs appear on the screen edges when looking away from them.
		- Works only for offset-size billboards since trying to put scale into the mix will cause problems.
		- In practice, this is a screen GUI placed on the screen.
		- Changed event is supported. No support for ChildAdded/Removed
	- Extra events, such as when the GUI is displayed or hidden.
	- Add an optional yieldable callback that executes right before the GUI is disabled to perform tweens.
	
	Due to how this module works, changing the Enabled property of the billboard will no longer work.
	You must set an attribute 'IsEnabled' to toggle whether or not the billboard should render.
]]
-----------------------------
-- SERVICES --
-----------------------------
--local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-----------------------------
-- DEPENDENCIES --
-----------------------------
-- path: lib/lib/ClientModuleUtils/_BillboardGuiClass
-- ../ModuleUtils -> script.Parent.Parent.ModuleUtils
-- ../FunctionUtils -> script.Parent.Parent.FunctionUtils
local ModuleUtils = require(script.Parent.Parent.ModuleUtils)
local FunctionUtils = require(script.Parent.Parent.FunctionUtils)
local Trove = ModuleUtils.Trove
local Signal = ModuleUtils.Signal
local t = FunctionUtils.t

-----------------------------
-- TYPES --
-----------------------------
-- This is for all of the properties of an object made from this class for type annotation purposes.
type HidingCallback = (obj: WrappedBillboardGui) -> ()

type self = {
	Signals: {
		GuiShown: ModuleUtils.Signal<() -> (), ()>, -- fired when the gui is shown
		GuiHidden: ModuleUtils.Signal<() -> (), ()>, -- fired after the gui is hidden
		RenderModeChanged: ModuleUtils.Signal<() -> (), ()>,
		StayOnScreenChanged: ModuleUtils.Signal<() -> (), ()>,
		RotationLimitChanged: ModuleUtils.Signal<() -> (), ()>,
	},
	_trove: ModuleUtils.TroveType,
	_visibleTrove: ModuleUtils.TroveType, -- cleaned when gui is shown or hidden
	_onHidingCallback: HidingCallback?,
	_gui: BillboardGui,

	_adorneePos: Vector3,
	_billboardRenderPos: Vector3,
	_renderMode: RenderMode,
	_maxDistance: number,
	_inRange: boolean,
	_stayOnScreen: boolean,
	_stayOnScreenFrame: Frame?,
}

type RenderMode = "DEFAULT" | "BILLBOARD"
type CompatibleAdornees = BasePart | Model | Attachment

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}
local MT = {}
MT.__index = MT
export type WrappedBillboardGui = typeof(setmetatable({} :: self, MT))

local objectCache: { WrappedBillboardGui } = {}
local stayOnScreenGui = script.StayOnScreenBillboards
local logger = ModuleUtils.Logger.new(script.Name)
local renderStepConnection: RBXScriptConnection?

-- CONSTANTS --
local CAMERA = workspace.CurrentCamera
local PLAYER = Players.LocalPlayer

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-- Copies everything from one instance to the other instance.
-- This also listens to the Changed signal for all instances in <code>from</code> and updates the corresponding instance in <code>to</code>
-- Returns a trove for cleaning up connections.
local function deepCopyAndListen(from: Instance, to: Instance, _trove: ModuleUtils.TroveType?): ModuleUtils.TroveType
	if not _trove then
		_trove = ModuleUtils.Trove.new()
	end
	assert(_trove, "expected trove")
	for _, child: Instance in pairs(from:GetChildren()) do
		local newChild: Instance = child:Clone()
		newChild.Parent = to

		local connections = deepCopyAndListen(child, newChild, _trove)

		_trove:Connect(child.Changed, function(property)
			pcall(function()
				(newChild :: any)[property] = (child :: any)[property]
			end)
		end)
	end

	return _trove :: any
end

local function getAdornee(gui: BillboardGui): CompatibleAdornees?
	local adornee = gui.Adornee or gui.Parent
	if
		t.instanceIsA("BasePart")(adornee)
		or t.instanceIsA("Model")(adornee)
		or t.instanceIsA("Attachment")(adornee)
	then
		return adornee :: any
	end
	return
end

local function getAdorneeCFrame(adornee: CompatibleAdornees): CFrame
	if adornee:IsA("BasePart") then
		return adornee.CFrame
	elseif adornee:IsA("Model") then
		-- Bounding box center is used by billboard GUIs
		local cf, _ = adornee:GetBoundingBox()
		return cf
	elseif adornee:IsA("Attachment") then
		return adornee.WorldCFrame
	end
	error("Invalid adornee")
end

local function onRenderStep()
	debug.profilebegin("WRAPPED_BILLBOARD_UPDATE")
	if #objectCache == 0 and renderStepConnection then
		renderStepConnection:Disconnect()
		renderStepConnection = nil
		return
	end
	local cameraPosition = CAMERA.Focus.Position -- this is the RENDERING position
	for _, obj in ipairs(objectCache) do
		obj:_Step(cameraPosition)
	end
	debug.profileend()
end

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

-- Creates a new WrappedBillboardGui.
function Module.new(gui: BillboardGui): WrappedBillboardGui
	assert(typeof(gui) == "Instance" and gui:IsA("BillboardGui"), "Expected BillboardGui!")
	local myTrove = Trove.new()
	local adornee = getAdornee(gui)
	local self: self = {
		_trove = myTrove,
		_visibleTrove = myTrove:Construct(Trove),
		Signals = {
			GuiShown = myTrove:Construct(Signal),
			GuiHidden = myTrove:Construct(Signal),
			RenderModeChanged = myTrove:Construct(Signal),
			StayOnScreenChanged = myTrove:Construct(Signal),
			RotationLimitChanged = myTrove:Construct(Signal),
		},

		_gui = gui,
		_adorneePos = if adornee then getAdorneeCFrame(adornee).Position else Vector3.zero,
		_billboardRenderPos = FunctionUtils.Math.getBillboardWorldPosition(gui) or Vector3.zero,
		_renderMode = "DEFAULT",
		_maxDistance = gui.MaxDistance,
		_inRange = false,
		_stayOnScreen = false,
	}
	setmetatable(self, MT)

	gui.MaxDistance = 0
	gui:SetAttribute("IsEnabled", gui.Enabled)
	gui.Enabled = false

	myTrove:Connect(gui:GetPropertyChangedSignal("MaxDistance"), function()
		if gui.MaxDistance == 0 then
			return
		end
		self._maxDistance = gui.MaxDistance
		gui.MaxDistance = 0
	end)

	if not renderStepConnection then
		renderStepConnection = RunService.RenderStepped:Connect(onRenderStep)
	end

	self._trove:Add(gui.Destroying:Once(function()
		self:Destroy()
	end))

	table.insert(objectCache, self)
	return self
end

function Module:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")

	return getmetatable(object).__index == MT
end

-- Allows you to set a function that will be called before the GUI is hidden. This callback may yield and the GUI will not hide
-- until the callback stops yielding. This is useful if you want to tween out the billboard GUI before it stops rendering.
-- If the GUI comes back into view/rendering before the callback finishes, the yielding thread will be cancelled.
-- Only one callback may be set!
function MT.SetOnHiding(self: WrappedBillboardGui, callback: HidingCallback): WrappedBillboardGui
	self._onHidingCallback = callback
	return self
end

-- Defines the point where the <code>MaxDistance</code> is calculated from.
-- 'DEFAULT' mode is the position of the adornee.
-- 'BILLBOARD' mode is the position the billboard is being rendered in the world.
function MT.SetRenderMode(self: WrappedBillboardGui, mode: RenderMode): WrappedBillboardGui
	local old = self._renderMode
	self._renderMode = mode
	if old ~= self._renderMode then
		self.Signals.RenderModeChanged:Fire()
	end
	return self
end

-- Determines if the billboard GUI should clamp along the edges of the screen when <code>:GetBillboardPosition()</code> goes off-screen.
-- Only works for billboard GUI's with Offset size.
function MT.SetStayOnScreen(self: WrappedBillboardGui, stayOnScreen: boolean): WrappedBillboardGui
	local size = self:GetBillboard().Size
	if size.X.Offset == 0 and size.Y.Offset == 0 then
		warn("Unable to :SetStayOnScreen() on incompatible billboard")
		return self
	end
	local old = self._stayOnScreen
	self._stayOnScreen = stayOnScreen
	if old ~= self._stayOnScreen then
		self.Signals.StayOnScreenChanged:Fire()
	end
	return self
end

function MT.StayOnScreen(self: WrappedBillboardGui): boolean
	return self._stayOnScreen
end

function MT.GetRenderMode(self: WrappedBillboardGui): RenderMode
	return self._renderMode
end

function MT.GetBillboard(self: WrappedBillboardGui): BillboardGui
	return self._gui
end

-- Returns the world position of where the billboard is being rendered.
function MT.GetBillboardPosition(self: WrappedBillboardGui): Vector3
	return self._billboardRenderPos
end

-- Return the world position of the adornee used for calculating the final position of the billboard.
function MT.GetAdorneePosition(self: WrappedBillboardGui): Vector3
	return self._adorneePos
end

function MT.GetAdornee(self: WrappedBillboardGui): CompatibleAdornees?
	local gui = self:GetBillboard()
	return getAdornee(gui)
end

-- Is this billboard within range of the player's camera to be rendered?
function MT.InRange(self: WrappedBillboardGui)
	return self._inRange
end

function MT._Step(self: WrappedBillboardGui, cameraPosition: Vector3)
	local billboard = self:GetBillboard()
	local adornee = self:GetAdornee()
	if not adornee then
		return
	end
	if not billboard:GetAttribute("IsEnabled") then
		return
	end
	self._adorneePos = getAdorneeCFrame(adornee).Position
	self._billboardRenderPos = FunctionUtils.Math.getBillboardWorldPosition(billboard) :: Vector3

	local checkPosition = if self:GetRenderMode() == "DEFAULT"
		then self:GetAdorneePosition()
		else self:GetBillboardPosition()
	local maxDistance = if self._maxDistance <= 0 then math.huge else self._maxDistance
	local magnitude = (cameraPosition - checkPosition).Magnitude

	if self:InRange() and magnitude > maxDistance then
		self._visibleTrove:Clean()
		self._visibleTrove:Add(task.spawn(function()
			self._inRange = false
			if self._onHidingCallback then
				self._onHidingCallback(self)
			end
			billboard.Enabled = false
			self.Signals.GuiHidden:Fire()
		end))
	elseif not self:InRange() and magnitude <= maxDistance then
		self._visibleTrove:Clean()
		self._inRange = true
		billboard.Enabled = true
		self.Signals.GuiShown:Fire()
	end

	local stayFrame = self:_GetStayOnScreenFrame()
	if self:StayOnScreen() and self:InRange() then
		stayOnScreenGui.Parent = PLAYER.PlayerGui

		local framePos, wasClamped = FunctionUtils.Camera.toClampedScreenSpace(
			self:GetBillboardPosition(),
			Vector2.new(stayFrame.Size.X.Offset / 2, stayFrame.Size.Y.Offset / 2)
		)

		if wasClamped then
			stayFrame.Position = UDim2.fromOffset(framePos.X, framePos.Y)
			-- funky bug (roblox moment): --
			-- https://devforum.roblox.com/t/frames-are-rendered-at-previous-position-when-visibility-is-enabled/2930768
			local _ = stayFrame.AbsolutePosition
			-- --
			stayFrame.Visible = true
			billboard.Enabled = false
		else
			billboard.Enabled = true
			stayFrame.Visible = false
		end
	elseif stayFrame.Visible then
		if self:InRange() then
			billboard.Enabled = true
		end
		stayFrame.Visible = false
	end

	-- TODO: Migrate to a potential SurfaceGui wrapper class --
	--[[local guiPart, surfaceGui = self:_GetRotLimitGui()
	if self:IsRotationLimited() and self:InRange() then
		billboard.Enabled = false
		surfaceGui.Enabled = true
		guiPart.CFrame = CFrame.new(self:GetBillboardPosition()) * FunctionUtils.CFrame.getLookRotation("Y", self:GetBillboardPosition(), CAMERA.CFrame.Position)
	elseif surfaceGui.Enabled then
		if self:InRange() then
			billboard.Enabled = true
		end
		surfaceGui.Enabled = false
	end]]
end

function MT._GetStayOnScreenFrame(self: WrappedBillboardGui): Frame
	if not self._stayOnScreenFrame then
		local frame = Instance.new("Frame")
		frame.Size = self:GetBillboard().Size
		frame.AnchorPoint = Vector2.new(0.5, 0.5)
		frame.BackgroundTransparency = 1
		frame.Visible = false
		local cleanup = deepCopyAndListen(self:GetBillboard(), frame)
		frame.Parent = stayOnScreenGui
		cleanup:Connect(self.Signals.StayOnScreenChanged, function()
			if not self:StayOnScreen() then
				cleanup:Clean()
				frame:Destroy()
				self._stayOnScreenFrame = nil
			end
		end)
		self._stayOnScreenFrame = frame
	end
	return self._stayOnScreenFrame :: Frame
end

function MT.Destroy(self: WrappedBillboardGui)
	self._trove:Clean()
	table.remove(objectCache, table.find(objectCache, self))
	setmetatable(self :: any, nil)
	table.clear(self :: any)
end

-----------------------------
-- MAIN --
-----------------------------
return Module
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043c9</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4096B315FB654B0E9546E738A62C3C80">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc082180130000939a</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_CinematicClass</string>
							<string name="ScriptGuid">{380CBA47-6DD5-42B5-9734-3D70F64E2B14}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 4/17/25
--[[@description:
	For creating cool Bezier curve cinematics for the camera.
	You can control the duration, easing style, and easing direction for the cinematic!
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local ModuleUtils = require("../ModuleUtils")
local FunctionUtils = require("../FunctionUtils")
local t = FunctionUtils.t

-----------------------------
-- TYPES --
-----------------------------
-- For all of the properties/fields of an object made from this class.
type fields = {
	_trove: ModuleUtils.TroveType,
	_userData: { [any]: any },
	_cinematic: Model,
	_startArgs: StartArgsStrict,
	_parts: { BasePart },
	_active: boolean,
	_t: number,

	Signals: {
		Started: ModuleUtils.GenericSignal,
		Ended: ModuleUtils.SignalType<(completed: boolean) -> (), (boolean)>
	},

	_rotQuats: { ModuleUtils.Quaternion },
	_workQuats: { ModuleUtils.Quaternion },

	_posControls: { Vector3 },
	_posWork: { Vector3 },

	_posSamples: { Vector3 },
	_quatSamples: { ModuleUtils.Quaternion },
	_sampleCount: number,

	_renderBindings: { string },
}

type EasingFunc = (number) -> (number)

export type StartArgs = {
	EasingStyle: EasingFunc?,
	EasingDirection: ( (number, EasingFunc) -> (number) )?,

	Duration: number?
}

export type CinematicStartArgs = StartArgs

-- this is goofy
type StartArgsStrict = {
	EasingStyle: EasingFunc,
	EasingDirection: ( (number, EasingFunc) -> (number) ),

	Duration: number
}

-----------------------------
-- VARIABLES --
-----------------------------
local Module = {}
local MT = {}
MT.__index = MT
export type Cinematic = typeof(setmetatable({} :: fields, MT))

-- CONSTANTS --
local DEFAULT_DURATION = 5
local SAMPLE_RATE = 60 -- 60fps

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

local function getDefaultStartArgs(): StartArgsStrict
	return {
		EasingStyle = FunctionUtils.Math.EasingStyle.Linear,
		EasingDirection = FunctionUtils.Math.EasingDirection.In,
		Duration = DEFAULT_DURATION
	}
end

@native
local function deCasteljauQuat(orig: { ModuleUtils.Quaternion }, work: { ModuleUtils.Quaternion }, t: number): ModuleUtils.Quaternion
	local n = #orig
	table.move(orig, 1, n, 1, work)
	for level = 1, n - 1 do
		for i = 1, n - level do
			work[i] = work[i]:Slerp(work[i + 1], t)
		end
	end
	return work[1]
end

@native
local function deCasteljauPos(orig: { Vector3 }, work: { Vector3 }, t: number): Vector3
	local n = #orig
	table.move(orig, 1, n, 1, work)
	for level = 1, n - 1 do
		for i = 1, n - level do
			work[i] = work[i]:Lerp(work[i + 1], t)
		end
	end
	return work[1]
end

-----------------------------
-- CLASS FUNCTIONS --
-----------------------------

--[[
	Creates a new cinematic object.
	<strong>cinematic</strong>: should be an instance containing parts named with integer values starting at '1'.
]]
function Module.new(cinematic: any): Cinematic
	assert(cinematic:FindFirstChild("1"), "model missing starting part '1'")
	local parts = {}
	for _, part in ipairs(cinematic:GetChildren()) do
		assert(part:IsA("BasePart") and tonumber(part.Name), "invalid part/name in cinematic model")
		table.insert(parts, part)
	end
	assert(#parts >= 2, "expected at least 2 parts")
	table.sort(parts, function(a, b)
		return tonumber(a.Name) < tonumber(b.Name)
	end)

	local self = setmetatable({} :: fields, MT) :: Cinematic
	self._trove = ModuleUtils.Trove.new()
	self._userData = {}
	self._renderBindings = {}

	self.Signals = {
		Started = self._trove:Construct(ModuleUtils.Signal),
		Ended = self._trove:Construct(ModuleUtils.Signal),
	}

	self._cinematic = cinematic
	self._parts = parts
	self._active = false
	self._t = 0
	self._startArgs = getDefaultStartArgs()

	-- buffers for rotation
	self._rotQuats = {} -- control points
	self._workQuats= {}
	-- buffers for position
	self._posControls = {}
	self._posWork = {}

	self._posSamples = {}
	self._quatSamples = {}
	self._sampleCount = 0

	return self
end

function Module:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")
	local mt = getmetatable(object)
	return mt ~= nil and mt.__index == MT
end

-----------------------------
-- METHODS --
-----------------------------

--[[
	Starts the cinematic. For the camera to start moving, you must <code>:BindToRenderStep()</code>.
	<strong>Duration</strong>: Time in seconds over which to interpolate along the curve.
	<strong>EasingStyle</strong>: Should be an easing style function that takes in a number and returns a number.
	<strong>EasingDirection</strong>: Should be an easing direction function that takes in a number & easing style function and returns a number.
]]
function MT.Start(self: Cinematic, startArgs: CinematicStartArgs?)
	self._startArgs = if startArgs then FunctionUtils.Table.reconcile(startArgs, self._startArgs) else self._startArgs
	assert(self._startArgs.Duration > 0, "Duration must be greater than 0")
	self.Signals.Started:FireDefer()

	-- Initialize rotation quaternions & positions
	for i, part in ipairs(self._parts) do
		local q = ModuleUtils.Quaternion.fromOrientation(part.CFrame:ToOrientation())
		self._rotQuats[i] = q
		self._workQuats[i] = q
		self._posControls[i] = part.Position
		self._posWork[i] = part.Position
	end

	local duration   = self._startArgs.Duration
	local size = math.ceil(duration * SAMPLE_RATE) + 1

	self._sampleCount = size
	self._posSamples = {}  -- size S
	self._quatSamples = {}  -- size S

	for i = 1, size do
		local t = (i - 1) / (size - 1)  -- from 0 to 1
		-- direct De Casteljau on positions:
		local p = deCasteljauPos(self._posControls, self._posWork, t)
		-- quaternion Bezier:
		local q = deCasteljauQuat(self._rotQuats, self._workQuats, t)
		self._posSamples[i]  = p
		self._quatSamples[i] = q
	end

	self._active = true
	self._t = 0
end

--[[
	Calculates the current cinematic CFrame.
	This should be called every frame.
	Returns CFrame and done flag.
]]
function MT.Update(self: Cinematic, dt: number): (CFrame, boolean)
	if not self._active then
		return CFrame.identity, true
	end

	local args = self._startArgs
	self._t = math.clamp(self._t + dt/args.Duration, 0, 1)
	local tRaw = self._t
	local tEased = args.EasingDirection(tRaw, args.EasingStyle)

	-- Map eased time into pre-sampled array
	local rawIndex = tEased * (self._sampleCount - 1) + 1
	rawIndex = math.clamp(rawIndex, 1, self._sampleCount)
	local i0 = math.floor(rawIndex)
	local i1 = math.min(i0 + 1, self._sampleCount)
	local frac = rawIndex - i0

	local p0 = self._posSamples[i0]
	local p1 = self._posSamples[i1]
	local pos = p0:Lerp(p1, frac)

	local q0 = self._quatSamples[i0]
	local q1 = self._quatSamples[i1]
	local quat = q0:Slerp(q1, frac)

	local cf = quat:ToCFrame(pos)

	local done = (tRaw >= 1)
	if done then
		self:_Stop(true)
	end

	return cf, done
end

--[[
	Binds the cinematic to RenderStep.
	Callback receives (position, rotation, done)
]]
function MT.BindToRenderStep(self: Cinematic, name: string, priority: number, callback: (cf: CFrame, done: boolean) -> ())
	RunService:BindToRenderStep(name, priority, function(dt)
		callback(self:Update(dt))
	end)
	table.insert(self._renderBindings, name)
end

--[[
	Ends the cinematic and unbinds from RenderStep.
]]
function MT.Stop(self: Cinematic)
	self:_Stop(false)
end

function MT._Stop(self: Cinematic, completed: boolean)
	if not self._active then
		return
	end
	self.Signals.Ended:FireDefer(completed)
	self._active = false
	for _, name in ipairs(self._renderBindings) do
		RunService:UnbindFromRenderStep(name)
	end
	table.clear(self._renderBindings)
end

-----------------------------
-- SETTERS --
-----------------------------

-----------------------------
-- GETTERS --
-----------------------------

function MT.GetTrove(self: Cinematic): ModuleUtils.TroveType
	return self._trove
end

function MT.GetUserData(self: Cinematic): { [any]: any }
	return self._userData
end

--[[
	Returns the cinematic model.
]]
function MT.GetModel(self: Cinematic): any
	return self._cinematic
end

function MT.IsActive(self: Cinematic): boolean
	return self._active
end

-----------------------------
-- CLEANUP --
-----------------------------

function MT.Destroy(self: Cinematic)
	self:Stop()
	self._trove:Clean()
end

-----------------------------
-- MAIN --
-----------------------------
return Module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043cb</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC4FD2D3FD308434BA142762F1BFC80C1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc082180130000939c</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_GuiStrokeClass</string>
							<string name="ScriptGuid">{93543745-0127-4579-B011-503C3223DA39}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--@author: crusherfire
--@date: 11/21/24
--[[@description:
	Adds extra features to the UIStroke instance.
]]
-----------------------------
-- SERVICES --
-----------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-----------------------------
-- DEPENDENCIES --
-----------------------------
local ModuleUtils = require("../ModuleUtils")

-----------------------------
-- TYPES --
-----------------------------
-- For all of the properties/fields of an object made from this class.
type fields = {
	_trove: ModuleUtils.TroveType,
	_scaleTrove: ModuleUtils.TroveType,
	_stroke: UIStroke,
	_usingScale: boolean,
}

-----------------------------
-- VARIABLES --
-----------------------------
local GuiStrokeClass = {}
local MT = {}
MT.__index = MT
export type WrappedUiStroke = typeof(setmetatable({} :: fields, MT))

-- CONSTANTS --

-----------------------------
-- PRIVATE FUNCTIONS --
-----------------------------

-----------------------------
-- PUBLIC FUNCTIONS --
-----------------------------

function GuiStrokeClass.new(stroke: UIStroke): WrappedUiStroke
	local self = setmetatable({} :: fields, MT)

	self._trove = ModuleUtils.Trove.new()
	self._scaleTrove = self._trove:Construct(ModuleUtils.Trove)
	self._stroke = stroke
	self._usingScale = false
	
	self._trove:Add(stroke.Destroying:Once(function()
		self:Destroy()
	end))

	return self
end

function GuiStrokeClass:BelongsToClass(object: any)
	assert(typeof(object) == "table", "Expected table for object!")

	return getmetatable(object).__index == MT
end

--[[
	Converts the UIStroke to scale with its parent element.
	If stroke on text, the scale will be based on the text size.
	If stroke on any other Gui object, the scale will be based on an average of the X & Y, or on one axis if <strong>primaryAxis</strong> is provided.
	<strong>sizeConstraint</strong>: Optional size constraint to limit the stroke size in pixels.
]]
function MT.UseScale(self: WrappedUiStroke, scale: number, primaryAxis: ("X" | "Y")?, sizeConstraint: NumberRange?): WrappedUiStroke
	self._scaleTrove:Clean()
	local obj = self._stroke.Parent :: GuiObject
	if not obj then
		warn("UIStroke does not have a parent.")
		return self
	end
	self._usingScale = true
	
	local function getScale()
		local valueForScale
		if
			self:GetStroke().ApplyStrokeMode == Enum.ApplyStrokeMode.Contextual
			and (obj:IsA("TextBox") or obj:IsA("TextLabel") or obj:IsA("TextButton"))
		then
			valueForScale = if not obj.TextFits then (obj.AbsoluteSize.X + obj.AbsoluteSize.Y) / 2 else (obj.TextBounds.Y + obj.TextBounds.X) / 2
		elseif primaryAxis == "X" then
			valueForScale = obj.AbsoluteSize.X
		elseif primaryAxis == "Y" then
			valueForScale = obj.AbsoluteSize.Y
		else
			valueForScale = (obj.AbsoluteSize.X + obj.AbsoluteSize.Y) / 2
		end
		return valueForScale * scale
	end
	
	local function evaluateStrokeThickness()
		local thickness = getScale()
		self:GetStroke().Thickness = if sizeConstraint then math.clamp(thickness, sizeConstraint.Min, sizeConstraint.Max) else thickness
	end

	self._scaleTrove:Connect(obj:GetPropertyChangedSignal("AbsoluteSize"), evaluateStrokeThickness)
	self._scaleTrove:Connect(self._stroke:GetPropertyChangedSignal("ApplyStrokeMode"), evaluateStrokeThickness)
	self._scaleTrove:Connect(self._stroke:GetPropertyChangedSignal("Parent"), function()
		if not self._stroke.Parent then
			return
		end
		self:UseScale(scale, primaryAxis, sizeConstraint)
	end)
	evaluateStrokeThickness()
	return self
end

function MT.UseOffset(self: WrappedUiStroke, offset: number): WrappedUiStroke
	self._scaleTrove:Clean()
	self:GetStroke().Thickness = offset
	self._usingScale = false
	return self
end

function MT.GetStroke(self: WrappedUiStroke): UIStroke
	return self._stroke
end

function MT.UsingScale(self: WrappedUiStroke): boolean
	return self._usingScale
end

function MT.Destroy(self: WrappedUiStroke)
	self._trove:Clean()
end

-----------------------------
-- MAIN --
-----------------------------
return GuiStrokeClass]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043cc</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB0BD81C2CA1C41A7957D0873A4A26195">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">09edd42ec210d5cc08218013000093d2</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Input</string>
							<string name="ScriptGuid">{E7AED876-E0F7-4E1F-AC8E-DE477BA0247E}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
local _Gamepad = require(script._Gamepad)
local _Mouse = require(script._Mouse)
local _Keyboard = require(script._Keyboard)
local _PreferredInput = require(script._PreferredInput)
local _Touch = require(script._Touch)

export type GamepadType = _Gamepad.GamepadType
export type MouseType = _Mouse.MouseType
export type KeyboardType = _Keyboard.KeyboardType
export type TouchType = _Touch.TouchType

return {
	Gamepad = _Gamepad,
	Mouse = _Mouse,
	Keyboard = _Keyboard,
	PreferredInput = _PreferredInput,
	Touch = _Touch
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043cd</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXAAFD296BCB014FC5B14AD64346A18711">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc08218013000093d3</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_Gamepad</string>
								<string name="ScriptGuid">{02EA4813-B246-4E16-9BB2-7803175767A8}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- Gamepad
-- Stephen Leitnick
-- December 23, 2021
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ModuleUtils = require("../../ModuleUtils")

local Trove = ModuleUtils.Trove
local Signal = ModuleUtils.Signal

local UserInputService = game:GetService("UserInputService")
local HapticService = game:GetService("HapticService")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")

local function ApplyDeadzone(value: number, threshold: number): number
	if math.abs(value) < threshold then
		return 0
	end
	return ((math.abs(value) - threshold) / (1 - threshold)) * math.sign(value)
end

local function GetActiveGamepad(): Enum.UserInputType?
	local activeGamepad = nil :: Enum.UserInputType?
	local navGamepads = UserInputService:GetNavigationGamepads()
	if #navGamepads > 1 then
		for _, navGamepad in ipairs(navGamepads) do
			if activeGamepad == nil or navGamepad.Value < activeGamepad.Value then
				activeGamepad = navGamepad
			end
		end
	else
		local connectedGamepads = UserInputService:GetConnectedGamepads()
		for _, connectedGamepad in ipairs(connectedGamepads) do
			if activeGamepad == nil or connectedGamepad.Value < activeGamepad.Value then
				activeGamepad = connectedGamepad
			end
		end
	end
	if activeGamepad and not UserInputService:GetGamepadConnected(activeGamepad) then
		activeGamepad = nil
	end
	return activeGamepad
end

local function HeartbeatDelay(duration: number, callback: () -> nil): RBXScriptConnection
	local start = time()
	local connection
	connection = RunService.Heartbeat:Connect(function()
		local elapsed = time() - start
		if elapsed >= duration then
			connection:Disconnect()
			callback()
		end
	end)
	return connection
end

--[=[
	@class Gamepad
	@client

	The Gamepad class is part of the Input package.

	```lua
	local Gamepad = require(packages.Input).Gamepad

	local gamepad = Gamepad.new()
	```
]=]
local Gamepad = {}
Gamepad.__index = Gamepad
type self = {
	_trove: ModuleUtils.TroveType,
	_setMotorIds: { [Enum.VibrationMotor]: number }?,
	_gamepad: Enum.UserInputType?,
	_gamepadTrove: ModuleUtils.TroveType,
	ButtonDown: ModuleUtils.SignalType<(keycode: Enum.KeyCode, processed: boolean) -> (), (Enum.KeyCode, boolean)>,
	ButtonUp: ModuleUtils.SignalType<(keycode: Enum.KeyCode, processed: boolean) -> (), (Enum.KeyCode, boolean)>,
	Connected: ModuleUtils.SignalType<() -> ()>,
	Disconnected: ModuleUtils.SignalType<() -> ()>,
	GamepadChanged: ModuleUtils.SignalType<(gamepad: Enum.UserInputType?) -> (), (Enum.UserInputType?)>,
	DefaultDeadzone: number,
	SupportsVibration: boolean,
	State: { [Enum.KeyCode]: InputObject }
}
export type GamepadType = typeof(setmetatable({} :: self, Gamepad))

--[=[
	@within Gamepad
	@prop ButtonDown Signal<(button: Enum.KeyCode, processed: boolean)>
	@readonly
	The ButtonDown signal fires when a gamepad button is pressed
	down. The pressed KeyCode is passed to the signal, along with
	whether or not the event was processed.

	```lua
	gamepad.ButtonDown:Connect(function(button: Enum.KeyCode, processed: boolean)
		print("Button down", button, processed)
	end)
	```
]=]

--[=[
	@within Gamepad
	@prop ButtonUp Signal<(button: Enum.KeyCode, processed: boolean)>
	@readonly
	The ButtonUp signal fires when a gamepad button is released.
	The released KeyCode is passed to the signal, along with
	whether or not the event was processed.

	```lua
	gamepad.ButtonUp:Connect(function(button: Enum.KeyCode, processed: boolean)
		print("Button up", button, processed)
	end)
	```
]=]

--[=[
	@within Gamepad
	@prop Connected Signal
	@readonly
	Fires when the gamepad is connected. This will _not_ fire if the
	active gamepad is switched. To detect switching to different
	active gamepads, use the `GamepadChanged` signal.

	There is also a `gamepad:IsConnected()` method.

	```lua
	gamepad.Connected:Connect(function()
		print("Connected")
	end)
	```
]=]

--[=[
	@within Gamepad
	@prop Disconnected Signal
	@readonly
	Fires when the gamepad is disconnected. This will _not_ fire if the
	active gamepad is switched. To detect switching to different
	active gamepads, use the `GamepadChanged` signal.

	There is also a `gamepad:IsConnected()` method.

	```lua
	gamepad.Disconnected:Connect(function()
		print("Disconnected")
	end)
	```
]=]

--[=[
	@within Gamepad
	@prop GamepadChanged Signal<gamepad: Enum.UserInputType>
	@readonly
	Fires when the active gamepad switches. Internally, the gamepad
	object will always wrap around the active gamepad, so nothing
	needs to be changed.

	```lua
	gamepad.GamepadChanged:Connect(function(newGamepad: Enum.UserInputType)
		print("Active gamepad changed to:", newGamepad)
	end)
	```
]=]

--[=[
	@within Gamepad
	@prop DefaultDeadzone number

	:::info Default
	Defaults to `0.05`
	:::

	The default deadzone used for trigger and thumbstick
	analog readings. It is usually best to set this to
	a small value, or allow players to set this option
	themselves in an in-game settings menu.

	The `GetThumbstick` and `GetTrigger` methods also allow
	a deadzone value to be passed in, which overrides this
	value.
]=]

--[=[
	@within Gamepad
	@prop SupportsVibration boolean
	@readonly
	Flag to indicate if the currently-active gamepad supports
	haptic motor vibration.

	It is safe to use the motor methods on the gamepad without
	checking this value, but nothing will happen if the motors
	are not supported.
]=]

--[=[
	@within Gamepad
	@prop State GamepadState
	@readonly
	Maps KeyCodes to the matching InputObjects within the gamepad.
	These can be used to directly read the current input state of
	a given part of the gamepad. For most cases, the given methods
	and properties of `Gamepad` should make use of this table quite
	rare, but it is provided for special use-cases that might occur.

	:::note Do Not Cache
	These state objects will change if the active gamepad changes.
	Because a player might switch up gamepads during playtime, it cannot
	be assumed that these state objects will always be the same. Thus
	they should be accessed directly from this `State` table anytime they
	need to be used.
	:::

	```lua
	local leftThumbstick = gamepad.State[Enum.KeyCode.Thumbstick1]
	print(leftThumbstick.Position)
	-- It would be better to use gamepad:GetThumbstick(Enum.KeyCode.Thumbstick1),
	-- but this is just an example of direct state access.
	```
]=]

--[=[
	@within Gamepad
	@type GamepadState {[Enum.KeyCode]: InputObject}
]=]

--[=[
	@param gamepad Enum.UserInputType?
	@return Gamepad
	Constructs a gamepad object.

	If no gamepad UserInputType is provided, this object will always wrap
	around the currently-active gamepad, even if it changes. In most cases
	where input is needed from just the primary gamepad used by the player,
	leaving the `gamepad` argument blank is preferred.

	Only include the `gamepad` argument when it is necessary to hard-lock
	the object to a specific gamepad input type.

	```lua
	-- In most cases, construct the gamepad as such:
	local gamepad = Gamepad.new()

	-- If the exact UserInputType gamepad is needed, pass it as such:
	local gamepad = Gamepad.new(Enum.UserInputType.Gamepad1)
	```
]=]
function Gamepad.new(gamepad: Enum.UserInputType?): GamepadType
	local self = setmetatable({}, Gamepad)
	self._trove = Trove.new()
	self._gamepadTrove = self._trove:Construct(Trove)
	self.ButtonDown = self._trove:Construct(Signal)
	self.ButtonUp = self._trove:Construct(Signal)
	self.Connected = self._trove:Construct(Signal)
	self.Disconnected = self._trove:Construct(Signal)
	self.GamepadChanged = self._trove:Construct(Signal)
	self.DefaultDeadzone = 0.05
	self.SupportsVibration = false
	self.State = {}
	self:_setupGamepad(gamepad)
	self:_setupMotors()
	return self
end

function Gamepad._setupActiveGamepad(self: GamepadType, gamepad: Enum.UserInputType?)
	local lastGamepad = self._gamepad
	if gamepad == lastGamepad then
		return
	end

	self._gamepadTrove:Clean()
	table.clear(self.State)
	self.SupportsVibration = if gamepad then HapticService:IsVibrationSupported(gamepad) else false

	self._gamepad = gamepad

	-- Stop if disconnected:
	if not gamepad then
		self.Disconnected:Fire()
		self.GamepadChanged:Fire(nil)
		return
	end

	for _, inputObject in ipairs(UserInputService:GetGamepadState(gamepad)) do
		self.State[inputObject.KeyCode] = inputObject
	end

	self._gamepadTrove:Add(self, "StopMotors")

	self._gamepadTrove:Connect(UserInputService.InputBegan, function(input, processed)
		if input.UserInputType == gamepad then
			self.ButtonDown:Fire(input.KeyCode, processed)
		end
	end)

	self._gamepadTrove:Connect(UserInputService.InputEnded, function(input, processed)
		if input.UserInputType == gamepad then
			self.ButtonUp:Fire(input.KeyCode, processed)
		end
	end)

	if lastGamepad == nil then
		self.Connected:Fire()
	end
	self.GamepadChanged:Fire(gamepad)
end

function Gamepad._setupGamepad(self: GamepadType, forcedGamepad: Enum.UserInputType?)
	if forcedGamepad then
		-- Forced gamepad:

		self._trove:Connect(UserInputService.GamepadConnected, function(gp)
			if gp == forcedGamepad then
				self:_setupActiveGamepad(forcedGamepad)
			end
		end)

		self._trove:Connect(UserInputService.GamepadDisconnected, function(gp)
			if gp == forcedGamepad then
				self:_setupActiveGamepad(nil)
			end
		end)

		if UserInputService:GetGamepadConnected(forcedGamepad) then
			self:_setupActiveGamepad(forcedGamepad)
		end
	else
		-- Dynamic gamepad:

		local function CheckToSetupActive()
			local active = GetActiveGamepad()
			if active ~= self._gamepad then
				self:_setupActiveGamepad(active)
			end
		end

		self._trove:Connect(UserInputService.GamepadConnected, CheckToSetupActive)
		self._trove:Connect(UserInputService.GamepadDisconnected, CheckToSetupActive)
		self:_setupActiveGamepad(GetActiveGamepad())
	end
end

function Gamepad:_setupMotors()
	self._setMotorIds = {}
	for _, motor in ipairs(Enum.VibrationMotor:GetEnumItems()) do
		self._setMotorIds[motor] = 0
	end
end

--[=[
	@param thumbstick Enum.KeyCode
	@param deadzoneThreshold number?
	@return Vector2
	Gets the position of the given thumbstick. The two thumbstick
	KeyCodes are `Enum.KeyCode.Thumbstick1` and `Enum.KeyCode.Thumbstick2`.

	If `deadzoneThreshold` is not included, the `DefaultDeadzone` value is
	used instead.

	```lua
	local leftThumbstick = gamepad:GetThumbstick(Enum.KeyCode.Thumbstick1)
	print("Left thumbstick position", leftThumbstick)
	```
]=]
function Gamepad:GetThumbstick(thumbstick: Enum.KeyCode, deadzoneThreshold: number?): Vector2
	local pos = self.State[thumbstick].Position
	local deadzone = deadzoneThreshold or self.DefaultDeadzone
	return Vector2.new(ApplyDeadzone(pos.X, deadzone), ApplyDeadzone(pos.Y, deadzone))
end

--[=[
	@param trigger KeyCode
	@param deadzoneThreshold number?
	@return number
	Gets the position of the given trigger. The triggers are usually going
	to be `Enum.KeyCode.ButtonL2` and `Enum.KeyCode.ButtonR2`. These trigger
	buttons are analog, and will output a value between the range of [0, 1].

	If `deadzoneThreshold` is not included, the `DefaultDeadzone` value is
	used instead.

	```lua
	local triggerAmount = gamepad:GetTrigger(Enum.KeyCode.ButtonR2)
	print(triggerAmount)
	```
]=]
function Gamepad:GetTrigger(trigger: Enum.KeyCode, deadzoneThreshold: number?): number
	return ApplyDeadzone(self.State[trigger].Position.Z, deadzoneThreshold or self.DefaultDeadzone)
end

--[=[
	@param gamepadButton KeyCode
	@return boolean
	Returns `true` if the given button is down. This includes
	any button on the gamepad, such as `Enum.KeyCode.ButtonA`,
	`Enum.KeyCode.ButtonL3`, `Enum.KeyCode.DPadUp`, etc.

	```lua
	-- Check if the 'A' button is down:
	if gamepad:IsButtonDown(Enum.KeyCode.ButtonA) then
		print("ButtonA is down")
	end
	```
]=]
function Gamepad:IsButtonDown(gamepadButton: Enum.KeyCode): boolean
	return UserInputService:IsGamepadButtonDown(self._gamepad, gamepadButton)
end

--[=[
	@param motor Enum.VibrationMotor
	@return boolean
	Returns `true` if the given motor is supported.

	```lua
	-- Pulse the trigger (e.g. shooting a weapon), but fall back to
	-- the large motor if not supported:
	local motor = Enum.VibrationMotor.Large
	if gamepad:IsMotorSupported(Enum.VibrationMotor.RightTrigger) then
		motor = Enum.VibrationMotor.RightTrigger
	end
	gamepad:PulseMotor(motor, 1, 0.1)
	```
]=]
function Gamepad:IsMotorSupported(motor: Enum.VibrationMotor): boolean
	return HapticService:IsMotorSupported(self._gamepad, motor)
end

--[=[
	@param motor Enum.VibrationMotor
	@param intensity number
	Sets the gamepad's haptic motor to a certain intensity. The
	intensity value is a number in the range of [0, 1].

	```lua
	gamepad:SetMotor(Enum.VibrationMotor.Large, 0.5)
	```
]=]
function Gamepad:SetMotor(motor: Enum.VibrationMotor, intensity: number): number
	self._setMotorIds[motor] += 1
	local id = self._setMotorIds[motor]
	HapticService:SetMotor(self._gamepad, motor, intensity)
	return id
end

--[=[
	@param motor Enum.VibrationMotor
	@param intensity number
	@param duration number
	Sets the gamepad's haptic motor to a certain intensity for a given
	period of time. The motor will stop vibrating after the given
	`duration` has elapsed.

	Calling any motor setter methods (e.g. `SetMotor`, `PulseMotor`,
	`StopMotor`) _after_ calling this method will override the pulse.
	For instance, if `PulseMotor` is called, and then `SetMotor` is
	called right afterwards, `SetMotor` will take precedent.

	```lua
	-- Pulse the large motor for 0.2 seconds with an intensity of 90%:
	gamepad:PulseMotor(Enum.VibrationMotor.Large, 0.9, 0.2)

	-- Example of PulseMotor being overridden:
	gamepad:PulseMotor(Enum.VibrationMotor.Large, 1, 3)
	task.wait(0.1)
	gamepad:SetMotor(Enum.VibrationMotor.Large, 0.5)
	-- Now the pulse won't shut off the motor after 3 seconds,
	-- because SetMotor was called, which cancels the pulse.
	```
]=]
function Gamepad:PulseMotor(motor: Enum.VibrationMotor, intensity: number, duration: number)
	local id = self:SetMotor(motor, intensity)
	local heartbeat = HeartbeatDelay(duration, function()
		if self._setMotorIds[motor] ~= id then
			return
		end
		self:StopMotor(motor)
	end)
	self._gamepadTrove:Add(heartbeat)
end

--[=[
	@param motor Enum.VibrationMotor
	Stops the given motor. This is equivalent to calling
	`gamepad:SetMotor(motor, 0)`.

	```lua
	gamepad:SetMotor(Enum.VibrationMotor.Large, 1)
	task.wait(0.1)
	gamepad:StopMotor(Enum.VibrationMotor.Large)
	```
]=]
function Gamepad:StopMotor(motor: Enum.VibrationMotor)
	self:SetMotor(motor, 0)
end

--[=[
	Stops all motors on the gamepad.

	```lua
	gamepad:SetMotor(Enum.VibrationMotor.Large, 1)
	gamepad:SetMotor(Enum.VibrationMotor.Small, 1)
	task.wait(0.1)
	gamepad:StopMotors()
	```
]=]
function Gamepad:StopMotors()
	for _, motor in ipairs(Enum.VibrationMotor:GetEnumItems()) do
		if self:IsMotorSupported(motor) then
			self:StopMotor(motor)
		end
	end
end

--[=[
	@return boolean
	Returns `true` if the gamepad is currently connected.
]=]
function Gamepad:IsConnected(): boolean
	return if self._gamepad then UserInputService:GetGamepadConnected(self._gamepad) else false
end

--[=[
	@return Enum.UserInputType?
	Gets the current gamepad UserInputType that the gamepad object
	is using. This will be `nil` if there is no connected gamepad.
]=]
function Gamepad:GetUserInputType(): Enum.UserInputType?
	return self._gamepad
end

--[=[
	@param enabled boolean
	Sets the [`GuiService.AutoSelectGuiEnabled`](https://developer.roblox.com/en-us/api-reference/property/GuiService/AutoSelectGuiEnabled)
	property.

	This sets whether or not the Select button on a gamepad will try to auto-select
	a GUI object on screen. This does _not_ turn on/off GUI gamepad navigation,
	but just the initial selection using the Select button.

	For UX purposes, it usually is preferred to set this to `false` and then
	manually set the [`GuiService.SelectedObject`](https://developer.roblox.com/en-us/api-reference/property/GuiService/SelectedObject)
	property within code to set the selected object for gamepads.

	```lua
	gamepad:SetAutoSelectGui(false)
	game:GetService("GuiService").SelectedObject = someGuiObject
	```
]=]
function Gamepad:SetAutoSelectGui(enabled: boolean)
	GuiService.AutoSelectGuiEnabled = enabled
end

--[=[
	@return boolean
	Returns the [`GuiService.AutoSelectGuiEnabled`](https://developer.roblox.com/en-us/api-reference/property/GuiService/AutoSelectGuiEnabled)
	property.
]=]
function Gamepad:IsAutoSelectGuiEnabled(): boolean
	return GuiService.AutoSelectGuiEnabled
end

--[=[
	Destroys the gamepad object.
]=]
function Gamepad:Destroy()
	self._trove:Destroy()
end

return Gamepad]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043ce</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX442CF9AAB4BD4CECA1F63D31D800BAB4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc08218013000093d4</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_Keyboard</string>
								<string name="ScriptGuid">{10CFA3B5-EF81-463B-9A10-1FE73249B343}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- Keyboard
-- Stephen Leitnick
-- October 10, 2021
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ModuleUtils = require("../../ModuleUtils")

local Trove = ModuleUtils.Trove
local Signal = ModuleUtils.Signal

local UserInputService = game:GetService("UserInputService")

--[=[
	@class Keyboard
	@client

	The Keyboard class is part of the Input package.

	```lua
	local Keyboard = require(packages.Input).Keyboard
	```
]=]
local Keyboard = {}
Keyboard.__index = Keyboard
type self = {
	_trove: ModuleUtils.TroveType,
	KeyDown: ModuleUtils.SignalType<(key: Enum.KeyCode, wasProcessed: boolean) -> (), (Enum.KeyCode, boolean)>,
	KeyUp: ModuleUtils.SignalType<(key: Enum.KeyCode, wasProcessed: boolean) -> (), (Enum.KeyCode, boolean)>
}
export type KeyboardType = typeof(setmetatable({} :: self, Keyboard))

--[=[
	@within Keyboard
	@prop KeyDown Signal<Enum.KeyCode>
	@tag Event
	Fired when a key is pressed.
	```lua
	keyboard.KeyDown:Connect(function(key: KeyCode)
		print("Key pressed", key)
	end)
	```
]=]
--[=[
	@within Keyboard
	@prop KeyUp Signal<Enum.KeyCode>
	@tag Event
	Fired when a key is released.
	```lua
	keyboard.KeyUp:Connect(function(key: KeyCode)
		print("Key released", key)
	end)
	```
]=]

--[=[
	@return Keyboard

	Constructs a new keyboard input capturer.

	```lua
	local keyboard = Keyboard.new()
	```
]=]
function Keyboard.new(): KeyboardType
	local self = setmetatable({}, Keyboard)
	self._trove = Trove.new()
	self.KeyDown = self._trove:Construct(Signal)
	self.KeyUp = self._trove:Construct(Signal)
	self:_setup()
	return self
end

--[=[
	Check if the given key is down.

	```lua
	local w = keyboard:IsKeyDown(Enum.KeyCode.W)
	if w then ... end
	```
]=]
function Keyboard:IsKeyDown(keyCode: Enum.KeyCode): boolean
	return UserInputService:IsKeyDown(keyCode)
end

--[=[
	Check if _both_ keys are down. Useful for key combinations.

	```lua
	local shiftA = keyboard:AreKeysDown(Enum.KeyCode.LeftShift, Enum.KeyCode.A)
	if shiftA then ... end
	```
]=]
function Keyboard:AreKeysDown(keyCodeOne: Enum.KeyCode, keyCodeTwo: Enum.KeyCode): boolean
	return (self:IsKeyDown(keyCodeOne) and self:IsKeyDown(keyCodeTwo)) :: boolean
end

--[=[
	Check if _either_ of the keys are down. Useful when two keys might perform
	the same operation.

	```lua
	local wOrUp = keyboard:AreEitherKeysDown(Enum.KeyCode.W, Enum.KeyCode.Up)
	if wOrUp then
		-- Go forward
	end
	```
]=]
function Keyboard:AreEitherKeysDown(keyCodeOne: Enum.KeyCode, keyCodeTwo: Enum.KeyCode): boolean
	return self:IsKeyDown(keyCodeOne) or self:IsKeyDown(keyCodeTwo)
end

function Keyboard:_setup()
	self._trove:Connect(UserInputService.InputBegan, function(input, processed)
		if input.UserInputType == Enum.UserInputType.Keyboard then
			self.KeyDown:Fire(input.KeyCode, processed)
		end
	end)

	self._trove:Connect(UserInputService.InputEnded, function(input, processed)
		if input.UserInputType == Enum.UserInputType.Keyboard then
			self.KeyUp:Fire(input.KeyCode, processed)
		end
	end)
end

--[=[
	Destroy the keyboard input capturer.
]=]
function Keyboard:Destroy()
	self._trove:Destroy()
end

return Keyboard]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043cf</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF1D2AE2EC09446B99C8D8FE8B4227F57">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc08218013000093d5</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_Mouse</string>
								<string name="ScriptGuid">{203E5045-7B0C-4980-B2CA-A7B9C09D979F}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- Mouse
-- Stephen Leitnick
-- November 07, 2020
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ModuleUtils = require("../../ModuleUtils")

local Signal = ModuleUtils.Signal
local Trove = ModuleUtils.Trove

local UserInputService = game:GetService("UserInputService")

local RAY_DISTANCE = 1000

--[=[
	@class Mouse
	@client

	The Mouse class is part of the Input package.

	```lua
	local Mouse = require(packages.Input).Mouse
	```
]=]
local Mouse = {}
Mouse.__index = Mouse
type self = {
	_trove: ModuleUtils.TroveType,
	LeftDown: ModuleUtils.SignalType<() -> ()>,
	LeftUp: ModuleUtils.SignalType<() -> ()>,
	RightDown: ModuleUtils.SignalType<() -> ()>,
	RightUp: ModuleUtils.SignalType<() -> ()>,
	MiddleDown: ModuleUtils.SignalType<() -> ()>,
	MiddleUp: ModuleUtils.SignalType<() -> ()>,
	Scrolled: ModuleUtils.SignalType<(scrollAmount: number, processed: boolean) -> (), (number, boolean)>,
	Moved: ModuleUtils.SignalType<(position: Vector2, processed: boolean) -> (), (Vector2, boolean)>,
}
export type MouseType = typeof(setmetatable({} :: self, Mouse))

--[=[
	@within Mouse
	@prop LeftDown Signal
	@tag Event
]=]
--[=[
	@within Mouse
	@prop LeftUp Signal
	@tag Event
]=]
--[=[
	@within Mouse
	@prop RightDown Signal
	@tag Event
]=]
--[=[
	@within Mouse
	@prop RightUp Signal
	@tag Event
]=]
--[=[
	@within Mouse
	@prop MiddleDown Signal
	@tag Event
]=]
--[=[
	@within Mouse
	@prop MiddleUp Signal
	@tag Event
]=]
--[=[
	@within Mouse
	@prop Moved Signal<Vector2>
	@tag Event
	```lua
	mouse.Moved:Connect(function(position) ... end)
	```
]=]
--[=[
	@within Mouse
	@prop Scrolled Signal<number>
	@tag Event
	```lua
	mouse.Scrolled:Connect(function(scrollAmount) ... end)
	```
]=]

--[=[
	@return Mouse

	Constructs a new mouse input capturer.

	```lua
	local mouse = Mouse.new()
	```
]=]
function Mouse.new(): MouseType
	local self = setmetatable({}, Mouse)

	self._trove = Trove.new()

	self.LeftDown = self._trove:Construct(Signal)
	self.LeftUp = self._trove:Construct(Signal)
	self.RightDown = self._trove:Construct(Signal)
	self.RightUp = self._trove:Construct(Signal)
	self.MiddleDown = self._trove:Construct(Signal)
	self.MiddleUp = self._trove:Construct(Signal)
	self.Scrolled = self._trove:Construct(Signal)
	self.Moved = self._trove:Construct(Signal)

	self._trove:Connect(UserInputService.InputBegan, function(input, processed)
		if processed then
			return
		end
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			self.LeftDown:Fire()
		elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
			self.RightDown:Fire()
		elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
			self.MiddleDown:Fire()
		end
	end)

	self._trove:Connect(UserInputService.InputEnded, function(input, processed)
		if processed then
			return
		end
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			self.LeftUp:Fire()
		elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
			self.RightUp:Fire()
		elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
			self.MiddleUp:Fire()
		end
	end)

	self._trove:Connect(UserInputService.InputChanged, function(input, processed)
		if input.UserInputType == Enum.UserInputType.MouseMovement then
			local position = input.Position
			self.Moved:Fire(Vector2.new(position.X, position.Y), processed)
		elseif input.UserInputType == Enum.UserInputType.MouseWheel then
			self.Scrolled:Fire(input.Position.Z, processed)
		end
	end)

	return self
end

--[=[
	Checks if the left mouse button is down.
]=]
function Mouse:IsLeftDown(): boolean
	return UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
end

--[=[
	Checks if the right mouse button is down.
]=]
function Mouse:IsRightDown(): boolean
	return UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
end

--[=[
	Checks if the middle mouse button is down.
]=]
function Mouse:IsMiddleDown(): boolean
	return UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton3)
end

--[=[
	Gets the screen position of the mouse.
]=]
function Mouse:GetPosition(): Vector2
	return UserInputService:GetMouseLocation()
end

--[=[
	Gets the delta screen position of the mouse. In other words, the
	distance the mouse has traveled away from its locked position in
	a given frame (see note about mouse locking below).

	:::info Only When Mouse Locked
	Getting the mouse delta is only intended for when the mouse is locked. If the
	mouse is _not_ locked, this will return a zero Vector2. The mouse can be locked
	using the `mouse:Lock()` and `mouse:LockCenter()` method.
]=]
function Mouse:GetDelta(): Vector2
	return UserInputService:GetMouseDelta()
end

--[=[
	Returns the viewport point ray for the mouse at the current mouse
	position (or the override position if provided).
]=]
function Mouse:GetRay(overridePos: Vector2?): Ray
	local mousePos = overridePos or UserInputService:GetMouseLocation()
	local viewportMouseRay = workspace.CurrentCamera:ViewportPointToRay(mousePos.X, mousePos.Y)
	return viewportMouseRay
end

--[=[
	Performs a raycast operation out from the mouse position (or the
	`overridePos` if provided) into world space. The ray will go
	`distance` studs forward (or 1000 studs if not provided).

	Returns the `RaycastResult` if something was hit, else returns `nil`.

	Use `Raycast` if it is important to capture any objects that could be
	hit along the projected ray. If objects can be ignored and only the
	final position of the ray is needed, use `Project` instead.

	```lua
	local params = RaycastParams.new()
	local result = mouse:Raycast(params)
	if result then
		print(result.Instance)
	else
		print("Mouse raycast did not hit anything")
	end
	```
]=]
function Mouse:Raycast(raycastParams: RaycastParams, distance: number?, overridePos: Vector2?): RaycastResult?
	local viewportMouseRay = self:GetRay(overridePos) :: Ray
	local result = workspace:Raycast(
		viewportMouseRay.Origin,
		viewportMouseRay.Direction * (distance or RAY_DISTANCE),
		raycastParams
	)
	return result
end

--[=[
	Gets the 3D world position of the mouse when projected forward. This would be the
	end-position of a raycast if nothing was hit. Similar to `Raycast`, optional
	`distance` and `overridePos` arguments are allowed.
	
	Use `Project` if you want to get the 3D world position of the mouse at a given
	distance but don't care about any objects that could be in the way. It is much
	faster to project a position into 3D space than to do a full raycast operation.

	```lua
	local params = RaycastParams.new()
	local distance = 200

	local result = mouse:Raycast(params, distance)
	if result then
		-- Do something with result
	else
		-- Raycast failed, but still get the world position of the mouse:
		local worldPosition = mouse:Project(distance)
	end
	```
]=]
function Mouse:Project(distance: number?, overridePos: Vector2?): Vector3
	local viewportMouseRay = self:GetRay(overridePos) :: Ray
	return viewportMouseRay.Origin + (viewportMouseRay.Direction.Unit * (distance or RAY_DISTANCE))
end

--[=[
	Locks the mouse in its current position on screen. Call `mouse:Unlock()`
	to unlock the mouse.

	:::caution Must explicitly unlock
	Be sure to explicitly call `mouse:Unlock()` before cleaning up the mouse.
	The `Destroy` method does _not_ unlock the mouse since there is no way
	to guarantee who "owns" the mouse lock.
]=]
function Mouse:Lock()
	UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
end

--[=[
	Locks the mouse in the center of the screen. Call `mouse:Unlock()`
	to unlock the mouse.

	:::caution Must explicitly unlock
	See cautionary in `Lock` method above.
]=]
function Mouse:LockCenter()
	UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
end

--[=[
	Unlocks the mouse.
]=]
function Mouse:Unlock()
	UserInputService.MouseBehavior = Enum.MouseBehavior.Default
end

--[=[
	Destroys the mouse.
]=]
function Mouse:Destroy()
	self._trove:Destroy()
end

return Mouse]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043d0</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX765EE36E93414312A46A7D3E71B95BC0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc08218013000093d6</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_PreferredInput</string>
								<string name="ScriptGuid">{8EB77F5F-A390-4386-A810-E3A734EFCCFA}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

-- PreferredInput
-- Stephen Leitnick
-- April 05, 2021

--[=[
	@within PreferredInput
	@type InputType "MouseKeyboard" | "Touch" | "Gamepad"

	The InputType is just a string that is either `"MouseKeyboard"`,
	`"Touch"`, or `"Gamepad"`.
]=]
export type InputType = "MouseKeyboard" | "Touch" | "Gamepad"

local UserInputService = game:GetService("UserInputService")

local touchUserInputType = Enum.UserInputType.Touch
local keyboardUserInputType = Enum.UserInputType.Keyboard

type PreferredInput = {
	Current: InputType,
	Observe: (handler: (inputType: InputType) -> ()) -> () -> (),
}

--[=[
	@class PreferredInput
	@client

	A helper library for observing the preferred user input of the
	player. This is useful for determining what input schemes
	to use during gameplay. A player might switch from using
	a mouse to a gamepad mid-game, and it is important for the
	game to respond to this change.

	The Preferred class is part of the Input package.

	```lua
	local PreferredInput = require(packages.Input).PreferredInput
	```
]=]
--[=[
	@within PreferredInput
	@prop Current InputType
	@readonly

	The current preferred InputType.

	```lua
	print(PreferredInput.Current)
	```
]=]
--[=[
	@within PreferredInput
	@function Observe
	@param handler (preferred: InputType) -> ()
	@return () -> ()

	Observes the preferred input. In other words, the handler function will
	be fired immediately, as well as any time the preferred input changes.

	The returned function can be called to disconnect the observer.

	```lua
	local disconnect = PreferredInput.Observe(function(preferred)
		-- Fires immediately & any time the preferred input changes
		print(preferred)
	end)

	-- If/when desired, observer can be stopped by calling the returned function:
	disconnect()
	```
]=]

local PreferredInput: PreferredInput

local subscribers = {}

PreferredInput = {

	Current = "MouseKeyboard",

	Observe = function(handler: (inputType: InputType) -> ()): () -> ()
		if table.find(subscribers, handler) then
			error("function already subscribed", 2)
		end
		table.insert(subscribers, handler)

		task.spawn(handler, PreferredInput.Current)

		return function()
			local index = table.find(subscribers, handler)
			if index then
				local n = #subscribers
				subscribers[index], subscribers[n] = subscribers[n], nil
			end
		end
	end,
}

local function SetPreferred(preferred: InputType)
	if preferred == PreferredInput.Current then
		return
	end
	PreferredInput.Current = preferred

	for _, subscriber in subscribers do
		task.spawn(subscriber, preferred)
	end
end

local function DeterminePreferred(inputType: Enum.UserInputType)
	if inputType == touchUserInputType then
		SetPreferred("Touch")
	elseif inputType == keyboardUserInputType or string.sub(inputType.Name, 1, 5) == "Mouse" then
		SetPreferred("MouseKeyboard")
	elseif string.sub(inputType.Name, 1, 7) == "Gamepad" then
		SetPreferred("Gamepad")
	end
end

DeterminePreferred(UserInputService:GetLastInputType())
UserInputService.LastInputTypeChanged:Connect(DeterminePreferred)

return PreferredInput]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043d1</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXD2C176E33059430C8CF9EB7724113C29">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">09edd42ec210d5cc08218013000093d7</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">_Touch</string>
								<string name="ScriptGuid">{999B1AB1-96EC-4211-8AB9-6E0692D07254}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- Touch
-- Stephen Leitnick
-- March 14, 2021
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ModuleUtils = require("../../ModuleUtils")
local FunctionUtils = require("../../FunctionUtils")

local Trove = ModuleUtils.Trove
local Signal = ModuleUtils.Signal

local UserInputService = game:GetService("UserInputService")

--[=[
	@class Touch
	@client

	The Touch class is part of the Input package.

	```lua
	local Touch = require(packages.Input).Touch
	```
]=]
local Touch = {}
Touch.__index = Touch
type self = {
	_trove: ModuleUtils.TroveType,
	_usingTouchControls: InputObject?,
	TouchTap: ModuleUtils.SignalType<(touchPositions: { Vector2 }, processed: boolean) -> (), ({ Vector2 }, boolean)>,
	TouchTapInWorld: ModuleUtils.SignalType<(position: Vector2, processed: boolean) -> (), ({ Vector2 }, boolean)>,
	TouchMoved: ModuleUtils.SignalType<(touch: InputObject, processed: boolean) -> (), (InputObject, boolean)>,
	TouchLongPress: ModuleUtils.SignalType<(touchPositions: { Vector2 }, state: Enum.UserInputState, processed: boolean) -> (), ({ Vector2 }, Enum.UserInputState, boolean)>,
	TouchPan: ModuleUtils.SignalType<(touchPositions: { Vector2 }, totalTranslation: Vector2, velocity: Vector2, state: Enum.UserInputState, processed: boolean) -> (), ({ Vector2 }, Vector2, Vector2, Enum.UserInputState, boolean)>,
	TouchPinch: ModuleUtils.SignalType<(touchPositions: { Vector2 }, scale: number, velocity: Vector2, state: Enum.UserInputState, processed: boolean) -> (), ({ Vector2 }, number, Vector2, Enum.UserInputState, boolean)>,
	TouchRotate: ModuleUtils.SignalType<(touchPositions: { Vector2 }, rotation: number, velocity: number, state: Enum.UserInputState, processed: boolean) -> (), ({ Vector2 }, number, number, Enum.UserInputState, boolean)>,
	TouchSwipe: ModuleUtils.SignalType<(swipeDirection: Enum.SwipeDirection, numberOfTouches: number, processed: boolean) -> (), (Enum.SwipeDirection, number, boolean)>,
	TouchStarted: ModuleUtils.SignalType<() -> ()>,
	TouchEnded: ModuleUtils.SignalType<() -> ()>,
	TouchEnabledChanged: ModuleUtils.SignalType<() -> ()>,
	
	ThumbstickControlsBegan: ModuleUtils.SignalType<(input: InputObject) -> (), (InputObject)>,
	ThumbstickControlsEnded: ModuleUtils.SignalType<(input: InputObject) -> (), (InputObject)>,
}
export type TouchType = typeof(setmetatable({} :: self, Touch))

--[=[
	@within Touch
	@prop TouchTap Signal<(touchPositions: {Vector2}, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchTap](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchTap).
]=]
--[=[
	@within Touch
	@prop TouchTapInWorld Signal<(position: Vector2, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchTapInWorld](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchTapInWorld).
]=]
--[=[
	@within Touch
	@prop TouchMoved Signal<(touch: InputObject, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchMoved](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchMoved).
]=]
--[=[
	@within Touch
	@prop TouchLongPress Signal<(touchPositions: {Vector2}, state: Enum.UserInputState, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchLongPress](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchLongPress).
]=]
--[=[
	@within Touch
	@prop TouchPan Signal<(touchPositions: {Vector2}, totalTranslation: Vector2, velocity: Vector2, state: Enum.UserInputState, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchPan](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchPan).
]=]
--[=[
	@within Touch
	@prop TouchPinch Signal<(touchPositions: {Vector2}, scale: number, velocity: Vector2, state: Enum.UserInputState, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchPinch](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchPinch).
]=]
--[=[
	@within Touch
	@prop TouchRotate Signal<(touchPositions: {Vector2}, rotation: number, velocity: number, state: Enum.UserInputState, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchRotate](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchRotate).
]=]
--[=[
	@within Touch
	@prop TouchSwipe Signal<(swipeDirection: Enum.SwipeDirection, numberOfTouches: number, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchSwipe](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchSwipe).
]=]
--[=[
	@within Touch
	@prop TouchStarted Signal<(touch: InputObject, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchStarted](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchStarted).
]=]
--[=[
	@within Touch
	@prop TouchEnded Signal<(touch: InputObject, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchEnded](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchEnded).
]=]

--[=[
	Constructs a new Touch input capturer.
]=]
function Touch.new(): TouchType
	local self = setmetatable({} :: self, Touch)

	self._trove = Trove.new()
	
	self.TouchTap = self._trove:Construct(Signal.Wrap, UserInputService.TouchTap)
	self.TouchTapInWorld = self._trove:Construct(Signal.Wrap, UserInputService.TouchTapInWorld)
	self.TouchMoved = self._trove:Construct(Signal.Wrap, UserInputService.TouchMoved)
	self.TouchLongPress = self._trove:Construct(Signal.Wrap, UserInputService.TouchLongPress)
	self.TouchPan = self._trove:Construct(Signal.Wrap, UserInputService.TouchPan)
	self.TouchPinch = self._trove:Construct(Signal.Wrap, UserInputService.TouchPinch)
	self.TouchRotate = self._trove:Construct(Signal.Wrap, UserInputService.TouchRotate)
	self.TouchSwipe = self._trove:Construct(Signal.Wrap, UserInputService.TouchSwipe)
	self.TouchStarted = self._trove:Construct(Signal.Wrap, UserInputService.TouchStarted)
	self.TouchEnded = self._trove:Construct(Signal.Wrap, UserInputService.TouchEnded)
	self.TouchEnabledChanged = self._trove:Construct(Signal.Wrap, UserInputService:GetPropertyChangedSignal("TouchEnabled"))
	
	self.ThumbstickControlsBegan = self._trove:Construct(Signal)
	self.ThumbstickControlsEnded = self._trove:Construct(Signal)
	
	self._trove:Connect(UserInputService.InputBegan, function(input: InputObject, processed)
		if input.UserInputType ~= Enum.UserInputType.Touch then
			return
		end
		if self._usingTouchControls then
			-- A finger is already using the touch controls, ignore other fingers
			return
		end
		
		local objects = FunctionUtils.Interface.getGuiObjectsAtPosition(Vector2.new(input.Position.X, input.Position.Y))
		for _, object in ipairs(objects) do
			if object.Name == "DynamicThumbstickFrame" then
				self._usingTouchControls = input
				self.ThumbstickControlsBegan:Fire(input)
				return
			end
		end
	end)
	self._trove:Connect(UserInputService.InputEnded, function(input: InputObject, processed)
		if input.UserInputType ~= Enum.UserInputType.Touch then
			return
		end
		if self._usingTouchControls == input then
			self._usingTouchControls = nil
			self.ThumbstickControlsEnded:Fire(input)
		end
	end)
	
	return self
end

--[=[
	Returns the value of [`UserInputService.TouchEnabled`](https://developer.roblox.com/en-us/api-reference/property/UserInputService/TouchEnabled).
]=]
function Touch:IsTouchEnabled(): boolean
	return UserInputService.TouchEnabled
end

-- Returns a boolean if touch controls (thumb stick) is actively being used. If so, the InputObject responsible is also returned.
function Touch.IsUsingThumbstickControls(self: TouchType): (boolean, InputObject?)
	if self._usingTouchControls then 
		return true, self._usingTouchControls
	else
		return false
	end
end

--[=[
	Destroys the Touch input capturer.
]=]
function Touch:Destroy()
	self._trove:Destroy()
end

return Touch]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043d2</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX7CB521B6FE8A496DB44FAA808B53BCA0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d180002c2d9</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">_Screen3D</string>
							<string name="ScriptGuid">{1AA8D140-0253-4CE9-8002-482CEDCD8D4F}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
local GuiService = game:GetService("GuiService")

local Component3D = require(script.Component3D)
local Definitions = require(script.Definitions)

export type screen3D = Definitions.screen3D
export type screenGen = Definitions.screenGen
export type component3D = Definitions.component3D
export type componentGen = Definitions.componentGen

local screenGen : Definitions.screenGen = {} :: Definitions.screenGen
screenGen.__index = screenGen

function screenGen.new(screenGui: ScreenGui, displayDistance: number)
	local partIndex : {[GuiObject] : Definitions.component3D} = {}

	local self = setmetatable(
		{
			partIndex = partIndex,
			rootGui = screenGui,
			displayDistance = displayDistance,
			rootOffset = CFrame.new()
		},
		
		screenGen
	)

	for _,Component2D in screenGui:GetDescendants() do
		if Component2D:IsA("GuiObject") then
			partIndex[Component2D] = Component3D.new(Component2D,self)
		end
	end

	screenGui.DescendantAdded:Connect(function(AddedComponent: Instance)
		if AddedComponent:IsA("GuiObject") then
			partIndex[AddedComponent] = Component3D.new(AddedComponent,self)
		end

		for _,Component2D in AddedComponent:GetDescendants() do
			if Component2D:IsA("GuiObject") and not partIndex[Component2D] then
				partIndex[Component2D] = Component3D.new(Component2D,self)
			end
		end
	end)

	return self 
end

function screenGen:GetRealCanvasSize(): Vector2
	return workspace.CurrentCamera.ViewportSize
end

function screenGen:GetInset(): Vector2
	local inset = GuiService:GetGuiInset()
	return inset
end

function screenGen:GetInsetCanvasSize(): Vector2
	return self:GetRealCanvasSize() - self:GetInset()
end

function screenGen:GetIntendedCanvasSize(): Vector2
	if self.rootGui.IgnoreGuiInset then
		return self:GetRealCanvasSize()
	end
	
	return self:GetInsetCanvasSize()
end

function screenGen:GetComponent3D(Component2D)
	return self.partIndex[Component2D]
end

return screenGen
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043d3</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXE590FD08B7B54FEFA4B5D7C41514A939">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d180002c2d5</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Component3D</string>
								<string name="ScriptGuid">{D788E4D4-72F6-45D6-9E13-40AF6B8F6AF8}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
local RunService = game:GetService("RunService")

local Definitions = require(script.Parent.Definitions)

local componentGen : Definitions.componentGen = {} :: Definitions.componentGen
componentGen.__index = componentGen

local function pivot(original: CFrame, pivot: CFrame, angle: CFrame) 
	return original:Inverse() * pivot * angle * pivot:Inverse() * original
end

function componentGen.new(Component2D, Screen3D)
	local self = setmetatable(
		{
			enabled = false,

			component2D = Component2D,
			surfaceGui = nil,

			parent3D = nil,
			screen3D = Screen3D,

			offset = CFrame.new(),
			viewportSize = Screen3D:GetIntendedCanvasSize(),

			conn = nil
		},
		
		componentGen
	)

	self.viewportSize = self:GetViewportSize()

	if Component2D.Parent and Component2D.Parent:IsA("GuiObject") then
		self.parent2D = Component2D.Parent
	end

	return self
end

function componentGen:Enable()
	if self.enabled or not self.component2D then
		return self
	end	

	self.enabled = true

	local surfaceGui = Instance.new('SurfaceGui')
	local surfacePart = Instance.new('Part')

	surfacePart.CanCollide = false
	surfacePart.Anchored = true
	surfacePart.Parent = surfaceGui

	surfaceGui.Parent = self.parent2D or self.screen3D.rootGui
	surfaceGui.Face =  Enum.NormalId.Back
	surfaceGui.Adornee = surfacePart
	surfaceGui.AlwaysOnTop = true

	self.surfaceGui = surfaceGui

	self.component2D.Parent = self.surfaceGui

	--self:RecomputeParent()

	self.conn = RunService.RenderStepped:Connect(function(deltaTime: number)
		if self.conn and not (self.surfaceGui and surfacePart) then
			self.conn:Disconnect()
			return
		end

		local viewportSize = self:GetViewportSize()

		self.viewportSize = viewportSize

		surfaceGui.CanvasSize = viewportSize
		surfacePart.Size = self:GetStudsScreenSize(viewportSize)
		surfacePart.CFrame = self:ReadWorldCFrame()

	end)

	return self
end

function componentGen:Disable()
	if not self.enabled then
		return self
	end

	self.enabled = false

	if self.conn then
		self.conn:Disconnect()
	end

	if self.component2D then
		self.component2D.Parent = self.parent2D or self.screen3D.rootGui
	end

	if self.surfaceGui then
		self.surfaceGui:Destroy()
	end
	
	return self
end

function componentGen:GetViewportSize(): Vector2
	if self.parent3D and self.parent3D.component2D then
		return self.parent3D.component2D.AbsoluteSize
	end
	
	return self.screen3D:GetIntendedCanvasSize()
end

function componentGen:UDim2ToCFrame(position2D: UDim2): CFrame
	if not self.component2D then
		return CFrame.new()
	end

	local scaleX, scaleY = position2D.X.Scale, position2D.Y.Scale
	local offsetX, offsetY = position2D.X.Offset, position2D.Y.Offset

	local viewSize = self:GetViewportSize()
	
	local partSize = self:GetStudsScreenSize(viewSize)
	local trueScaleX, trueScaleY = scaleX +  offsetX/ viewSize.X , scaleY + offsetY / viewSize.Y



	local partSize = self:GetStudsScreenSize(viewSize)

	return CFrame.new(
		(partSize.X) * (trueScaleX - 0.5),
		-(partSize.Y) * (trueScaleY -0.5 ),
		0		
	)	
end

function componentGen:GetStudsScreenSize(viewportSize: Vector2): Vector3
	local trueSize =  self.screen3D:GetRealCanvasSize()

	local currentCamera = workspace.CurrentCamera
	local FOV = currentCamera.FieldOfView

	return Vector3.new(
		(trueSize.X / trueSize.Y) * math.tan(math.rad(FOV)/2) * (viewportSize.X / trueSize.X) ,
		math.tan(math.rad(FOV)/2)  * (viewportSize.Y / trueSize.Y),
		0	
	) * self.screen3D.displayDistance

end

function componentGen:RecomputeParent()
	if self.parent2D and self.parent2D:IsA("GuiObject") then
		self.parent3D = self.screen3D:GetComponent3D(self.parent2D)
	end

	if self.surfaceGui then
		local parent = self.parent3D
		local zIndex = 0
		
		while parent do
			zIndex += 1
			parent = parent.parent3D
		end
		
		self.surfaceGui.ZOffset = zIndex
	end

	return self
end

function componentGen:ReadWorldCFrame(): CFrame
	if not self.component2D then
		return CFrame.new()
	end

	self:RecomputeParent()

	local originalCFrame, udimPos, addedPosition
	
	local udimMax = self:UDim2ToCFrame(UDim2.fromScale(1,1))
	
	if self.parent3D then


		if not self.parent3D.component2D or not self.parent2D then
			return CFrame.new()
		end


		
		local anchorPoint = self.parent3D.component2D.AnchorPoint

		originalCFrame = self.parent3D:ReadWorldCFrame()
		udimPos = self.parent3D.component2D.Position 
		addedPosition = 
			self.parent3D:UDim2ToCFrame(udimPos) 
			* udimMax  
			* self:UDim2ToCFrame(UDim2.fromScale(-anchorPoint.X+0.5,-anchorPoint.Y+0.5))
			* CFrame.Angles(0,0, -math.rad(self.parent2D.Rotation) ) 
	else
		local viewportDiff = self.screen3D:GetRealCanvasSize() - self.screen3D:GetIntendedCanvasSize()

		originalCFrame = workspace.CurrentCamera.CFrame * CFrame.new(0,0,-(self.screen3D.displayDistance)/2 ) * self.screen3D.rootOffset
		
		udimPos = UDim2.new(0,viewportDiff.X/2,0,viewportDiff.Y/2)
		
		addedPosition = self:UDim2ToCFrame(udimPos) * self:UDim2ToCFrame(UDim2.fromScale(1,1)) 

	end
	
	
	local finalCFrame = originalCFrame  * addedPosition
	
	local finalPivot =  
		finalCFrame 
		* udimMax:Inverse() 
		* self:UDim2ToCFrame(self.component2D.Position) 
		* udimMax

	
	
	return finalCFrame * pivot(finalCFrame,finalPivot,self.offset) 
end

return componentGen
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043d4</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXD1FE32C7F6A04AA7BBC4EA901B1CB1F2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">69f3a2bd88ee2db2088e9d180002c2d7</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Definitions</string>
								<string name="ScriptGuid">{2F0F3FBF-1CAE-4F49-B800-8BA523F7BF2C}</string>
								<ProtectedString name="Source"><![CDATA[export type screen3D = typeof(
	setmetatable(
		{} :: {
			partIndex : {[GuiObject] : component3D},
			rootGui : ScreenGui,
			displayDistance : number,
			rootOffset : CFrame

		}, 
		
		{} :: screenGen
	)
)

export type component3D = typeof(
	setmetatable(
		{} :: {
			enabled : boolean,
			
			component2D : GuiObject?,
			surfaceGui : SurfaceGui?,
			
			parent2D : GuiObject?,
			screen3D : screen3D,
			parent3D : component3D?,

			offset : CFrame,
			viewportSize : Vector2,

			conn : RBXScriptConnection?
		},
		
		{} :: componentGen
	)
)

export type screenGen = {
	__index : screenGen,
	new: (screenGui : ScreenGui, displayDistance : number) -> screen3D,
	
	GetComponent3D : (screen3D, Component2D : GuiObject) -> component3D?,
	
	GetRealCanvasSize : (screen3D) -> Vector2,
	GetInsetCanvasSize : (screen3D) -> Vector2,
	GetIntendedCanvasSize : (screen3D) -> Vector2,
	GetInset: (screen3D) -> Vector2
}

export type componentGen = {
	__index : componentGen,
	new: (Component2D : GuiObject, Screen3D : screen3D) -> component3D,
	
	Enable: (component3D ) -> (component3D),
	Disable: (component3D ) -> (component3D),
	
	RecomputeParent : (component3D) -> (),
	
	GetStudsScreenSize : (component3D, viewportSize : Vector2) -> Vector3,
	ReadWorldCFrame: (component3D) -> (CFrame),
	UDim2ToCFrame : (component3D, position2D : UDim2) -> CFrame,
	--AbsoluteUDim2ToCFrame : (component3D, position2D : UDim2) -> CFrame,
	
	GetViewportSize : (component3D) -> Vector2
}

return nil
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043d5</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="PackageLink" referent="RBX8996DB931AA84A59B2EC57D55BC07DEA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoUpdate">false</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<string name="DefaultName"></string>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">74a76f371dcdf99b08a51344000022b6</UniqueId>
						<int name="ModifiedState">1</int>
						<string name="Name">PackageLink</string>
						<Content name="PackageIdSerialize"><url>rbxassetid://103174396272469</url></Content>
						<BinaryString name="SerializedDefaultAttributes"></BinaryString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">74a76f371dcdf99b08a51344000043d6</UniqueId>
						<int64 name="VersionIdSerialize">11</int64>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX39D8875B15D14CC79B2D4318C66E91F2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Assets</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b2b</UniqueId>
			</Properties>
			<Item class="Folder" referent="RBX2258D6A88BFC42EA998AF2E8AF1A1E0D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Maps</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b2c</UniqueId>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX78C9DD9B1C6F4A968C16DDD9D7A0DE4A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Rigs</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b2d</UniqueId>
				</Properties>
				<Item class="Model" referent="RBX6DC86FBEAEA648CCABEA0C23007183EA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<token name="LevelOfDetail">0</token>
						<CoordinateFrame name="ModelMeshCFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
						<Vector3 name="ModelMeshSize">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="ModelStreamingMode">0</token>
						<string name="Name">Prisoner</string>
						<bool name="NeedsPivotMigration">false</bool>
						<Ref name="PrimaryPart">RBXA2EE69F89CE04E25A5719FBE77FE82E0</Ref>
						<float name="ScaleFactor">1</float>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b2e</UniqueId>
						<OptionalCoordinateFrame name="WorldPivotData">
							<CFrame>
								<X>-18.0348244</X>
								<Y>3.3163662</Y>
								<Z>30.5560474</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CFrame>
						</OptionalCoordinateFrame>
					</Properties>
					<Item class="Part" referent="RBXA2EE69F89CE04E25A5719FBE77FE82E0">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">4</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-18.0348244</X>
								<Y>7.8163662</Y>
								<Z>30.5560474</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4286545791</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">Head</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>-4.5</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b2f</UniqueId>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>2</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBXCDCFE9BCBFE34FDC9ED42E59684BC68B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="MeshId"><null></null></Content>
								<token name="MeshType">0</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1.25</X>
									<Y>1.25</Y>
									<Z>1.25</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="TextureId"><null></null></Content>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b30</UniqueId>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Decal" referent="RBXF4906D101537434CAD139B7548B56D4E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<Color3 name="Color3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<bool name="DefinesCapabilities">false</bool>
								<token name="Face">5</token>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="MetalnessMap"><null></null></Content>
								<string name="Name">face</string>
								<Content name="NormalMap"><null></null></Content>
								<Content name="RoughnessMap"><null></null></Content>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="Texture"><url>rbxasset://textures/face.png</url></Content>
								<Content name="TexturePack"><null></null></Content>
								<string name="TexturePackMetadata"></string>
								<float name="Transparency">0</float>
								<Vector2 name="UVOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="UVScale">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b31</UniqueId>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBX735DE59CE9BB487F80A27B0D475EA2F4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>0.600000024</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">HairAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b32</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBXB0053992CF72462D861D94812C9AFCCD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>0.600000024</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">HatAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b33</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBX90F46CD8B1624770B2818A67EF859908">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>0</Y>
									<Z>-0.600000024</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">FaceFrontAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b34</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBX000B401582154BDF8C9F7F2EEFBEBEA2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">FaceCenterAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b35</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
					</Item>
					<Item class="Part" referent="RBXCB7FAD9E4F094570A22518AE9FEF287B">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">4</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-18.0348244</X>
								<Y>6.3163662</Y>
								<Z>30.5560474</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4286545791</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<float name="LeftParamA">0</float>
							<float name="LeftParamB">0</float>
							<token name="LeftSurface">2</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">Torso</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">0</float>
							<float name="RightParamB">0</float>
							<token name="RightSurface">2</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">3</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b36</UniqueId>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>2</X>
								<Y>2</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="Decal" referent="RBX0B7115FBA7794C20BEDE6EC3DADE2093">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<Color3 name="Color3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<bool name="DefinesCapabilities">false</bool>
								<token name="Face">5</token>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="MetalnessMap"><null></null></Content>
								<string name="Name">roblox</string>
								<Content name="NormalMap"><null></null></Content>
								<Content name="RoughnessMap"><null></null></Content>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="Texture"><null></null></Content>
								<Content name="TexturePack"><null></null></Content>
								<string name="TexturePackMetadata"></string>
								<float name="Transparency">0</float>
								<Vector2 name="UVOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="UVScale">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b37</UniqueId>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBX61F166F7C10C48B4B9136A26375CC0F9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>1</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">NeckAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b38</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBXD9C6D16316764C13812DDFEF3092CF7C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>0</Y>
									<Z>-0.5</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">BodyFrontAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b39</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBX57E62143C9364B4EB176071E5E56A9B3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>0</Y>
									<Z>0.5</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">BodyBackAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b3a</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBX94B18D56074F4390B2F29570698A2E31">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>-1</X>
									<Y>1</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">LeftCollarAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b3b</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBX2B25CDBAFB464BEDA9BA53BDC12D43EB">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>1</X>
									<Y>1</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">RightCollarAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b3c</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBXB6336A1B5E194722B57BFB3866866A52">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>-1</Y>
									<Z>-0.5</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">WaistFrontAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b3d</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBXEA0C5FF070D9468E9DCBC50FB23CFAA3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>-1</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">WaistCenterAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b3e</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBX89E5208A83A14588BBAD3523F30117D5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>-1</Y>
									<Z>0.5</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">WaistBackAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b3f</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX724D2A029DC643E0A7E737436BD33AED">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>1</X>
									<Y>0.5</Y>
									<Z>0</Z>
									<R00>0</R00>
									<R01>0</R01>
									<R02>1</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>-0</R12>
									<R20>-1</R20>
									<R21>0</R21>
									<R22>0</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0.5</X>
									<Y>0.5</Y>
									<Z>0</Z>
									<R00>0</R00>
									<R01>0</R01>
									<R02>1</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>-0</R12>
									<R20>-1</R20>
									<R21>0</R21>
									<R22>0</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0.100000001</float>
								<string name="Name">Right Shoulder</string>
								<Ref name="Part0">RBXCB7FAD9E4F094570A22518AE9FEF287B</Ref>
								<Ref name="Part1">RBX4F66AA911E094E6991CE2A109EB0E8EF</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b40</UniqueId>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX8D3B1CB0D8D14645BEBBDD336135D2B2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-1</X>
									<Y>0.5</Y>
									<Z>0</Z>
									<R00>0</R00>
									<R01>0</R01>
									<R02>-1</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>1</R20>
									<R21>0</R21>
									<R22>0</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>0.5</X>
									<Y>0.5</Y>
									<Z>0</Z>
									<R00>0</R00>
									<R01>0</R01>
									<R02>-1</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>1</R20>
									<R21>0</R21>
									<R22>0</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0.100000001</float>
								<string name="Name">Left Shoulder</string>
								<Ref name="Part0">RBXCB7FAD9E4F094570A22518AE9FEF287B</Ref>
								<Ref name="Part1">RBXC9E35B72CC994F5FB75E77CECFF6E350</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b41</UniqueId>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBXFCE130B2491C4867A41B5A8C76257355">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>1</X>
									<Y>-1</Y>
									<Z>0</Z>
									<R00>0</R00>
									<R01>0</R01>
									<R02>1</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>-0</R12>
									<R20>-1</R20>
									<R21>0</R21>
									<R22>0</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>0.5</X>
									<Y>1</Y>
									<Z>0</Z>
									<R00>0</R00>
									<R01>0</R01>
									<R02>1</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>-0</R12>
									<R20>-1</R20>
									<R21>0</R21>
									<R22>0</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0.100000001</float>
								<string name="Name">Right Hip</string>
								<Ref name="Part0">RBXCB7FAD9E4F094570A22518AE9FEF287B</Ref>
								<Ref name="Part1">RBX81115759064A4ECD97BAF411C2692722</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b42</UniqueId>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBXD8566EB671DA44E5984D820EB360F024">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-1</X>
									<Y>-1</Y>
									<Z>0</Z>
									<R00>0</R00>
									<R01>0</R01>
									<R02>-1</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>1</R20>
									<R21>0</R21>
									<R22>0</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0.5</X>
									<Y>1</Y>
									<Z>0</Z>
									<R00>0</R00>
									<R01>0</R01>
									<R02>-1</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>1</R20>
									<R21>0</R21>
									<R22>0</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0.100000001</float>
								<string name="Name">Left Hip</string>
								<Ref name="Part0">RBXCB7FAD9E4F094570A22518AE9FEF287B</Ref>
								<Ref name="Part1">RBXEA7B03365DFD46A1942AA8351E87A385</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b43</UniqueId>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX566D409B6DE644B2922D861B471E0B1D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>0</X>
									<Y>1</Y>
									<Z>0</Z>
									<R00>-1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>0</R11>
									<R12>1</R12>
									<R20>0</R20>
									<R21>1</R21>
									<R22>-0</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>0</X>
									<Y>-0.5</Y>
									<Z>0</Z>
									<R00>-1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>0</R11>
									<R12>1</R12>
									<R20>0</R20>
									<R21>1</R21>
									<R22>-0</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0.100000001</float>
								<string name="Name">Neck</string>
								<Ref name="Part0">RBXCB7FAD9E4F094570A22518AE9FEF287B</Ref>
								<Ref name="Part1">RBXA2EE69F89CE04E25A5719FBE77FE82E0</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b44</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="Part" referent="RBXC9E35B72CC994F5FB75E77CECFF6E350">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">4</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-19.5348244</X>
								<Y>6.3163662</Y>
								<Z>30.5560474</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4286545791</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">Left Arm</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">3</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b45</UniqueId>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>2</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="Attachment" referent="RBX028A0559B6B0467DB0D3600C01066ED3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>1</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">LeftShoulderAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b46</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBX279BAA9958594C94948E62209A373258">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>-1</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">LeftGripAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b47</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
					</Item>
					<Item class="Part" referent="RBX4F66AA911E094E6991CE2A109EB0E8EF">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">4</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-16.5348244</X>
								<Y>6.3163662</Y>
								<Z>30.5560474</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4286545791</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">Right Arm</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">3</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b48</UniqueId>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>2</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="Attachment" referent="RBX88C6F983A4FD4CE7AC9D178406558023">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>1</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">RightShoulderAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b49</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBXA9F9FC818A1B4FDCB4E38331CF6B3CBE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>-1</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">RightGripAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b4a</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
					</Item>
					<Item class="Part" referent="RBXEA7B03365DFD46A1942AA8351E87A385">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-18.5348244</X>
								<Y>4.3163662</Y>
								<Z>30.5560474</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4286545791</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">Left Leg</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">3</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b4b</UniqueId>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>2</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="Attachment" referent="RBX6EEB58F18FAF4C9E8C09C13B1CB5EF98">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>-1</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">LeftFootAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b4c</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
					</Item>
					<Item class="Part" referent="RBX81115759064A4ECD97BAF411C2692722">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-17.5348244</X>
								<Y>4.3163662</Y>
								<Z>30.5560474</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4286545791</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">Right Leg</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">3</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b4d</UniqueId>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>2</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="Attachment" referent="RBXD6C21EE03983453DB20DDB3EDABBFED4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>-1</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">RightFootAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b4e</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
					</Item>
					<Item class="Humanoid" referent="RBX7F4D8E5C45A34B3FAFDC4D8E99857918">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoJumpEnabled">true</bool>
							<bool name="AutoRotate">true</bool>
							<bool name="AutomaticScalingEnabled">true</bool>
							<bool name="BreakJointsOnDeath">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<token name="CollisionType">0</token>
							<bool name="DefinesCapabilities">false</bool>
							<token name="DisplayDistanceType">0</token>
							<string name="DisplayName"></string>
							<bool name="EvaluateStateMachine">true</bool>
							<float name="HealthDisplayDistance">100</float>
							<token name="HealthDisplayType">0</token>
							<float name="Health_XML">100</float>
							<float name="HipHeight">0</float>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Vector3 name="InternalBodyScale">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
							<float name="InternalHeadScale">1</float>
							<float name="JumpHeight">7.19999981</float>
							<float name="JumpPower">50</float>
							<float name="MaxHealth">100</float>
							<float name="MaxSlopeAngle">89</float>
							<string name="Name">Humanoid</string>
							<float name="NameDisplayDistance">100</float>
							<token name="NameOcclusion">2</token>
							<bool name="RequiresNeck">true</bool>
							<token name="RigType">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b4f</UniqueId>
							<bool name="UseJumpPower">true</bool>
							<float name="WalkSpeed">16</float>
						</Properties>
						<Item class="Animator" referent="RBXDE7D64D560A34809A38B4CC8C7EDF9E0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Animator</string>
								<bool name="PreferLodEnabled">true</bool>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b50</UniqueId>
							</Properties>
						</Item>
						<Item class="HumanoidDescription" referent="RBXCE729BEE12484F899DECEE112A96001E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BodyTypeScale">0</float>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<int64 name="ClimbAnimation">0</int64>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DepthScale">1</float>
								<string name="EmotesDataInternal"></string>
								<string name="EquippedEmotesDataInternal"></string>
								<int64 name="Face">0</int64>
								<int64 name="FallAnimation">0</int64>
								<int64 name="GraphicTShirt">0</int64>
								<float name="HeadScale">1</float>
								<float name="HeightScale">1</float>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<int64 name="IdleAnimation">0</int64>
								<int64 name="JumpAnimation">0</int64>
								<int64 name="MoodAnimation">0</int64>
								<string name="Name">HumanoidDescription</string>
								<int64 name="Pants">0</int64>
								<float name="ProportionScale">0</float>
								<int64 name="RunAnimation">0</int64>
								<int64 name="Shirt">0</int64>
								<int64 name="SourceAssetId">-1</int64>
								<int64 name="SwimAnimation">0</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b51</UniqueId>
								<int64 name="WalkAnimation">0</int64>
								<float name="WidthScale">1</float>
							</Properties>
							<Item class="BodyPartDescription" referent="RBX33F85C5D5A744179A6509F9092D2451B">
								<Properties>
									<int64 name="AssetId">0</int64>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="BodyPart">0</token>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<Color3 name="Color">
										<R>0.5</R>
										<G>0.5</G>
										<B>0.5</B>
									</Color3>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Ref name="Instance">null</Ref>
									<string name="Name">BodyPartDescription</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b52</UniqueId>
								</Properties>
							</Item>
							<Item class="BodyPartDescription" referent="RBXF568261B39024F18B519387BCA1A249C">
								<Properties>
									<int64 name="AssetId">0</int64>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="BodyPart">2</token>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<Color3 name="Color">
										<R>0.5</R>
										<G>0.5</G>
										<B>0.5</B>
									</Color3>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Ref name="Instance">null</Ref>
									<string name="Name">BodyPartDescription</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b53</UniqueId>
								</Properties>
							</Item>
							<Item class="BodyPartDescription" referent="RBXD25C4158A3424600A6194F7222CCDD30">
								<Properties>
									<int64 name="AssetId">0</int64>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="BodyPart">4</token>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<Color3 name="Color">
										<R>0.5</R>
										<G>0.5</G>
										<B>0.5</B>
									</Color3>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Ref name="Instance">null</Ref>
									<string name="Name">BodyPartDescription</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b54</UniqueId>
								</Properties>
							</Item>
							<Item class="BodyPartDescription" referent="RBX9EA604DEE60248E9940450BCA56ADD48">
								<Properties>
									<int64 name="AssetId">0</int64>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="BodyPart">3</token>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<Color3 name="Color">
										<R>0.5</R>
										<G>0.5</G>
										<B>0.5</B>
									</Color3>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Ref name="Instance">null</Ref>
									<string name="Name">BodyPartDescription</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b55</UniqueId>
								</Properties>
							</Item>
							<Item class="BodyPartDescription" referent="RBXCB8F405D3FCF4C99B888A0F725B8A065">
								<Properties>
									<int64 name="AssetId">0</int64>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="BodyPart">5</token>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<Color3 name="Color">
										<R>0.5</R>
										<G>0.5</G>
										<B>0.5</B>
									</Color3>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Ref name="Instance">null</Ref>
									<string name="Name">BodyPartDescription</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b56</UniqueId>
								</Properties>
							</Item>
							<Item class="BodyPartDescription" referent="RBXF61EE89718F7458D83D22C640804B643">
								<Properties>
									<int64 name="AssetId">0</int64>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="BodyPart">1</token>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<Color3 name="Color">
										<R>0.5</R>
										<G>0.5</G>
										<B>0.5</B>
									</Color3>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Ref name="Instance">null</Ref>
									<string name="Name">BodyPartDescription</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b57</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Part" referent="RBX4FEBFFB8B7E549178776E4916396F952">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-18.0348244</X>
								<Y>6.3163662</Y>
								<Z>30.5560474</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288700213</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<float name="LeftParamA">0</float>
							<float name="LeftParamB">0</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">HumanoidRootPart</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">0</float>
							<float name="RightParamB">0</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">1</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b58</UniqueId>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>2</X>
								<Y>2</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="Attachment" referent="RBXC75312EB13404973A271135848EE36AA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">RootAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b59</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBXABF13A0C22C6428DB097D69C7220AF03">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>-1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>0</R11>
									<R12>1</R12>
									<R20>0</R20>
									<R21>1</R21>
									<R22>-0</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>-1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>0</R11>
									<R12>1</R12>
									<R20>0</R20>
									<R21>1</R21>
									<R22>-0</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0.100000001</float>
								<string name="Name">RootJoint</string>
								<Ref name="Part0">RBX4FEBFFB8B7E549178776E4916396F952</Ref>
								<Ref name="Part1">RBXCB7FAD9E4F094570A22518AE9FEF287B</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b5a</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBXC45884EC44B347D59C04D22C95C7D3CE">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Disabled">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Animate</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{287A2120-3890-4D71-872F-B8608DB5930F}</string>
							<ProtectedString name="Source"><![CDATA[-- humanoidAnimatePlayEmote.lua

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local EMOTE_TRANSITION_TIME = 0.1

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Figure:GetScale()
	else
		return 1
	end
end

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	speed /= getRigScale()
	
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	speed /= getRigScale()
	
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

---- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, 0.1, Humanoid)
	end

end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end
	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end

	-- Return false to indicate that the emote could not be played
	return false
end
-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end


]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b5b</UniqueId>
						</Properties>
						<Item class="StringValue" referent="RBX61BA0E2D2F6A43B39CE630EBED809BDF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">idle</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b5c</UniqueId>
								<string name="Value"></string>
							</Properties>
							<Item class="Animation" referent="RBX40CFC10AB84E48B19F6F1174747ACF7B">
								<Properties>
									<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=180435571</url></Content>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">Animation1</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b5d</UniqueId>
								</Properties>
								<Item class="NumberValue" referent="RBX6F07CCEE57EA4DF8BC9403F33B21BE78">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">Weight</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b5e</UniqueId>
										<double name="Value">9</double>
									</Properties>
								</Item>
							</Item>
							<Item class="Animation" referent="RBX86CF95E2ABD840A2BAA0F6A47B27FBD9">
								<Properties>
									<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=180435792</url></Content>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">Animation2</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b5f</UniqueId>
								</Properties>
								<Item class="NumberValue" referent="RBXD996345C89D24ACF864925EBC56EC552">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">Weight</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b60</UniqueId>
										<double name="Value">1</double>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="StringValue" referent="RBXB40EA81D6B774D16B6314B13180DFFA8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">walk</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b61</UniqueId>
								<string name="Value"></string>
							</Properties>
							<Item class="Animation" referent="RBX2F519B4290AC49ECBC49175A2D997F2D">
								<Properties>
									<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=180426354</url></Content>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">WalkAnim</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b62</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="StringValue" referent="RBX472DA594F173424CA499509857EC8488">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">run</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b63</UniqueId>
								<string name="Value"></string>
							</Properties>
							<Item class="Animation" referent="RBXBAFB0FB3FB024E6E8BB1BA922C8F56E1">
								<Properties>
									<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=180426354</url></Content>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">RunAnim</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b64</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="StringValue" referent="RBXC39AC308101E41A2B4B7EADDEBC29FFE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">jump</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b65</UniqueId>
								<string name="Value"></string>
							</Properties>
							<Item class="Animation" referent="RBXAEAA5BF813844BF7B2E805931228AB9F">
								<Properties>
									<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=125750702</url></Content>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">JumpAnim</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b66</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="StringValue" referent="RBX99860044FA314871885A2642FA5FC536">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">climb</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b67</UniqueId>
								<string name="Value"></string>
							</Properties>
							<Item class="Animation" referent="RBXDFA0CA1FE4DA4ABA9C262ADB16732B7F">
								<Properties>
									<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=180436334</url></Content>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">ClimbAnim</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b68</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="StringValue" referent="RBXCFC280A08111461096F24B66552EF212">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">toolnone</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b69</UniqueId>
								<string name="Value"></string>
							</Properties>
							<Item class="Animation" referent="RBXEA5BA44531E943BEA56D932ACFFF13E0">
								<Properties>
									<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=182393478</url></Content>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">ToolNoneAnim</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b6a</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="StringValue" referent="RBX4DECC02C3E10404EB335B8AD3A4AD150">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">fall</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b6b</UniqueId>
								<string name="Value"></string>
							</Properties>
							<Item class="Animation" referent="RBX90104921ADDF4634A4B2D3B785D2BC09">
								<Properties>
									<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=180436148</url></Content>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">FallAnim</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b6c</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="StringValue" referent="RBX5E211B33D494458BA028DB55B81F5099">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">sit</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b6d</UniqueId>
								<string name="Value"></string>
							</Properties>
							<Item class="Animation" referent="RBX93B9E609FF4844EC9D020061BF7B73A9">
								<Properties>
									<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=178130996</url></Content>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">SitAnim</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b6e</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="BindableFunction" referent="RBX7833CB475A3840FABF4AA881D16C0682">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">PlayEmote</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b6f</UniqueId>
							</Properties>
						</Item>
						<Item class="NumberValue" referent="RBX9003BDC972844862B661C3ED66CE4DC7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">ScaleDampeningPercent</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b70</UniqueId>
								<double name="Value">1</double>
							</Properties>
						</Item>
					</Item>
					<Item class="BodyColors" referent="RBXD7F7D44F0F464BF784B562F84F7CDC8B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Color3 name="HeadColor3">
								<R>0.5</R>
								<G>0.5</G>
								<B>0.5</B>
							</Color3>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Color3 name="LeftArmColor3">
								<R>0.5</R>
								<G>0.5</G>
								<B>0.5</B>
							</Color3>
							<Color3 name="LeftLegColor3">
								<R>0.5</R>
								<G>0.5</G>
								<B>0.5</B>
							</Color3>
							<string name="Name">Body Colors</string>
							<Color3 name="RightArmColor3">
								<R>0.5</R>
								<G>0.5</G>
								<B>0.5</B>
							</Color3>
							<Color3 name="RightLegColor3">
								<R>0.5</R>
								<G>0.5</G>
								<B>0.5</B>
							</Color3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Color3 name="TorsoColor3">
								<R>0.5</R>
								<G>0.5</G>
								<B>0.5</B>
							</Color3>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b71</UniqueId>
						</Properties>
					</Item>
					<Item class="Pants" referent="RBXD47EE7C24ABA474991ED21FE5503ED9B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">Clothing</string>
							<Content name="PantsTemplate"><url>rbxassetid://5057284243</url></Content>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b72</UniqueId>
						</Properties>
					</Item>
					<Item class="Shirt" referent="RBX9473661B89544318A5446ECF6AB83D89">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">Clothing</string>
							<Content name="ShirtTemplate"><url>rbxassetid://6171111155</url></Content>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b73</UniqueId>
						</Properties>
					</Item>
					<Item class="Accessory" referent="RBX4DC5D336ACCA44A78E1E88094D6473E4">
						<Properties>
							<token name="AccessoryType">0</token>
							<CoordinateFrame name="AttachmentPoint">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">Accessory</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b74</UniqueId>
						</Properties>
					</Item>
					<Item class="Accessory" referent="RBX62ADD08C03C94B1B8F9CBE13AC4BD956">
						<Properties>
							<token name="AccessoryType">0</token>
							<CoordinateFrame name="AttachmentPoint">
								<X>0.000667572021</X>
								<Y>1.19676876</Y>
								<Z>-0.129613876</Z>
								<R00>1</R00>
								<R01>7.87137555e-09</R01>
								<R02>3.02998127e-15</R02>
								<R10>-7.87137555e-09</R10>
								<R11>1</R11>
								<R12>-4.1444258e-16</R12>
								<R20>-3.02998127e-15</R20>
								<R21>4.14442554e-16</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">Accessory (Anime Cat Hair)</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b75</UniqueId>
						</Properties>
						<Item class="Part" referent="RBX2BE23ED586AF43E78346F94634A2F6C3">
							<Properties>
								<bool name="Anchored">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AudioCanCollide">true</bool>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>-18.0354919</X>
									<Y>7.21959734</Y>
									<Z>30.6856613</Z>
									<R00>1</R00>
									<R01>-7.87137555e-09</R01>
									<R02>-3.02998127e-15</R02>
									<R10>7.87137555e-09</R10>
									<R11>1</R11>
									<R12>4.14442554e-16</R12>
									<R20>3.02998127e-15</R20>
									<R21>-4.1444258e-16</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="CastShadow">true</bool>
								<string name="CollisionGroup">Default</string>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="EnableFluidForces">true</bool>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">256</token>
								<string name="MaterialVariantSerialized"></string>
								<string name="Name">Handle</string>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b76</UniqueId>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">1</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBX41F64937905C46C0AF82F2C2233321A5">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="MeshId"><url>rbxassetid://118619331508766</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">SpecialMesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="TextureId"><url>http://www.roblox.com/asset/?id=80684415119173</url></Content>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b77</UniqueId>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBX8D334E17CC134C3AA6DEE97564416DC4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">AvatarPartScaleType</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b78</UniqueId>
									<string name="Value">Classic</string>
								</Properties>
							</Item>
							<Item class="Attachment" referent="RBX4969C4121B3443F699CCD333C6210B67">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<CoordinateFrame name="CFrame">
										<X>0.000667572021</X>
										<Y>1.19676876</Y>
										<Z>-0.129613876</Z>
										<R00>1</R00>
										<R01>7.87137555e-09</R01>
										<R02>3.02998127e-15</R02>
										<R10>-7.87137555e-09</R10>
										<R11>1</R11>
										<R12>-4.1444258e-16</R12>
										<R20>-3.02998127e-15</R20>
										<R21>4.14442554e-16</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">HairAttachment</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b79</UniqueId>
									<bool name="Visible">false</bool>
								</Properties>
							</Item>
							<Item class="Vector3Value" referent="RBXB209A0712A854A3BB8C18E05E4040AAE">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">OriginalSize</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b7a</UniqueId>
									<Vector3 name="Value">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
							<Item class="Weld" referent="RBXFE00FC4941CD41F5A2E9DA92AA7117EC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<CoordinateFrame name="C0">
										<X>0.000667572021</X>
										<Y>1.19676876</Y>
										<Z>-0.129613876</Z>
										<R00>1</R00>
										<R01>7.87137555e-09</R01>
										<R02>3.02998127e-15</R02>
										<R10>-7.87137555e-09</R10>
										<R11>1</R11>
										<R12>-4.1444258e-16</R12>
										<R20>-3.02998127e-15</R20>
										<R21>4.14442554e-16</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<CoordinateFrame name="C1">
										<X>0</X>
										<Y>0.600000024</Y>
										<Z>0</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Enabled">true</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">AccessoryWeld</string>
									<Ref name="Part0">RBX2BE23ED586AF43E78346F94634A2F6C3</Ref>
									<Ref name="Part1">RBXA2EE69F89CE04E25A5719FBE77FE82E0</Ref>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b7b</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Configuration" referent="RBX236F15A1306E4BE8B224CC0876D83342">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">ThumbnailConfiguration</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b7c</UniqueId>
							</Properties>
							<Item class="ObjectValue" referent="RBX522B21B0CFA74469926AB555E1F94D79">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">ThumbnailCameraTarget</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b7d</UniqueId>
									<Ref name="Value">RBX2BE23ED586AF43E78346F94634A2F6C3</Ref>
								</Properties>
							</Item>
							<Item class="CFrameValue" referent="RBXB39B3F3893644D3B903C500C7DC50CE5">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">ThumbnailCameraValue</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b7e</UniqueId>
									<CoordinateFrame name="Value">
										<X>4.36049095e-06</X>
										<Y>3.48782349</Y>
										<Z>-49.8782043</Z>
										<R00>-1</R00>
										<R01>-6.09830453e-09</R01>
										<R02>8.72098198e-08</R02>
										<R10>0</R10>
										<R11>0.997564077</R11>
										<R12>0.0697564706</R12>
										<R20>-8.74227766e-08</R20>
										<R21>0.0697564706</R21>
										<R22>-0.997564077</R22>
									</CoordinateFrame>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Model" referent="RBX9E32F23E6A434AD8A55091F067DF0292">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<token name="LevelOfDetail">0</token>
						<CoordinateFrame name="ModelMeshCFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
						<Vector3 name="ModelMeshSize">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="ModelStreamingMode">0</token>
						<string name="Name">PoliceOfficer</string>
						<bool name="NeedsPivotMigration">false</bool>
						<Ref name="PrimaryPart">RBXA923D47754C948BFBE3830D292664044</Ref>
						<float name="ScaleFactor">1</float>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b7f</UniqueId>
						<OptionalCoordinateFrame name="WorldPivotData">
							<CFrame>
								<X>-11.2468796</X>
								<Y>3.6975174</Y>
								<Z>29.0112495</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CFrame>
						</OptionalCoordinateFrame>
					</Properties>
					<Item class="Part" referent="RBXA923D47754C948BFBE3830D292664044">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">4</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-11.2468796</X>
								<Y>3.6975174</Y>
								<Z>29.0112495</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4293256415</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">HumanoidRootPart</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">3</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">1</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b80</UniqueId>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>2</X>
								<Y>2</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="Attachment" referent="RBXFD6139990E5E491F8DF95B0D37C7EA06">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">RootRigAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b81</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Vector3Value" referent="RBX968D03553AE043A08BA6C62C35EC99A4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">OriginalSize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b82</UniqueId>
								<Vector3 name="Value">
									<X>2</X>
									<Y>2</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
					</Item>
					<Item class="MeshPart" referent="RBX78B4518C946B4F3898B3F2F8EF745214">
						<Properties>
							<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-9.74688053</X>
								<Y>3.49751711</Y>
								<Z>29.0112495</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4294954137</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="DoubleSided">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<token name="FluidFidelityInternal">0</token>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="InertiaMigrated">false</bool>
							<Vector3 name="InitialSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<Content name="MeshId"><null></null></Content>
							<string name="Name">LeftHand</string>
							<SharedString name="PhysicalConfigData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b83</UniqueId>
							<Vector3 name="UnscaledCofm">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaOffDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<float name="UnscaledVolume">NAN</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int name="VertexCount">0</int>
							<Vector3 name="size">
								<X>0.999999762</X>
								<Y>0.299999982</Y>
								<Z>0.999999881</Z>
							</Vector3>
						</Properties>
						<Item class="Vector3Value" referent="RBXEBB7DFC8610B4878ACF60EFE7974B277">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">OriginalSize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b84</UniqueId>
								<Vector3 name="Value">
									<X>0.999999762</X>
									<Y>0.299999982</Y>
									<Z>0.999999881</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBXE02C375815C34C3A8873A578813DC73B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>0.000478506088</X>
									<Y>-0.549999952</Y>
									<Z>7.64462551e-20</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>0.000478863716</X>
									<Y>0.149999991</Y>
									<Z>5.96046448e-08</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">LeftWrist</string>
								<Ref name="Part0">RBX86214DC9BEC84C63BFC5A488E888F0CC</Ref>
								<Ref name="Part1">RBX78B4518C946B4F3898B3F2F8EF745214</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b85</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="MeshPart" referent="RBX86214DC9BEC84C63BFC5A488E888F0CC">
						<Properties>
							<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-9.74688053</X>
								<Y>4.19751692</Y>
								<Z>29.0112495</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4294954137</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="DoubleSided">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<token name="FluidFidelityInternal">0</token>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="InertiaMigrated">false</bool>
							<Vector3 name="InitialSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<Content name="MeshId"><null></null></Content>
							<string name="Name">LeftLowerArm</string>
							<SharedString name="PhysicalConfigData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b86</UniqueId>
							<Vector3 name="UnscaledCofm">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaOffDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<float name="UnscaledVolume">NAN</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int name="VertexCount">0</int>
							<Vector3 name="size">
								<X>0.999999762</X>
								<Y>1.20000029</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="Vector3Value" referent="RBX55B413A3704D44C9AC8ADBA4E6704464">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">OriginalSize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b87</UniqueId>
								<Vector3 name="Value">
									<X>0.999999762</X>
									<Y>1.20000029</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBXB22264019F634C3A81F637B7B6C4340B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>0.000479102135</X>
									<Y>-0.200000167</Y>
									<Z>8.94069672e-08</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>0.000478506088</X>
									<Y>0.25000003</Y>
									<Z>7.64462551e-20</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">LeftElbow</string>
								<Ref name="Part0">RBX20D7498E74AB4AC7B8FEBB303EC48539</Ref>
								<Ref name="Part1">RBX86214DC9BEC84C63BFC5A488E888F0CC</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b88</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="MeshPart" referent="RBX20D7498E74AB4AC7B8FEBB303EC48539">
						<Properties>
							<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-9.74687958</X>
								<Y>4.6475172</Y>
								<Z>29.0112495</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4294954137</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="DoubleSided">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<token name="FluidFidelityInternal">0</token>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="InertiaMigrated">false</bool>
							<Vector3 name="InitialSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<Content name="MeshId"><null></null></Content>
							<string name="Name">LeftUpperArm</string>
							<SharedString name="PhysicalConfigData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b89</UniqueId>
							<Vector3 name="UnscaledCofm">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaOffDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<float name="UnscaledVolume">NAN</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int name="VertexCount">0</int>
							<Vector3 name="size">
								<X>0.999999762</X>
								<Y>1.40000033</Y>
								<Z>0.99999994</Z>
							</Vector3>
						</Properties>
						<Item class="Vector3Value" referent="RBX4F58B1D9D04D42CEA032BB25344E965D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">OriginalSize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b8a</UniqueId>
								<Vector3 name="Value">
									<X>0.999999762</X>
									<Y>1.40000033</Y>
									<Z>0.99999994</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX4ED67A68BA6443E9942D60A372C12357">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-1.24989128</X>
									<Y>0.549999952</Y>
									<Z>1.1920929e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>0.250109196</X>
									<Y>0.449999809</Y>
									<Z>8.94069672e-08</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">LeftShoulder</string>
								<Ref name="Part0">RBX63A14B3FBB67451286446D3B6EFD7622</Ref>
								<Ref name="Part1">RBX20D7498E74AB4AC7B8FEBB303EC48539</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b8b</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="MeshPart" referent="RBX610907A977504951BC6C9FA4DDF2D1E2">
						<Properties>
							<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-12.7468796</X>
								<Y>3.49751711</Y>
								<Z>29.0112495</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4294954137</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="DoubleSided">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<token name="FluidFidelityInternal">0</token>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="InertiaMigrated">false</bool>
							<Vector3 name="InitialSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<Content name="MeshId"><null></null></Content>
							<string name="Name">RightHand</string>
							<SharedString name="PhysicalConfigData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b8c</UniqueId>
							<Vector3 name="UnscaledCofm">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaOffDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<float name="UnscaledVolume">NAN</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int name="VertexCount">0</int>
							<Vector3 name="size">
								<X>0.999999881</X>
								<Y>0.299999982</Y>
								<Z>0.999999881</Z>
							</Vector3>
						</Properties>
						<Item class="Vector3Value" referent="RBX45CD615EF99E4AB2AC989522849C6473">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">OriginalSize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b8d</UniqueId>
								<Vector3 name="Value">
									<X>0.999999881</X>
									<Y>0.299999982</Y>
									<Z>0.999999881</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX18EA5E2DF2754A2A9B9B62BF18568AA4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>1.1920929e-07</X>
									<Y>-0.549999952</Y>
									<Z>-6.86244753e-18</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>3.57627869e-07</X>
									<Y>0.149999991</Y>
									<Z>5.96046448e-08</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">RightWrist</string>
								<Ref name="Part0">RBXD0750ECC594448A9BF5EE6AE53FA3229</Ref>
								<Ref name="Part1">RBX610907A977504951BC6C9FA4DDF2D1E2</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b8e</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="MeshPart" referent="RBXD0750ECC594448A9BF5EE6AE53FA3229">
						<Properties>
							<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-12.7468796</X>
								<Y>4.19751692</Y>
								<Z>29.0112495</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4294954137</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="DoubleSided">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<token name="FluidFidelityInternal">0</token>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="InertiaMigrated">false</bool>
							<Vector3 name="InitialSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<Content name="MeshId"><null></null></Content>
							<string name="Name">RightLowerArm</string>
							<SharedString name="PhysicalConfigData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b8f</UniqueId>
							<Vector3 name="UnscaledCofm">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaOffDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<float name="UnscaledVolume">NAN</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int name="VertexCount">0</int>
							<Vector3 name="size">
								<X>0.999999762</X>
								<Y>1.20000029</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="Attachment" referent="RBXB4DCFB78969346C3860922CFC9B0BB49">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>1.1920929e-07</X>
									<Y>0.25000003</Y>
									<Z>7.64462551e-20</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">RightElbowRigAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b90</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBX0416359B8B9747F6BE99C6E97540D141">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>1.1920929e-07</X>
									<Y>-0.549999952</Y>
									<Z>-6.86244753e-18</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">RightWristRigAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b91</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Vector3Value" referent="RBX4D510E8A9CBE46BCBB3A2C4025AF41C3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">OriginalSize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b92</UniqueId>
								<Vector3 name="Value">
									<X>0.999999762</X>
									<Y>1.20000029</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX90E4FE0B1BFD45F9A9077B8AB828ED6B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-5.96046448e-07</X>
									<Y>-0.200000167</Y>
									<Z>8.94069672e-08</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>1.1920929e-07</X>
									<Y>0.25000003</Y>
									<Z>7.64462551e-20</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">RightElbow</string>
								<Ref name="Part0">RBX81D0A1F27BD4422988FF4E816F72E463</Ref>
								<Ref name="Part1">RBXD0750ECC594448A9BF5EE6AE53FA3229</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b93</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="MeshPart" referent="RBX81D0A1F27BD4422988FF4E816F72E463">
						<Properties>
							<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-12.7468805</X>
								<Y>4.6475172</Y>
								<Z>29.0112495</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4294954137</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="DoubleSided">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<token name="FluidFidelityInternal">0</token>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="InertiaMigrated">false</bool>
							<Vector3 name="InitialSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<Content name="MeshId"><null></null></Content>
							<string name="Name">RightUpperArm</string>
							<SharedString name="PhysicalConfigData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b94</UniqueId>
							<Vector3 name="UnscaledCofm">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaOffDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<float name="UnscaledVolume">NAN</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int name="VertexCount">0</int>
							<Vector3 name="size">
								<X>0.999999642</X>
								<Y>1.40000033</Y>
								<Z>0.99999994</Z>
							</Vector3>
						</Properties>
						<Item class="Vector3Value" referent="RBX09C5C8B80F654F0CB78A456842326E4A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">OriginalSize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b95</UniqueId>
								<Vector3 name="Value">
									<X>0.999999642</X>
									<Y>1.40000033</Y>
									<Z>0.99999994</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX404F93E21BB744A18DE0C12218E6A002">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>1.24998045</X>
									<Y>0.549999952</Y>
									<Z>1.1920929e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0.250020266</X>
									<Y>0.449999809</Y>
									<Z>8.94069672e-08</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">RightShoulder</string>
								<Ref name="Part0">RBX63A14B3FBB67451286446D3B6EFD7622</Ref>
								<Ref name="Part1">RBX81D0A1F27BD4422988FF4E816F72E463</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b96</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="MeshPart" referent="RBX63A14B3FBB67451286446D3B6EFD7622">
						<Properties>
							<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-11.2468796</X>
								<Y>4.5475173</Y>
								<Z>29.0112495</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4294954137</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="DoubleSided">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<token name="FluidFidelityInternal">0</token>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="InertiaMigrated">false</bool>
							<Vector3 name="InitialSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<Content name="MeshId"><null></null></Content>
							<string name="Name">UpperTorso</string>
							<SharedString name="PhysicalConfigData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b97</UniqueId>
							<Vector3 name="UnscaledCofm">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaOffDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<float name="UnscaledVolume">NAN</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int name="VertexCount">0</int>
							<Vector3 name="size">
								<X>2</X>
								<Y>1.60000014</Y>
								<Z>1.00000036</Z>
							</Vector3>
						</Properties>
						<Item class="Vector3Value" referent="RBX2949A7C1B98F47B48B6D0CD848E91F3A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">OriginalSize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b98</UniqueId>
								<Vector3 name="Value">
									<X>2</X>
									<Y>1.60000014</Y>
									<Z>1.00000036</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBXAF194DD5C3684DDF9BF7F47ADDF7A3DD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-1.1920929e-07</X>
									<Y>0.550000072</Y>
									<Z>7.64462551e-20</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-5.96046448e-08</X>
									<Y>-0.450000018</Y>
									<Z>1.1920929e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">Waist</string>
								<Ref name="Part0">RBX22D8878A3FF146628F74F7C2C1EFF330</Ref>
								<Ref name="Part1">RBX63A14B3FBB67451286446D3B6EFD7622</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b99</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="MeshPart" referent="RBX8E932390867B4F1A81AF180FCD9BCED5">
						<Properties>
							<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-10.7468796</X>
								<Y>1.49751759</Y>
								<Z>29.0112495</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4294954137</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="DoubleSided">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<token name="FluidFidelityInternal">0</token>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="InertiaMigrated">false</bool>
							<Vector3 name="InitialSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<Content name="MeshId"><null></null></Content>
							<string name="Name">LeftFoot</string>
							<SharedString name="PhysicalConfigData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b9a</UniqueId>
							<Vector3 name="UnscaledCofm">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaOffDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<float name="UnscaledVolume">NAN</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int name="VertexCount">0</int>
							<Vector3 name="size">
								<X>1</X>
								<Y>0.300000191</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="Vector3Value" referent="RBXC28EA19A1B234906B9F7A8795A242A84">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">OriginalSize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b9b</UniqueId>
								<Vector3 name="Value">
									<X>1</X>
									<Y>0.300000191</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX6FB75CFB73BE4B2D9A26D715979BC2CF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-1.78813934e-07</X>
									<Y>-0.749997616</Y>
									<Z>6.29340548e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-2.38418579e-07</X>
									<Y>0.0500025749</Y>
									<Z>8.08154482e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">LeftAnkle</string>
								<Ref name="Part0">RBX1A07E05B8081480680C48BD5E087FC42</Ref>
								<Ref name="Part1">RBX8E932390867B4F1A81AF180FCD9BCED5</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b9c</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="MeshPart" referent="RBX1A07E05B8081480680C48BD5E087FC42">
						<Properties>
							<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-10.7468796</X>
								<Y>2.29751778</Y>
								<Z>29.0112495</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4294954137</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="DoubleSided">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<token name="FluidFidelityInternal">0</token>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="InertiaMigrated">false</bool>
							<Vector3 name="InitialSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<Content name="MeshId"><null></null></Content>
							<string name="Name">LeftLowerLeg</string>
							<SharedString name="PhysicalConfigData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b9d</UniqueId>
							<Vector3 name="UnscaledCofm">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaOffDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<float name="UnscaledVolume">NAN</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int name="VertexCount">0</int>
							<Vector3 name="size">
								<X>0.99999994</X>
								<Y>1.50000036</Y>
								<Z>1.00000012</Z>
							</Vector3>
						</Properties>
						<Item class="Vector3Value" referent="RBXDB15A5DCC04D4C64811E01B83F424E16">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">OriginalSize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b9e</UniqueId>
								<Vector3 name="Value">
									<X>0.99999994</X>
									<Y>1.50000036</Y>
									<Z>1.00000012</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX986CED2BDE984D0FB228A0ED3756C569">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>5.96046448e-08</X>
									<Y>-0.299999952</Y>
									<Z>-1.63912773e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0</X>
									<Y>0.249999642</Y>
									<Z>-1.78813934e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">LeftKnee</string>
								<Ref name="Part0">RBX5CA3C595AA0C41CDAC6DA5B8F382F2B6</Ref>
								<Ref name="Part1">RBX1A07E05B8081480680C48BD5E087FC42</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002b9f</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="MeshPart" referent="RBX5CA3C595AA0C41CDAC6DA5B8F382F2B6">
						<Properties>
							<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-10.7468796</X>
								<Y>2.84751749</Y>
								<Z>29.0112495</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4294954137</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="DoubleSided">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<token name="FluidFidelityInternal">0</token>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="InertiaMigrated">false</bool>
							<Vector3 name="InitialSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<Content name="MeshId"><null></null></Content>
							<string name="Name">LeftUpperLeg</string>
							<SharedString name="PhysicalConfigData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002ba0</UniqueId>
							<Vector3 name="UnscaledCofm">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaOffDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<float name="UnscaledVolume">NAN</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int name="VertexCount">0</int>
							<Vector3 name="size">
								<X>1.00000036</X>
								<Y>1.49999976</Y>
								<Z>0.999999881</Z>
							</Vector3>
						</Properties>
						<Item class="Vector3Value" referent="RBXCF31322BFD5A42E89D8A2C9A0D79B1E3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">OriginalSize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002ba1</UniqueId>
								<Vector3 name="Value">
									<X>1.00000036</X>
									<Y>1.49999976</Y>
									<Z>0.999999881</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX6EC77A7F55D94936AE7B9E0D2590F7C2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-0.500000119</X>
									<Y>-0.199999958</Y>
									<Z>-0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>5.96046448e-08</X>
									<Y>0.5</Y>
									<Z>-1.63912773e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">LeftHip</string>
								<Ref name="Part0">RBX22D8878A3FF146628F74F7C2C1EFF330</Ref>
								<Ref name="Part1">RBX5CA3C595AA0C41CDAC6DA5B8F382F2B6</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002ba2</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="MeshPart" referent="RBX1D5B7996CAB44061BDA6BCD51C9DB801">
						<Properties>
							<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-11.7468796</X>
								<Y>1.49751759</Y>
								<Z>29.0112495</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4294954137</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="DoubleSided">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<token name="FluidFidelityInternal">0</token>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="InertiaMigrated">false</bool>
							<Vector3 name="InitialSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<Content name="MeshId"><null></null></Content>
							<string name="Name">RightFoot</string>
							<SharedString name="PhysicalConfigData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002ba3</UniqueId>
							<Vector3 name="UnscaledCofm">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaOffDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<float name="UnscaledVolume">NAN</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int name="VertexCount">0</int>
							<Vector3 name="size">
								<X>0.99999994</X>
								<Y>0.300000191</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="Attachment" referent="RBX4C07F883AE984ADAB5ED5634A0514D66">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>-0</X>
									<Y>0.0499997139</Y>
									<Z>9.84534345e-05</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">RightAnkleRigAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002ba4</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Vector3Value" referent="RBXC51CAB1D60C64D4C8D16B6CEB34098BC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">OriginalSize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002ba5</UniqueId>
								<Vector3 name="Value">
									<X>0.99999994</X>
									<Y>0.300000191</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBXD0435AD9805B4F5F84D664BFE46824E1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-0</X>
									<Y>-0.750000477</Y>
									<Z>9.82746205e-05</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0</X>
									<Y>0.0499997139</Y>
									<Z>9.84534345e-05</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">RightAnkle</string>
								<Ref name="Part0">RBXC5383B9525B54D8BBDD52A1A36690951</Ref>
								<Ref name="Part1">RBX1D5B7996CAB44061BDA6BCD51C9DB801</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002ba6</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="MeshPart" referent="RBXC5383B9525B54D8BBDD52A1A36690951">
						<Properties>
							<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-11.7468796</X>
								<Y>2.29751778</Y>
								<Z>29.0112495</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4294954137</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="DoubleSided">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<token name="FluidFidelityInternal">0</token>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="InertiaMigrated">false</bool>
							<Vector3 name="InitialSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<Content name="MeshId"><null></null></Content>
							<string name="Name">RightLowerLeg</string>
							<SharedString name="PhysicalConfigData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002ba7</UniqueId>
							<Vector3 name="UnscaledCofm">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaOffDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<float name="UnscaledVolume">NAN</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int name="VertexCount">0</int>
							<Vector3 name="size">
								<X>0.99999994</X>
								<Y>1.50000036</Y>
								<Z>1.00000012</Z>
							</Vector3>
						</Properties>
						<Item class="Attachment" referent="RBX120F0932976845F9AC25EC84E4F65537">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>-0</X>
									<Y>0.249999642</Y>
									<Z>4.35260044e-05</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">RightKneeRigAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002ba8</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBX4BF9C9010A3A492B86066B3D031FA126">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>-0</X>
									<Y>-0.750000477</Y>
									<Z>9.82746205e-05</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">RightAnkleRigAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002ba9</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Vector3Value" referent="RBX610725E93DB940E0B3705840877D1340">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">OriginalSize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002baa</UniqueId>
								<Vector3 name="Value">
									<X>0.99999994</X>
									<Y>1.50000036</Y>
									<Z>1.00000012</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX3A47124CDD5542C9860FD556EC6517F1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-0</X>
									<Y>-0.299999952</Y>
									<Z>4.36005103e-05</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0</X>
									<Y>0.249999642</Y>
									<Z>4.35260044e-05</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">RightKnee</string>
								<Ref name="Part0">RBX4CB9F89B446B4CA98BEEEAF7941A9023</Ref>
								<Ref name="Part1">RBXC5383B9525B54D8BBDD52A1A36690951</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bab</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="MeshPart" referent="RBX4CB9F89B446B4CA98BEEEAF7941A9023">
						<Properties>
							<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-11.7468796</X>
								<Y>2.84751749</Y>
								<Z>29.0112495</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4294954137</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="DoubleSided">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<token name="FluidFidelityInternal">0</token>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="InertiaMigrated">false</bool>
							<Vector3 name="InitialSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<Content name="MeshId"><null></null></Content>
							<string name="Name">RightUpperLeg</string>
							<SharedString name="PhysicalConfigData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bac</UniqueId>
							<Vector3 name="UnscaledCofm">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaOffDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<float name="UnscaledVolume">NAN</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int name="VertexCount">0</int>
							<Vector3 name="size">
								<X>1.00000048</X>
								<Y>1.49999976</Y>
								<Z>0.999999881</Z>
							</Vector3>
						</Properties>
						<Item class="Attachment" referent="RBX7344B210157145EAAC6AFE2D755E002F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>-0</X>
									<Y>0.5</Y>
									<Z>-1.04308128e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">RightHipRigAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bad</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBX483B0A85B5C84D34BB0087A3E62BA365">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>-0</X>
									<Y>-0.299999952</Y>
									<Z>4.36005103e-05</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">RightKneeRigAttachment</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bae</UniqueId>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Vector3Value" referent="RBX48EE011111774202B7D744EC44221BE8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">OriginalSize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002baf</UniqueId>
								<Vector3 name="Value">
									<X>1.00000048</X>
									<Y>1.49999976</Y>
									<Z>0.999999881</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBXCD5637E34CD14AD8804333ED28D04E7C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>0.499999881</X>
									<Y>-0.199999958</Y>
									<Z>-0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0</X>
									<Y>0.5</Y>
									<Z>-1.04308128e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">RightHip</string>
								<Ref name="Part0">RBX22D8878A3FF146628F74F7C2C1EFF330</Ref>
								<Ref name="Part1">RBX4CB9F89B446B4CA98BEEEAF7941A9023</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bb0</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="MeshPart" referent="RBX22D8878A3FF146628F74F7C2C1EFF330">
						<Properties>
							<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-11.2468796</X>
								<Y>3.5475173</Y>
								<Z>29.0112495</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4294954137</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="DoubleSided">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<token name="FluidFidelityInternal">0</token>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="InertiaMigrated">false</bool>
							<Vector3 name="InitialSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<Content name="MeshId"><null></null></Content>
							<string name="Name">LowerTorso</string>
							<SharedString name="PhysicalConfigData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bb1</UniqueId>
							<Vector3 name="UnscaledCofm">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<Vector3 name="UnscaledVolInertiaOffDiags">
								<X>NAN</X>
								<Y>NAN</Y>
								<Z>NAN</Z>
							</Vector3>
							<float name="UnscaledVolume">NAN</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int name="VertexCount">0</int>
							<Vector3 name="size">
								<X>1.99999976</X>
								<Y>0.399999976</Y>
								<Z>1.00000012</Z>
							</Vector3>
						</Properties>
						<Item class="Vector3Value" referent="RBX8A48670E41164E52BA17370A8D232F91">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">OriginalSize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bb2</UniqueId>
								<Vector3 name="Value">
									<X>1.99999976</X>
									<Y>0.399999976</Y>
									<Z>1.00000012</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBXFF01FCA253874E4AA31901EA5E7AD7F0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-1.1920929e-07</X>
									<Y>0.150000036</Y>
									<Z>-0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">Root</string>
								<Ref name="Part0">RBXA923D47754C948BFBE3830D292664044</Ref>
								<Ref name="Part1">RBX22D8878A3FF146628F74F7C2C1EFF330</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bb3</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="Humanoid" referent="RBXF247D54E0E5A45D3B665C1E4F9A1C4C0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoJumpEnabled">true</bool>
							<bool name="AutoRotate">true</bool>
							<bool name="AutomaticScalingEnabled">true</bool>
							<bool name="BreakJointsOnDeath">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<token name="CollisionType">0</token>
							<bool name="DefinesCapabilities">false</bool>
							<token name="DisplayDistanceType">0</token>
							<string name="DisplayName"></string>
							<bool name="EvaluateStateMachine">true</bool>
							<float name="HealthDisplayDistance">100</float>
							<token name="HealthDisplayType">0</token>
							<float name="Health_XML">100</float>
							<float name="HipHeight">1.35000002</float>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Vector3 name="InternalBodyScale">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
							<float name="InternalHeadScale">1</float>
							<float name="JumpHeight">7.19999981</float>
							<float name="JumpPower">50</float>
							<float name="MaxHealth">100</float>
							<float name="MaxSlopeAngle">89</float>
							<string name="Name">Humanoid</string>
							<float name="NameDisplayDistance">100</float>
							<token name="NameOcclusion">2</token>
							<bool name="RequiresNeck">true</bool>
							<token name="RigType">1</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bb4</UniqueId>
							<bool name="UseJumpPower">true</bool>
							<float name="WalkSpeed">16</float>
						</Properties>
						<Item class="Animator" referent="RBX173E2E67AD224625B69ED139D923B25F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Animator</string>
								<bool name="PreferLodEnabled">true</bool>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bb5</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="Part" referent="RBX44DD570BF95743908A5876E1A28A087F">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AudioCanCollide">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-11.2468796</X>
								<Y>5.84751749</Y>
								<Z>29.0109768</Z>
								<R00>-1</R00>
								<R01>-3.14382545e-29</R01>
								<R02>0</R02>
								<R10>3.14382545e-29</R10>
								<R11>1</R11>
								<R12>-2.30003937e-26</R12>
								<R20>0</R20>
								<R21>2.30003937e-26</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4294954137</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="EnableFluidForces">true</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">Head</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bb6</UniqueId>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>2</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX724B927610544860813E1068081FEE35">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="MeshId"><null></null></Content>
								<token name="MeshType">0</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1.25</X>
									<Y>1.25</Y>
									<Z>1.25</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="TextureId"><null></null></Content>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bb7</UniqueId>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Decal" referent="RBX837934E5E84B43F6B6699627030CD302">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<Color3 name="Color3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<bool name="DefinesCapabilities">false</bool>
								<token name="Face">5</token>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="MetalnessMap"><null></null></Content>
								<string name="Name">face</string>
								<Content name="NormalMap"><null></null></Content>
								<Content name="RoughnessMap"><null></null></Content>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="Texture"><url>rbxasset://textures/face.png</url></Content>
								<Content name="TexturePack"><null></null></Content>
								<string name="TexturePackMetadata"></string>
								<float name="Transparency">0</float>
								<Vector2 name="UVOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="UVScale">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bb8</UniqueId>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX162EF93AF06E44C5B06B0B72815F0655">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-5.96046448e-08</X>
									<Y>0.799999952</Y>
									<Z>1.1920929e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0</X>
									<Y>-0.500000119</Y>
									<Z>-0.000272244215</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">Neck</string>
								<Ref name="Part0">RBX63A14B3FBB67451286446D3B6EFD7622</Ref>
								<Ref name="Part1">RBX44DD570BF95743908A5876E1A28A087F</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bb9</UniqueId>
							</Properties>
						</Item>
						<Item class="Vector3Value" referent="RBXF8BF498A5EE3490A953059AFDAFB7A1D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">OriginalSize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bba</UniqueId>
								<Vector3 name="Value">
									<X>2</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX83311E4B18A0449195C561789327B149">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-5.96046448e-08</X>
									<Y>0.799999952</Y>
									<Z>1.1920929e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0</X>
									<Y>-0.500000119</Y>
									<Z>-0.000272244215</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">Neck</string>
								<Ref name="Part0">RBX63A14B3FBB67451286446D3B6EFD7622</Ref>
								<Ref name="Part1">RBX44DD570BF95743908A5876E1A28A087F</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bbb</UniqueId>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX6F0854D73DA74BB7A75D7ABAC63B5350">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-5.96046448e-08</X>
									<Y>0.799999952</Y>
									<Z>1.1920929e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0</X>
									<Y>-0.500000119</Y>
									<Z>-0.000272244215</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">Neck</string>
								<Ref name="Part0">RBX63A14B3FBB67451286446D3B6EFD7622</Ref>
								<Ref name="Part1">RBX44DD570BF95743908A5876E1A28A087F</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bbc</UniqueId>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX31937BDF01524DC7A6D0019740FBFD2D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-5.96046448e-08</X>
									<Y>0.799999952</Y>
									<Z>1.1920929e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0</X>
									<Y>-0.500000119</Y>
									<Z>-0.000272244215</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">Neck</string>
								<Ref name="Part0">RBX63A14B3FBB67451286446D3B6EFD7622</Ref>
								<Ref name="Part1">RBX44DD570BF95743908A5876E1A28A087F</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bbd</UniqueId>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX6CF07DBD6BCE4C25A13C5B794BCC0AD4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-5.96046448e-08</X>
									<Y>0.799999952</Y>
									<Z>1.1920929e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0</X>
									<Y>-0.500000119</Y>
									<Z>-0.000272244215</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">Neck</string>
								<Ref name="Part0">RBX63A14B3FBB67451286446D3B6EFD7622</Ref>
								<Ref name="Part1">RBX44DD570BF95743908A5876E1A28A087F</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bbe</UniqueId>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX5DF1B2ADD12A47D5B144886920BAB4A2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-5.96046448e-08</X>
									<Y>0.799999952</Y>
									<Z>1.1920929e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0</X>
									<Y>-0.500000119</Y>
									<Z>-0.000272244215</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">Neck</string>
								<Ref name="Part0">RBX63A14B3FBB67451286446D3B6EFD7622</Ref>
								<Ref name="Part1">RBX44DD570BF95743908A5876E1A28A087F</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bbf</UniqueId>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBXF7259EA91EF74BD78A283DF2BAC9666C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-5.96046448e-08</X>
									<Y>0.799999952</Y>
									<Z>1.1920929e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0</X>
									<Y>-0.500000119</Y>
									<Z>-0.000272244215</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">Neck</string>
								<Ref name="Part0">RBX63A14B3FBB67451286446D3B6EFD7622</Ref>
								<Ref name="Part1">RBX44DD570BF95743908A5876E1A28A087F</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bc0</UniqueId>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBXF37E09D403654B1186A8596D06725B16">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-5.96046448e-08</X>
									<Y>0.799999952</Y>
									<Z>1.1920929e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0</X>
									<Y>-0.500000119</Y>
									<Z>-0.000272244215</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">Neck</string>
								<Ref name="Part0">RBX63A14B3FBB67451286446D3B6EFD7622</Ref>
								<Ref name="Part1">RBX44DD570BF95743908A5876E1A28A087F</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bc1</UniqueId>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBXB138DE2D9BE54C8F88BC00F55E7AA856">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-5.96046448e-08</X>
									<Y>0.799999952</Y>
									<Z>1.1920929e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0</X>
									<Y>-0.500000119</Y>
									<Z>-0.000272244215</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">Neck</string>
								<Ref name="Part0">RBX63A14B3FBB67451286446D3B6EFD7622</Ref>
								<Ref name="Part1">RBX44DD570BF95743908A5876E1A28A087F</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bc2</UniqueId>
							</Properties>
						</Item>
						<Item class="Motor6D" referent="RBX3BE855C1C29E49AB87A129E0ABD3D00E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>-5.96046448e-08</X>
									<Y>0.799999952</Y>
									<Z>1.1920929e-07</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>-0</X>
									<Y>-0.500000119</Y>
									<Z>-0.000272244215</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<float name="DesiredAngle">0</float>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="MaxVelocity">0</float>
								<string name="Name">Neck</string>
								<Ref name="Part0">RBX63A14B3FBB67451286446D3B6EFD7622</Ref>
								<Ref name="Part1">RBX44DD570BF95743908A5876E1A28A087F</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bc3</UniqueId>
							</Properties>
						</Item>
						<Item class="Weld" referent="RBXF09C1B64EFA34E19BCD4A56F08730CB6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="C0">
									<X>0</X>
									<Y>0.5</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<CoordinateFrame name="C1">
									<X>0</X>
									<Y>-0.150000006</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Enabled">true</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">HeadWeld</string>
								<Ref name="Part0">RBX44DD570BF95743908A5876E1A28A087F</Ref>
								<Ref name="Part1">RBX9FBCBB2643AC4D67A7C78532EE18588F</Ref>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bc4</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="Accessory" referent="RBX0A5145F517A44E9AB4AF0F818A714C1A">
						<Properties>
							<token name="AccessoryType">0</token>
							<CoordinateFrame name="AttachmentPoint">
								<X>0</X>
								<Y>-0.150000006</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">PoliceSergeantCap</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bc5</UniqueId>
						</Properties>
						<Item class="Part" referent="RBX9FBCBB2643AC4D67A7C78532EE18588F">
							<Properties>
								<bool name="Anchored">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AudioCanCollide">true</bool>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>-11.2468796</X>
									<Y>6.49751759</Y>
									<Z>29.0109768</Z>
									<R00>-1</R00>
									<R01>-3.14382545e-29</R01>
									<R02>0</R02>
									<R10>3.14382545e-29</R10>
									<R11>1</R11>
									<R12>-2.30003937e-26</R12>
									<R20>0</R20>
									<R21>2.30003937e-26</R21>
									<R22>-1</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="CastShadow">true</bool>
								<string name="CollisionGroup">Default</string>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="EnableFluidForces">true</bool>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">true</bool>
								<bool name="Massless">false</bool>
								<token name="Material">256</token>
								<string name="MaterialVariantSerialized"></string>
								<string name="Name">Handle</string>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bc6</UniqueId>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">1</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>1</X>
									<Y>0.800000012</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBX269527CCCF5840F2AB6CB72AF1FEAC91">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=1028788</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>1.10000002</X>
										<Y>1.10000002</Y>
										<Z>1.10000002</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="TextureId"><url>http://www.roblox.com/asset/?id=1081380</url></Content>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bc7</UniqueId>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
							<Item class="Attachment" referent="RBXDCF7BD499BF24CADA21C336E2AC6D647">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<CoordinateFrame name="CFrame">
										<X>8.65838956e-09</X>
										<Y>-0.0500001907</Y>
										<Z>-0.000272244215</Z>
										<R00>1</R00>
										<R01>7.87137555e-09</R01>
										<R02>-3.26223034e-24</R02>
										<R10>-7.87137555e-09</R10>
										<R11>1</R11>
										<R12>-4.1444221e-16</R12>
										<R20>0</R20>
										<R21>4.1444221e-16</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">HatAttachment</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bc8</UniqueId>
									<bool name="Visible">false</bool>
								</Properties>
							</Item>
							<Item class="Vector3Value" referent="RBXC2586EFBDCAD4F00BB018613F5288739">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">OriginalSize</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bc9</UniqueId>
									<Vector3 name="Value">
										<X>1</X>
										<Y>0.800000012</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="BodyColors" referent="RBX04D7982148DD45AA9A0C137CB406E34F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Color3 name="HeadColor3">
								<R>1</R>
								<G>0.800000072</G>
								<B>0.600000024</B>
							</Color3>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Color3 name="LeftArmColor3">
								<R>1</R>
								<G>0.800000072</G>
								<B>0.600000024</B>
							</Color3>
							<Color3 name="LeftLegColor3">
								<R>1</R>
								<G>0.800000072</G>
								<B>0.600000024</B>
							</Color3>
							<string name="Name">Body Colors</string>
							<Color3 name="RightArmColor3">
								<R>1</R>
								<G>0.800000072</G>
								<B>0.600000024</B>
							</Color3>
							<Color3 name="RightLegColor3">
								<R>1</R>
								<G>0.800000072</G>
								<B>0.600000024</B>
							</Color3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Color3 name="TorsoColor3">
								<R>1</R>
								<G>0.800000072</G>
								<B>0.600000024</B>
							</Color3>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bca</UniqueId>
						</Properties>
					</Item>
					<Item class="Shirt" referent="RBX2B4C4162E5CA45F49CA3FFB97D6013BB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">Clothing</string>
							<Content name="ShirtTemplate"><null></null></Content>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bcb</UniqueId>
						</Properties>
					</Item>
					<Item class="Pants" referent="RBX9E036CA6EBDC4910AB7B9B1C89CB8CC3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">Clothing</string>
							<Content name="PantsTemplate"><url>rbxassetid://398633811</url></Content>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bcc</UniqueId>
						</Properties>
					</Item>
					<Item class="Pants" referent="RBX73A5971E3B90427989E00DEEB7D39F35">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">Pants</string>
							<Content name="PantsTemplate"><url>rbxassetid://1218990367</url></Content>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bcd</UniqueId>
						</Properties>
					</Item>
					<Item class="Shirt" referent="RBX1BF47218B0924284ABC7F54F06E81499">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">Shirt</string>
							<Content name="ShirtTemplate"><url>rbxassetid://1089315465</url></Content>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bce</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXA04962E2980443E98CC7A937EF0DCAA6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Displays</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bcf</UniqueId>
				</Properties>
				<Item class="Frame" referent="RBX43C7C96653C64DE893265D42871501CF">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0.5</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="ClipsDescendants">false</bool>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Draggable">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">ItemInfoOverlay</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0.100000001</XS>
							<XO>0</XO>
							<YS>0.100000001</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bd0</UniqueId>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX82B9E4794D8543478508061C155DB0A2">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">Info</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bd1</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UIListLayout" referent="RBX05B6E16B7B1D4D2A8266B3A955448E37">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<token name="FillDirection">1</token>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<token name="HorizontalAlignment">0</token>
								<token name="HorizontalFlex">3</token>
								<token name="ItemLineAlignment">0</token>
								<string name="Name">UIListLayout</string>
								<UDim name="Padding">
									<S>0.00499999989</S>
									<O>0</O>
								</UDim>
								<token name="SortOrder">2</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bd2</UniqueId>
								<token name="VerticalAlignment">1</token>
								<token name="VerticalFlex">0</token>
								<bool name="Wraps">true</bool>
							</Properties>
						</Item>
						<Item class="UIPadding" referent="RBX0164F497E5C940FA890AA1C0366BBF29">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">UIPadding</string>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>5</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>2</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>2</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>5</O>
								</UDim>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bd3</UniqueId>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX970E3938ECBF46DD8993FC6C782AE0D4">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
								</Font>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">1</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">ItemName</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0.174999997</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Long Item Name Here</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">0</token>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bd4</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX0EBB56EDA44941A3B9F5BF4473B65FB8">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">2</int>
								<string name="Name">Div</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0.0500000007</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bd5</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="Frame" referent="RBXA18832719A134B058CBC0E1E6B7A9A97">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">2</int>
									<string name="Name">Frame</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>1</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bd6</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="Frame" referent="RBXBF37CBDDE4AC41719AA723CA665EAAF0">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">3</int>
								<string name="Name">Info</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0.739000022</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bd7</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIListLayout" referent="RBX68F5E8E474414E83BCCD98B22F48B96A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<token name="FillDirection">1</token>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<token name="HorizontalAlignment">0</token>
									<token name="HorizontalFlex">3</token>
									<token name="ItemLineAlignment">0</token>
									<string name="Name">UIListLayout</string>
									<UDim name="Padding">
										<S>0.00499999989</S>
										<O>0</O>
									</UDim>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bd8</UniqueId>
									<token name="VerticalAlignment">1</token>
									<token name="VerticalFlex">0</token>
									<bool name="Wraps">true</bool>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX7528BE0FBA3E464FB1D3C0B3DA3FFEC2">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">Speed</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<string name="OpenTypeFeatures"></string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0.319999993</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Speed: High</string>
									<Color3 name="TextColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">0</token>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bd9</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBXA2806242DC8140ECAE1BFAB217F7E772">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">2</int>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">Damage</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<string name="OpenTypeFeatures"></string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0.319999993</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Damage: Low</string>
									<Color3 name="TextColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">0</token>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bda</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX8BB5EFFF3B47487BBF1520A9B71BC14C">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">3</int>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">Range</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<string name="OpenTypeFeatures"></string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0.319999993</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Range: Medium</string>
									<Color3 name="TextColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">0</token>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bdb</UniqueId>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="UIPadding" referent="RBX574B845C873A4E2EBC3051F57D174D04">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">UIPadding</string>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>2</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>3</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>3</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>2</O>
									</UDim>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bdc</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Frame" referent="RBXD6CCD7001DCD4596AA9074F7CA062A34">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>1</X>
								<Y>1</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">Frame</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>5</XO>
								<YS>0</YS>
								<YO>1</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bdd</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX5984F83E2D7B4463B896FB0F54A20DA6">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>1</X>
								<Y>1</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">Frame</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>1</XO>
								<YS>0</YS>
								<YO>5</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bde</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBXDC0421C386EA4FDA8CB680CA92657B75">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">Frame</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>5</XO>
								<YS>0</YS>
								<YO>1</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002bdf</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBXA6381A10C2DE4BACB8DDF3DDF4EE5C9B">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">Frame</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>1</XO>
								<YS>0</YS>
								<YO>5</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002be0</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="UIStroke" referent="RBX56383929B1EA467390A237BBDFD30A33">
						<Properties>
							<token name="ApplyStrokeMode">0</token>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UDim name="BorderOffset">
								<S>0</S>
								<O>0</O>
							</UDim>
							<token name="BorderStrokePosition">0</token>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color">
								<R>1</R>
								<G>0</G>
								<B>0.0156862754</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Enabled">true</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<token name="LineJoinMode">0</token>
							<string name="Name">UIStroke</string>
							<int64 name="SourceAssetId">-1</int64>
							<token name="StrokeSizingMode">0</token>
							<BinaryString name="Tags"></BinaryString>
							<float name="Thickness">1</float>
							<float name="Transparency">0.850000024</float>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002be1</UniqueId>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX0FDDFD284E564841BD2B4ABD2A448C8E">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0.5</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoButtonColor">true</bool>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="ClipsDescendants">false</bool>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Draggable">false</bool>
						<Font name="FontFace">
							<Family><url>rbxasset://fonts/families/FredokaOne.json</url></Family>
							<Weight>400</Weight>
							<Style>Normal</Style>
						</Font>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Ref name="HoverHapticEffect">null</Ref>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">1</int>
						<float name="LineHeight">1</float>
						<string name="LocalizationMatchIdentifier"></string>
						<string name="LocalizationMatchedSourceText"></string>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="Modal">false</bool>
						<string name="Name">ButtonTemplate</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<string name="OpenTypeFeatures"></string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="PressHapticEffect">null</Ref>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0.699999988</XS>
							<XO>0</XO>
							<YS>0.850000024</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags">YW5pbTE=</BinaryString>
						<string name="Text">X</string>
						<Color3 name="TextColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="TextDirection">0</token>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002be2</UniqueId>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="UICorner" referent="RBX54A6BCB8298E40FBBD3C3523AD52CEB3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>0</O>
							</UDim>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002be3</UniqueId>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX65B5EF40A9E34F91A30B3F87165AF2C2">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">Display</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002be4</UniqueId>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX773C7183628045D087EAA30223B13CC7">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="Image"><url>rbxassetid://134475223951384</url></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">ImageLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<token name="ResampleMode">0</token>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">0</token>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<UniqueId name="UniqueId">38e5043c158bb8f708cc740e00002be5</UniqueId>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX3557E529E9BD421BA5B1B23776C8DB0C">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Folder</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">38e5043c158bb8f708cc740e000040fc</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="ServerScriptService" referent="RBX0A342D40700B4B24B2F946C87F647F76">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000373</UniqueId>
		</Properties>
		<Item class="Script" referent="RBX22F485C802844EAB94C14A4AA992C3B5">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Main</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{8BAAFC73-D893-4324-AABB-31568D60D7BB}</string>
				<ProtectedString name="Source"><![CDATA[local serverStorage = game:GetService("ServerStorage")
local replicatedStorage = game:GetService("ReplicatedStorage")
local replicatedStoragemodules = replicatedStorage.Modules
local serverStoragemodules = serverStorage.Modules

local Classes = serverStoragemodules.Classes
local secCamClasse = require(Classes.SecurityCamera)
local chestClasse = require(Classes.Chest)
local itemClasse = require(Classes.Item)
local ilegalItemDetectorClass = require(Classes.IlegalItemDetector)

local serverServicesFolder = serverStoragemodules.Services
local replicatedStorageServicesFolder = replicatedStoragemodules.Shared.Services
local playerDataService = require(serverServicesFolder.PlayerDataService)
local inventoryService = require(serverServicesFolder.InventoryService)
local replicableInstancesHandler = require(replicatedStorageServicesFolder.ReplicableInstancesHandler)
local characterBehaviorService = require(serverServicesFolder.CharacterBehaviorService)

local directoryFolder = replicatedStorage.Directory
local itemDirectory = require(directoryFolder.Items)

playerDataService.Init()
playerDataService.Start()

inventoryService.Init()
inventoryService.Start()

replicableInstancesHandler.Init()
replicableInstancesHandler.Start()

characterBehaviorService.Init()
characterBehaviorService.Start()

local plr
local cam = secCamClasse.new()
local chest1 = chestClasse.new(01)
local chest2 = chestClasse.new(01)
local chest3 = chestClasse.new(01)

cam:AttachCameraArea(workspace.Area1)
cam:start()

chest1:Replicate()
chest1:Materialize(workspace.bau1.CFrame)

for _ = 1, math.random(3, 12) do
	local newItem = itemClasse.new()
	newItem:AttachItem(itemDirectory:getRandomItemId())

	chest1:AddItem(newItem.UID)
end
for _ = 1, math.random(2, 6) do
	local newItem = itemClasse.new()
	newItem:AttachItem(itemDirectory:getRandomItemId())

	chest1:AddItem(newItem.UID, "HiddenContents")
end

chest2:Replicate()
chest2:Materialize(workspace.bau2.CFrame)

for _ = 1, math.random(3, 12) do
	local newItem = itemClasse.new()
	newItem:AttachItem(itemDirectory:getRandomItemId())

	chest2:AddItem(newItem.UID)
end
for _ = 1, math.random(2, 6) do
	local newItem = itemClasse.new()
	newItem:AttachItem(itemDirectory:getRandomItemId())

	chest2:AddItem(newItem.UID, "HiddenContents")
end

chest3:Replicate()
chest3:Materialize(workspace.bau3.CFrame)

for _ = 1, math.random(3, 12) do
	local newItem = itemClasse.new()
	newItem:AttachItem(itemDirectory:getRandomItemId())

	chest3:AddItem(newItem.UID)
end
for _ = 1, math.random(2, 6) do
	local newItem = itemClasse.new()
	newItem:AttachItem(itemDirectory:getRandomItemId())

	chest3:AddItem(newItem.UID, "HiddenContents")
end

local itemDetector1 = ilegalItemDetectorClass.new()
itemDetector1:Replicate(true)
itemDetector1:AttachIlegalItemDetector(1)
itemDetector1:Materialize(workspace.md1.CFrame)
itemDetector1:Active()

local itemDetector2 = ilegalItemDetectorClass.new()
itemDetector2:Replicate(true)
itemDetector2:AttachIlegalItemDetector(1)
itemDetector2:Materialize(workspace.md2.CFrame)
itemDetector2:Active()

plr = game.Players.PlayerAdded:Wait()
chest1:SetOwner(plr)

--table.insert(instances, cam)
--table.insert(instances, chest)

--print(instances)

--print(lib.Utils.ReplicableInstance.objsCreated)
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005205</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="RBXDD9ACBD73E57454ABD205E212FD5165C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000374</UniqueId>
		</Properties>
		<Item class="Folder" referent="RBXDCD983A479B44E40877FBDCDBF64EB1F">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Modules</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">6e87ccb51f069bf408b38bfe00002fe3</UniqueId>
			</Properties>
			<Item class="Folder" referent="RBXCEBD6F6445D64ABC9C1CD9ABED3C9D62">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Classes</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">7745f3117c4a251a089954ce000051e4</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBXED4394354D1440C88A76744648B602D2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">IlegalItemDetector</string>
						<string name="ScriptGuid">{085BB2CD-F711-46D4-B837-C3B414C23790}</string>
						<ProtectedString name="Source"><![CDATA[local replicatedStorage = game:GetService("ReplicatedStorage")
local serverStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

local ilegalItemsDetectorDirectory = require(replicatedStorage.Directory.IlegalItemDetector)
local lib = require(replicatedStorage.lib)
local charUtil = lib.FunctionUtils.Character
local t = lib.FunctionUtils.t
local replicableInstance = require(replicatedStorage.Modules.Shared.Classes.ReplicableInstance)
--TODO
local zonePlus = lib.ModuleUtils.ZonePlus

local inventorySharedUtil = require(replicatedStorage.Modules.Shared.Utils.InventoryUtilShared)

local module = setmetatable({}, replicableInstance)
module.__index = module

export type ClassType = typeof(setmetatable(
	{} :: {
		isActivated: boolean,
		CFrame: CFrame,
		DetectionArea: Part,

		AlertLevel: number, -- 0..3
		PlayersAlerting: { Player | nil }, -- set global por userId
		AlertClientThread: thread?,
	},
	module
)) & lib.ReplicableInstance & ilegalItemsDetectorDirectory.Type

local alertingConfigurations = {
	[1] = { TimeDuration = 6 },
	[2] = { TimeDuration = 10 },
	[3] = { TimeDuration = 15 },
}

local function clampLevel(n: number): number
	return math.clamp(n, 0, 3)
end

function module.new(id: string | number?): ClassType
	local self: ClassType = setmetatable(replicableInstance.new() :: lib.ReplicableInstance, module)
	self._Type = "IlegalItemDetector"
	self.AlertLevel = 0
	self.PlayersAlerting = {}
	if id then
		self:AttachIlegalItemDetector(id)
	end
	return self
end

function module.Materialize(self: ClassType, CF: CFrame)
	if not t.CFrame(CF) then
		return self
	end
	self.CFrame = lib.Utils.GetLegalCFrame(CF)

	self.DetectionArea = ilegalItemsDetectorDirectory:getItemModel(self.Id):Clone().DetectionArea
	self.DetectionArea.CFrame = self.CFrame
	self.DetectionArea.Parent = workspace

	self.Remote:Fire(self.UID, "Materialize", { self.CFrame })
	return self
end

function module.AttachIlegalItemDetector(self: ClassType, id: string | number?)
	if not (t.number(id) or t.string(id)) then
		return self
	end
	local info = ilegalItemsDetectorDirectory:getItemInfo(id)
	if not info then
		return self
	end
	for k, v in info do
		self[k] = v
	end
	self.Remote:Fire(self.UID, "AttachIlegalItemDetector", { self.Id })
	return self
end

function module.Alert(self: ClassType, level: number?)
	if self.AlertLevel == level then
		return self
	end
	self.AlertLevel = level and clampLevel(level) or self.AlertLevel
	if self.AlertClientThread and self.AlertClientThread ~= coroutine.running() then
		task.cancel(self.AlertClientThread)
		self.AlertClientThread = nil
	end

	local duration = alertingConfigurations[self.AlertLevel] and alertingConfigurations[self.AlertLevel].TimeDuration
		or 0
	if duration > 0 then
		self.AlertClientThread = task.delay(duration, function()
			if self.PlayersAlerting then
				table.clear(self.PlayersAlerting)
				self.PlayersAlerting = {}
				self.AlertLevel = clampLevel(#self.PlayersAlerting)
				self:Alert()
				print("alerting players")
				self.Remote:Fire(self.UID, "Alert", { self.AlertLevel })
			end
			self.AlertClientThread = nil
		end)
	end

	self.Remote:Fire(self.UID, "Alert", { self.AlertLevel })
	return self
end

-- jogador disparou (server valida globalmente e NOTIFICA TODOS)
function module.OnTriggerByPlayer(self: ClassType, player: Player)
	if not table.find(self.PlayersAlerting, player) then
		table.insert(self.PlayersAlerting, player)
	end

	self.AlertLevel = #self.PlayersAlerting
	self:Alert()

	return self
end

function module.Active(self: ClassType)
	if self.isActivated then
		return self
	end
	self.isActivated = true
	self.Trove:Add(self.DetectionArea.Touched:Connect(function(who: Instance)
		local plr = charUtil.getPlayerFromCharacter(who)
		if plr then
			local inv = inventorySharedUtil.getPlayerInventory(plr)
			if inventorySharedUtil.isThereAnIlegalItemOnInventory(inv) then
				self:OnTriggerByPlayer(plr) -- server valida e AVISA TODO MUNDO
			end
		end
	end))

	self.Remote:Fire(self.UID, "Active", {})
	return self
end

function module.ReplicateTo(self: ClassType, client: Player?)
	local newIlegalItemDetector = lib.Remotes.instanceCreated.IlegalItemDetector

	if client then
		newIlegalItemDetector:FireClient(client, self.UID)

		self.Remote:FireClient(client, self.UID, "AttachIlegalItemDetector", { self.Id })
		self.Remote:FireClient(client, self.UID, "Materialize", { self.CFrame })

		if self.isActivated then
			self.Remote:FireClient(client, self.UID, "Active", {})
		end
	else
		newIlegalItemDetector:Fire(self.UID)

		self.Remote:Fire(self.UID, "AttachIlegalItemDetector", { self.Id })
		self.Remote:Fire(self.UID, "Materialize", { self.CFrame })

		if self.isActivated then
			self.Remote:Fire(self.UID, "Active", {})
		end
	end

	return self
end

return module
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00004a02</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5DD44AB7D8624CE9B708C8C6E8858CC7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SecurityCamera</string>
						<string name="ScriptGuid">{1BE07E76-4B9E-44DD-834A-85CCDBFA1395}</string>
						<ProtectedString name="Source"><![CDATA[local serverStorage = game:GetService("ServerStorage")
local replicatedStorage = game:GetService("ReplicatedStorage")
local httpService = game:GetService("HttpService")
local gameSettings = require(replicatedStorage.Modules.Shared.GameSettings)
local lib = require(replicatedStorage.lib)
local directory = replicatedStorage.Directory
local securityCameraDirectory = require(directory.SecurityCameras)
local trove = lib.ModuleUtils.Trove
local signal = lib.ModuleUtils.Signal
local zonePlus = lib.ModuleUtils.ZonePlus

local dataStoreManager = require(serverStorage.Modules.Managers.PlayerDataManager)

export type securityCameraSettingsType = securityCameraType.Type

local module = {}
module.__index = module

export type ClassType = typeof(setmetatable(
	{} :: {
		_type: 'SecurityCamera',
		_started: boolean,
		UID: string,
		Trove: lib.TroveType,
		CameraArea: BasePart | Model,
		CameraZone: {[any]: any},
		Model: Model & BasePart,
		Support: typeof(module.Model.Support) & BasePart,
		
		PlayerEnteredCameraZone: lib.SignalType,
		
	},
	module
)) & securityCameraSettingsType

function module.new() : ClassType
	local self = {
		_type = 'SecurityCamera',
		_started = false, 
		UID = lib.Utils.GetLegalUID(),
		Trove = trove.new(),
		Model = nil,
	}
	
	setmetatable(self, module)
	return self
end

function module.AttachCamera(self: ClassType, target: Model | Attachment, cameraModel: Model?)
	self.Model = target:IsA('PVInstance') and target or target:IsA('Attachment') and cameraModel or securityCameraDirectory:getItemModel(01)
	self.Support = self.Model:FindFirstChild('Support')
	print('a')
	for k, v in securityCameraDirectory:getItemModule(1) do
		self[k] = v
	end
	print('b')
	if target:IsA('Attachment') then
		self.Support.CFrame = target:FindFirstAncestorOfClass('BasePart').CFrame * target.CFrame * CFrame.new(self.Support.Size.X/2, 0 , 0)
	end
	
	return self
end

function module.AttachCameraArea(self: ClassType, part: BasePart)
	self.CameraArea = part
	self.CameraZone = zonePlus.new(self.CameraArea)
	self.PlayerEnteredCameraZone = self.CameraZone.playerEntered
	
	return self
end

function module.StartWatching(self: ClassType, plr)
	if not self.CameraArea then return end
	
	
end

function module.FinishWatching(self: ClassType)
	
end

function module.AlertPolices(self: ClassType)
	
end

function module.StartConnections(self: ClassType)
	if self.CameraZone then
		self:StartWatching()
		self.Trove:Connect(self.CameraZone.playerEntered, function(plr)
			print(plr)
			
			local data = dataStoreManager.get(plr)
			
			if data.hasAnIlegalItem then
				self:AlertPolices()
			end
		end)
		
		self.Trove:Connect(self.CameraZone.playerExited, function(plr)
			print(plr)
			
			self:FinishWatching()
		end)
	end
	
	return self
end

function module.start(self: ClassType)
	if self._started then return end
	self._started = true
	task.spawn(self.StartConnections, self)
	
	return self
end

function module.finish(self: ClassType)
	if not self._started then return end
	self._started = false
	self.Trove:Clean()
	
	return self
end

return module
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600006295</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1B6F8F01A3D0493E9CFB3EA6C1EE89BB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Item</string>
						<string name="ScriptGuid">{F6847DE9-E96F-4A3A-B7C4-50B590BD0567}</string>
						<ProtectedString name="Source"><![CDATA[local replicatedStorage = game:GetService("ReplicatedStorage")
local serverStorage = game:GetService('ServerStorage')
local itemsDirectory = require(replicatedStorage.Directory.Items)

local lib = require(replicatedStorage.lib)

local sharedModules = replicatedStorage.Modules.Shared

local replicableInstance = require(sharedModules.Classes.ReplicableInstance)
local instancesManager = require(sharedModules.Managers.InstancesManager)

local inventoryServerUtil = require(serverStorage.Modules.Utils.InventoryUtilServer)
local inventorySharedUtil = require(sharedModules.Utils.InventoryUtilShared)

local dataStoreManager = require(serverStorage.Modules.Managers.PlayerDataManager)

local module = setmetatable({}, replicableInstance)
module.__index = module

export type ClassType = typeof(setmetatable(
	{} :: {
		playerOwner: Player,
		equipped: boolean,
		InstantiatedTo: string | Player,
		CFrame: CFrame?,

	},
	module
)) & lib.ReplicableInstance & itemsDirectory.Type

function module.new() : ClassType
	local self: ClassType = setmetatable(replicableInstance.new() :: lib.ReplicableInstance, module)
	self._Type = 'Item'
	
	return self
end

function module.AttachItem(self: ClassType, itemId: number)
	local itemInfo = itemsDirectory:getItemInfo(itemId)
	if not itemId then return self end

	for k, v in itemInfo do
		self[k] = v
	end

	self.Remote:Fire(self.UID, 'AttachItem', {itemId})
	return self
end

function module.Materialize(self: ClassType)
	
	return self
end

function module.InstantiateTo(self: ClassType, any: string | Player, ...)
	if self.InstantiatedTo == any then return self end
	self.InstantiatedTo = any
	
	self.Remote:Fire(self.UID, 'InstantiateTo', {any, ...})
	return self
end

function module.Drop(self: ClassType)
	if self.InstantiatedTo ~= '' then
		self:InstantiateTo('')
	end

	self.Model:PivotTo(self.Model:GetPivot() * CFrame.new(0, 4, 0))

	return self
end

function module.ToggleEquip(self: ClassType)
	
end

function module.TryToInstantiateTo(self: ClassType, plr: Player, any: string | Player?, chestStorage: string?)
	print(plr, any, chestStorage)
	print(self.InstantiatedTo)
	any = any or plr
	if self.InstantiatedTo == any then return self end
	
	local isPlayer = (typeof(any) == "Instance" and any:IsA("Player"))
	local isChest  = (type(any) == "string" and any ~= "")
	local isGround = (type(any) == "string" and any == "")

	if not (isPlayer or isChest or isGround) then return self end

	if type(self.InstantiatedTo) == "string" and self.InstantiatedTo ~= "" then
		local chestNow = instancesManager.getObj(self.InstantiatedTo)
		if chestNow then
			chestNow:RemoveItem(self.UID)
		end
	end

	if isGround then
		self:Drop()
	elseif isChest then
		local chest = instancesManager.getObj(any)
		if chest then
			chest:AddItem(self.UID, chestStorage)
		end
	elseif isPlayer then
		local plrDataInfo = dataStoreManager.getProfileData(plr)
		local inv = plrDataInfo.inventory
		print(inv)
		if inventorySharedUtil.canAddItem(inv, self.UID) then
			inventorySharedUtil.addItemToInventory(self.UID, inv)
			
			local chest = instancesManager.getObj(self.InstantiatedTo)
			if chest then
				print(chest.ItemsInside)
				chest:RemoveItem(self.UID)
				print(chest.ItemsInside)
			end
			print(inv)
			dataStoreManager.updateClient(plr)
		end
	end
	self:InstantiateTo(any, chestStorage)

	print(self.InstantiatedTo)
	return self
end

function module.ReplicateTo(self: ClassType, client: Player?)
	local newItem = lib.Remotes.instanceCreated.Item
	
	if client then
		local response = newItem:FireClient(client, self.UID)
		
		self.Remote:FireClient(client, self.UID, 'AttachItem', {self.Id})
		self.Remote:FireClient(client, self.UID, 'Materialize', {self.CFrame})
		self.Remote:FireClient(client, self.UID, 'InstantiateTo', {self.InstantiatedTo})
	else
		newItem:Fire(self.UID)
		
		self.Remote:Fire(self.UID, 'AttachItem', {self.Id})
		self.Remote:Fire(self.UID, 'Materialize', {self.CFrame})
		self.Remote:Fire(self.UID, 'InstantiateTo', {self.InstantiatedTo})
	end
	
	return self
end

return module
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">0eee8637571f3d340899bb4a00000df7</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8DB8C79952DB436089BD2BF3024DE39D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">4759be5bc435f364089ffe8100001a2a</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Chest</string>
						<string name="ScriptGuid">{94C3488E-5E92-4B5D-B5F8-0166A7920C54}</string>
						<ProtectedString name="Source"><![CDATA[local replicatedStorage = game:GetService("ReplicatedStorage")
local runService = game:GetService("RunService")

local sharedModules = replicatedStorage.Modules.Shared

local lib = require(replicatedStorage.lib)
local t = lib.FunctionUtils.t

local replicableInstance = require(sharedModules.Classes.ReplicableInstance)
local instancesManager = require(sharedModules.Managers.InstancesManager)
local charUtils = lib.FunctionUtils.Character

local chestSharedClass = require(sharedModules.Classes.ChestClasse)

local module = setmetatable({}, { __index = chestSharedClass })

local Storages = {
	DeskContents = {
		Name = "DeskContents",
		MaxAmountOfItems = 12,
	},
	HiddenContents = {
		Name = "HiddenContents",
		MaxAmountOfItems = 6,
	},
}

export type Storages = "DeskContents" | "HiddenContents"

export type ChestItems = chestSharedClass.ChestItems

export type ClassType = typeof(setmetatable(
	{} :: {
		PlayersSearching: { Player | nil },
		SendPlayerItemsInsideThread: thread?,
	},
	{ __index = module }
)) & chestSharedClass.ClassType

function module.new(id: string | number?): ClassType
	local self = replicableInstance.newLinkedToAClass(module, chestSharedClass) :: ClassType
	self.PlayersSearching = {}

	if id then
		self:AttachId(id)
	end
	return self
end

function module.AttachId(self: ClassType, _id: string | number)
	self.Remote:Fire(self.UID, "AttachChest", { self.Id })
	return self
end

function module.getNextFreeSlot(self: ClassType, contentName: Storages)
	if not contentName then
		return
	end
	local itemsInside = self.ItemsInside
	local chestStorage = itemsInside[contentName]
	local maxNOfItems = Storages[contentName].MaxAmountOfItems
	if maxNOfItems <= #chestStorage then
		return self
	end

	print(#chestStorage)
	for i = 1, maxNOfItems do
		local uid = chestStorage[i]
		if not uid then
			return i
		end
	end

	return self
end

function module.UpdatePlayerItemsInside(self: ClassType, plr: Player, nothing: boolean?): ClassType
	if nothing then
		self.Remote:FireClient(plr, self.UID, "UpdateItemsInside", { { DeskContents = {}, HiddenContents = {} } })
	else
		print(self.PlayerOwner)
		local tabToSend = {}
		local itemsInside = self.ItemsInside
		for contentName, contentTab in itemsInside do
			local owner = self.PlayerOwner
			if owner and owner ~= plr and contentName == "HiddenContents" then
				continue
			end
			tabToSend[contentName] = {}
			for _, itemUID in contentTab do
				table.insert(tabToSend[contentName], itemUID)
				local item = instancesManager.getObj(itemUID)
				if item then
					item:Replicate(true)
				end
			end
		end
		print(tabToSend)
		self.Remote:FireClient(plr, self.UID, "UpdateItemsInside", { tabToSend })
	end
	return self
end

function module.UpdatePlayerSearchingItemsInside(self: ClassType)
	if not #self.PlayersSearching then
		return self
	end
	local plrs = self.PlayersSearching
	for _, plr in plrs do
		self:UpdatePlayerItemsInside(plr)
	end

	return self
end

function module.AddItem(self: ClassType, itemUID: string, contentName: Storages)
	if not itemUID then
		return self
	end
	local item = instancesManager.getObj(itemUID)
	if not item then
		return self
	end
	contentName = contentName or "DeskContents"

	local itemsInside = self.ItemsInside
	local contentTab = itemsInside[contentName]
	if table.find(contentTab, itemUID) then
		return self
	end

	local pos = self:getNextFreeSlot(contentName)
	if pos then
		contentTab[pos] = itemUID
		item:InstantiateTo(self.UID, contentName)
	end

	self:UpdatePlayerSearchingItemsInside()
	return self
end

function module.RemoveItem(self: ClassType, itemUID: string, contentName: Storages?)
	print("REMOVE")
	print(itemUID)
	print(self.ItemsInside)
	if contentName then
		local itemsInside = self.ItemsInside
		local chestStorage = itemsInside[contentName]
		local pos = table.find(chestStorage, itemUID)
		if pos then
			chestStorage[pos] = nil
		end
	else
		print()
		local itemsInside = self.ItemsInside
		for _, storage in itemsInside do
			local pos = table.find(storage, itemUID)
			print(storage)
			print(pos)
			if pos then
				print(storage[pos])
				storage[pos] = nil
				return self
			end
		end
	end
	print(self.ItemsInside)

	self:UpdatePlayerSearchingItemsInside()
	return self
end

function module.UpdatePlayerSearching(self: ClassType, plr: Player)
	if not t.Player(plr) then
		return self
	end

	local findPlayer = table.find(self.PlayersSearching, plr)
	local value = not findPlayer and self.UID or nil

	if findPlayer then
		table.remove(self.PlayersSearching, findPlayer)
	else
		table.insert(self.PlayersSearching, plr)
	end

	plr:SetAttribute("ChestOpen", value)
	return self
end

function module.playerBeganHoldingProximityPrompt(self: ClassType, plr: Player)
	local playerPing = plr:GetNetworkPing()

	--local plrRootPart = charUtils.getAlivePlayerRootPart(plr)
	--print((plrRootPart.Position - self.CFrame.Position).Magnitude, self.MaxDistanceToInteract + 0.2)
	--if plrRootPart and (plrRootPart.Position - self.CFrame.Position).Magnitude <= self.MaxDistanceToInteract + 0.2 then
	local con

	self.SendPlayerItemsInsideThread = task.delay(self.OpenTime - playerPing * 4 - 0.1, function()
		self.SendPlayerItemsInsideThread = nil
		con:Disconnect()

		local con2
		con2 = runService.Heartbeat:Connect(function()
			local plrRootPart = charUtils.getAlivePlayerRootPart(plr)
			if
				not plrRootPart
				or (plrRootPart.Position - self.CFrame.Position).Magnitude >= self.MaxDistanceToInteract
			then
				con2:Disconnect()
				con2 = nil
				plr:SetAttribute("ChestOpen", nil)
				self:UpdatePlayerItemsInside(plr, true)
				return
			end
		end)
		self.Trove:Add(con2)

		local plrRootPart = charUtils.getAlivePlayerRootPart(plr)
		if not plrRootPart or (plrRootPart.Position - self.CFrame.Position).Magnitude >= self.MaxDistanceToInteract then
			return
		end

		plr:SetAttribute("ChestOpen", self.UID)
		self:UpdatePlayerItemsInside(plr, false)
	end)

	con = runService.Heartbeat:Connect(function()
		local plrRootPart = charUtils.getAlivePlayerRootPart(plr)
		if not plrRootPart or (plrRootPart.Position - self.CFrame.Position).Magnitude >= self.MaxDistanceToInteract then
			con:Disconnect()
			con = nil
			self:playerEndedHoldingProximityPrompt(plr)
			return
		end
	end)
	self.Trove:Add(con)
	--end

	return self
end

function module.SetOwner(self: ClassType, plr: Player?)
	if not t.Player(plr) then
		return self
	end
	self.Remote:Fire(self.UID, "SetOwner", { self.PlayerOwner })
	return self
end

function module.playerEndedHoldingProximityPrompt(self: ClassType, plr: Player)
	if self.SendPlayerItemsInsideThread then
		task.cancel(self.SendPlayerItemsInsideThread)
		self.SendPlayerItemsInsideThread = nil
		plr:SetAttribute("ChestOpen", nil)
		self:UpdatePlayerItemsInside(plr, true)
	end

	return self
end

function module.Materialize(self: ClassType, CF: CFrame)
	if not t.CFrame(CF) then
		return self
	end
	self.Remote:Fire(self.UID, "Materialize", { self.CFrame })
	return self
end

function module.ReplicateTo(self: ClassType, client: Player?)
	local newchest = lib.Remotes.instanceCreated.Chest

	if client then
		newchest:FireClient(client, self.UID)

		self.Remote:FireClient(client, self.UID, "AttachChest", { self.Id })
		self.Remote:FireClient(client, self.UID, "Materialize", { self.CFrame })
	else
		newchest:Fire(self.UID)

		self.Remote:Fire(self.UID, "AttachChest", { self.Id })
		self.Remote:Fire(self.UID, "Materialize", { self.CFrame })
	end

	return self
end

return module
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4759be5bc435f364089ffe8100001a2e</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXB44A0AFC19F54DCAB4E4E4E0E115F585">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Services</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">6e87ccb51f069bf408b38bfe00000e24</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBXC5273B02515E47BB9C88126B0F1030D2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">InventoryService</string>
						<string name="ScriptGuid">{CDD5CCF6-D6D7-4E03-B4C8-E3921DC2927E}</string>
						<ProtectedString name="Source"><![CDATA[local replicatedStorage = game:GetService('ReplicatedStorage')
local serverStorage = game:GetService('ServerStorage')
local lib = require(replicatedStorage.lib)
local InventoryUtilShared = require(replicatedStorage.Modules.Shared.Utils.InventoryUtilShared)
local remotes = lib.Remotes
local instancesManager = require(replicatedStorage.Modules.Shared.Managers.InstancesManager)
local charUtil = lib.FunctionUtils.Character
local playerDataManager = require(serverStorage.Modules.Managers.PlayerDataManager)
local GameSettings = require(replicatedStorage.Modules.Shared.GameSettings)

local MaxDistanceToGetAnItem = GameSettings.MaxDistanceToGetAnItem

local module = {}

function module.Init()
	
end

function module.Start()
	remotes.AddItemToInventory.OnServerEvent:Connect(function(plr: Player, itemUID: string)
		local plrInv = InventoryUtilShared.getPlayerInventory(plr)
		if not plrInv then return end
		if InventoryUtilShared.hasSpaceOnInventory(plrInv) then
			local item = instancesManager.getObj(itemUID)
			local itemParent = item.InstantiatedTo
			if itemParent then
				if type(itemParent) == 'string' then
					local cf
					local pos
					local whereInChest
					local dist
					if itemParent == '' then
						cf = item.CFrame
						dist = MaxDistanceToGetAnItem
					else
						itemParent = instancesManager.getObj(itemParent)
						if itemParent._Type == 'Chest' then
							if itemParent.PlayerOwner == plr then
								pos = table.find(itemParent.ItemsInside.HiddenContents, itemUID)
								whereInChest = itemParent.ItemsInside.HiddenContents
								dist = itemParent.MaxDistanceToInteract
							end
							if not pos then
								pos = table.find(itemParent.ItemsInside.DeskContents, itemUID)
								whereInChest = itemParent.ItemsInside.DeskContents
								dist = itemParent.MaxDistanceToInteract
							end
							if not pos then
								warn('item '.. itemUID.. ' does not have a chest as a parent anymore')
								return
							end
							cf = itemParent.CFrame
						end
					end
					local rootPart = charUtil.getAlivePlayerRootPart(plr)
					if rootPart and (rootPart.Position - cf.Position).Magnitude <= dist then
						if pos then 
							table.remove(whereInChest, pos) 
						end
						item:InstantiateTo(plr)
						InventoryUtilShared.addItem(itemUID, plr)
					end
				end
			end
		end
	end)
end

return module
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">202599fc2afe428b08a7768300001438</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF73AB59863D64254AAC2BA47AC873B6B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlayerDataService</string>
						<string name="ScriptGuid">{DA4B7142-B9F2-4943-91EF-F4F82EFA1492}</string>
						<ProtectedString name="Source"><![CDATA[local serverStorage = game:GetService('ServerStorage')
local playersService = game:GetService('Players')
local remotes = require(game:GetService('ReplicatedStorage').lib.Remotes)
local playerLoadedEvent = remotes.PlayerLoaded

local playerData = {}
playerData.manage = require(serverStorage.Modules.Managers.PlayerDataManager)

local profileStore = require(script.ProfileStore)

local plrData = profileStore.New('PlayerInfo', playerData.manage.getPlayerTemplateData())

function playerData.Init()
	
end

function playerData.Start()
	--playersService.PlayerAdded:Connect(playerData.startPlayer)
	playerLoadedEvent.OnServerEvent:Connect(function(plr) playerData.startPlayer(plr) end)
	playersService.PlayerRemoving:Connect(playerData.finishPlayer)
end

function playerData.startPlayer(plr : Player)
	local profile = plrData:StartSessionAsync('Player_'.. plr.UserId, {
		Cancel = function()
			return plr.Parent ~= playersService
		end,
	})

	if not profile then 
		print('error: 1 Rejoin, an error occurred')
	else
		profile:AddUserId(plr.UserId)
		profile:Reconcile()

		profile.OnSessionEnd:Connect(function()
			playerData.manage._cache[plr] = nil
			plr:Kick('error: 2 Rejoin, an error occurred')
		end)

		if plr.Parent == playersService then
			playerData.manage.setStats(plr, profile)
			--playerData.manage.updateClient(plr)
		else
			profile:EndSession()
		end
	end
	--playerData.manage.resetStat(plr)
end

function playerData.finishPlayer(plr: Player)
	local profile = playerData.manage.getPlayerSalvableData(plr)
	print(profile)
	if not profile then return end
	--playerData.manage.resetStat(plr)
	profile:EndSession()
	playerData.manage._cache[plr] = nil
end

return playerData]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">551644548e65349908aacf550000246d</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBXC6C5240D8A944C52837FD80297BB2A2E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">7745f3117c4a251a089954ce00004f08</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ProfileStore</string>
							<string name="ScriptGuid">{A8D77384-C78F-451D-93E7-7A20609C34B9}</string>
							<ProtectedString name="Source"><![CDATA[--[[
MAD STUDIO (by loleris)

-[ProfileStore]---------------------------------------

	Periodic DataStore saving solution with session locking
	
	WARNINGS FOR "Profile.Data" VALUES:
	 	! Do not create numeric tables with gaps - attempting to store such tables will result in an error.
		! Do not create mixed tables (some values indexed by number and others by a string key)
			- only numerically indexed  data will be stored.
		! Do not index tables by anything other than numbers and strings.
		! Do not reference Roblox Instances
		! Do not reference userdata (Vector3, Color3, CFrame...) - Serialize userdata before referencing
		! Do not reference functions
		
	Members:
	
		ProfileStore.IsClosing          [bool]
			-- Set to true after a game:BindToClose() trigger
			
		ProfileStore.IsCriticalState    [bool]
			-- Set to true when ProfileStore experiences too many consecutive errors
		
		ProfileStore.OnError            [Signal] (message, store_name, profile_key)
			-- Most ProfileStore errors will be caught and passed to this signal
			
		ProfileStore.OnOverwrite        [Signal] (store_name, profile_key)
			-- Triggered when a DataStore key was likely used to store data that wasn't
			a ProfileStore profile or the ProfileStore structure was invalidly manually
			altered for that DataStore key
			
		ProfileStore.OnCriticalToggle   [Signal] (is_critical)
			-- Triggered when ProfileStore experiences too many consecutive errors
		
		ProfileStore.DataStoreState     [string] ("NotReady", "NoInternet", "NoAccess", "Access")
			-- This value resembles ProfileStore's access to the DataStore; The value starts
			as "NotReady" and will eventually change to one of the other 3 possible values.
	
	Functions:
	
		ProfileStore.New(store_name, template?) --> [ProfileStore]
			store_name   [string] -- DataStore name
			template     [table] or nil -- Profiles will default to given table (hard-copy) when no data was saved previously
			
		ProfileStore.SetConstant(name, value)
			name    [string]
			value   [number]
				
	Members [ProfileStore]:
	
		ProfileStore.Mock   [ProfileStore]
			-- Reflection of ProfileStore utils, but the utils will now query a mock
			DataStore with no relation to the real DataStore
			
		ProfileStore.Name   [string]
		
	Utils [ProfileStore]:
	
		ProfileStore:StartSessionAsync(profile_key, params?) --> [Profile] or nil
			profile_key [string] -- DataStore key
			params      nil or [table]: -- Custom params; E.g. {Steal = true}
				{
					Steal = true, -- Pass this to disregard an existing session lock
					Cancel = fn() -> (boolean), -- Pass this to create a request cancel condition.
						-- If the cancel function returns true, ProfileStore will stop trying to
						-- start the session and return nil
				}
			
		ProfileStore:MessageAsync(profile_key, message) --> is_success [bool]
			profile_key [string] -- DataStore key
			message     [table] -- Data to be messaged to the profile
			
		ProfileStore:GetAsync(profile_key, version?) --> [Profile] or nil
			-- Reads a profile without starting a session - will not autosave
			profile_key   [string] -- DataStore key
			version       nil or [string] -- DataStore key version

		ProfileStore:VersionQuery(profile_key, sort_direction?, min_date?, max_date?) --> [VersionQuery]
			profile_key      [string]
			sort_direction   nil or [Enum.SortDirection]
			min_date         nil or [DateTime]
			max_date         nil or [DateTime]
			
		ProfileStore:RemoveAsync(profile_key) --> is_success [bool]
			-- Completely removes profile data from the DataStore / mock DataStore with no way to recover it.

	Utils [VersionQuery]:

		VersionQuery:NextAsync() --> [Profile] or nil -- (Yields)
			-- Returned profile is similar to profiles returned by ProfileStore:GetAsync()
		
	Members [Profile]:
	
		Profile.Data               [table]
			-- When the profile is active changes to this table are guaranteed to be saved
		Profile.LastSavedData      [table] (Read-only)
			-- Last snapshot of "Profile.Data" that has been successfully saved to the DataStore;
			Useful for proper developer product purchase receipt handling
		
		Profile.FirstSessionTime   [number] (Read-only)
			-- os.time() timestamp of the first profile session
			
		Profile.SessionLoadCount   [number] (Read-only) -- Amount of times a session was started for this profile
			
		Profile.Session            [table] (Read-only) {PlaceId = number, JobId = string} / nil
			-- Set to a table if this profile is in use by a server; nil if released

		Profile.RobloxMetaData     [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.UserIds            [table] -- (Read-only) -- {user_id [number], ...} -- User ids associated with this profile

		Profile.KeyInfo            [DataStoreKeyInfo] -- Changes before OnAfterSave signal
		
		Profile.OnSave             [Signal] ()
			-- Triggered right before changes to Profile.Data are saved to the DataStore
			
		Profile.OnLastSave         [Signal] (reason [string]: "Manual", "External", "Shutdown")
			-- Triggered right before changes to Profile.Data are saved to the DataStore
			for the last time; A reason is provided for the last save:
				- "Manual"   - Profile:EndSession() was called
				- "Shutdown" - The server that has ownership of this profile is shutting down
				- "External" - Another server has started a session for this profile
			Note that this event will not trigger for when a profile session is ended by
			another server trying to take ownership of the session - this is impossible to
			do without compromising on ProfileStore's speed.
			
		Profile.OnSessionEnd       [Signal] ()
			-- Triggered when the profile session is terminated on this server
		
		Profile.OnAfterSave        [Signal] (last_saved_data)
			-- Triggered after a successful save
			last_saved_data [table] -- Profile.LastSavedData
			
		Profile.ProfileStore       [ProfileStore] -- ProfileStore object this profile belongs to
		Profile.Key                [string] -- DataStore key
		
	Utils [Profile]:
	
		Profile:IsActive() --> [bool] -- If "true" is returned, changes to Profile.Data are guaranteed to save;
			This guarantee is only valid until code yields (e.g. task.wait() is used).
			
		Profile:Reconcile() -- Fills in missing (nil) [string_key] = [value] pairs to the Profile.Data structure
			from the "template" argument that was passed to "ProfileStore.New()"
			
		Profile:EndSession() -- Call after the server has finished working with this profile
			e.g., after the player leaves (Profile object will become inactive)

		Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)
			user_id   [number]

		Profile:RemoveUserId(user_id) -- Unassociates user_id with profile (safe function)
			user_id   [number]
			
		Profile:MessageHandler(fn) -- Sets a message handler for this profile
			fn [function] (message [table], processed [function]())
			-- The handler function receives a message table and a callback function;
			The callback function is to be called when a message has been processed
			- this will discard the message from the profile message cache; If the
			callback function is not called, other message handlers will also be triggered
			with unprocessed message data.
			
		Profile:Save() -- If the profile session is still active makes an UpdateAsync call
			to the DataStore to immediately save profile data

		Profile:SetAsync() -- Forcefully saves changes to the profile; Only for profiles
			loaded with ProfileStore:GetAsync() or ProfileStore:VersionQuery()
		
--]]

local AUTO_SAVE_PERIOD = 100000000 -- (Seconds) Time between when changes to a profile are saved to the DataStore
local LOAD_REPEAT_PERIOD = 10 -- (Seconds) Time between successive profile reads when handling a session conflict
local FIRSTrLOAD_REPEAT = 5 -- (Seconds) Time between first and second profile read when handling a session conflict
local SESSION_STEAL = 40 -- (Seconds) Time until a session conflict is resolved with the waiting server stealing the session
local ASSUME_DEAD = 630 -- (Seconds) If a profile hasn't had updates for this long, quickly assume an active session belongs to a crashed server
local START_SESSION_TIMEOUT = 120 -- (Seconds) If a session can't be started for a profile for this long, stop repeating calls to the DataStore

local CRITICAL_STATE_ERROR_COUNT = 5 -- Assume critical state if this many issues happen in a short amount of time
local CRITICAL_STATE_ERROR_EXPIRE = 120 -- (Seconds) Individual issue expiration
local CRITICAL_STATE_EXPIRE = 120 -- (Seconds) Critical state expiration

local MAX_MESSAGE_QUEUE = 1000 -- Max messages saved in a profile that were sent using "ProfileStore:MessageAsync()"

----- Dependencies -----

-- local Util = require(game.ReplicatedStorage.Shared.Util)
-- local Signal = Util.Signal

local Signal do

	local FreeRunnerThread

	--[[
		Yield-safe coroutine reusing by stravant;
		Sources:
		https://devforum.roblox.com/t/lua-signal-class-comparison-optimal-goodsignal-class/1387063
		https://gist.github.com/stravant/b75a322e0919d60dde8a0316d1f09d2f
	--]]

	local function AcquireRunnerThreadAndCallEventHandler(fn, ...)
		local acquired_runner_thread = FreeRunnerThread
		FreeRunnerThread = nil
		fn(...)
		-- The handler finished running, this runner thread is free again.
		FreeRunnerThread = acquired_runner_thread
	end

	local function RunEventHandlerInFreeThread(...)
		AcquireRunnerThreadAndCallEventHandler(...)
		while true do
			AcquireRunnerThreadAndCallEventHandler(coroutine.yield())
		end
	end

	local Connection = {}
	Connection.__index = Connection

	local SignalClass = {}
	SignalClass.__index = SignalClass

	function Connection:Disconnect()

		if self.is_connected == false then
			return
		end

		local signal = self.signal
		self.is_connected = false
		signal.listener_count -= 1

		if signal.head == self then
			signal.head = self.next
		else
			local prev = signal.head
			while prev ~= nil and prev.next ~= self do
				prev = prev.next
			end
			if prev ~= nil then
				prev.next = self.next
			end
		end

	end

	function SignalClass.New()

		local self = {
			head = nil,
			listener_count = 0,
		}
		setmetatable(self, SignalClass)

		return self

	end

	function SignalClass:Connect(listener: (...any) -> ())

		if type(listener) ~= "function" then
			error(`[{script.Name}]: \"listener\" must be a function; Received {typeof(listener)}`)
		end

		local connection = {
			listener = listener,
			signal = self,
			next = self.head,
			is_connected = true,
		}
		setmetatable(connection, Connection)

		self.head = connection
		self.listener_count += 1

		return connection

	end

	function SignalClass:GetListenerCount(): number
		return self.listener_count
	end

	function SignalClass:Fire(...)
		local item = self.head
		while item ~= nil do
			if item.is_connected == true then
				if not FreeRunnerThread then
					FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
				end
				task.spawn(FreeRunnerThread, item.listener, ...)
			end
			item = item.next
		end
	end

	function SignalClass:Wait()
		local co = coroutine.running()
		local connection
		connection = self:Connect(function(...)
			connection:Disconnect()
			task.spawn(co, ...)
		end)
		return coroutine.yield()
	end

	Signal = table.freeze({
		New = SignalClass.New,
	})

end

----- Private -----

local ActiveSessionCheck = {} -- {[session_token] = profile, ...}
local AutoSaveList = {} -- {profile, ...} -- Loaded profile table which will be circularly auto-saved
local IssueQueue = {} -- {issue_time, ...}

local DataStoreService = game:GetService("DataStoreService")
local MessagingService = game:GetService("MessagingService")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local PlaceId = game.PlaceId
local JobId = game.JobId

local AutoSaveIndex = 1 -- Next profile to auto save
local LastAutoSave = os.clock()

local LoadIndex = 0

local ActiveProfileLoadJobs = 0 -- Number of active threads that are loading in profiles
local ActiveProfileSaveJobs = 0 -- Number of active threads that are saving profiles

local CriticalStateStart = 0 -- os.clock()

local IsStudio = RunService:IsStudio()
local DataStoreState: "NotReady" | "NoInternet" | "NoAccess" | "Access" = "NotReady"

local MockStore = {}
local UserMockStore = {}
local MockFlag = false

local OnError = Signal.New() -- (message, store_name, profile_key)
local OnOverwrite = Signal.New() -- (store_name, profile_key)

local UpdateQueue = { -- For stability sake, we won't do UpdateAsync calls for the same key until all previous calls finish
	--[[
		[session_token] = {
			coroutine, ...
		},
		...
	--]]
}

local function WaitInUpdateQueue(session_token) --> next_in_queue()

	local is_first = false

	if UpdateQueue[session_token] == nil then
		is_first = true
		UpdateQueue[session_token] = {}
	end

	local queue = UpdateQueue[session_token]

	if is_first == false then
		table.insert(queue, coroutine.running())
		coroutine.yield()
	end

	return function()
		local next_co = table.remove(queue, 1)
		if next_co ~= nil then
			coroutine.resume(next_co)
		else
			UpdateQueue[session_token] = nil
		end
	end

end

local function SessionToken(store_name, profile_key, is_mock)

	local session_token = "L_" -- Live

	if is_mock == true then
		session_token = "U_" -- User mock
	elseif DataStoreState ~= "Access" then
		session_token = "M_" -- Mock, cause no DataStore access
	end

	session_token ..= store_name .. "\0" .. profile_key

	return session_token

end

local function DeepCopyTable(t)
	local copy = {}
	for key, value in pairs(t) do
		if type(value) == "table" then
			copy[key] = DeepCopyTable(value)
		else
			copy[key] = value
		end
	end
	return copy
end

local function ReconcileTable(target, template)
	for k, v in pairs(template) do
		if type(k) == "string" then -- Only string keys will be reconciled
			if target[k] == nil then
				if type(v) == "table" then
					target[k] = DeepCopyTable(v)
				else
					target[k] = v
				end
			elseif type(target[k]) == "table" and type(v) == "table" then
				ReconcileTable(target[k], v)
			end
		end
	end
end

local function RegisterError(error_message, store_name, profile_key) -- Called when a DataStore API call errors
	warn(`[{script.Name}]: DataStore API error (STORE:{store_name}; KEY:{profile_key}) - {tostring(error_message)}`)
	table.insert(IssueQueue, os.clock()) -- Adding issue time to queue
	OnError:Fire(tostring(error_message), store_name, profile_key)
end

local function RegisterOverwrite(store_name, profile_key) -- Called when a corrupted profile is loaded
	warn(`[{script.Name}]: Invalid profile was overwritten (STORE:{store_name}; KEY:{profile_key})`)
	OnOverwrite:Fire(store_name, profile_key)
end

local function NewMockDataStoreKeyInfo(params)

	local version_id_string = tostring(params.VersionId or 0)
	local meta_data = params.MetaData or {}
	local user_ids = params.UserIds or {}

	return {
		CreatedTime = params.CreatedTime,
		UpdatedTime = params.UpdatedTime,
		Version = string.rep("0", 16) .. "."
			.. string.rep("0", 10 - string.len(version_id_string)) .. version_id_string
			.. "." .. string.rep("0", 16) .. "." .. "01",

		GetMetadata = function()
			return DeepCopyTable(meta_data)
		end,

		GetUserIds = function()
			return DeepCopyTable(user_ids)
		end,
	}

end

local function MockUpdateAsync(mock_data_store, profile_store_name, key, transform_function, is_get_call) --> loaded_data, key_info

	local profile_store = mock_data_store[profile_store_name]

	if profile_store == nil then
		profile_store = {}
		mock_data_store[profile_store_name] = profile_store
	end

	local epoch_time = math.floor(os.time() * 1000)
	local mock_entry = profile_store[key]
	local mock_entry_was_nil = false

	if mock_entry == nil then
		mock_entry_was_nil = true
		if is_get_call ~= true then
			mock_entry = {
				Data = nil,
				CreatedTime = epoch_time,
				UpdatedTime = epoch_time,
				VersionId = 0,
				UserIds = {},
				MetaData = {},
			}
			profile_store[key] = mock_entry
		end
	end

	local mock_key_info = mock_entry_was_nil == false and NewMockDataStoreKeyInfo(mock_entry) or nil

	local transform, user_ids, roblox_meta_data = transform_function(mock_entry and mock_entry.Data, mock_key_info)

	if transform == nil then
		return nil
	else
		if mock_entry ~= nil and is_get_call ~= true then
			mock_entry.Data = DeepCopyTable(transform)
			mock_entry.UserIds = DeepCopyTable(user_ids or {})
			mock_entry.MetaData = DeepCopyTable(roblox_meta_data or {})
			mock_entry.VersionId += 1
			mock_entry.UpdatedTime = epoch_time
		end

		return DeepCopyTable(transform), mock_entry ~= nil and NewMockDataStoreKeyInfo(mock_entry) or nil
	end

end

local function UpdateAsync(profile_store, profile_key, transform_params, is_user_mock, is_get_call, version) --> loaded_data, key_info
	--transform_params = {
	--	ExistingProfileHandle = function(latest_data),
	--	MissingProfileHandle = function(latest_data),
	--	EditProfile = function(lastest_data),
	--}

	local loaded_data, key_info

	local next_in_queue = WaitInUpdateQueue(SessionToken(profile_store.Name, profile_key, is_user_mock))

	local success = true

	local success, error_message = pcall(function()
		local transform_function = function(latest_data)

			local missing_profile = false
			local overwritten = false
			local global_updates = {0, {}}

			if latest_data == nil then

				missing_profile = true

			elseif type(latest_data) ~= "table" then

				missing_profile = true
				overwritten = true

			else

				if type(latest_data.Data) == "table" and type(latest_data.MetaData) == "table" and type(latest_data.GlobalUpdates) == "table" then

					-- Regular profile structure detected:

					latest_data.WasOverwritten = false -- Must be set to false if set previously
					global_updates = latest_data.GlobalUpdates

					if transform_params.ExistingProfileHandle ~= nil then
						transform_params.ExistingProfileHandle(latest_data)
					end

				elseif latest_data.Data == nil and latest_data.MetaData == nil and type(latest_data.GlobalUpdates) == "table" then

					-- Regular structure not detected, but GlobalUpdate data exists:

					latest_data.WasOverwritten = false -- Must be set to false if set previously
					global_updates = latest_data.GlobalUpdates or global_updates
					missing_profile = true

				else

					missing_profile = true
					overwritten = true

				end

			end

			-- Profile was not created or corrupted and no GlobalUpdate data exists:
			if missing_profile == true then
				latest_data = {
					-- Data = nil,
					-- MetaData = nil,
					GlobalUpdates = global_updates,
				}
				if transform_params.MissingProfileHandle ~= nil then
					transform_params.MissingProfileHandle(latest_data)
				end
			end

			-- Editing profile:
			if transform_params.EditProfile ~= nil then
				transform_params.EditProfile(latest_data)
			end

			-- Invalid data handling (Silently override with empty profile)
			if overwritten == true then
				latest_data.WasOverwritten = true -- Temporary tag that will be removed on first save
			end

			return latest_data, latest_data.UserIds, latest_data.RobloxMetaData
		end

		if is_user_mock == true then -- Used when the profile is accessed through ProfileStore.Mock

			loaded_data, key_info = MockUpdateAsync(UserMockStore, profile_store.Name, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield

		elseif DataStoreState ~= "Access" then -- Used when API access is disabled

			loaded_data, key_info = MockUpdateAsync(MockStore, profile_store.Name, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield

		else

			if is_get_call == true then

				if version ~= nil then

					local success, error_message = pcall(function()
						loaded_data, key_info = profile_store.data_store:GetVersionAsync(profile_key, version)
					end)

					if success == false and type(error_message) == "string" and string.find(error_message, "not valid") ~= nil then
						warn(`[{script.Name}]: Passed version argument is not valid; Traceback:\n` .. debug.traceback())
					end

				else

					loaded_data, key_info = profile_store.data_store:GetAsync(profile_key)

				end

				loaded_data = transform_function(loaded_data)

			else

				loaded_data, key_info = profile_store.data_store:UpdateAsync(profile_key, transform_function)

			end

		end

	end)

	next_in_queue()

	if success == true and type(loaded_data) == "table" then
		-- Invalid data handling:
		if loaded_data.WasOverwritten == true and is_get_call ~= true then
			RegisterOverwrite(
				profile_store.Name,
				profile_key
			)
		end
		-- Return loaded_data:
		return loaded_data, key_info
	else
		-- Error handling:
		RegisterError(
			error_message or "Undefined error",
			profile_store.Name,
			profile_key
		)
		-- Return nothing:
		return nil
	end

end

local function IsThisSession(session_tag)
	return session_tag[1] == PlaceId and session_tag[2] == JobId
end

local function ReadMockFlag(): boolean
	local is_mock = MockFlag
	MockFlag = false
	return is_mock
end

local function WaitForStoreReady(profile_store)
	while profile_store.is_ready == false do
		task.wait()
	end
end

local function AddProfileToAutoSave(profile)

	ActiveSessionCheck[profile.session_token] = profile

	-- Add at AutoSaveIndex and move AutoSaveIndex right:

	table.insert(AutoSaveList, AutoSaveIndex, profile)

	if #AutoSaveList > 1 then
		AutoSaveIndex = AutoSaveIndex + 1
	elseif #AutoSaveList == 1 then
		-- First profile created - make sure it doesn't get immediately auto saved:
		LastAutoSave = os.clock()
	end

end

local function RemoveProfileFromAutoSave(profile)

	ActiveSessionCheck[profile.session_token] = nil

	local auto_save_index = table.find(AutoSaveList, profile)

	if auto_save_index ~= nil then
		table.remove(AutoSaveList, auto_save_index)
		if auto_save_index < AutoSaveIndex then
			AutoSaveIndex = AutoSaveIndex - 1 -- Table contents were moved left before AutoSaveIndex so move AutoSaveIndex left as well
		end
		if AutoSaveList[AutoSaveIndex] == nil then -- AutoSaveIndex was at the end of the AutoSaveList - reset to 1
			AutoSaveIndex = 1
		end
	end

end

local function SaveProfileAsync(profile, is_ending_session, is_overwriting, last_save_reason)

	if type(profile.Data) ~= "table" then
		error(`[{script.Name}]: Developer code likely set "Profile.Data" to a non-table value! (STORE:{profile.ProfileStore.Name}; KEY:{profile.Key})`)
	end

	profile.OnSave:Fire()
	if is_ending_session == true then
		profile.OnLastSave:Fire(last_save_reason or "Manual")
	end

	if is_ending_session == true and is_overwriting ~= true then
		if profile.roblox_message_subscription ~= nil then
			profile.roblox_message_subscription:Disconnect()
		end
		RemoveProfileFromAutoSave(profile)
		profile.OnSessionEnd:Fire()
	end

	ActiveProfileSaveJobs = ActiveProfileSaveJobs + 1

	-- Compare "SessionLoadCount" when writing to profile to prevent a rare case of repeat last save when the profile is loaded on the same server again

	local repeat_save_flag = true -- Released Profile save calls have to repeat until they succeed
	local exp_backoff = 1

	while repeat_save_flag == true do

		if is_ending_session ~= true then
			repeat_save_flag = false
		end

		local loaded_data, key_info = UpdateAsync(
			profile.ProfileStore,
			profile.Key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					-- Check if this session still owns the profile:

					local session_owns_profile = false

					if is_overwriting ~= true then

						local active_session = latest_data.MetaData.ActiveSession
						local sessionrLoad_count = latest_data.MetaData.SessionLoadCount

						if type(active_session) == "table" then
							session_owns_profile = IsThisSession(active_session) and sessionrLoad_count == profile.load_index
						end

					else
						session_owns_profile = true
					end

					-- We may only edit the profile if this server has ownership of the profile:

					if session_owns_profile == true then

						-- Clear processed updates (messages):

						local locked_updates = profile.locked_global_updates -- [index] = true, ...
						local active_updates = latest_data.GlobalUpdates[2]
						-- ProfileService module format: {{update_id, version_id, updaterLocked, update_data}, ...}
						-- ProfileStore module format: {{update_id, update_data}, ...}

						if next(locked_updates) ~= nil then
							local i = 1
							while i <= #active_updates do
								local update = active_updates[i]
								if locked_updates[update[1]] == true then
									table.remove(active_updates, i)
								else
									i += 1
								end
							end
						end

						-- Save profile data:

						latest_data.Data = profile.Data
						latest_data.RobloxMetaData = profile.RobloxMetaData
						latest_data.UserIds = profile.UserIds

						if is_overwriting ~= true then

							latest_data.MetaData.LastUpdate = os.time()

							if is_ending_session == true then
								latest_data.MetaData.ActiveSession = nil
							end

						else

							latest_data.MetaData.ActiveSession = nil
							latest_data.MetaData.ForceLoadSession = nil

						end

					end

				end,
			},
			profile.is_mock
		)

		if loaded_data ~= nil and key_info ~= nil then

			if is_overwriting == true then
				break
			end

			repeat_save_flag = false

			local active_session = loaded_data.MetaData.ActiveSession
			local sessionrLoad_count = loaded_data.MetaData.SessionLoadCount
			local session_owns_profile = false

			if type(active_session) == "table" then
				session_owns_profile = IsThisSession(active_session) and sessionrLoad_count == profile.load_index
			end

			local forcerLoad_session = loaded_data.MetaData.ForceLoadSession
			local forcerLoad_pending = false
			if type(forcerLoad_session) == "table" then
				forcerLoad_pending = not IsThisSession(forcerLoad_session)
			end

			local is_active = profile:IsActive()

			-- If another server is trying to start a session for this profile - end the session:

			if forcerLoad_pending == true and session_owns_profile == true then
				if is_active == true then
					SaveProfileAsync(profile, true, false, "External")
				end
				break
			end

			-- Clearing processed update list / Detecting new updates:

			local locked_updates = profile.locked_global_updates -- [index] = true, ...
			local received_updates = profile.received_global_updates -- [index] = true, ...
			local active_updates = loaded_data.GlobalUpdates[2]

			local new_updates = {} -- {}, ...
			local still_pending = {} -- [index] = true, ...

			for _, update in ipairs(active_updates) do
				if locked_updates[update[1]] == true then
					still_pending[update[1]] = true
				elseif received_updates[update[1]] ~= true then
					received_updates[update[1]] = true
					table.insert(new_updates, update)
				end
			end

			for index in pairs(locked_updates) do
				if still_pending[index] ~= true then
					locked_updates[index] = nil
				end
			end

			-- Updating profile values:

			profile.KeyInfo = key_info
			profile.LastSavedData = loaded_data.Data
			profile.global_updates = loaded_data.GlobalUpdates and loaded_data.GlobalUpdates[2] or {}

			if session_owns_profile == true then
				if is_active == true and is_ending_session ~= true then

					-- Processing new global updates (messages):

					for _, update in ipairs(new_updates) do

						local index = update[1]
						local update_data = update[#update] -- Backwards compatibility with ProfileService

						for _, handler in ipairs(profile.message_handlers) do

							local is_processed = false
							local processed_callback = function()
								is_processed = true
								locked_updates[index] = true
							end

							local send_update_data = DeepCopyTable(update_data)

							task.spawn(handler, send_update_data, processed_callback)

							if is_processed == true then
								break
							end

						end

					end

				end
			else

				if profile.roblox_message_subscription ~= nil then
					profile.roblox_message_subscription:Disconnect()
				end

				if is_active == true then
					RemoveProfileFromAutoSave(profile)
					profile.OnSessionEnd:Fire()
				end

			end

			profile.OnAfterSave:Fire(profile.LastSavedData)

		elseif repeat_save_flag == true then

			-- DataStore call likely resulted in an error; Repeat the DataStore call shortly
			task.wait(exp_backoff)
			exp_backoff = math.min(if last_save_reason == "Shutdown" then 8 else 20, exp_backoff * 2)

		end

	end

	ActiveProfileSaveJobs = ActiveProfileSaveJobs - 1

end

----- Public -----

--[[
	Saved profile structure:
	
	{
		Data = {},
		
		MetaData = {
			ProfileCreateTime = 0,
			SessionLoadCount = 0,
			ActiveSession = {place_id, game_job_id, unique_session_id} / nil,
			ForceLoadSession = {place_id, game_job_id} / nil,
			LastUpdate = 0, -- os.time()
			MetaTags = {}, -- Backwards compatibility with ProfileService
		},
		
		RobloxMetaData = {},
		UserIds = {},
		
		GlobalUpdates = {
			update_index,
			{
				{update_index, data}, ...
			},
		},
	}

--]]

export type JSONAcceptable = { JSONAcceptable } | { [string]: JSONAcceptable } | number | string | boolean | buffer

export type Profile<T> = {
	Data: T & JSONAcceptable,
	LastSavedData: T & JSONAcceptable,
	FirstSessionTime: number,
	SessionLoadCount: number,
	Session: {PlaceId: number, JobId: string}?,
	RobloxMetaData: JSONAcceptable,
	UserIds: {number},
	KeyInfo: DataStoreKeyInfo,
	OnSave: {Connect: (self: any, listener: () -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnLastSave: {Connect: (self: any, listener: (reason: "Manual" | "External" | "Shutdown") -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnSessionEnd: {Connect: (self: any, listener: () -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnAfterSave: {Connect: (self: any, listener: (last_saved_data: T & JSONAcceptable) -> ()) -> ({Disconnect: (self: any) -> ()})},
	ProfileStore: JSONAcceptable,
	Key: string,

	IsActive: (self: any) -> (boolean),
	Reconcile: (self: any) -> (),
	EndSession: (self: any) -> (),
	AddUserId: (self: any, user_id: number) -> (),
	RemoveUserId: (self: any, user_id: number) -> (),
	MessageHandler: (self: any, fn: (message: JSONAcceptable, processed: () -> ()) -> ()) -> (),
	Save: (self: any) -> (),
	SetAsync: (self: any) -> (),
}

export type VersionQuery<T> = {
	NextAsync: (self: any) -> (Profile<T>?),
}

type ProfileStoreStandard<T> = {
	Name: string,
	StartSessionAsync: (self: any, profile_key: string, params: {Steal: boolean?}) -> (Profile<T>?),
	MessageAsync: (self: any, profile_key: string, message: JSONAcceptable) -> (boolean),
	GetAsync: (self: any, profile_key: string, version: string?) -> (Profile<T>?),
	VersionQuery: (self: any, profile_key: string, sort_direction: Enum.SortDirection?, min_date: DateTime | number | nil, max_date: DateTime | number | nil) -> (VersionQuery<T>),
	RemoveAsync: (self: any, profile_key: string) -> (boolean),
}

export type ProfileStore<T> = {
	Mock: ProfileStoreStandard<T>,
} & ProfileStoreStandard<T>

type ConstantName = "AUTO_SAVE_PERIOD" | "LOAD_REPEAT_PERIOD" | "FIRSTrLOAD_REPEAT" | "SESSION_STEAL"
| "ASSUME_DEAD" | "START_SESSION_TIMEOUT" | "CRITICAL_STATE_ERROR_COUNT" | "CRITICAL_STATE_ERROR_EXPIRE"
| "CRITICAL_STATE_EXPIRE" | "MAX_MESSAGE_QUEUE"

export type ProfileStoreModule = {
	IsClosing: boolean,
	IsCriticalState: boolean,
	OnError: {Connect: (self: any, listener: (message: string, store_name: string, profile_key: string) -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnOverwrite: {Connect: (self: any, listener: (store_name: string, profile_key: string) -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnCriticalToggle: {Connect: (self: any, listener: (is_critical: boolean) -> ()) -> ({Disconnect: (self: any) -> ()})},
	DataStoreState: "NotReady" | "NoInternet" | "NoAccess" | "Access",
	New: <T>(store_name: string, template: (T & JSONAcceptable)?) -> (ProfileStore<T>),
	SetConstant: (name: ConstantName, value: number) -> ()
}

local Profile = {}
Profile.__index = Profile

function Profile.New(raw_data, key_info, profile_store, key, is_mock, session_token)

	local data = raw_data.Data or {}
	local session = raw_data.MetaData and raw_data.MetaData.ActiveSession or nil

	local global_updates = raw_data.GlobalUpdates and raw_data.GlobalUpdates[2] or {}
	local received_global_updates = {}

	for _, update in ipairs(global_updates) do
		received_global_updates[update[1]] = true
	end

	local self = {

		Data = data,
		LastSavedData = DeepCopyTable(data),

		FirstSessionTime = raw_data.MetaData and raw_data.MetaData.ProfileCreateTime or 0,
		SessionLoadCount = raw_data.MetaData and raw_data.MetaData.SessionLoadCount or 0,
		Session = session and {PlaceId = session[1], JobId = session[2]},

		RobloxMetaData = raw_data.RobloxMetaData or {},
		UserIds = raw_data.UserIds or {},
		KeyInfo = key_info,

		OnAfterSave = Signal.New(),
		OnSave = Signal.New(),
		OnLastSave = Signal.New(),
		OnSessionEnd = Signal.New(),

		ProfileStore = profile_store,
		Key = key,

		load_timestamp = os.clock(),
		is_mock = is_mock,
		session_token = session_token or "",
		load_index = raw_data.MetaData and raw_data.MetaData.SessionLoadCount or 0,
		locked_global_updates = {},
		received_global_updates = received_global_updates,
		message_handlers = {},
		global_updates = global_updates,

	}
	setmetatable(self, Profile)

	return self

end

function Profile:IsActive()
	return ActiveSessionCheck[self.session_token] == self
end

function Profile:Reconcile()
	ReconcileTable(self.Data, self.ProfileStore.template)
end

function Profile:EndSession()
	if self:IsActive() == true then
		task.spawn(SaveProfileAsync, self, true, nil, "Manual") -- Call save function in a new thread with release_from_session = true
	end
end

function Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn(`[{script.Name}]: Invalid UserId argument for :AddUserId() ({tostring(user_id)}); Traceback:\n` .. debug.traceback())
		return
	end

	if user_id < 0 and self.is_mock ~= true and DataStoreState == "Access" then
		return -- Avoid giving real Roblox APIs negative UserId's
	end

	if table.find(self.UserIds, user_id) == nil then
		table.insert(self.UserIds, user_id)
	end

end

function Profile:RemoveUserId(user_id) -- Unassociates user_id with profile (safe function)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn(`[{script.Name}]: Invalid UserId argument for :RemoveUserId() ({tostring(user_id)}); Traceback:\n` .. debug.traceback())
		return
	end

	local index = table.find(self.UserIds, user_id)

	if index ~= nil then
		table.remove(self.UserIds, index)
	end

end

function Profile:SetAsync() -- Saves the profile to the DataStore and removes the session lock

	if self.view_mode ~= true then
		error(`[{script.Name}]: :SetAsync() can only be used in view mode`)
	end

	SaveProfileAsync(self, nil, true)

end

function Profile:MessageHandler(fn)

	if type(fn) ~= "function" then
		error(`[{script.Name}]: fn argument is not a function`)
	end

	if self.view_mode ~= true and self:IsActive() ~= true then
		return -- Don't process messages if the profile session was ended
	end

	local locked_updates = self.locked_global_updates
	table.insert(self.message_handlers, fn)

	for _, update in ipairs(self.global_updates) do

		local index = update[1]
		local update_data = update[#update] -- Backwards compatibility with ProfileService

		if locked_updates[index] ~= true then

			local processed_callback = function()
				locked_updates[index] = true
			end

			local send_update_data = DeepCopyTable(update_data)

			task.spawn(fn, send_update_data, processed_callback)

		end

	end

end

function Profile:Save()

	if self.view_mode == true then
		error(`[{script.Name}]: Can't save profile in view mode; Should you be calling :SetAsync() instead?`)
	end

	if self:IsActive() == false then
		warn(`[{script.Name}]: Attempted saving an inactive profile (STORE:{self.ProfileStore.Name}; KEY:{self.Key});`
			.. ` Traceback:\n` .. debug.traceback())
		return
	end

	-- Move the profile right behind the auto save index to delay the next auto save for it:
	RemoveProfileFromAutoSave(self)
	AddProfileToAutoSave(self)

	-- Perform save in new thread:
	task.spawn(SaveProfileAsync, self)

end

local ProfileStore: ProfileStoreModule = {

	IsClosing = false,
	IsCriticalState = false,
	OnError = OnError, -- (message, store_name, profile_key)
	OnOverwrite = OnOverwrite, -- (store_name, profile_key)
	OnCriticalToggle = Signal.New(), -- (is_critical)
	DataStoreState = "NotReady", -- ("NotReady", "NoInternet", "NoAccess", "Access")

}
ProfileStore.__index = ProfileStore

function ProfileStore.SetConstant(name, value)

	if type(value) ~= "number" then
		error(`[{script.Name}]: Invalid value type`)
	end

	if name == "AUTO_SAVE_PERIOD" then
		AUTO_SAVE_PERIOD = value
	elseif name == "LOAD_REPEAT_PERIOD" then
		LOAD_REPEAT_PERIOD = value
	elseif name == "FIRSTrLOAD_REPEAT" then
		FIRSTrLOAD_REPEAT = value
	elseif name == "SESSION_STEAL" then
		SESSION_STEAL = value
	elseif name == "ASSUME_DEAD" then
		ASSUME_DEAD = value
	elseif name == "START_SESSION_TIMEOUT" then
		START_SESSION_TIMEOUT = value
	elseif name == "CRITICAL_STATE_ERROR_COUNT" then
		CRITICAL_STATE_ERROR_COUNT = value
	elseif name == "CRITICAL_STATE_ERROR_EXPIRE" then
		CRITICAL_STATE_ERROR_EXPIRE = value
	elseif name == "CRITICAL_STATE_EXPIRE" then
		CRITICAL_STATE_EXPIRE = value
	elseif name == "MAX_MESSAGE_QUEUE" then
		MAX_MESSAGE_QUEUE = value
	else
		error(`[{script.Name}]: Invalid constant name was provided`)
	end

end

function ProfileStore.Test()
	return {
		ActiveSessionCheck = ActiveSessionCheck,
		AutoSaveList = AutoSaveList,
		ActiveProfileLoadJobs = ActiveProfileLoadJobs,
		ActiveProfileSaveJobs = ActiveProfileSaveJobs,
		MockStore = MockStore,
		UserMockStore = UserMockStore,
		UpdateQueue = UpdateQueue,
	}
end

function ProfileStore.New(store_name, template)

	template = template or {}

	if type(store_name) ~= "string" then
		error(`[{script.Name}]: Invalid or missing "store_name"`)
	elseif string.len(store_name) == 0 then
		error(`[{script.Name}]: store_name cannot be an empty string`)
	elseif string.len(store_name) > 50 then
		error(`[{script.Name}]: store_name is too long`)
	end

	if type(template) ~= "table" then
		error(`[{script.Name}]: Invalid template argument`)
	end

	local self
	self = {

		Mock = {

			Name = store_name,

			StartSessionAsync = function(_, profile_key)
				MockFlag = true
				return self:StartSessionAsync(profile_key)
			end,
			MessageAsync = function(_, profile_key, message)
				MockFlag = true
				return self:MessageAsync(profile_key, message)
			end,
			GetAsync = function(_, profile_key, version)
				MockFlag = true
				return self:GetAsync(profile_key, version)
			end,
			VersionQuery = function(_, profile_key, sort_direction, min_date, max_date)
				MockFlag = true
				return self:VersionQuery(profile_key, sort_direction, min_date, max_date)
			end,
			RemoveAsync = function(_, profile_key)
				MockFlag = true
				return self:RemoveAsync(profile_key)
			end
		},

		Name = store_name,

		template = template,
		data_store = nil,
		load_jobs = {},
		mockrLoad_jobs = {},
		is_ready = true,

	}
	setmetatable(self, ProfileStore)

	local options = Instance.new("DataStoreOptions")
	options:SetExperimentalFeatures({v2 = true})

	if DataStoreState == "NotReady" then

		-- The module is not sure whether DataStores are accessible yet:

		self.is_ready = false

		task.spawn(function()

			repeat task.wait() until DataStoreState ~= "NotReady"

			if DataStoreState == "Access" then
				self.data_store = DataStoreService:GetDataStore(store_name, nil, options)
			end

			self.is_ready = true

		end)

	elseif DataStoreState == "Access" then

		self.data_store = DataStoreService:GetDataStore(store_name, nil, options)

	end

	return self

end

function ProfileStore:StartSessionAsync(profile_key, params)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if params ~= nil and type(params) ~= "table" then
		error(`[{script.Name}]: Invalid params`)
	end

	params = params or {}

	if ProfileStore.IsClosing == true then
		return nil
	end

	WaitForStoreReady(self)

	local session_token = SessionToken(self.Name, profile_key, is_mock)

	if ActiveSessionCheck[session_token] ~= nil then
		error(`[{script.Name}]: Profile (STORE:{self.Name}; KEY:{profile_key}) is already loaded in this session`)
	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs + 1

	local is_user_cancel = false

	local function cancel_condition()
		if is_user_cancel == false then
			if params.Cancel ~= nil then
				is_user_cancel = params.Cancel() == true
			end
			return is_user_cancel
		end
		return true
	end

	local user_steal = params.Steal == true

	local forcerLoad_steps = 0 -- Session conflict handling values
	local request_forcerLoad = true
	local steal_session = false

	local start = os.clock()
	local exp_backoff = 1

	while ProfileStore.IsClosing == false and cancel_condition() == false do

		-- Load profile:

		-- SPECIAL CASE - If StartSessionAsync is called for the same key again before another StartSessionAsync finishes,
		-- grab the DataStore return for the new call. The early call will return nil. This is supposed to retain
		-- expected and efficient behaviour in cases where a player would quickly rejoin the same server.

		LoadIndex += 1
		local load_id = LoadIndex
		local profilerLoad_jobs = is_mock == true and self.mockrLoad_jobs or self.load_jobs
		local profilerLoad_job = profilerLoad_jobs[profile_key] -- {load_id, {loaded_data, key_info} or nil}

		local loaded_data, key_info
		local unique_session_id = HttpService:GenerateGUID(false)

		if profilerLoad_job ~= nil then

			profilerLoad_job[1] = load_id -- Steal load job
			while profilerLoad_job[2] == nil do -- Wait for job to finish
				task.wait()
			end
			if profilerLoad_job[1] == load_id then -- Load job hasn't been double-stolen
				loaded_data, key_info = table.unpack(profilerLoad_job[2])
				profilerLoad_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end

		else

			profilerLoad_job = {load_id, nil}
			profilerLoad_jobs[profile_key] = profilerLoad_job

			profilerLoad_job[2] = table.pack(UpdateAsync(
				self,
				profile_key,
				{
					ExistingProfileHandle = function(latest_data)

						if ProfileStore.IsClosing == true or cancel_condition() == true then
							return
						end

						local active_session = latest_data.MetaData.ActiveSession
						local forcerLoad_session = latest_data.MetaData.ForceLoadSession

						if active_session == nil then
							latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
							latest_data.MetaData.ForceLoadSession = nil
						elseif type(active_session) == "table" then
							if IsThisSession(active_session) == false then
								local last_update = latest_data.MetaData.LastUpdate
								if last_update ~= nil then
									if os.time() - last_update > ASSUME_DEAD then
										latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
										latest_data.MetaData.ForceLoadSession = nil
										return
									end
								end
								if steal_session == true or user_steal == true then
									local forcerLoad_interrupted = if forcerLoad_session ~= nil then not IsThisSession(forcerLoad_session) else true
									if forcerLoad_interrupted == false or user_steal == true then
										latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
										latest_data.MetaData.ForceLoadSession = nil
									end
								elseif request_forcerLoad == true then
									latest_data.MetaData.ForceLoadSession = {PlaceId, JobId}
								end
							else
								latest_data.MetaData.ForceLoadSession = nil
							end
						end

					end,
					MissingProfileHandle = function(latest_data)

						local is_cancel = ProfileStore.IsClosing == true or cancel_condition() == true

						latest_data.Data = DeepCopyTable(self.template)
						latest_data.MetaData = {
							ProfileCreateTime = os.time(),
							SessionLoadCount = 0,
							ActiveSession = if is_cancel == false then {PlaceId, JobId, unique_session_id} else nil,
							ForceLoadSession = nil,
							MetaTags = {}, -- Backwards compatibility with ProfileService
						}

					end,
					EditProfile = function(latest_data)

						if ProfileStore.IsClosing == true or cancel_condition() == true then
							return
						end

						local active_session = latest_data.MetaData.ActiveSession
						if active_session ~= nil and IsThisSession(active_session) == true then
							latest_data.MetaData.SessionLoadCount = latest_data.MetaData.SessionLoadCount + 1
							latest_data.MetaData.LastUpdate = os.time()
						end

					end,
				},
				is_mock
				))
			if profilerLoad_job[1] == load_id then -- Load job hasn't been stolen
				loaded_data, key_info = table.unpack(profilerLoad_job[2])
				profilerLoad_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- Load job stolen
			end
		end

		-- Handle load_data:

		if loaded_data ~= nil and key_info ~= nil then
			local active_session = loaded_data.MetaData.ActiveSession
			if type(active_session) == "table" then

				if IsThisSession(active_session) == true then

					-- Profile is now taken by this session:

					local profile = Profile.New(loaded_data, key_info, self, profile_key, is_mock, session_token)
					AddProfileToAutoSave(profile)

					if is_mock ~= true and DataStoreState == "Access" then

						-- Use MessagingService to quickly detect session conflicts and resolve them quickly:

						local last_roblox_message = 0

						profile.roblox_message_subscription = MessagingService:SubscribeAsync("PS_" .. unique_session_id, function(message)
							if type(message.Data) == "table" and message.Data.LoadCount == profile.SessionLoadCount then
								-- High reaction rate, based on numPlayers × 10 DataStore budget as of writing
								if os.clock() - last_roblox_message > 6 then 
									last_roblox_message = os.clock()
									if profile:IsActive() == true then
										if message.Data.EndSession == true then
											SaveProfileAsync(profile, true, false, "External")
										else
											profile:Save()
										end
									end
								end
							end
						end)

					end

					if ProfileStore.IsClosing == true or cancel_condition() == true then
						-- The server has initiated a shutdown by the time this profile was loaded
						SaveProfileAsync(profile, true) -- Release profile and yield until the DataStore call is finished
						profile = nil -- Don't return the profile object
					end

					ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
					return profile

				else

					if ProfileStore.IsClosing == true or cancel_condition() == true then
						ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
						return nil
					end

					-- Profile is taken by some other session:

					local forcerLoad_session = loaded_data.MetaData.ForceLoadSession
					local forcerLoad_interrupted = if forcerLoad_session ~= nil then not IsThisSession(forcerLoad_session) else true

					if forcerLoad_interrupted == false then

						if request_forcerLoad == false then
							forcerLoad_steps = forcerLoad_steps + 1
							if forcerLoad_steps >= math.ceil(SESSION_STEAL / LOAD_REPEAT_PERIOD) then
								steal_session = true
							end
						end

						-- Request the remote server to end its session:
						if type(active_session[3]) == "string" then
							local sessionrLoad_count = loaded_data.MetaData.SessionLoadCount or 0
							MessagingService:PublishAsync("PS_" .. active_session[3], {LoadCount = sessionrLoad_count, EndSession = true})
						end

						-- Attempt to load the profile again after a delay
						local wait_until = os.clock() + if request_forcerLoad == true then FIRSTrLOAD_REPEAT else LOAD_REPEAT_PERIOD
						repeat task.wait() until os.clock() >= wait_until or ProfileStore.IsClosing == true

					else
						-- Another session tried to load this profile:
						ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
						return nil
					end

					request_forcerLoad = false -- Only request a force load once

				end

			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- In this scenario it is likely that this server started shutting down
			end
		else

			-- A DataStore call has likely ended in an error:

			local default_timeout = false

			if params.Cancel == nil then
				default_timeout = os.clock() - start >= START_SESSION_TIMEOUT
			end

			if default_timeout == true or ProfileStore.IsClosing == true or cancel_condition() == true then
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end

			task.wait(exp_backoff)  -- Repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
	return nil -- Game started shutting down or the request was cancelled - don't return the profile

end

function ProfileStore:MessageAsync(profile_key, message)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if type(message) ~= "table" then
		error(`[{script.Name}]: message must be a table`)
	end

	if ProfileStore.IsClosing == true then
		return false
	end

	WaitForStoreReady(self)

	local exp_backoff = 1

	while ProfileStore.IsClosing == false do

		-- Updating profile:

		local loaded_data = UpdateAsync(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					local global_updates = latest_data.GlobalUpdates
					local updaterList = global_updates[2]
					--{
					--	update_index,
					--	{
					--		{update_index, data}, ...
					--	},
					--},

					global_updates[1] += 1
					table.insert(updaterList, {global_updates[1], message})

					-- Clearing queue if above limit:

					while #updaterList > MAX_MESSAGE_QUEUE do
						table.remove(updaterList, 1)
					end

				end,
			},
			is_mock
		)

		if loaded_data ~= nil then

			local session_token = SessionToken(self.Name, profile_key, is_mock)

			local profile = ActiveSessionCheck[session_token]

			if profile ~= nil then

				-- The message was sent to a profile that is active in this server:
				profile:Save()

			else

				local meta_data = loaded_data.MetaData or {}
				local active_session = meta_data.ActiveSession
				local sessionrLoad_count = meta_data.SessionLoadCount or 0

				if type(active_session) == "table" and type(active_session[3]) == "string" then
					-- Request the remote server to auto-save sooner and receive the message:
					MessagingService:PublishAsync("PS_" .. active_session[3], {LoadCount = sessionrLoad_count})
				end

			end

			return true

		else

			task.wait(exp_backoff) -- A DataStore call has likely ended in an error - repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	return false

end

function ProfileStore:GetAsync(profile_key, version)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if ProfileStore.IsClosing == true then
		return nil
	end

	WaitForStoreReady(self)

	if version ~= nil and (is_mock or DataStoreState ~= "Access") then
		return nil -- No version support in mock mode
	end

	local exp_backoff = 1

	while ProfileStore.IsClosing == false do

		-- Load profile:

		local loaded_data, key_info = UpdateAsync(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = function(latest_data)

					latest_data.Data = DeepCopyTable(self.template)
					latest_data.MetaData = {
						ProfileCreateTime = os.time(),
						SessionLoadCount = 0,
						ActiveSession = nil,
						ForceLoadSession = nil,
						MetaTags = {}, -- Backwards compatibility with ProfileService
					}

				end,
				EditProfile = nil,
			},
			is_mock,
			true, -- Use :GetAsync()
			version -- DataStore key version
		)

		-- Handle load_data:

		if loaded_data ~= nil then

			if key_info == nil then
				return nil -- Load was successful, but the key was empty - return no profile object
			end

			local profile = Profile.New(loaded_data, key_info, self, profile_key, is_mock)
			profile.view_mode = true

			return profile

		else

			task.wait(exp_backoff) -- A DataStore call has likely ended in an error - repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	return nil -- Game started shutting down - don't return the profile

end

function ProfileStore:RemoveAsync(profile_key)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	end

	if ProfileStore.IsClosing == true then
		return false
	end

	WaitForStoreReady(self)

	local wipe_status = false

	local next_in_queue = WaitInUpdateQueue(SessionToken(self.Name, profile_key, is_mock))

	if is_mock == true then -- Used when the profile is accessed through ProfileStore.Mock

		local mock_data_store = UserMockStore[self.Name]

		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
			if next(mock_data_store) == nil then
				UserMockStore[self.Name] = nil
			end
		end

		wipe_status = true
		task.wait() -- Simulate API call yield

	elseif DataStoreState ~= "Access" then -- Used when API access is disabled

		local mock_data_store = MockStore[self.Name]

		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
			if next(mock_data_store) == nil then
				MockStore[self.Name] = nil
			end
		end

		wipe_status = true
		task.wait() -- Simulate API call yield

	else -- Live DataStore

		wipe_status = pcall(function()
			self.data_store:RemoveAsync(profile_key)
		end)

	end

	next_in_queue()

	return wipe_status

end

local ProfileVersionQuery = {}
ProfileVersionQuery.__index = ProfileVersionQuery

function ProfileVersionQuery.New(profile_store, profile_key, sort_direction, min_date, max_date, is_mock)

	local self = {
		profile_store = profile_store,
		profile_key = profile_key,
		sort_direction = sort_direction,
		min_date = min_date,
		max_date = max_date,

		query_pages = nil,
		query_index = 0,
		query_failure = false,

		is_query_yielded = false,
		query_queue = {},

		is_mock = is_mock,
	}
	setmetatable(self, ProfileVersionQuery)

	return self

end

function MoveVersionQueryQueue(self) -- Hidden ProfileVersionQuery method
	while #self.query_queue > 0 do

		local queue_entry = table.remove(self.query_queue, 1)

		task.spawn(queue_entry)

		if self.is_query_yielded == true then
			break
		end

	end
end

local VersionQueryNextAsyncStackingFlag = false
local WarnAboutVersionQueryOnce = false

function ProfileVersionQuery:NextAsync()

	local is_stacking = VersionQueryNextAsyncStackingFlag == true
	VersionQueryNextAsyncStackingFlag = false

	WaitForStoreReady(self.profile_store)

	if ProfileStore.IsClosing == true then
		return nil -- Silently fail :NextAsync() requests
	end

	if self.is_mock == true or DataStoreState ~= "Access" then
		if IsStudio == true and WarnAboutVersionQueryOnce == false then
			WarnAboutVersionQueryOnce = true
			warn(`[{script.Name}]: :VersionQuery() is not supported in mock mode!`)
		end
		return nil -- Silently fail :NextAsync() requests
	end

	local profile
	local is_finished = false

	local function query_job()

		if self.query_failure == true then
			is_finished = true
			return
		end

		-- First "next" call loads version pages:

		if self.query_pages == nil then

			self.is_query_yielded = true

			task.spawn(function()
				VersionQueryNextAsyncStackingFlag = true
				profile = self:NextAsync()
				is_finished = true
			end)

			local list_success, error_message = pcall(function()
				self.query_pages = self.profile_store.data_store:ListVersionsAsync(
					self.profile_key,
					self.sort_direction,
					self.min_date,
					self.max_date
				)
				self.query_index = 0
			end)

			if list_success == false or self.query_pages == nil then
				warn(`[{script.Name}]: Version query fail - {tostring(error_message)}`)
				self.query_failure = true
			end

			self.is_query_yielded = false

			MoveVersionQueryQueue(self)

			return

		end

		local current_page = self.query_pages:GetCurrentPage()
		local next_item = current_page[self.query_index + 1]

		-- No more entries:

		if self.query_pages.IsFinished == true and next_item == nil then
			is_finished = true
			return
		end

		-- Load next page when this page is over:

		if next_item == nil then

			self.is_query_yielded = true
			task.spawn(function()
				VersionQueryNextAsyncStackingFlag = true
				profile = self:NextAsync()
				is_finished = true
			end)

			local success, error_message = pcall(function()
				self.query_pages:AdvanceToNextPageAsync()
				self.query_index = 0
			end)

			if success == false or #self.query_pages:GetCurrentPage() == 0 then
				self.query_failure = true
			end

			self.is_query_yielded = false
			MoveVersionQueryQueue(self)

			return

		end

		-- Next page item:

		self.query_index += 1
		profile = self.profile_store:GetAsync(self.profile_key, next_item.Version)
		is_finished = true

	end

	if self.is_query_yielded == false then
		query_job()
	else
		if is_stacking == true then
			table.insert(self.query_queue, 1, query_job)
		else
			table.insert(self.query_queue, query_job)
		end
	end

	while is_finished == false do
		task.wait()
	end

	return profile

end

function ProfileStore:VersionQuery(profile_key, sort_direction, min_date, max_date)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	end

	-- Type check:

	if sort_direction ~= nil and (typeof(sort_direction) ~= "EnumItem"
		or sort_direction.EnumType ~= Enum.SortDirection) then
		error(`[{script.Name}]: Invalid sort_direction ({tostring(sort_direction)})`)
	end

	if min_date ~= nil and typeof(min_date) ~= "DateTime" and typeof(min_date) ~= "number" then
		error(`[{script.Name}]: Invalid min_date ({tostring(min_date)})`)
	end

	if max_date ~= nil and typeof(max_date) ~= "DateTime" and typeof(max_date) ~= "number" then
		error(`[{script.Name}]: Invalid max_date ({tostring(max_date)})`)
	end

	min_date = typeof(min_date) == "DateTime" and min_date.UnixTimestampMillis or min_date
	max_date = typeof(max_date) == "DateTime" and max_date.UnixTimestampMillis or max_date

	return ProfileVersionQuery.New(self, profile_key, sort_direction, min_date, max_date, is_mock)

end

-- DataStore API access check:

if IsStudio == true then

	task.spawn(function()

		local new_state = "NoAccess"

		local status, message = pcall(function()
			-- This will error if current instance has no Studio API access:
			DataStoreService:GetDataStore("____PS"):SetAsync("____PS", os.time())
		end)

		local no_internet_access = status == false and string.find(message, "ConnectFail", 1, true) ~= nil

		if no_internet_access == true then
			warn(`[{script.Name}]: No internet access - check your network connection`)
		end

		if status == false and
			(string.find(message, "403", 1, true) ~= nil or -- Cannot write to DataStore from studio if API access is not enabled
				string.find(message, "must publish", 1, true) ~= nil or -- Game must be published to access live keys
				no_internet_access == true) then -- No internet access

			new_state = if no_internet_access == true then "NoInternet" else "NoAccess"
			print(`[{script.Name}]: Roblox API services unavailable - data will not be saved`)
		else
			new_state = "Access"
			print(`[{script.Name}]: Roblox API services available - data will be saved`)
		end

		DataStoreState = new_state
		ProfileStore.DataStoreState = new_state

	end)

else

	DataStoreState = "Access"
	ProfileStore.DataStoreState = "Access"

end

-- Update loop:

RunService.Heartbeat:Connect(function()

	-- Auto saving:

	local auto_saverListrLength = #AutoSaveList
	if auto_saverListrLength > 0 then
		local auto_save_index_speed = AUTO_SAVE_PERIOD / auto_saverListrLength
		local os_clock = os.clock()
		while os_clock - LastAutoSave > auto_save_index_speed do
			LastAutoSave = LastAutoSave + auto_save_index_speed
			local profile = AutoSaveList[AutoSaveIndex]
			if os_clock - profile.load_timestamp < AUTO_SAVE_PERIOD / 2 then
				-- This profile is freshly loaded - auto saving immediately is not necessary:
				profile = nil
				for _ = 1, auto_saverListrLength - 1 do
					-- Move auto save index to the right:
					AutoSaveIndex = AutoSaveIndex + 1
					if AutoSaveIndex > auto_saverListrLength then
						AutoSaveIndex = 1
					end
					profile = AutoSaveList[AutoSaveIndex]
					if os_clock - profile.load_timestamp >= AUTO_SAVE_PERIOD / 2 then
						break
					else
						profile = nil
					end
				end
			end
			-- Move auto save index to the right:
			AutoSaveIndex = AutoSaveIndex + 1
			if AutoSaveIndex > auto_saverListrLength then
				AutoSaveIndex = 1
			end
			-- Perform save call:
			if profile ~= nil then
				task.spawn(SaveProfileAsync, profile) -- Auto save profile in new thread
			end
		end
	end

	-- Critical state handling:

	if ProfileStore.IsCriticalState == false then
		if #IssueQueue >= CRITICAL_STATE_ERROR_COUNT then
			ProfileStore.IsCriticalState = true
			ProfileStore.OnCriticalToggle:Fire(true)
			CriticalStateStart = os.clock()
			warn(`[{script.Name}]: Entered critical state`)
		end
	else
		if #IssueQueue >= CRITICAL_STATE_ERROR_COUNT then
			CriticalStateStart = os.clock()
		elseif os.clock() - CriticalStateStart > CRITICAL_STATE_EXPIRE then
			ProfileStore.IsCriticalState = false
			ProfileStore.OnCriticalToggle:Fire(false)
			warn(`[{script.Name}]: Critical state ended`)
		end
	end

	-- Issue queue:

	while true do
		local issue_time = IssueQueue[1]
		if issue_time == nil then
			break
		elseif os.clock() - issue_time > CRITICAL_STATE_ERROR_EXPIRE then
			table.remove(IssueQueue, 1)
		else
			break
		end
	end

end)

-- Release all loaded profiles when the server is shutting down:

task.spawn(function()

	while DataStoreState == "NotReady" do
		task.wait()
	end

	if DataStoreState ~= "Access" then

		game:BindToClose(function()
			ProfileStore.IsClosing = true
			task.wait() -- Mock shutdown delay
		end)

		return -- Don't wait for profiles to properly save in mock mode so studio could end the simulation faster

	end

	game:BindToClose(function()

		ProfileStore.IsClosing = true

		-- Release all active profiles:
		-- (Clone AutoSaveList to a new table because AutoSaveList changes when profiles are released)

		local on_close_save_job_count = 0
		local active_profiles = {}
		for index, profile in ipairs(AutoSaveList) do
			active_profiles[index] = profile
		end

		-- Release the profiles; Releasing profiles can trigger listeners that release other profiles, so check active state:
		for _, profile in ipairs(active_profiles) do
			if profile:IsActive() == true then
				on_close_save_job_count = on_close_save_job_count + 1
				task.spawn(function() -- Save profile on new thread
					SaveProfileAsync(profile, true, nil, "Shutdown")
					on_close_save_job_count = on_close_save_job_count - 1
				end)
			end
		end

		-- Yield until all active profile jobs are finished:
		while on_close_save_job_count > 0 or ActiveProfileLoadJobs > 0 or ActiveProfileSaveJobs > 0 do
			task.wait()
		end

		return -- We're done!

	end)

end)

return ProfileStore]]></ProtectedString>
							<int64 name="SourceAssetId">109379033046155</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005080</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXAAB2DA5D1EC64EF68084B46E57A51810">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CharacterBehaviorService</string>
						<string name="ScriptGuid">{9EA6A629-36D9-464B-8C4C-62F8E33A61FA}</string>
						<ProtectedString name="Source"><![CDATA[local replicatedStorage = game:GetService("ReplicatedStorage")

local lib = require(replicatedStorage.lib)
local remotes = lib.Remotes
local playerLoaded = lib.Remotes.PlayerLoaded

local Assets = replicatedStorage.Assets
local rigsFolder = Assets.Rigs
local prisionerRig = rigsFolder.Prisoner


local module = {}

function module.Init()
	
	
	
end

function module.Start()
	playerLoaded.OnServerEvent:Connect(function(player)
		if prisionerRig then
			local newChar = prisionerRig:Clone()
			newChar.PrimaryPart = newChar.HumanoidRootPart
			newChar:SetPrimaryPartCFrame(player.Character.PrimaryPart.CFrame)
			newChar.Name = player.Name
			if player.Character:FindFirstChild("Animate") and not newChar:FindFirstChild("Animate") then
				player.Character.Animate:Clone().Parent = newChar
			end
			if player.Character:FindFirstChild("Health") and not newChar:FindFirstChild("Health") then
				player.Character.Health:Clone().Parent = newChar
			end
			player.Character = newChar
			newChar.Parent = game.Workspace
			newChar:FindFirstChild("HumanoidRootPart").CFrame = player.Character.HumanoidRootPart.CFrame
			for _, part in pairs(newChar:GetDescendants()) do
				if part:IsA("BasePart") then part.Anchored = false end
			end
		end
	end)
end




return module
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">34a6b895f5c9e85208c1d2f4000042e0</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX3EF30CC0F8EB4474AFAA45AD73766ED6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Utils</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">44cf0ce48b76346f08b4b31f00000c8e</UniqueId>
				</Properties>
				<Item class="Folder" referent="RBX97F00D12BD6442A39212F1A88AAEA7D2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">7745f3117c4a251a089954ce00004f06</UniqueId>
						<string name="Name">DataStore</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce0000507e</UniqueId>
					</Properties>
					<Item class="Folder" referent="RBXB50D9B6945C640CF883287D8852A1EEC">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">DataTemplates</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">43c00655b7588da408b7474300002850</UniqueId>
						</Properties>
						<Item class="Folder" referent="RBX59139C030C924B8BAF954F4C0357ACCE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Game</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">59acf661145fc00308b3f2d500000dbc</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX042A32D52B4D4A71B8982EE2507A8589">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">PrivateGameDataTemplate</string>
									<string name="ScriptGuid">{9A7A7756-311F-4BD4-86B7-D422F73D1F92}</string>
									<ProtectedString name="Source"><![CDATA[local templateData = {

	identityMissing = {
		'',
		''
	},

}	

export type TemplateData = typeof(templateData)

return templateData]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">43c00655b7588da408b7474300002852</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX88CE6558DB2B4C9BA796A5C8EE187D81">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">InventoryUtilServer</string>
						<string name="ScriptGuid">{2AD438DB-7982-49EB-9033-28F5797C16B1}</string>
						<ProtectedString name="Source"><![CDATA[local module = {}

return module
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">44375bddea0b7dae08bcd31200001bb4</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX7766C3BD76B9474BBB5E2ECE3CECF1B3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Configurations</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">3b4d352275f2c90608b5fa790000366d</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX2236B66E43AA49AD9DAE89CB0E7A2F84">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">FunctionsAllowedToSendToServer</string>
						<string name="ScriptGuid">{174760FE-1CD2-47B4-A3D7-916CFBB06921}</string>
						<ProtectedString name="Source"><![CDATA[return {
	Chest = {
		playerBeganHoldingProximityPrompt = 'playerBeganHoldingProximityPrompt',
		playerEndedHoldingProximityPrompt = 'playerEndedHoldingProximityPrompt'
	},
	Item = {
		TryToInstantiateTo = 'TryToInstantiateTo',
		TryToEquip = 'TryToEquip',
		TryToUnequip = 'TryToUnequip',
	} 
}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">3b4d352275f2c90608b5fa790000366f</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXA51C22BB1F324E53B369F0E482945AFA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Managers</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">34a6b895f5c9e85208c1d2f40000439d</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX57C55B902E164176BB36A2D711FDAFE5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">7745f3117c4a251a089954ce00004f09</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlayerDataManager</string>
						<string name="ScriptGuid">{C8EA0AAC-D09A-4429-9255-C423F8994650}</string>
						<ProtectedString name="Source"><![CDATA[local replicatedStorage = game:GetService('ReplicatedStorage')
local lib = require(replicatedStorage.lib)
local packet = lib.ModuleUtils.Packet
local remotes = lib.Remotes
local playerDataUpdatedRemote = remotes.PlayerDataUpdated
local TableToRemoteTable = lib.Utils.TableToRemoteTable

local updateStatsEvent = remotes.PlayerDataUpdated

local privatePlayerDataTemplate = require(script.PrivatePlayerDataTemplate)
local PublicPlayerDataTemplate = require(script.PublicPlayerDataTemplate)
local InGamePlayerDataTemplate = require(script.PublicPlayerDataTemplate.InGamePlayerDataTemplate)

local dataManager = {}
dataManager._cache = {}

function dataManager.getProfile(plr)
	if not plr:IsA('Player') then return end
	return dataManager._cache[plr]
end

function dataManager.getProfileData(plr): privatePlayerDataTemplate.TemplateData & PublicPlayerDataTemplate.TemplateData & InGamePlayerDataTemplate.TemplateData
	if not plr:IsA('Player') then return end
	return dataManager._cache[plr].Data
end

function dataManager.getPlayerTemplateData()
	local newData = {}
	
	for k, v in privatePlayerDataTemplate do
		newData[k] = v
	end
	for k, v in PublicPlayerDataTemplate do
		newData[k] = v
	end
	for k, v in InGamePlayerDataTemplate do
		newData[k] = v
	end
	
	return newData
end

function dataManager.getPlayerSalvableData(plr: Player)
	local profile = dataManager.getProfile(plr)
	if not profile then return end
	
	for k in profile.Data do
		if not PublicPlayerDataTemplate[k] and not privatePlayerDataTemplate[k] then
			profile.Data[k] = nil
		end
	end
	
	return profile
end

function dataManager.updateClient(plr : Player)
	local profile = dataManager.getProfileData(plr)
	if not profile then return end
	
	for k in profile do
		if not PublicPlayerDataTemplate[k] and not InGamePlayerDataTemplate[k] then
			profile[k] = nil
		end
	end
	
	local data = TableToRemoteTable.encode(profile)
	playerDataUpdatedRemote:FireClient(plr, data)
	--task.spawn(updateStatsEvent.FireClient, updateStatsEvent, plr, TableToRemoteTable.encode(profile))
end

function dataManager.setStats(plr: Player, key : any, value: any?)
	if value then 
		local profile = dataManager.getProfileData(plr)
		if not profile then return end
		
		profile[key] = value 
	else
		dataManager._cache[plr] = key
	end
	
	dataManager.updateClient(plr)
end

function dataManager.resetStat(plr: Player, key: string?)
	local profile = dataManager.getProfile(plr)
	if not profile then return end
	
	local template = dataManager.getPlayerTemplateData()
	if key then 
		profile.Data[key] = template[key]
	else
		profile.Data = template
	end
	
	dataManager.updateClient(plr)
end

function dataManager.increaseStats(plr: Player, key: string, value: number)
	if not key or not value then return end
	
	local profile = dataManager.getProfileData(plr)
	if not profile then return end
	
	profile[key] += value
	
	dataManager.updateClient(plr)
end

function dataManager.decreaseStats(plr: Player, key: string, value: number)
	if not key or not value then return end

	local profile = dataManager.getProfileData(plr)
	if not profile then return end

	profile[key] -= value

	dataManager.updateClient(plr)
end

function dataManager.get(plr: Player)
	return dataManager.getProfileData(plr)
end

--[[local function findPath(key, plr)
	local profile = getProfile(plr)
	if not profile then return end 
	local path = profile.Data
	if typeof(key) == 'string' then return path[key], profile end
	if typeof(key) == 'table' then 
		for i, k in key do
			path = path[k]
		end
		return path, profile
	end
end]]

--[[function dataManager.updateStats(plr: Player, key, value)
	if not plr or not key or not value then return end
	
	local playerData = getProfile(plr)
	if not playerData then return end
	
	
	
	
	
end]]

--[[function dataManager.updateStats(plr: Player, key : string | {[number] : string}, value : any, operation : string?, notUpdate:boolean?)
	if not plr or not key or not value then return end
	local path, profile
	if typeof(key) == 'table' then
		path, profile = findPath(key, plr)
		if typeof(path) ~= typeof(value) then return end
		
		path = rL.Functions.DeepUpdate(operation and operation or '+', path, value)
	else
		profile = getProfile(plr)
		if not profile then return end 
		profile.Data[key] = rL.Functions.DeepUpdate(operation and operation or '+', profile.Data[key], value)
	end
	if not notUpdate then updateStatsEvent:FireClient(plr, profile.Data) end
end]]

return dataManager
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005081</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX01EEEF50EFE249FCB1543E2B6D991C9B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">7745f3117c4a251a089954ce00004f0a</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PrivatePlayerDataTemplate</string>
							<string name="ScriptGuid">{3E8F57F3-9D04-40DD-80A0-996F995CC5B2}</string>
							<ProtectedString name="Source"><![CDATA[local templateData = {



}	

export type TemplateData = typeof(templateData)

return templateData]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7745f3117c4a251a089954ce00005082</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXACD06F63FECF4FACBB87FA24CE3B3F17">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PublicPlayerDataTemplate</string>
							<string name="ScriptGuid">{703408C6-7657-4FAE-9C20-66E7EC3244EC}</string>
							<ProtectedString name="Source"><![CDATA[local templateData = {

	xp = 0,
	coins = 100,
	
}	

export type TemplateData = typeof(templateData)

return templateData]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6e87ccb51f069bf408b38bfe00002fe4</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX8F3158B5547B4670A150022566BE600D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">InGamePlayerDataTemplate</string>
								<string name="ScriptGuid">{20325B60-5FBB-405F-B9DC-275565319856}</string>
								<ProtectedString name="Source"><![CDATA[local templateData = {

	inventory = {
		[1] = nil,
		[2] = nil,
		[3] = nil,
		[4] = nil,
		[5] = nil,
		[6] = nil,
	},

	identity = '',
	isWanted = false,
	hasAnIlegalItem = false,

}	

export type TemplateData = typeof(templateData)

return templateData]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">59acf661145fc00308b3f2d500000dbd</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXC99F926B571546F5A7933F03431103EB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ModuleScript</string>
						<string name="ScriptGuid">{650816A4-0FB5-4523-97A0-7355955F5D73}</string>
						<ProtectedString name="Source"><![CDATA[local serverStorage = game:GetService('ServerStorage')
local replicatedStorage = game:GetService("ReplicatedStorage")
local lib = require(replicatedStorage.lib)
local signal = lib.ModuleUtils.Signal
local trove = lib.ModuleUtils.Trove
local t = lib.FunctionUtils.t

local isPlayer = t.instance('Player')

local timeForPrisonerBeForgotten = require(serverStorage.Modules.GameSettings).TimeForPrisonerBeForgotten

local module = {}

module.Prisoners = {} :: {
	[Player]: {
		flagLevel: number,
		timeOutThread: thread, 
		wanted: boolean,
	}
}
module.PrisonerWantedAdded = signal.new()
module.PrisonerWantedRemoved = signal.new()

module.Trove = trove.new()
module.Trove:Add(module.PrisonerWantedAdded)
module.Trove:Add(module.PrisonerWantedRemoved)

function HowManyPrisonersBeenChased()
	local n = 0
	for _ in module.PrisonersWanted do
		n+=1
	end
	return n
end

function module.AddPrisonerWanted(player: Player)
	if not isPlayer(player) then return end
	
	module.PrisonersWanted[player] = task.delay(timeForPrisonerBeForgotten, function()
		module.RemovePrisonerWanted(player)
	end)
	
	
	
	module.PlayerWantedAdded:Fire(player)
end

function module.RemovePrisonerWanted(player: Player)
	if not isPlayer(player) then return end
	
	
	
	
end


function module.FlagPrisoner(player: Player, flagLevel: number)
	if not isPlayer(player) or not t.number(flagLevel) then return end
	local prisionerTab = module.Prisoners[player]
	if not prisionerTab then return end
	
	if prisionerTab.timeOutThread then
		task.cancel(prisionerTab.timeOutThread)
		prisionerTab.timeOutThread = nil
	end
	
	prisionerTab.flagLevel += flagLevel
	prisionerTab.timeOutThread = task.delay(timeForPrisonerBeForgotten, function()
		module.RemovePrisonerWanted(player)
	end)
	

end




return module
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">34a6b895f5c9e85208c1d2f4000045bf</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXAAAD61B5F5A54668858C74CCEA572D9D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GameSettings</string>
					<string name="ScriptGuid">{7D8643A6-9563-4C4C-BD0C-5598BEDE4911}</string>
					<ProtectedString name="Source"><![CDATA[return {
	TimeForPrisonerBeForgotten = 30,
	
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">34a6b895f5c9e85208c1d2f4000045c3</UniqueId>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="ServiceVisibilityService" referent="RBXB6C970DA6796451C8C5C48CF1F0457B0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<BinaryString name="HiddenServices">AAAAAA==</BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServiceVisibilityService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000378</UniqueId>
			<BinaryString name="VisibleServices">AAAAAA==</BinaryString>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBX88C65069D8C04210A0205844FACB8873">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="HttpEnabled">true</bool>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de60000038d</UniqueId>
		</Properties>
	</Item>
	<Item class="DataStoreService" referent="RBXF6B6F3FA9EFB42369EDF3D897069872F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutomaticRetry">true</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LegacyNamingScheme">false</bool>
			<string name="Name">DataStoreService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000390</UniqueId>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBXDA300AC23F974B7EA342C88BC37207CC">
		<Properties>
			<Color3 name="Ambient">
				<R>0.274509817</R>
				<G>0.274509817</G>
				<B>0.274509817</B>
			</Color3>
			<BinaryString name="AttributesSerialize"><![CDATA[AgAAACYAAABSQlhfTGlnaHRpbmdUZWNobm9sb2d5VW5pZmllZE1pZ3JhdGlvbgMBIAAAAFJC
WF9PcmlnaW5hbFRlY2hub2xvZ3lPbkZpbGVMb2FkBAMAAAA=]]></BinaryString>
			<float name="Brightness">0.5</float>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<bool name="DefinesCapabilities">false</bool>
			<float name="EnvironmentDiffuseScale">1</float>
			<float name="EnvironmentSpecularScale">1</float>
			<float name="ExposureCompensation">0</float>
			<token name="ExtendLightRangeTo120">0</token>
			<Color3 name="FogColor">
				<R>0.752941251</R>
				<G>0.752941251</G>
				<B>0.752941251</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">0</float>
			<bool name="GlobalShadows">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="LightingStyle">1</token>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.274509817</R>
				<G>0.274509817</G>
				<B>0.274509817</B>
			</Color3>
			<bool name="Outlines">false</bool>
			<bool name="PrioritizeLightingQuality">true</bool>
			<float name="ShadowSoftness">0.200000003</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">3</token>
			<string name="TimeOfDay">20:00:00</string>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000391</UniqueId>
		</Properties>
		<Item class="Sky" referent="RBX3E304D45B567429D9460E68BE4C3BC14">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CelestialBodiesShown">true</bool>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="MoonAngularSize">11</float>
				<Content name="MoonTextureId"><url>rbxassetid://6444320592</url></Content>
				<string name="Name">Sky</string>
				<Content name="SkyboxBk"><url>rbxassetid://6444884337</url></Content>
				<Content name="SkyboxDn"><url>rbxassetid://6444884785</url></Content>
				<Content name="SkyboxFt"><url>rbxassetid://6444884337</url></Content>
				<Content name="SkyboxLf"><url>rbxassetid://6444884337</url></Content>
				<Vector3 name="SkyboxOrientation">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Content name="SkyboxRt"><url>rbxassetid://6444884337</url></Content>
				<Content name="SkyboxUp"><url>rbxassetid://6412503613</url></Content>
				<int64 name="SourceAssetId">332039975</int64>
				<int name="StarCount">3000</int>
				<float name="SunAngularSize">11</float>
				<Content name="SunTextureId"><url>rbxassetid://6196665106</url></Content>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003a3</UniqueId>
			</Properties>
		</Item>
		<Item class="SunRaysEffect" referent="RBXFFCCD0C29BB047E391DD02E29F52C144">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="Intensity">0.00999999978</float>
				<string name="Name">SunRays</string>
				<int64 name="SourceAssetId">-1</int64>
				<float name="Spread">0.100000001</float>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003a4</UniqueId>
			</Properties>
		</Item>
		<Item class="Atmosphere" referent="RBX8C2E2603AD714EE9BF53353F11E6C222">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<Color3 name="Color">
					<R>0.78039217</R>
					<G>0.78039217</G>
					<B>0.78039217</B>
				</Color3>
				<Color3 name="Decay">
					<R>0.41568628</R>
					<G>0.43921569</G>
					<B>0.490196079</B>
				</Color3>
				<bool name="DefinesCapabilities">false</bool>
				<float name="Density">0.300000012</float>
				<float name="Glare">0</float>
				<float name="Haze">0</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Atmosphere</string>
				<float name="Offset">0.25</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003a5</UniqueId>
			</Properties>
		</Item>
		<Item class="BloomEffect" referent="RBX28E611BE99AC497B858B11A3A47CD0FC">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="Intensity">1</float>
				<string name="Name">Bloom</string>
				<float name="Size">24</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="Threshold">2</float>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003a6</UniqueId>
			</Properties>
		</Item>
		<Item class="DepthOfFieldEffect" referent="RBXA44D05DF472148AC874BC2040007DDFA">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">false</bool>
				<float name="FarIntensity">0.100000001</float>
				<float name="FocusDistance">0.0500000007</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="InFocusRadius">30</float>
				<string name="Name">DepthOfField</string>
				<float name="NearIntensity">0.75</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003a7</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="LodDataService" referent="RBXC5B6E35E2B544C798D19958E08D1C9DC">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000392</UniqueId>
		</Properties>
	</Item>
	<Item class="ProximityPromptService" referent="RBX7852985805B241D6A5D9358F87107473">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Enabled">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxIndicatorsVisible">16</int>
			<int name="MaxPromptsVisible">16</int>
			<string name="Name">ProximityPromptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000393</UniqueId>
		</Properties>
	</Item>
	<Item class="Teams" referent="RBXE7EB8B1370A34D889F37D689C2BC4D30">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Teams</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000394</UniqueId>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBX2203E66B1211413DAC6EC5AA2DB081E7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoRuns">true</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<bool name="ThrottlePhysicsToRealtime">true</bool>
			<double name="Timeout">10</double>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000395</UniqueId>
		</Properties>
	</Item>
	<Item class="UGCAvatarService" referent="RBX467D6C6172DA4116A0808D913B45C892">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">UGCAvatarService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000396</UniqueId>
		</Properties>
	</Item>
	<Item class="VideoService" referent="RBXC02F80AA88B04DF49CA640173089CDD1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VideoService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de6000003bf</UniqueId>
		</Properties>
	</Item>
	<Item class="VoiceChatService" referent="RBXAF892E460B4F455B98CA53D83887887C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="DefaultDistanceAttenuation">0</token>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="EnableDefaultVoice">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VoiceChatService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">759ee19baa6ba7f8088b6de600000398</UniqueId>
			<token name="UseAudioApi">2</token>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>